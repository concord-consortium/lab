<!DOCTYPE html>
<head>
  <title>Gradient parser</title>
  <style>
    body {
      font-family: sans-serif;
      font-size: 20pt;
      overflow:hidden;
     -webkit-transition-timing-function: cubic-bezier(0.165, 0.840, 0.440, 1.000);
    }
    body, #area, #preview {
      margin: 0;
      position: absolute;
      left: 0;
      right: 0;
      bottom: 0;
      top: 0;
    }
    #area {
      border: none;
      font-size: 32pt;
      z-index: 0;
      margin: 25px;
      padding: 10px;
      background-color: transparent;
      -webkit-transition: background-color 0.5s;
    }
    #area:hover {
      background-color: rgba(255,255,255,0.5);
    }
    #area:focus {
      outline: none;
    }
    #help {
      z-index: 10000;
      padding: 20px;
      position: absolute;
      background-color: rgba(255,255,255,0.8);
      left: 100%;
      width: 70%;
      top: 0;
      bottom: 0;
      overflow: auto;
      -webkit-transition: left 600ms;
      -webkit-transition-timing-function: inherit;
    }
    nav {
      position: absolute;
      right: 0;
      bottom: 0;
      -webkit-user-select:none;
    }
    nav div {
      float:left;
      padding:5px;
      margin:5px;
      cursor:pointer;
      -webkit-transition:background-color 200ms;
      -webkit-transition-timing-function: inherit;
    }
    nav:hover div {
      background-color:rgba(255,255,255,0.2)
    }
    nav div:hover {
      background-color:rgba(255,255,255,0.8)
    }
    nav div:active {
      background-color:rgba(200,200,200,0.8)
    }
  </style>
</head>
<body>
  <section id="preview" onclick="help.style.left='100%'">
    <textarea id="area" oninput="enter(this.value)"></textarea>
  </section>
  <nav>
    <div onclick="save()">Standardize and Save</div>
    <div onclick="help.style.left='30%'">Help</div>
    <div onclick="location.hash='';location.reload()">Reset</div>
  </nav>
  <section id="help">
Type some text to see the parsed color or gradient previewed in the background in real time.<br>
Clicking <b>Standardize and Save</b> will convert the typed text into a standard form for use in md2d, and also save the gradient to the URL for sharing.<br>
<br>
The parser is very flexible. This works:<br>
<a href="#" onclick="area.value=this.innerText;enter(this.innerText);return false">red orange</a><br>
as well as this<br>
<a href="#" onclick="area.value=this.innerText;enter(this.innerText);return false">linear right rgb(255,0,0) 0%,#FF8800 100%</a><br>
and so does this<br>
<a href="#" onclick="area.value=this.innerText;enter(this.innerText);return false">-webkit-linear-gradient(0 deg, rgb(255,0,0) 0%,#FF8800 100%)</a><br>
The only thing you need to be aware of is that offset percentages come AFTER the color they describe. Otherwise, they may be interpreted as rotations.</section>
  <div id="output"></div>
  <script>
  //Uses the gradients object from gradients.js
  gradients={
    /**
     * NOT INTENDED FOR INDEPENDENT USE
     * Resolves mismatched parentheses in a string.
     * Optionally, removes or "peels" the outermost pair of parenthesis
     *
     * @param  {string} string    String to resolve
     * @param  {boolean} peel     Whether or not to "peel" the outermost parenthesis pair.
     * @return {string}           Resolved string
     */
    settleParens: function(string, peel) {
      var end, inparens, firstparen;
      inparens = false;
      string = string.split("")
      for (end = 0; end < string.length; end++) {
        if (inparens) {
          if (string[end] == ")") {
            inparens = false;
          } else if (string[end] == "(") {
            string[firstparen] = " ";
            firstparen = end;
          }
        } else {
          if (string[end] == "(") {
            if (peel) {
              string[end] = " "
              peel = false
            } else {
              inparens = true;
              firstparen = end;
            }
          } else if (string[end] == ")") {
            string[end] = " ";
          }
        }
      }
      return string.join("").replace(/\s+/, " ").trim()
    },
    /**
     * NOT INTENDED FOR INDEPENDENT USE
     * Splits a string by space or comma, keeping parentheses intact
     * Then, parses each "word" for possible meanings
     * Optionally, removes or "peels" the outermost pair of parenthesis before splitting
     *
     * @param  {string} string    String to split
     * @param  {boolean} peel     Whether or not to "peel" the outermost parenthesis pair.
     * @return {Array.<Object>}   Array of "words"
     */
    smartSplit: function(string, peel) {
      var start, end, result, inparens, temp;
      string = this.settleParens(string, peel);
      inparens = false;
      result = [];
      for (end = 1; end < string.length; end++) {
        if (inparens) {
          if (string[end] == ")") {
            inparens = false;
          }
          continue;
        }
        if (string[end] == "," || string[end] == " ") {
          temp = string.slice(start, end).trim()
          if (temp.length > 0) {
            result.push(this.parseWord(temp));
          }
          start = end + 1;
        } else if (string[end] == "(") {
          inparens = true;
        }
      }
      if (end == string.length) {
        result.push(this.parseWord(string.slice(start, end).trim()));
      }
      return result;
    },
    /**
     * NOT INTENDED FOR INDEPENDENT USE
     * Finds all possible meanings of a given word, storing those
     * as properties into a String representation of the word
     *
     * @param  {string} word                      Word to find the meaning of
     * @return {Object.<string,number|boolean>}   Word as a String object and properties set
     */
    parseWord: function(word) {
      var result, temp;
      result = new String(word);
      if (word.search(/(^|[^a-zA-Z])li?n?e?a?r?($|[^a-zA-Z])/) != -1) {
        result.linear = true;
      }
      if (word.search(/(^|[^a-zA-Z])ra?d?i?a?l?($|[^a-zA-Z])/) != -1) {
        result.radial = true;
      }
      if (word.search(/(^|[^a-zA-Z])gr?a?d?i?e?n?t?($|[^a-zA-Z])/) != -1) {
        result.gradient = true;
      }
      if (word.search(/(\(|\))/) != -1) {
        result.parens = true;
        return result;
      }
      temp = parseFloat(word);
      if (!isNaN(temp)) {
        result.number = temp;
      }
      if (word.search(/(^|[^a-zA-Z])de?g?r?e?e?s?($|[^a-zA-Z])/) != -1) {
        result.degrees = true;
      }
      if (word.search(/(^|[^a-zA-Z])ri?g?h?t?($|[^a-zA-Z])/) != -1) {
        result.right = true;
      }
      if (word.search(/(^|[^a-zA-Z])le?f?t?($|[^a-zA-Z])/) != -1) {
        result.left = true;
      }
      if (word.search(/(^|[^a-zA-Z])(t|u)o?p?($|[^a-zA-Z])/) != -1) {
        result.top = true;
      }
      if (word.search(/(^|[^a-zA-Z])bo?t?t?o?m?($|[^a-zA-Z])/) != -1) {
        result.bottom = true;
      }
      if (word.search(/(^|[^a-zA-Z])re?pe?a?t?($|[^a-zA-Z])/) != -1) {
        result.repeat = true;
      }
      if (word.search(/(^|[^a-zA-Z])re?fl?e?c?t?($|[^a-zA-Z])/) != -1) {
        result.reflect = true;
      }
      return result;
    },
    /**
     * NOT INTENDED FOR INDEPENDENT USE
     * Given an array containing stop objects of color data and optionally offset data,
     * interpolate values for stops without offsets.
     * e.g.
     * [{"color":"red","offset":0},{"color":"yellow"},{"color":"blue","offset":100}]
     * would return
     * [{"color":"red","offset":0},{"color":"yellow","offset":50},{"color":"blue","offset":100}]
     *
     * @param  {Array.<Object<string,Object|string|number>>} stops  Array of objects containing color data and optionally offset data
     * @return {Array.<Object<string,Object|string|number>>}        Array of objects containing both color and offset data
     */
    interpolateStops: function(stops) {
      var i, j, k, start, end, step;
      if (stops.length == 0) {
        return stops;
      }
      if (!("offset" in stops[0])) {
        stops[0].offset = 0;
      }
      if (stops.length == 1) {
        return stops;
      }
      if (!("offset" in stops[stops.length - 1])) {
        stops[stops.length - 1].offset = 100;
      }
      for (i = 2; i < stops.length; i++) {
        if ("offset" in stops[i] && !("offset" in stops[i - 1])) {
          start = 0;
          end = stops[i].offset;
          for (j = i - 2; j >= 0; j--) {
            if ("offset" in stops[j]) {
              start = stops[j].offset;
              break;
            }
          }
          step = (end - start) / (i - j)
          for (var k = j + 1; k < i; k++) {
            stops[k].offset = start + step * (k - j);
          }
        }
      }
      return stops
    },
    /**
     * NOT INTENDED FOR INDEPENDENT USE: use gradients.parse instead
     * Parses and returns any color or gradient that a given string contains
     * as a gradient/color object of the form
     * {"color":"red"}
     * or
     * {"gradient":"linear","direction":0,"stops":[{"color":"red","offset":0}, ... ]}
     *
     * @param  {string} string  String
     * @return {Object}         Gradient/color object
     */
    fullParse: function(string) {
      //Preliminary gradient verification
      string = string.trim().toLowerCase();
      if (string.search(/[^#0-9a-zA-Z-]/) == -1) {
        return {
          "color": string
        };
      }
      var stops, words, direction, linear, radial, i, gradient, remove, x_direction, y_direction, repeat;

      //String preprocessing
      string = string.replace(/[\n\r:;]/g, ' ').replace(/\/\*.*\*\/$/, '').replace(/\{\[/, "(").replace(/\}\]/, ")").replace(/[^a-zA-Z0-9%#\-\(\)\., ]*/g, "").replace(/\s*-\s+/g, "-").replace(/\s*\(/g, "(").replace(/\s+/g, " ");
      words = this.smartSplit(string, false);
      gradient = {};

      //Remove any irrelevant parentheses
      for (i = 0; i < words.length; i++) {
        if ("parens" in words[i] && ("gradient" in words[i] || "linear" in words[i] || "radial" in words[i])) {
          words.splice.apply(words, [i, 1].concat(this.smartSplit(words[i], true)))
        }
      }

      //Parse gradient metadata
      direction = false;
      radial = false;
      linear = false;
      repeat = false;
      x_direction = 0;
      y_direction = 0;
      for (i = 0; i < words.length; i++) {
        remove = false
        if ("left" in words[i]) {
          x_direction -= 1;
          remove = true;
        } else if ("right" in words[i]) {
          x_direction += 1;
          remove = true;
        }
        if ("top" in words[i]) {
          y_direction += 1;
          remove = true;
        } else if ("bottom" in words[i]) {
          y_direction -= 1;
          remove = true;
        }
        if ("radial" in words[i] && !("right" in words[i])) {
          radial = true;
          remove = true;
        }
        if ("linear" in words[i] && !("left" in words[i])) {
          linear = true;
          remove = true;
        }
        if ("number" in words[i]) {
          if ("degrees" in words[i] || i + 1 < words.length && "degrees" in words[i + 1]) {
            if (direction === false) {
              direction = words[i].number;
            }
            remove = true;
          }
        }
        if ("repeat" in words[i]) {
          repeat = "repeat";
          remove = true;
        } else if ("reflect" in words[i]) {
          repeat = "reflect";
          remove = true;
        }
        if (remove || "degrees" in words[i] || "gradient" in words[i]) {
          words.splice(i, 1);
          i--;
        }
      }
      if (direction === false && (x_direction != 0 || y_direction != 0)) {
        direction = (180 * Math.atan2(y_direction, x_direction) / Math.PI % 360);
      }

      //Parse the stops
      stops = [];
      for (i = 0; i < words.length; i++) {
        if (!("number" in words[i])) {
          if (i + 1 < words.length && ("number" in words[i + 1])) {
            stops.push({
              color: words[i],
              offset: words[i + 1].number
            })
            words.splice(i, 2)
          } else {
            stops.push({
              color: words[i]
            })
            words.splice(i, 1)
          }
          i--
        }
      }
      if (stops.length == 1) {
        return {
          "color": stops[0].color
        };
      }
      if (stops.length == 0) {
        return {
          "color": "none"
        };
      }
      this.interpolateStops(stops);

      //Parse leftover words
      for (i = 0; i < words.length; i++) {
        if ("number" in words[i]) {
          if (direction === false) {
            direction = words[i].number;
          }
        }
      }

      //Build and return gradient object
      if (radial && !linear) {
        direction = false
        gradient.gradient = "radial"
      } else {
        if (direction === false) {
          direction = 0
        }
        direction %= 360;
        if (direction < 0) {
          direction += 360;
        }
        gradient.gradient = "linear"
        gradient.direction = direction
      }
      if (repeat !== false) {
        gradient.repeat = repeat
      }
      gradient.stops = stops;
      gradient.standard = this.toStandardForm(gradient);
      return gradient;
    },
    /**
     * Parses and returns any color or gradient that a given string contains
     * as a gradient/color object of the form
     * {"color":"red"}
     * or
     * {"gradient":"linear","direction":0,"stops":[{"color":"red","offset":0}, ... ]}
     *
     * A string given in standard form is faster to parse. An arbitrary string will use gradient.fullParse.
     *
     * @param  {string} string  String
     * @return {Object}         Gradient/color object
     */
    parse: function(string) {
      string = string.trim().toLowerCase().replace(/\s+/g, " ")
      if (string.search(/ /) == -1) {
        return {
          "color": string,
          "standard": string
        };
      }
      var stops, direction, gradient, type, s, offset, restandardize;
      stops = string.split(' ');
      gradient = {}
      type = stops.shift()
      if (type == "linear" || type == "radial") {
        gradient.gradient = type;
      } else {
        return this.fullParse(string);
      }
      if (type == "linear") {
        direction = parseFloat(stops.shift());
        if (isNaN(direction)) {
          return this.fullParse(string);
        }
        direction %= 360;
        if (direction < 0) {
          direction += 360;
        }
        gradient.direction = direction;
        restandardize = true;
      }
      gradient.stops = []
      if (stops.length % 2 == 0) {
        for (s = 0; s < stops.length; s += 2) {
          offset = parseFloat(stops[s + 1])
          if (isNaN(offset)) {
            return this.fullParse(string);
          }
          gradient.stops.push({
            "color": stops[s],
            "offset": offset
          });
        }
      } else {
        return this.fullParse(string);
      }
      if (restandardize) {
        gradient.standard = this.toStandardForm(gradient);
      } else {
        gradient.standard = string;
      }
      return gradient;
    },
    /**
     * Applies a given gradient/color to the background of a given element
     *
     * @param  {Object} color   A gradient/color object created by gradients.parse
     * @param  {Object} element The specified DOM element to apply the background to
     */
    toCSS: function(color, element) {
      var temp, i;
      if ("color" in color) {
        element.style.backgroundColor = color.color.length ? color.color : "inherit"
        element.style.backgroundImage = "none"
      } else {
        temp = (color.gradient == "radial" ? "-webkit-radial-gradient(ellipse," : "-webkit-linear-gradient(" + color.direction + "deg, ");
        for (i = 0; i < color.stops.length; i++) {
          temp += color.stops[i].color + " " + color.stops[i].offset + "%";
          if (i < color.stops.length - 1) {
            temp += ",";
          }
        }
        temp += ")";
        element.style.backgroundColor = "none";
        element.style.backgroundImage = temp;
      }
    },
    /**
     * Converts a given gradient/color to standard form
     *
     * @param  {Object} color A gradient/color object created by gradients.parse
     * @return {string}       The converted standard form string
     */
    toStandardForm: function(color) {
      var temp, i;
      if ("color" in color) {
        color.standard = color.color;
        return color.color;
      } else {
        temp = color.gradient + " " + (color.gradient == "linear" ? color.direction + "deg " : "");
        for (i = 0; i < color.stops.length; i++) {
          temp += color.stops[i].color + " " + color.stops[i].offset + "%";
          if (i < color.stops.length - 1) {
            temp += " ";
          }
        }
        color.standard = temp;
        return temp;
      }
    },
    /**
     * Converts a given gradient/color to an SVG fill, creating a gradient definition if necessary
     *
     * @param  {Object} color    A gradient/color object created by gradients.parse
     * @param  {Object} continer The container to append the gradient definitions to
     * @return {string}          The converted string for use in SVG fill
     */
    toSVG: function(color, container) {
      if (color.color) {
        return color.color;
      }
      var gradientUrl, defs, gradient, id, c, x0, y0, xt, yt, args, stop;
      defs = container.select("defs");
      if (defs.empty()) {
        // Store gradients in 'defs' element.
        defs = container.append("defs");
      }

      id = color.standard.replace(/[^a-z0-9]/g, '');
      gradient = defs.select("#" + id);

      if (gradient.empty()) {
        // Create a new gradient.
        if (color.gradient == 'linear') {
          xt = -Math.cos(Math.PI * color.direction / 180);
          yt = -Math.sin(Math.PI * color.direction / 180);
          if (Math.abs(yt) > Math.abs(xt)) {
            x0 = xt * Math.abs(50 / yt);
            y0 = (yt < 0 ? -1 : 1) * 50;
          } else {
            x0 = (xt < 0 ? -1 : 1) * 50;
            y0 = yt * Math.abs(50 / xt);
          }
          gradient = defs.append("linearGradient").attr("id", id).attr("x1", (50 + x0) + "%").attr("y1", (50 + y0) + "%").attr("x2", (50 - x0) + "%").attr("y2", (50 - y0) + "%");
        } else {
          gradient = defs.append("radialGradient").attr("id", id).attr("cx", "50%").attr("cy", "50%").attr("r", "50%").attr("fx", "50%").attr("fy", "50%");
        }
      } else {
        // Gradient exists. Using it.
        return "url(#" + id + ")";
      }

      for (c = 0; c < color.stops.length; c++) {
        stop = gradient.append("stop").attr("stop-color", color.stops[c].color).attr("offset", color.stops[c].offset + "%");
        args = color.stops[c].color.split(",");
        if (args.length == 4 && !isNaN(args = parseFloat(args[3]))) {
          stop.attr("stop-opacity", args)
        }
      };

      return "url(#" + id + ")";
    }
  };
  function enter(value){
    //localStorage.value=value;
    gradients.toCSS(gradients.parse(value),preview);
  }
  function save(){
    location.hash=encodeURIComponent(area.value=gradients.parse(area.value).standard);
  }
  try{
    area.value=decodeURIComponent(location.hash.slice(1))
  }
  catch(error){}
  area.value=area.value||"bottom\n#222244\n#00AACC 20%\nwhite 40%\nrgb(255,255,0)\n#FF8800 60%\nyellow\nhsl(0,0%,100%)\n#00AACC\n#222244";
  enter(area.value);
  </script>
</body>