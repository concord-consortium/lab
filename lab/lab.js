(function() {
/**
 * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("../../vendor/almond/almond", function(){});

// this file is generated during build process by: ./script/generate-js-version.rb
define('lab.version',['require'],function (require) {
  return {
    "repo": {
      "branch": "master",
      "commit": {
        "sha":           "60c506322d3f6a9edd6e7bfc6d2691af99a35500",
        "short_sha":      "60c50632",
        "url":            "https://github.com/concord-consortium/lab/commit/60c50632",
        "author":        "Stephen Bannasch",
        "email":         "stephen.bannasch@gmail.com",
        "date":          "2013-07-18 22:38:11 -0400",
        "short_message": "don&#39;t include Shutterbug in gh-pages branch",
        "message":       "don&#39;t include Shutterbug in gh-pages branch\n\nFIXME:\nThis should also be done when generating the versioned\ntar.gz archives  but since they are created from running\ncode on a server using Rack, Shutterbug can&#39;t be easily\nremoved ..."
      },
      "dirty": false
    }
  };
});

/*global define: false */

define('common/actual-root',[],function () {
  var newPattern = /^(\/.+?\/)(interactives|embeddable)\.html$/,

      // For legacy code, if any, that (a) uses actualRoot and (b) isn't in an interactive
      // (Not folded into the same regex as newPattern for the sake of readability. Note the regexes
      // are only matched against one time.)
      oldPattern = /(\/.+?\/)(doc|examples|experiments)(\/\w+)*?\/\w+\.html/,
      match;

  match = document.location.pathname.match(newPattern);
  if (match && match[1]) {
    return match[1];
  }

  match = document.location.pathname.match(oldPattern);
  return match && match[1] || "/";
});

// this file is generated during build process by: ./script/generate-js-config.rb
define('lab.config',['require','common/actual-root'],function (require) {
  var actualRoot = require('common/actual-root'),
      publicAPI;
  publicAPI = {
  "sharing": true,
  "home": "http://lab.concord.org",
  "homeForSharing": "http://lab.concord.org",
  "homeInteractivePath": "/interactive.html",
  "homeEmbeddablePath": "/embeddable.html",
  "utmCampaign": null,
  "fontface": "Lato",
  "hostName": "lab.dev.concord.org",
  "dataGamesProxyPrefix": "DataGames/Games/concord/lab/",
  "logging": true,
  "tracing": false,
  "authoring": false,
  "actualRoot": "",
  "environment": "development"
};
  publicAPI.actualRoot = actualRoot;
  return publicAPI;
});

/*global window Uint8Array Uint8ClampedArray Int8Array Uint16Array Int16Array Uint32Array Int32Array Float32Array Float64Array */
/*jshint newcap: false */

// Module can be used both in Node.js environment and in Web browser
// using RequireJS. R.JS Optimizer will strip out this if statement.


define('arrays/index',['require','exports','module'],function (require, exports, module) {
  var arrays = {};

  arrays.version = '0.0.1';

  arrays.webgl = (typeof window !== 'undefined') && !!window.WebGLRenderingContext;

  arrays.typed = (function() {
    try {
      new Float64Array(0);
      return true;
    } catch(e) {
      return false;
    }
  }());

  // http://www.khronos.org/registry/typedarray/specs/latest/#TYPEDARRAYS
  // regular
  // Uint8Array
  // Uint8ClampedArray
  // Uint16Array
  // Uint32Array
  // Int8Array
  // Int16Array
  // Int32Array
  // Float32Array
  // Float64Array

  arrays.create = function(size, fill, array_type) {
    if (!array_type) {
      if (arrays.webgl || arrays.typed) {
        array_type = "Float32Array";
      } else {
        array_type = "regular";
      }
    }
    if (fill === undefined) {
      fill = 0;
    }
    var a, i;
    if (array_type === "regular") {
      a = new Array(size);
    } else {
      switch(array_type) {
        case "Float64Array":
          a = new Float64Array(size);
          break;
        case "Float32Array":
          a = new Float32Array(size);
          break;
        case "Int32Array":
          a = new Int32Array(size);
          break;
        case "Int16Array":
          a = new Int16Array(size);
          break;
        case "Int8Array":
          a = new Int8Array(size);
          break;
        case "Uint32Array":
          a = new Uint32Array(size);
          break;
        case "Uint16Array":
          a = new Uint16Array(size);
          break;
        case "Uint8Array":
          a = new Uint8Array(size);
          break;
        case "Uint8ClampedArray":
          a = new Uint8ClampedArray(size);
          break;
        default:
          throw new Error("arrays: couldn't understand array type \"" + array_type + "\".");
      }
    }
    arrays.fill(a, fill);
    return a;
  };

  arrays.fill = function(array, value) {
    var i = -1, size = array.length;
    while(++i < size) {
      array[i] = value;
    }
  };

  arrays.constructor_function = function(source) {
    if (source.buffer &&
        source.buffer.__proto__ &&
        source.buffer.__proto__.constructor &&
        Object.prototype.toString.call(source) === "[object Array]") {
      return source.__proto__.constructor;
    }

    switch(source.constructor) {
      case Array:             return Array;
      case Float32Array:      return Float32Array;
      case Uint8Array:        return Uint8Array;
      case Float64Array:      return Float64Array;
      case Int32Array:        return Int32Array;
      case Int16Array:        return Int16Array;
      case Int8Array:         return Int8Array;
      case Uint32Array:       return Uint32Array;
      case Uint16Array:       return Uint16Array;
      case Uint8ClampedArray: return Uint8ClampedArray;
      default:
        throw new Error(
            "arrays.constructor_function: must be an Array or Typed Array: " + "  source: " + source);
            // ", source.constructor: " + source.constructor +
            // ", source.buffer: " + source.buffer +
            // ", source.buffer.slice: " + source.buffer.slice +
            // ", source.buffer.__proto__: " + source.buffer.__proto__ +
            // ", source.buffer.__proto__.constructor: " + source.buffer.__proto__.constructor
      }
  };

  arrays.copy = function(source, dest) {
    var len = source.length,
        i = -1;
    while(++i < len) { dest[i] = source[i]; }
    if (arrays.constructor_function(dest) === Array) dest.length = len;
    return dest;
  };

  arrays.clone = function(source) {
    var i, len = source.length, clone, constructor;
    constructor = arrays.constructor_function(source);
    if (constructor === Array) {
      clone = new constructor(len);
      for (i = 0; i < len; i++) { clone[i] = source[i]; }
      return clone;
    }
    if (source.buffer.slice) {
      clone = new constructor(source.buffer.slice(0));
      return clone;
    }
    clone = new constructor(len);
    for (i = 0; i < len; i++) { clone[i] = source[i]; }
    return clone;
  };

  /** @return true if x is between a and b. */
  // float a, float b, float x
  arrays.between = function(a, b, x) {
    return x < Math.max(a, b) && x > Math.min(a, b);
  };

  // float[] array
  arrays.max = function(array) {
    return Math.max.apply( Math, array );
  };

  // float[] array
  arrays.min = function(array) {
    return Math.min.apply( Math, array );
  };

  // FloatxxArray[] array
  arrays.maxTypedArray = function(array) {
    var test, i,
    max = Number.MIN_VALUE,
    length = array.length;
    for(i = 0; i < length; i++) {
      test = array[i];
      max = test > max ? test : max;
    }
    return max;
  };

  // FloatxxArray[] array
  arrays.minTypedArray = function(array) {
    var test, i,
    min = Number.MAX_VALUE,
    length = array.length;
    for(i = 0; i < length; i++) {
      test = array[i];
      min = test < min ? test : min;
    }
    return min;
  };

  // float[] array
  arrays.maxAnyArray = function(array) {
    try {
      return Math.max.apply( Math, array );
    }
    catch (e) {
      if (e instanceof TypeError) {
        var test, i,
        max = Number.MIN_VALUE,
        length = array.length;
        for(i = 0; i < length; i++) {
          test = array[i];
          max = test > max ? test : max;
        }
        return max;
      }
    }
  };

  // float[] array
  arrays.minAnyArray = function(array) {
    try {
      return Math.min.apply( Math, array );
    }
    catch (e) {
      if (e instanceof TypeError) {
        var test, i,
        min = Number.MAX_VALUE,
        length = array.length;
        for(i = 0; i < length; i++) {
          test = array[i];
          min = test < min ? test : min;
        }
        return min;
      }
    }
  };

  arrays.average = function(array) {
    var i, acc = 0,
    length = array.length;
    for (i = 0; i < length; i++) {
      acc += array[i];
    }
    return acc / length;
  };

  /**
    Create a new array of the same type as 'array' and of length 'newLength', and copies as many
    elements from 'array' to the new array as is possible.

    If 'newLength' is less than 'array.length', and 'array' is  a typed array, we still allocate a
    new, shorter array in order to allow GC to work.

    The returned array should always take the place of the passed-in 'array' in client code, and this
    method should not be counted on to always return a copy. If 'array' is non-typed, we manipulate
    its length instead of copying it. But if 'array' is typed, we cannot increase its size in-place,
    therefore must pas a *new* object reference back to client code.
  */
  arrays.extend = function(array, newLength) {
    var extendedArray,
        Constructor,
        i;

    Constructor = arrays.constructor_function(array);

    if (Constructor === Array) {
      i = array.length;
      array.length = newLength;
      // replicate behavior of typed-arrays by filling with 0
      for(;i < newLength; i++) { array[i] = 0; }
      return array;
    }

    extendedArray = new Constructor(newLength);

    // prevent 'set' method from erroring when array.length > newLength, by using the (no-copy) method
    // 'subarray' to get an array view that is clamped to length = min(array.length, newLength)
    extendedArray.set(array.subarray(0, newLength));

    return extendedArray;
  };

  arrays.remove = function(array, idx) {
    var constructor = arrays.constructor_function(array),
        rest;

    if (constructor !== Array) {
      throw new Error("arrays.remove for typed arrays not implemented yet.");
    }

    rest = array.slice(idx + 1);
    array.length = idx;
    Array.prototype.push.apply(array, rest);

    return array;
  };

  arrays.isArray = function (object) {
    if (object === undefined || object === null) {
      return false;
    }
    switch(Object.prototype.toString.call(object)) {
      case "[object Array]":
      case "[object Float32Array]":
      case "[object Float64Array]":
      case "[object Uint8Array]":
      case "[object Uint16Array]":
      case "[object Uint32Array]":
      case "[object Uint8ClampedArray]":
      case "[object Int8Array]":
      case "[object Int16Array]":
      case "[object Int32Array]":
        return true;
      default:
        return false;
    }
  };

  // publish everything to exports
  for (var key in arrays) {
    if (arrays.hasOwnProperty(key)) exports[key] = arrays[key];
  }
});

define('arrays', ['arrays/index'], function (main) { return main; });

/*global define: false console: true */

define('common/console',['require','lab.config'],function (require) {
  // Dependencies.
  var labConfig = require('lab.config'),

      // Object to be returned.
      publicAPI,
      cons,
      emptyFunction = function () {};

  // Prevent a console.log from blowing things up if we are on a browser that
  // does not support it ... like IE9.
  if (typeof console === 'undefined') {
    console = {};
    if (window) window.console = console;
  }

  // Assign shortcut.
  cons = console;
  // Make sure that every method is defined.
  if (cons.log === undefined)
    cons.log = emptyFunction;
  if (cons.info === undefined)
    cons.info = emptyFunction;
  if (cons.warn === undefined)
    cons.warn = emptyFunction;
  if (cons.error === undefined)
    cons.error = emptyFunction;
  if (cons.time === undefined)
    cons.time = emptyFunction;
  if (cons.timeEnd === undefined)
    cons.timeEnd = emptyFunction;

  // Make sure that every method has access to an 'apply' method
  // This is a hack for IE9 and IE10 when using the built-in developer tools.
  // See: http://stackoverflow.com/questions/5472938/does-ie9-support-console-log-and-is-it-a-real-function
  if (cons.log.apply === undefined)
    cons.log = Function.prototype.bind.call(console.log, console);
  if (cons.info.apply === undefined)
    cons.info = Function.prototype.bind.call(console.info, console);
  if (cons.warn.apply === undefined)
    cons.warn = Function.prototype.bind.call(console.warn, console);
  if (cons.error.apply === undefined)
    cons.error = Function.prototype.bind.call(console.error, console);
  if (cons.time.apply === undefined)
    cons.time = Function.prototype.bind.call(console.time, console);
  if (cons.timeEnd.apply === undefined)
    cons.timeEnd = Function.prototype.bind.call(console.timeEnd, console);

  publicAPI = {
    log: function () {
      if (labConfig.logging)
        cons.log.apply(cons, arguments);
    },
    info: function () {
      if (labConfig.logging)
        cons.info.apply(cons, arguments);
    },
    warn: function () {
      if (labConfig.logging)
        cons.warn.apply(cons, arguments);
    },
    error: function () {
      if (labConfig.logging)
        cons.error.apply(cons, arguments);
    },
    time: function () {
      if (labConfig.tracing)
        cons.time.apply(cons, arguments);
    },
    timeEnd: function () {
      if (labConfig.tracing)
        cons.timeEnd.apply(cons, arguments);
    }
  };

  return publicAPI;
});

/*global define: false alert: false */

/**
  Tiny module providing global way to show errors to user.

  It's better to use module, as in the future, we may want to replace basic
  alert with more sophisticated solution (for example jQuery UI dialog).
*/
define('common/alert',['require','common/console'],function (require) {
  // Dependencies.
  var console = require('common/console'),

      // Try to use global alert. If it's not available, use console.error (node.js).
      alertFunc = typeof alert !== 'undefined' ? alert : console.error;

  return function alert(msg) {
    alertFunc(msg);
  };
});

/*global define: false */

define('common/controllers/interactive-metadata',[],function() {

  return {
    /**
      Interactive top-level properties:
    */
    interactive: {
      title: {
        required: true
      },

      publicationStatus: {
        defaultValue: "public"
      },

      subtitle: {
        defaultValue: ""
      },

      about: {
        defaultValue: ""
      },

      // optional: holds path of html or cml page this Interactive was imported from
      importedFrom: {},

      fontScale: {
        defaultValue: 1
      },

      models: {
        // List of model definitions. Its definition is below ('model').
        required: true
      },

      parameters: {
        // List of custom parameters.
        defaultValue: []
      },

      outputs: {
        // List of outputs.
        defaultValue: []
      },

      filteredOutputs: {
        // List of filtered outputs.
        defaultValue: []
      },

      exports: {
        required: false
      },

      components: {
        // List of the interactive components. Their definitions are below ('button', 'checkbox' etc.).
        defaultValue: []
      },

      layout: {
        // Layout definition.
        defaultValue: {}
      },

      template: {
        // Layout template definition.
        defaultValue: "simple"
      }
    },

    model: {
      // Definition of a model.
      // Can include either a URL to model definition or model options hash..
      type: {
        required: true
      },
      id: {
        required: true
      },
      url: {
        conflictsWith: ["model"]
      },
      // optional: holds path of html or cml page this Interactive was imported from
      importedFrom: {},
      model: {
        conflictsWith: ["url"]
      },
      // Optional "onLoad" script.
      onLoad: {},
      // Optional hash of options overwriting model options.
      viewOptions: {},
      modelOptions: {},
      // Parameters, outputs and filtered outputs can be also specified per model.
      parameters: {},
      outputs: {},
      filteredOutputs: {}
    },

    parameter: {
      name: {
        required: true
      },
      initialValue: {
        required: true
      },
      // Optional "onChange" script.
      onChange: {},
      // Optional description.
      label: {},
      unitType: {},
      unitName: {},
      unitPluralName: {},
      unitAbbreviation: {}
    },

    output: {
      name: {
        required: true
      },
      value: {
        required: true
      },
      // Optional description.
      label: {},
      unitType: {},
      unitName: {},
      unitPluralName: {},
      unitAbbreviation: {}
    },

    filteredOutput: {
      name: {
        required: true
      },
      property: {
        required: true
      },
      type: {
        // For now, only "RunningAverage" is supported.
        defaultValue: "RunningAverage"
      },
      period: {
        // Smoothing time period in fs.
        defaultValue: 2500
      },
      // Optional description.
      label: {},
      unitType: {},
      unitName: {},
      unitPluralName: {},
      unitAbbreviation: {}
    },

    exports: {
      perRun: {
        required: false,
        defaultValue: []
      },
      perTick: {
        required: true
      }
    },

    /**
      Interactive components:
    */
    playback: {
      id: {
        required: true
      },
      type: {
        required: true
      },
      stepping: {
        defaultValue: true
      }
    },

    text: {
      id: {
        required: true
      },
      type: {
        required: true
      },
      onClick: {
        // Script executed on user click, optional.
      },
      text: {
        // Text content.
        defaultValue: ""
      },
      width: {
        defaultValue: "auto"
      },
      height: {
        defaultValue: "auto"
      }
    },

    image: {
      id: {
        required: true
      },
      type: {
        required: true
      },
      src: {
        // Absolute path should start with http(s)://
        // Relative path is relative to model URL.
        defaultValue: ""
      },
      width: {
        defaultValue: "auto"
      },
      height: {
        defaultValue: "auto"
      },
      onClick: {
        // Script executed on user click, optional.
      }
    },

    div: {
      id: {
        required: true
      },
      type: {
        required: true
      },
      width: {
        defaultValue: "auto"
      },
      height: {
        defaultValue: "auto"
      },
      onClick: {
        // Script executed on user click, optional.
      },
      classes: {
        defaultValue: []
      },
      tooltip: {
        // Optional tooltip text
      }
    },

    button: {
      id: {
        required: true
      },
      type: {
        required: true
      },
      action: {
        required: true
      },
      text: {
        defaultValue: ""
      },
      width: {
        defaultValue: ""
      },
      height: {
        defaultValue: ""
      }
    },

    checkbox: {
      id: {
        required: true
      },
      type: {
        required: true
      },
      text: {
        defaultValue: ""
      },
      textOn: {
        defaultValue: "right"
      },
      width: {
        defaultValue: "auto"
      },
      height: {
        defaultValue: "auto"
      },
      property: {
        conflictsWith: ["initialValue"]
      },
      onClick: {
        // Script executed on user click, optional.
      },
      initialValue: {
        // Note that 'initialValue' makes sense only for checkboxes without property binding.
        // Do not use checkbox as setter.
        conflictsWith: ["property"]
      }
    },

    slider: {
      id: {
        required: true
      },
      type: {
        required: true
      },
      min: {
        required: true
      },
      max: {
        required: true
      },
      steps: {
        required: true
      },
      title: {
        defaultValue: ""
      },
      labels: {
        // Label is specified by the following object:
        // {
        //   "value": [value, e.g. 100],
        //   "label": [label, e.g. "High"]
        // }
        defaultValue: []
      },
      width: {
        defaultValue: "auto"
      },
      height: {
        defaultValue: "auto"
      },
      displayValue: {},
      // Use "property" OR "action" + "initialValue".
      property: {
        // If you use property binding, do not mix it with action scripts and initial values.
        conflictsWith: ["initialValue", "action"]
      },
      action: {
        conflictsWith: ["property"]
      },
      initialValue: {
        // Do not use slider as a property setter.
        // There are better ways to do it, e.g.:
        // "onLoad" scripts (and set({ }) call inside), "modelOptions", etc.
        conflictsWith: ["property"]
      }
    },

    pulldown: {
      id: {
        required: true
      },
      type: {
        required: true
      },
      label: {
        defaultValue: ""
      },
      labelOn: {
        // Other option is "left".
        defaultValue: "top"
      },
      options: {
        defaultValue: []
      },
      property: {
        // Pulldown can be also connected to a model property.
        // In such case, options should define "value", not "action".
      }
    },

    pulldownOption: {
      text: {
        defaultValue: ""
      },
      action: {
        // Use it when pulldown is not bound to any model property.
        conflictsWith: ["value"]
      },
      value: {
        // Use it when pulldown is bound to some model property.
        conflictsWith: ["action"]
      },
      selected: {
        // Use it when pulldown is not bound to any model property.
        // When "property" is used for pulldown, it will determine
        // selection.
        conflictsWith: ["value"]
      },
      disabled: {},
      loadModel: {}
    },

    radio: {
      id: {
        required: true
      },
      type: {
        required: true
      },
      orientation: {
        defaultValue: "vertical"
      },
      label: {
        defaultValue: ""
      },
      labelOn: {
        // Other option is "left".
        defaultValue: "top"
      },
      options: {
        defaultValue: []
      },
      property: {
        // Radio can be also connected to a model property.
        // In such case, options should define "value", not "action".
      }
    },

    radioOption: {
      text: {
        defaultValue: ""
      },
      action: {
        // Use it when radio is not bound to any model property.
        conflictsWith: ["value"]
      },
      value: {
        // Use it when radio is bound to some model property.
        conflictsWith: ["action"]
      },
      selected: {
        // Use it when radio is not bound to any model property.
        // When "property" is used for radio, it will determine
        // selection.
        conflictsWith: ["value"]
      },
      disabled: {},
      loadModel: {}
    },

    numericOutput: {
      id: {
        required: true
      },
      type: {
        required: true
      },
      label: {
        defaultValue: ""
      },
      units: {
        defaultValue: ""
      },
      orientation: {
        defaultValue: "horizontal"
      },
      width: {
        defaultValue: "auto"
      },
      height: {
        defaultValue: "auto"
      },
      property: {},
      displayValue: {}
    },

    thermometer: {
      id: {
        required: true
      },
      type: {
        required: true
      },
      min: {
        required: true
      },
      max: {
        required: true
      },
      width: {
        // It controls width of the thermometer graphics!
        // It won't affect label, e.g. making it truncated
        // as width is only "2.5em".
        defaultValue: "2.5em"
      },
      height: {
        // Height of the whole thermometer with reading.
        defaultValue: "100%"
      },
      labelIsReading: {
        defaultValue: false
      },
      reading: {
        defaultValue: {
          units: "K",
          offset: 0,
          scale: 1,
          digits: 0
        }
      },
      labels: {
        // Label is specified by the following object:
        // {
        //   "value": [value, e.g. 100],
        //   "label": [label, e.g. "High"]
        // }
        defaultValue: []
      }
    },

    graph: {
      id: {
        required: true
      },
      type: {
        required: true
      },
      dataPoints: {
        defaultValue: []
      },
      fontScaleRelativeToParent: {
        defaultValue: true
      },
      properties: {
        defaultValue: []
      },
      title: {
        defaultValue: "Graph"
      },
      width: {
        defaultValue: "100%"
      },
      height: {
        defaultValue: "100%"
      },
      xlabel: {
        defaultValue: "Model Time (ps)"
      },
      xmin: {
        defaultValue: 0
      },
      xmax: {
        defaultValue: 20
      },
      ylabel: {
        defaultValue: ""
      },
      ymin: {
        defaultValue: 0
      },
      ymax: {
        defaultValue: 10
      },
      xTickCount: {
        defaultValue: 10
      },
      yTickCount: {
        defaultValue: 10
      },
      xscaleExponent: {
        defaultValue: 0.5
      },
      yscaleExponent: {
        defaultValue: 0.5
      },
      xFormatter: {
        defaultValue: "3.2r"
      },
      yFormatter: {
        defaultValue: "3.2r"
      },
      lines: {
        defaultValue: true
      },
      bars: {
        defaultValue: false
      }
    },

    barGraph: {
      id: {
        required: true
      },
      type: {
        required: true
      },
      property: {
        required: true
      },
      secondProperty: {
        // Additional value displayed
        // using small triangle. E.g.
        // can be used to present
        // averaged value.
        conflictsWith: ["averagePeriod"]
      },
      min: {
        // Min value displayed.
        defaultValue: 0
      },
      max: {
        // Max value displayed.
        defaultValue: 10
      },
      title: {
        // Graph title.
        defaultValue: ""
      },
      titleOn: {
        // Title position, accepted values are:
        // "right", "top", "bottom"
        defaultValue: "right"
      },
      labels: {
        // Number of labels displayed on the left side of the graph.
        // This value is *only* a suggestion. The most clean
        // and human-readable values are used.
        // You can also specify value-label pairs, e.g.:
        // [
        //   {
        //     "value": 0,
        //     "label": "low"
        //   },
        //   {
        //     "value": 10,
        //     "label": "high"
        //   }
        // ]
        // Use 0 or null to disable labels completely.
        defaultValue: 5
      },
      units: {
        // Units displayed next to labels. Set it to 'true' to use units
        // automatically retrieved from property description. Set it to any
        // string to use custom unit symbol.
        defaultValue: false
      },
      gridLines: {
        // Number of grid lines displayed on the bar.
        // This value is *only* a suggestion, it's similar to 'ticks'.
        defaultValue: 10
      },
      labelFormat: {
        // Format of labels.
        // See the specification of this format:
        // https://github.com/mbostock/d3/wiki/Formatting#wiki-d3_format
        // or:
        // http://docs.python.org/release/3.1.3/library/string.html#formatspec
        defaultValue: "0.1f"
      },
      averagePeriod: {
        // Setting this property to some numeric value
        // enables displaying of the averaged property.
        // It's a shortcut which can be used instead
        // of a custom filtered output bound
        // to the "secondProperty".
        conflictsWith: ["secondProperty"]
      },
      barWidth: {
        // Widht of the bar graph, WITHOUT
        // labels, title and padding.
        defaultValue: "2em"
      },
      height: {
        // Height of the bar graph container,
        // including small padding.
        defaultValue: "100%"
      },
      barColor: {
        // Color of the main bar.
        defaultValue:  "#e23c34"
      },
      fillColor: {
        // Color of the area behind the bar.
        defaultValue: "#fff"
      }
    }
  };
});

/*global define: false, $: false */

// For now, only defaultValue, readOnly and immutable
// meta-properties are supported.
define('common/validator',['require','arrays'],function(require) {

  var arrays = require('arrays');

  // Create a new object, that prototypically inherits from the Error constructor.
  // It provides a direct information which property of the input caused an error.
  function ValidationError(prop, message) {
    this.prop = prop;
    this.message = message;
  }
  ValidationError.prototype = new Error();
  ValidationError.prototype.constructor = ValidationError;

  function checkConflicts(input, propName, conflictingProps) {
    var i, len;
    for (i = 0, len = conflictingProps.length; i < len; i++) {
      if (input.hasOwnProperty(conflictingProps[i])) {
        throw new ValidationError(propName, "Properties set contains conflicting properties: " +
          conflictingProps[i] + " and " + propName);
      }
    }
  }

  function validateSingleProperty(propertyMetadata, prop, value, ignoreImmutable) {
    if (propertyMetadata.readOnly) {
      throw new ValidationError(prop, "Properties set tries to overwrite read-only property " + prop);
    }
    if (!ignoreImmutable && propertyMetadata.immutable) {
      throw new ValidationError(prop, "Properties set tries to overwrite immutable property " + prop);
    }
    // Use custom validate function defined in metadata if provided.
    return propertyMetadata.validate ? propertyMetadata.validate(value) : value;
  }

  return {

    // Basic validation.
    // Check if provided 'input' hash doesn't try to overwrite properties
    // which are marked as read-only or immutable. Don't take into account
    // 'defaultValue' as the 'input' hash is allowed to be incomplete.
    // It should be used *only* for update of an object.
    // While creating new object, use validateCompleteness() instead!
    validate: function (metadata, input, ignoreImmutable) {
      var result = {},
          prop, propMetadata;

      if (arguments.length < 2) {
        throw new Error("Incorrect usage. Provide metadata and hash which should be validated.");
      }

      for (prop in input) {
        if (input.hasOwnProperty(prop)) {
          // Try to get meta-data for this property.
          propMetadata = metadata[prop];
          // Continue only if the property is listed in meta-data.
          if (propMetadata !== undefined) {
            input[prop] = validateSingleProperty(propMetadata, prop, input[prop], ignoreImmutable);
            if (propMetadata.conflictsWith) {
              checkConflicts(input, prop, propMetadata.conflictsWith);
            }
            result[prop] = input[prop];
          }
        }
      }
      return result;
    },

    validateSingleProperty: validateSingleProperty,

    propertyIsWritable: function(propertyMetadata) {
      // Note that immutable properties are writable, they just have to be
      return ! propertyMetadata.readOnly;
    },

    propertyChangeInvalidates: function(propertyMetadata) {
      // Default to true for safety.
      if (propertyMetadata.propertyChangeInvalidates === undefined) {
        return true;
      }
      return !!propertyMetadata.propertyChangeInvalidates;
    },

    // Complete validation.
    // Assume that provided 'input' hash is used for creation of new
    // object. Start with checking if all required values are provided,
    // and using default values if they are provided.
    // Later perform basic validation.
    validateCompleteness: function (metadata, input) {
      var result = {},
          prop, propMetadata;

      if (arguments.length < 2) {
        throw new Error("Incorrect usage. Provide metadata and hash which should be validated.");
      }

      for (prop in metadata) {
        if (metadata.hasOwnProperty(prop)) {
          propMetadata = metadata[prop];

          if (input[prop] === undefined || input[prop] === null) {
            // Value is not declared in the input data.
            if (propMetadata.required === true) {
              throw new ValidationError(prop, "Properties set is missing required property " + prop);
            } else if (arrays.isArray(propMetadata.defaultValue)) {
              // Copy an array defined as a default value.
              // Do not use instance defined in metadata.
              result[prop] = arrays.copy(propMetadata.defaultValue, []);
            } else if (typeof propMetadata.defaultValue === "object") {
              // Copy an object defined as a default value.
              // Do not use instance defined in metadata.
              result[prop] = $.extend(true, {}, propMetadata.defaultValue);
            } else if (propMetadata.defaultValue !== undefined) {
              // If it's basic type, just set value.
              result[prop] = propMetadata.defaultValue;
            }
          } else if (!arrays.isArray(input[prop]) && typeof input[prop] === "object" && typeof propMetadata.defaultValue === "object") {
            // Note that typeof [] is also "object" - that is the reason of the isArray() check.
            result[prop] = $.extend(true, {}, propMetadata.defaultValue, input[prop]);
          } else if (arrays.isArray(input[prop])) {
            // Deep copy of an array.
            result[prop] = $.extend(true, [], input[prop]);
          } else {
            // Basic type like number, so '=' is enough.
            result[prop] = input[prop];
          }
        }
      }

      // Perform standard check like for hash meant to update object.
      // However, ignore immutable check, as these properties are supposed
      // to create a new object.
      return this.validate(metadata, result, true);
    },

    // Expose ValidationError. It can be useful for the custom validation routines.
    ValidationError: ValidationError
  };
});

define('common/interactive-not-found',['require'],function (require) {

  return function interactiveNotFound(interactiveUrl) {
    return {
      "title": "Interactive not found",
      "subtitle": "Couldn't load Interactive definition",
      "about": [
        "Problem loading: [" + interactiveUrl + "](" + interactiveUrl + ")",
        "Either the definition for this Interactive has moved, been deleted or there have been network problems.",
        "It would be good to report this issue"
      ],
      "publicationStatus": "broken",
      "fontScale": 1.3,
      "models": [
        {
          "type": "md2d",
          "id": "empty-model",
          "model": {
            "type": "md2d",
            "width": 5,
            "height": 3
          },
          "viewOptions": {
            "controlButtons": "",
            "backgroundColor": "rgba(245,200,200,255)",
            "showClock": false
          }
        }
      ],
      "components": [
        {
          "type": "text",
          "id": "interactive-not-found",
          "text": [
            "##Oops!",
            "",
            "####We couldn't find the Interactive you are looking for:",
            "[" + interactiveUrl + "](" + interactiveUrl + ")",
            "",
            "It may have moved (without leaving a forwarding address).",
            "Try searching our [Next-Generation Molecular Workbench Activities page](http://mw.concord.org/nextgen/interactives/)."
          ]
        }
      ],
      "layout": {
        "error": [ "interactive-not-found" ]
      },
      "template": [
        {
          "id": "top",
          "bottom": "model.top",
          "height": "1em"
        },
        {
          "id": "bottom",
          "top": "model.bottom",
          "height": "1em"
        },
        {
          "id": "right",
          "left": "model.right",
          "width": "1em"
        },
        {
          "id": "left",
          "right": "model.left",
          "width": "1em"
        },
        {
          "id": "error",
          "top": "model.top",
          "left": "model.left",
          "height": "model.height",
          "width": "model.width",
          "padding-top": "0.5em",
          "padding-bottom": "0.5em",
          "padding-right": "1em",
          "padding-left": "1em"
        }
      ]
    };
  };
});

//     Underscore.js 1.4.2
//     http://underscorejs.org
//     (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `global` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var push             = ArrayProto.push,
      slice            = ArrayProto.slice,
      concat           = ArrayProto.concat,
      unshift          = ArrayProto.unshift,
      toString         = ObjProto.toString,
      hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root['_'] = _;
  }

  // Current version.
  _.VERSION = '1.4.2';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, l = obj.length; i < l; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      for (var key in obj) {
        if (_.has(obj, key)) {
          if (iterator.call(context, obj[key], key, obj) === breaker) return;
        }
      }
    }
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results[results.length] = iterator.call(context, value, index, list);
    });
    return results;
  };

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError('Reduce of empty array with no initial value');
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return arguments.length > 2 ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError('Reduce of empty array with no initial value');
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, iterator, context) {
    var result;
    any(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
    each(obj, function(value, index, list) {
      if (iterator.call(context, value, index, list)) results[results.length] = value;
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, iterator, context) {
    return _.filter(obj, function(value, index, list) {
      return !iterator.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
    each(obj, function(value, index, list) {
      if (!(result = result && iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, iterator, context) {
    iterator || (iterator = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
    each(obj, function(value, index, list) {
      if (result || (result = iterator.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    return _.map(obj, function(value) {
      return (_.isFunction(method) ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, function(value){ return value[key]; });
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // with specific `key:value` pairs.
  _.where = function(obj, attrs) {
    if (_.isEmpty(attrs)) return [];
    return _.filter(obj, function(value) {
      for (var key in attrs) {
        if (attrs[key] !== value[key]) return false;
      }
      return true;
    });
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See: https://bugs.webkit.org/show_bug.cgi?id=80797
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return -Infinity;
    var result = {computed : -Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed >= result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    if (!iterator && _.isEmpty(obj)) return Infinity;
    var result = {computed : Infinity};
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      computed < result.computed && (result = {value : value, computed : computed});
    });
    return result.value;
  };

  // Shuffle an array.
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    return _.isFunction(value) ? value : function(obj){ return obj[value]; };
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, value, context) {
    var iterator = lookupIterator(value);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value : value,
        index : index,
        criteria : iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index < right.index ? -1 : 1;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(obj, value, context, behavior) {
    var result = {};
    var iterator = lookupIterator(value);
    each(obj, function(value, index) {
      var key = iterator.call(context, value, index, obj);
      behavior(result, key, value);
    });
    return result;
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key, value) {
      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);
    });
  };

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = function(obj, value, context) {
    return group(obj, value, context, function(result, key, value) {
      if (!_.has(result, key)) result[key] = 0;
      result[key]++;
    });
  };

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = iterator == null ? _.identity : lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely convert anything iterable into a real, live array.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (obj.length === +obj.length) return slice.call(obj);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n != null) && !guard) {
      return slice.call(array, Math.max(array.length - n, 0));
    } else {
      return array[array.length - 1];
    }
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, function(value){ return !!value; });
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    each(input, function(value) {
      if (_.isArray(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Return a completely flattened version of an array.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(concat.apply(ArrayProto, arguments));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.indexOf(other, item) >= 0;
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var args = slice.call(arguments);
    var length = _.max(_.pluck(args, 'length'));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(args, "" + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, l = list.length; i < l; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, l = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < l; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var len = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(len);

    while(idx < len) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Binding with arguments is also known as `curry`.
  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.
  // We check for `func.bind` first, to fail fast when `func` is undefined.
  _.bind = function bind(func, context) {
    var bound, args;
    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Bind all of an object's methods to that object. Useful for ensuring that
  // all callbacks defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length == 0) funcs = _.functions(obj);
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time.
  _.throttle = function(func, wait) {
    var context, args, timeout, result;
    var previous = 0;
    var later = function() {
      previous = new Date;
      timeout = null;
      result = func.apply(context, args);
    };
    return function() {
      var now = new Date;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        previous = now;
        result = func.apply(context, args);
      } else if (!timeout) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, result;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        if (!immediate) result = func.apply(context, args);
      };
      var callNow = immediate && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
      if (callNow) result = func.apply(context, args);
      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return function() {
      var args = [func];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    if (times <= 0) return func();
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = nativeKeys || function(obj) {
    if (obj !== Object(obj)) throw new TypeError('Invalid object');
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var values = [];
    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var pairs = [];
    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      for (var prop in source) {
        if (obj[prop] == null) obj[prop] = source[prop];
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Objects with different constructors are not equivalent, but `Object`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {
        return false;
      }
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite( obj ) && !isNaN( parseFloat(obj) );
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    for (var i = 0; i < n; i++) iterator.call(context, i);
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + (0 | Math.random() * (max - min + 1));
  };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '/': '&#x2F;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named property is a function then invoke it;
  // otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return null;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name){
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });
      source +=
        escape ? "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'" :
        interpolate ? "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'" :
        evaluate ? "';\n" + evaluate + "\n__p+='" : '';
      index = offset + match.length;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

}).call(this);

define("underscore", (function (global) {
    return function () {
        var ret, fn;
        return ret || global._;
    };
}(this)));

//     Backbone.js 1.0.0

//     (c) 2010-2013 Jeremy Ashkenas, DocumentCloud Inc.
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org

(function(){

  // Initial Setup
  // -------------

  // Save a reference to the global object (`window` in the browser, `exports`
  // on the server).
  var root = this;

  // Save the previous value of the `Backbone` variable, so that it can be
  // restored later on, if `noConflict` is used.
  var previousBackbone = root.Backbone;

  // Create local references to array methods we'll want to use later.
  var array = [];
  var push = array.push;
  var slice = array.slice;
  var splice = array.splice;

  // The top-level namespace. All public Backbone classes and modules will
  // be attached to this. Exported for both the browser and the server.
  var Backbone;
  if (typeof exports !== 'undefined') {
    Backbone = exports;
  } else {
    Backbone = root.Backbone = {};
  }

  // Current version of the library. Keep in sync with `package.json`.
  Backbone.VERSION = '1.0.0';

  // Require Underscore, if we're on the server, and it's not already present.
  var _ = root._;
  if (!_ && (typeof require !== 'undefined')) _ = require('underscore');

  // For Backbone's purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
  // the `$` variable.
  Backbone.$ = root.jQuery || root.Zepto || root.ender || root.$;

  // Runs Backbone.js in *noConflict* mode, returning the `Backbone` variable
  // to its previous owner. Returns a reference to this Backbone object.
  Backbone.noConflict = function() {
    root.Backbone = previousBackbone;
    return this;
  };

  // Turn on `emulateHTTP` to support legacy HTTP servers. Setting this option
  // will fake `"PUT"` and `"DELETE"` requests via the `_method` parameter and
  // set a `X-Http-Method-Override` header.
  Backbone.emulateHTTP = false;

  // Turn on `emulateJSON` to support legacy servers that can't deal with direct
  // `application/json` requests ... will encode the body as
  // `application/x-www-form-urlencoded` instead and will send the model in a
  // form param named `model`.
  Backbone.emulateJSON = false;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  var Events = Backbone.Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = {};
        return this;
      }

      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeners = this._listeners;
      if (!listeners) return this;
      var deleteListener = !name && !callback;
      if (typeof name === 'object') callback = this;
      if (obj) (listeners = {})[obj._listenerId] = obj;
      for (var id in listeners) {
        listeners[id].off(name, callback, this);
        if (deleteListener) delete this._listeners[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeners = this._listeners || (this._listeners = {});
      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
      listeners[id] = obj;
      if (typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Allow the `Backbone` object to serve as a global event bus, for folks who
  // want global "pubsub" in a convenient place.
  _.extend(Backbone, Events);

  // Backbone.Model
  // --------------

  // Backbone **Models** are the basic data object in the framework --
  // frequently representing a row in a table in a database on your server.
  // A discrete chunk of data and a bunch of useful, related methods for
  // performing computations and transformations on that data.

  // Create a new model with the specified attributes. A client id (`cid`)
  // is automatically generated and assigned for you.
  var Model = Backbone.Model = function(attributes, options) {
    var defaults;
    var attrs = attributes || {};
    options || (options = {});
    this.cid = _.uniqueId('c');
    this.attributes = {};
    _.extend(this, _.pick(options, modelOptions));
    if (options.parse) attrs = this.parse(attrs, options) || {};
    if (defaults = _.result(this, 'defaults')) {
      attrs = _.defaults({}, attrs, defaults);
    }
    this.set(attrs, options);
    this.changed = {};
    this.initialize.apply(this, arguments);
  };

  // A list of options to be attached directly to the model, if provided.
  var modelOptions = ['url', 'urlRoot', 'collection'];

  // Attach all inheritable methods to the Model prototype.
  _.extend(Model.prototype, Events, {

    // A hash of attributes whose current and previous value differ.
    changed: null,

    // The value returned during the last failed validation.
    validationError: null,

    // The default name for the JSON `id` attribute is `"id"`. MongoDB and
    // CouchDB users may want to set this to `"_id"`.
    idAttribute: 'id',

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Return a copy of the model's `attributes` object.
    toJSON: function(options) {
      return _.clone(this.attributes);
    },

    // Proxy `Backbone.sync` by default -- but override this if you need
    // custom syncing semantics for *this* particular model.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Get the value of an attribute.
    get: function(attr) {
      return this.attributes[attr];
    },

    // Get the HTML-escaped value of an attribute.
    escape: function(attr) {
      return _.escape(this.get(attr));
    },

    // Returns `true` if the attribute contains a value that is not null
    // or undefined.
    has: function(attr) {
      return this.get(attr) != null;
    },

    // Set a hash of model attributes on the object, firing `"change"`. This is
    // the core primitive operation of a model, updating the data and notifying
    // anyone who needs to know about the change in state. The heart of the beast.
    set: function(key, val, options) {
      var attr, attrs, unset, changes, silent, changing, prev, current;
      if (key == null) return this;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      options || (options = {});

      // Run validation.
      if (!this._validate(attrs, options)) return false;

      // Extract attributes and options.
      unset           = options.unset;
      silent          = options.silent;
      changes         = [];
      changing        = this._changing;
      this._changing  = true;

      if (!changing) {
        this._previousAttributes = _.clone(this.attributes);
        this.changed = {};
      }
      current = this.attributes, prev = this._previousAttributes;

      // Check for changes of `id`.
      if (this.idAttribute in attrs) this.id = attrs[this.idAttribute];

      // For each `set` attribute, update or delete the current value.
      for (attr in attrs) {
        val = attrs[attr];
        if (!_.isEqual(current[attr], val)) changes.push(attr);
        if (!_.isEqual(prev[attr], val)) {
          this.changed[attr] = val;
        } else {
          delete this.changed[attr];
        }
        unset ? delete current[attr] : current[attr] = val;
      }

      // Trigger all relevant attribute changes.
      if (!silent) {
        if (changes.length) this._pending = true;
        for (var i = 0, l = changes.length; i < l; i++) {
          this.trigger('change:' + changes[i], this, current[changes[i]], options);
        }
      }

      // You might be wondering why there's a `while` loop here. Changes can
      // be recursively nested within `"change"` events.
      if (changing) return this;
      if (!silent) {
        while (this._pending) {
          this._pending = false;
          this.trigger('change', this, options);
        }
      }
      this._pending = false;
      this._changing = false;
      return this;
    },

    // Remove an attribute from the model, firing `"change"`. `unset` is a noop
    // if the attribute doesn't exist.
    unset: function(attr, options) {
      return this.set(attr, void 0, _.extend({}, options, {unset: true}));
    },

    // Clear all attributes on the model, firing `"change"`.
    clear: function(options) {
      var attrs = {};
      for (var key in this.attributes) attrs[key] = void 0;
      return this.set(attrs, _.extend({}, options, {unset: true}));
    },

    // Determine if the model has changed since the last `"change"` event.
    // If you specify an attribute name, determine if that attribute has changed.
    hasChanged: function(attr) {
      if (attr == null) return !_.isEmpty(this.changed);
      return _.has(this.changed, attr);
    },

    // Return an object containing all the attributes that have changed, or
    // false if there are no changed attributes. Useful for determining what
    // parts of a view need to be updated and/or what attributes need to be
    // persisted to the server. Unset attributes will be set to undefined.
    // You can also pass an attributes object to diff against the model,
    // determining if there *would be* a change.
    changedAttributes: function(diff) {
      if (!diff) return this.hasChanged() ? _.clone(this.changed) : false;
      var val, changed = false;
      var old = this._changing ? this._previousAttributes : this.attributes;
      for (var attr in diff) {
        if (_.isEqual(old[attr], (val = diff[attr]))) continue;
        (changed || (changed = {}))[attr] = val;
      }
      return changed;
    },

    // Get the previous value of an attribute, recorded at the time the last
    // `"change"` event was fired.
    previous: function(attr) {
      if (attr == null || !this._previousAttributes) return null;
      return this._previousAttributes[attr];
    },

    // Get all of the attributes of the model at the time of the previous
    // `"change"` event.
    previousAttributes: function() {
      return _.clone(this._previousAttributes);
    },

    // Fetch the model from the server. If the server's representation of the
    // model differs from its current attributes, they will be overridden,
    // triggering a `"change"` event.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        if (!model.set(model.parse(resp, options), options)) return false;
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Set a hash of model attributes, and sync the model to the server.
    // If the server returns an attributes hash that differs, the model's
    // state will be `set` again.
    save: function(key, val, options) {
      var attrs, method, xhr, attributes = this.attributes;

      // Handle both `"key", value` and `{key: value}` -style arguments.
      if (key == null || typeof key === 'object') {
        attrs = key;
        options = val;
      } else {
        (attrs = {})[key] = val;
      }

      // If we're not waiting and attributes exist, save acts as `set(attr).save(null, opts)`.
      if (attrs && (!options || !options.wait) && !this.set(attrs, options)) return false;

      options = _.extend({validate: true}, options);

      // Do not persist invalid models.
      if (!this._validate(attrs, options)) return false;

      // Set temporary attributes if `{wait: true}`.
      if (attrs && options.wait) {
        this.attributes = _.extend({}, attributes, attrs);
      }

      // After a successful server-side save, the client is (optionally)
      // updated with the server-side state.
      if (options.parse === void 0) options.parse = true;
      var model = this;
      var success = options.success;
      options.success = function(resp) {
        // Ensure attributes are restored during synchronous saves.
        model.attributes = attributes;
        var serverAttrs = model.parse(resp, options);
        if (options.wait) serverAttrs = _.extend(attrs || {}, serverAttrs);
        if (_.isObject(serverAttrs) && !model.set(serverAttrs, options)) {
          return false;
        }
        if (success) success(model, resp, options);
        model.trigger('sync', model, resp, options);
      };
      wrapError(this, options);

      method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
      if (method === 'patch') options.attrs = attrs;
      xhr = this.sync(method, this, options);

      // Restore attributes.
      if (attrs && options.wait) this.attributes = attributes;

      return xhr;
    },

    // Destroy this model on the server if it was already persisted.
    // Optimistically removes the model from its collection, if it has one.
    // If `wait: true` is passed, waits for the server to respond before removal.
    destroy: function(options) {
      options = options ? _.clone(options) : {};
      var model = this;
      var success = options.success;

      var destroy = function() {
        model.trigger('destroy', model, model.collection, options);
      };

      options.success = function(resp) {
        if (options.wait || model.isNew()) destroy();
        if (success) success(model, resp, options);
        if (!model.isNew()) model.trigger('sync', model, resp, options);
      };

      if (this.isNew()) {
        options.success();
        return false;
      }
      wrapError(this, options);

      var xhr = this.sync('delete', this, options);
      if (!options.wait) destroy();
      return xhr;
    },

    // Default URL for the model's representation on the server -- if you're
    // using Backbone's restful methods, override this to change the endpoint
    // that will be called.
    url: function() {
      var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
      if (this.isNew()) return base;
      return base + (base.charAt(base.length - 1) === '/' ? '' : '/') + encodeURIComponent(this.id);
    },

    // **parse** converts a response into the hash of attributes to be `set` on
    // the model. The default implementation is just to pass the response along.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new model with identical attributes to this one.
    clone: function() {
      return new this.constructor(this.attributes);
    },

    // A model is new if it has never been saved to the server, and lacks an id.
    isNew: function() {
      return this.id == null;
    },

    // Check if the model is currently in a valid state.
    isValid: function(options) {
      return this._validate({}, _.extend(options || {}, { validate: true }));
    },

    // Run validation against the next complete set of model attributes,
    // returning `true` if all is well. Otherwise, fire an `"invalid"` event.
    _validate: function(attrs, options) {
      if (!options.validate || !this.validate) return true;
      attrs = _.extend({}, this.attributes, attrs);
      var error = this.validationError = this.validate(attrs, options) || null;
      if (!error) return true;
      this.trigger('invalid', this, error, _.extend(options || {}, {validationError: error}));
      return false;
    }

  });

  // Underscore methods that we want to implement on the Model.
  var modelMethods = ['keys', 'values', 'pairs', 'invert', 'pick', 'omit'];

  // Mix in each Underscore method as a proxy to `Model#attributes`.
  _.each(modelMethods, function(method) {
    Model.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.attributes);
      return _[method].apply(_, args);
    };
  });

  // Backbone.Collection
  // -------------------

  // If models tend to represent a single row of data, a Backbone Collection is
  // more analagous to a table full of data ... or a small slice or page of that
  // table, or a collection of rows that belong together for a particular reason
  // -- all of the messages in this particular folder, all of the documents
  // belonging to this particular author, and so on. Collections maintain
  // indexes of their models, both in order, and for lookup by `id`.

  // Create a new **Collection**, perhaps to contain a specific type of `model`.
  // If a `comparator` is specified, the Collection will maintain
  // its models in sort order, as they're added and removed.
  var Collection = Backbone.Collection = function(models, options) {
    options || (options = {});
    if (options.url) this.url = options.url;
    if (options.model) this.model = options.model;
    if (options.comparator !== void 0) this.comparator = options.comparator;
    this._reset();
    this.initialize.apply(this, arguments);
    if (models) this.reset(models, _.extend({silent: true}, options));
  };

  // Default options for `Collection#set`.
  var setOptions = {add: true, remove: true, merge: true};
  var addOptions = {add: true, merge: false, remove: false};

  // Define the Collection's inheritable methods.
  _.extend(Collection.prototype, Events, {

    // The default model for a collection is just a **Backbone.Model**.
    // This should be overridden in most cases.
    model: Model,

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // The JSON representation of a Collection is an array of the
    // models' attributes.
    toJSON: function(options) {
      return this.map(function(model){ return model.toJSON(options); });
    },

    // Proxy `Backbone.sync` by default.
    sync: function() {
      return Backbone.sync.apply(this, arguments);
    },

    // Add a model, or list of models to the set.
    add: function(models, options) {
      return this.set(models, _.defaults(options || {}, addOptions));
    },

    // Remove a model, or a list of models from the set.
    remove: function(models, options) {
      models = _.isArray(models) ? models.slice() : [models];
      options || (options = {});
      var i, l, index, model;
      for (i = 0, l = models.length; i < l; i++) {
        model = this.get(models[i]);
        if (!model) continue;
        delete this._byId[model.id];
        delete this._byId[model.cid];
        index = this.indexOf(model);
        this.models.splice(index, 1);
        this.length--;
        if (!options.silent) {
          options.index = index;
          model.trigger('remove', model, this, options);
        }
        this._removeReference(model);
      }
      return this;
    },

    // Update a collection by `set`-ing a new list of models, adding new ones,
    // removing models that are no longer present, and merging models that
    // already exist in the collection, as necessary. Similar to **Model#set**,
    // the core operation for updating the data contained by the collection.
    set: function(models, options) {
      options = _.defaults(options || {}, setOptions);
      if (options.parse) models = this.parse(models, options);
      if (!_.isArray(models)) models = models ? [models] : [];
      var i, l, model, attrs, existing, sort;
      var at = options.at;
      var sortable = this.comparator && (at == null) && options.sort !== false;
      var sortAttr = _.isString(this.comparator) ? this.comparator : null;
      var toAdd = [], toRemove = [], modelMap = {};

      // Turn bare objects into model references, and prevent invalid models
      // from being added.
      for (i = 0, l = models.length; i < l; i++) {
        if (!(model = this._prepareModel(models[i], options))) continue;

        // If a duplicate is found, prevent it from being added and
        // optionally merge it into the existing model.
        if (existing = this.get(model)) {
          if (options.remove) modelMap[existing.cid] = true;
          if (options.merge) {
            existing.set(model.attributes, options);
            if (sortable && !sort && existing.hasChanged(sortAttr)) sort = true;
          }

        // This is a new model, push it to the `toAdd` list.
        } else if (options.add) {
          toAdd.push(model);

          // Listen to added models' events, and index models for lookup by
          // `id` and by `cid`.
          model.on('all', this._onModelEvent, this);
          this._byId[model.cid] = model;
          if (model.id != null) this._byId[model.id] = model;
        }
      }

      // Remove nonexistent models if appropriate.
      if (options.remove) {
        for (i = 0, l = this.length; i < l; ++i) {
          if (!modelMap[(model = this.models[i]).cid]) toRemove.push(model);
        }
        if (toRemove.length) this.remove(toRemove, options);
      }

      // See if sorting is needed, update `length` and splice in new models.
      if (toAdd.length) {
        if (sortable) sort = true;
        this.length += toAdd.length;
        if (at != null) {
          splice.apply(this.models, [at, 0].concat(toAdd));
        } else {
          push.apply(this.models, toAdd);
        }
      }

      // Silently sort the collection if appropriate.
      if (sort) this.sort({silent: true});

      if (options.silent) return this;

      // Trigger `add` events.
      for (i = 0, l = toAdd.length; i < l; i++) {
        (model = toAdd[i]).trigger('add', model, this, options);
      }

      // Trigger `sort` if the collection was sorted.
      if (sort) this.trigger('sort', this, options);
      return this;
    },

    // When you have more items than you want to add or remove individually,
    // you can reset the entire set with a new list of models, without firing
    // any granular `add` or `remove` events. Fires `reset` when finished.
    // Useful for bulk operations and optimizations.
    reset: function(models, options) {
      options || (options = {});
      for (var i = 0, l = this.models.length; i < l; i++) {
        this._removeReference(this.models[i]);
      }
      options.previousModels = this.models;
      this._reset();
      this.add(models, _.extend({silent: true}, options));
      if (!options.silent) this.trigger('reset', this, options);
      return this;
    },

    // Add a model to the end of the collection.
    push: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, _.extend({at: this.length}, options));
      return model;
    },

    // Remove a model from the end of the collection.
    pop: function(options) {
      var model = this.at(this.length - 1);
      this.remove(model, options);
      return model;
    },

    // Add a model to the beginning of the collection.
    unshift: function(model, options) {
      model = this._prepareModel(model, options);
      this.add(model, _.extend({at: 0}, options));
      return model;
    },

    // Remove a model from the beginning of the collection.
    shift: function(options) {
      var model = this.at(0);
      this.remove(model, options);
      return model;
    },

    // Slice out a sub-array of models from the collection.
    slice: function(begin, end) {
      return this.models.slice(begin, end);
    },

    // Get a model from the set by id.
    get: function(obj) {
      if (obj == null) return void 0;
      return this._byId[obj.id != null ? obj.id : obj.cid || obj];
    },

    // Get the model at the given index.
    at: function(index) {
      return this.models[index];
    },

    // Return models with matching attributes. Useful for simple cases of
    // `filter`.
    where: function(attrs, first) {
      if (_.isEmpty(attrs)) return first ? void 0 : [];
      return this[first ? 'find' : 'filter'](function(model) {
        for (var key in attrs) {
          if (attrs[key] !== model.get(key)) return false;
        }
        return true;
      });
    },

    // Return the first model with matching attributes. Useful for simple cases
    // of `find`.
    findWhere: function(attrs) {
      return this.where(attrs, true);
    },

    // Force the collection to re-sort itself. You don't need to call this under
    // normal circumstances, as the set will maintain sort order as each item
    // is added.
    sort: function(options) {
      if (!this.comparator) throw new Error('Cannot sort a set without a comparator');
      options || (options = {});

      // Run sort based on type of `comparator`.
      if (_.isString(this.comparator) || this.comparator.length === 1) {
        this.models = this.sortBy(this.comparator, this);
      } else {
        this.models.sort(_.bind(this.comparator, this));
      }

      if (!options.silent) this.trigger('sort', this, options);
      return this;
    },

    // Figure out the smallest index at which a model should be inserted so as
    // to maintain order.
    sortedIndex: function(model, value, context) {
      value || (value = this.comparator);
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _.sortedIndex(this.models, model, iterator, context);
    },

    // Pluck an attribute from each model in the collection.
    pluck: function(attr) {
      return _.invoke(this.models, 'get', attr);
    },

    // Fetch the default set of models for this collection, resetting the
    // collection when they arrive. If `reset: true` is passed, the response
    // data will be passed through the `reset` method instead of `set`.
    fetch: function(options) {
      options = options ? _.clone(options) : {};
      if (options.parse === void 0) options.parse = true;
      var success = options.success;
      var collection = this;
      options.success = function(resp) {
        var method = options.reset ? 'reset' : 'set';
        collection[method](resp, options);
        if (success) success(collection, resp, options);
        collection.trigger('sync', collection, resp, options);
      };
      wrapError(this, options);
      return this.sync('read', this, options);
    },

    // Create a new instance of a model in this collection. Add the model to the
    // collection immediately, unless `wait: true` is passed, in which case we
    // wait for the server to agree.
    create: function(model, options) {
      options = options ? _.clone(options) : {};
      if (!(model = this._prepareModel(model, options))) return false;
      if (!options.wait) this.add(model, options);
      var collection = this;
      var success = options.success;
      options.success = function(resp) {
        if (options.wait) collection.add(model, options);
        if (success) success(model, resp, options);
      };
      model.save(null, options);
      return model;
    },

    // **parse** converts a response into a list of models to be added to the
    // collection. The default implementation is just to pass it through.
    parse: function(resp, options) {
      return resp;
    },

    // Create a new collection with an identical list of models as this one.
    clone: function() {
      return new this.constructor(this.models);
    },

    // Private method to reset all internal state. Called when the collection
    // is first initialized or reset.
    _reset: function() {
      this.length = 0;
      this.models = [];
      this._byId  = {};
    },

    // Prepare a hash of attributes (or other model) to be added to this
    // collection.
    _prepareModel: function(attrs, options) {
      if (attrs instanceof Model) {
        if (!attrs.collection) attrs.collection = this;
        return attrs;
      }
      options || (options = {});
      options.collection = this;
      var model = new this.model(attrs, options);
      if (!model._validate(attrs, options)) {
        this.trigger('invalid', this, attrs, options);
        return false;
      }
      return model;
    },

    // Internal method to sever a model's ties to a collection.
    _removeReference: function(model) {
      if (this === model.collection) delete model.collection;
      model.off('all', this._onModelEvent, this);
    },

    // Internal method called every time a model in the set fires an event.
    // Sets need to update their indexes when models change ids. All other
    // events simply proxy through. "add" and "remove" events that originate
    // in other collections are ignored.
    _onModelEvent: function(event, model, collection, options) {
      if ((event === 'add' || event === 'remove') && collection !== this) return;
      if (event === 'destroy') this.remove(model, options);
      if (model && event === 'change:' + model.idAttribute) {
        delete this._byId[model.previous(model.idAttribute)];
        if (model.id != null) this._byId[model.id] = model;
      }
      this.trigger.apply(this, arguments);
    }

  });

  // Underscore methods that we want to implement on the Collection.
  // 90% of the core usefulness of Backbone Collections is actually implemented
  // right here:
  var methods = ['forEach', 'each', 'map', 'collect', 'reduce', 'foldl',
    'inject', 'reduceRight', 'foldr', 'find', 'detect', 'filter', 'select',
    'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke',
    'max', 'min', 'toArray', 'size', 'first', 'head', 'take', 'initial', 'rest',
    'tail', 'drop', 'last', 'without', 'indexOf', 'shuffle', 'lastIndexOf',
    'isEmpty', 'chain'];

  // Mix in each Underscore method as a proxy to `Collection#models`.
  _.each(methods, function(method) {
    Collection.prototype[method] = function() {
      var args = slice.call(arguments);
      args.unshift(this.models);
      return _[method].apply(_, args);
    };
  });

  // Underscore methods that take a property name as an argument.
  var attributeMethods = ['groupBy', 'countBy', 'sortBy'];

  // Use attributes instead of properties.
  _.each(attributeMethods, function(method) {
    Collection.prototype[method] = function(value, context) {
      var iterator = _.isFunction(value) ? value : function(model) {
        return model.get(value);
      };
      return _[method](this.models, iterator, context);
    };
  });

  // Backbone.View
  // -------------

  // Backbone Views are almost more convention than they are actual code. A View
  // is simply a JavaScript object that represents a logical chunk of UI in the
  // DOM. This might be a single item, an entire list, a sidebar or panel, or
  // even the surrounding frame which wraps your whole app. Defining a chunk of
  // UI as a **View** allows you to define your DOM events declaratively, without
  // having to worry about render order ... and makes it easy for the view to
  // react to specific changes in the state of your models.

  // Creating a Backbone.View creates its initial element outside of the DOM,
  // if an existing element is not provided...
  var View = Backbone.View = function(options) {
    this.cid = _.uniqueId('view');
    this._configure(options || {});
    this._ensureElement();
    this.initialize.apply(this, arguments);
    this.delegateEvents();
  };

  // Cached regex to split keys for `delegate`.
  var delegateEventSplitter = /^(\S+)\s*(.*)$/;

  // List of view options to be merged as properties.
  var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];

  // Set up all inheritable **Backbone.View** properties and methods.
  _.extend(View.prototype, Events, {

    // The default `tagName` of a View's element is `"div"`.
    tagName: 'div',

    // jQuery delegate for element lookup, scoped to DOM elements within the
    // current view. This should be prefered to global lookups where possible.
    $: function(selector) {
      return this.$el.find(selector);
    },

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // **render** is the core function that your view should override, in order
    // to populate its element (`this.el`), with the appropriate HTML. The
    // convention is for **render** to always return `this`.
    render: function() {
      return this;
    },

    // Remove this view by taking the element out of the DOM, and removing any
    // applicable Backbone.Events listeners.
    remove: function() {
      this.$el.remove();
      this.stopListening();
      return this;
    },

    // Change the view's element (`this.el` property), including event
    // re-delegation.
    setElement: function(element, delegate) {
      if (this.$el) this.undelegateEvents();
      this.$el = element instanceof Backbone.$ ? element : Backbone.$(element);
      this.el = this.$el[0];
      if (delegate !== false) this.delegateEvents();
      return this;
    },

    // Set callbacks, where `this.events` is a hash of
    //
    // *{"event selector": "callback"}*
    //
    //     {
    //       'mousedown .title':  'edit',
    //       'click .button':     'save'
    //       'click .open':       function(e) { ... }
    //     }
    //
    // pairs. Callbacks will be bound to the view, with `this` set properly.
    // Uses event delegation for efficiency.
    // Omitting the selector binds the event to `this.el`.
    // This only works for delegate-able events: not `focus`, `blur`, and
    // not `change`, `submit`, and `reset` in Internet Explorer.
    delegateEvents: function(events) {
      if (!(events || (events = _.result(this, 'events')))) return this;
      this.undelegateEvents();
      for (var key in events) {
        var method = events[key];
        if (!_.isFunction(method)) method = this[events[key]];
        if (!method) continue;

        var match = key.match(delegateEventSplitter);
        var eventName = match[1], selector = match[2];
        method = _.bind(method, this);
        eventName += '.delegateEvents' + this.cid;
        if (selector === '') {
          this.$el.on(eventName, method);
        } else {
          this.$el.on(eventName, selector, method);
        }
      }
      return this;
    },

    // Clears all callbacks previously bound to the view with `delegateEvents`.
    // You usually don't need to use this, but may wish to if you have multiple
    // Backbone views attached to the same DOM element.
    undelegateEvents: function() {
      this.$el.off('.delegateEvents' + this.cid);
      return this;
    },

    // Performs the initial configuration of a View with a set of options.
    // Keys with special meaning *(e.g. model, collection, id, className)* are
    // attached directly to the view.  See `viewOptions` for an exhaustive
    // list.
    _configure: function(options) {
      if (this.options) options = _.extend({}, _.result(this, 'options'), options);
      _.extend(this, _.pick(options, viewOptions));
      this.options = options;
    },

    // Ensure that the View has a DOM element to render into.
    // If `this.el` is a string, pass it through `$()`, take the first
    // matching element, and re-assign it to `el`. Otherwise, create
    // an element from the `id`, `className` and `tagName` properties.
    _ensureElement: function() {
      if (!this.el) {
        var attrs = _.extend({}, _.result(this, 'attributes'));
        if (this.id) attrs.id = _.result(this, 'id');
        if (this.className) attrs['class'] = _.result(this, 'className');
        var $el = Backbone.$('<' + _.result(this, 'tagName') + '>').attr(attrs);
        this.setElement($el, false);
      } else {
        this.setElement(_.result(this, 'el'), false);
      }
    }

  });

  // Backbone.sync
  // -------------

  // Override this function to change the manner in which Backbone persists
  // models to the server. You will be passed the type of request, and the
  // model in question. By default, makes a RESTful Ajax request
  // to the model's `url()`. Some possible customizations could be:
  //
  // * Use `setTimeout` to batch rapid-fire updates into a single request.
  // * Send up the models as XML instead of JSON.
  // * Persist models via WebSockets instead of Ajax.
  //
  // Turn on `Backbone.emulateHTTP` in order to send `PUT` and `DELETE` requests
  // as `POST`, with a `_method` parameter containing the true HTTP method,
  // as well as all requests with the body as `application/x-www-form-urlencoded`
  // instead of `application/json` with the model in a param named `model`.
  // Useful when interfacing with server-side languages like **PHP** that make
  // it difficult to read the body of `PUT` requests.
  Backbone.sync = function(method, model, options) {
    var type = methodMap[method];

    // Default options, unless specified.
    _.defaults(options || (options = {}), {
      emulateHTTP: Backbone.emulateHTTP,
      emulateJSON: Backbone.emulateJSON
    });

    // Default JSON-request options.
    var params = {type: type, dataType: 'json'};

    // Ensure that we have a URL.
    if (!options.url) {
      params.url = _.result(model, 'url') || urlError();
    }

    // Ensure that we have the appropriate request data.
    if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
      params.contentType = 'application/json';
      params.data = JSON.stringify(options.attrs || model.toJSON(options));
    }

    // For older servers, emulate JSON by encoding the request into an HTML-form.
    if (options.emulateJSON) {
      params.contentType = 'application/x-www-form-urlencoded';
      params.data = params.data ? {model: params.data} : {};
    }

    // For older servers, emulate HTTP by mimicking the HTTP method with `_method`
    // And an `X-HTTP-Method-Override` header.
    if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
      params.type = 'POST';
      if (options.emulateJSON) params.data._method = type;
      var beforeSend = options.beforeSend;
      options.beforeSend = function(xhr) {
        xhr.setRequestHeader('X-HTTP-Method-Override', type);
        if (beforeSend) return beforeSend.apply(this, arguments);
      };
    }

    // Don't process data on a non-GET request.
    if (params.type !== 'GET' && !options.emulateJSON) {
      params.processData = false;
    }

    // If we're sending a `PATCH` request, and we're in an old Internet Explorer
    // that still has ActiveX enabled by default, override jQuery to use that
    // for XHR instead. Remove this line when jQuery supports `PATCH` on IE8.
    if (params.type === 'PATCH' && window.ActiveXObject &&
          !(window.external && window.external.msActiveXFilteringEnabled)) {
      params.xhr = function() {
        return new ActiveXObject("Microsoft.XMLHTTP");
      };
    }

    // Make the request, allowing the user to override any Ajax options.
    var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger('request', model, xhr, options);
    return xhr;
  };

  // Map from CRUD to HTTP for our default `Backbone.sync` implementation.
  var methodMap = {
    'create': 'POST',
    'update': 'PUT',
    'patch':  'PATCH',
    'delete': 'DELETE',
    'read':   'GET'
  };

  // Set the default implementation of `Backbone.ajax` to proxy through to `$`.
  // Override this if you'd like to use a different library.
  Backbone.ajax = function() {
    return Backbone.$.ajax.apply(Backbone.$, arguments);
  };

  // Backbone.Router
  // ---------------

  // Routers map faux-URLs to actions, and fire events when routes are
  // matched. Creating a new one sets its `routes` hash, if not set statically.
  var Router = Backbone.Router = function(options) {
    options || (options = {});
    if (options.routes) this.routes = options.routes;
    this._bindRoutes();
    this.initialize.apply(this, arguments);
  };

  // Cached regular expressions for matching named param parts and splatted
  // parts of route strings.
  var optionalParam = /\((.*?)\)/g;
  var namedParam    = /(\(\?)?:\w+/g;
  var splatParam    = /\*\w+/g;
  var escapeRegExp  = /[\-{}\[\]+?.,\\\^$|#\s]/g;

  // Set up all inheritable **Backbone.Router** properties and methods.
  _.extend(Router.prototype, Events, {

    // Initialize is an empty function by default. Override it with your own
    // initialization logic.
    initialize: function(){},

    // Manually bind a single named route to a callback. For example:
    //
    //     this.route('search/:query/p:num', 'search', function(query, num) {
    //       ...
    //     });
    //
    route: function(route, name, callback) {
      if (!_.isRegExp(route)) route = this._routeToRegExp(route);
      if (_.isFunction(name)) {
        callback = name;
        name = '';
      }
      if (!callback) callback = this[name];
      var router = this;
      Backbone.history.route(route, function(fragment) {
        var args = router._extractParameters(route, fragment);
        callback && callback.apply(router, args);
        router.trigger.apply(router, ['route:' + name].concat(args));
        router.trigger('route', name, args);
        Backbone.history.trigger('route', router, name, args);
      });
      return this;
    },

    // Simple proxy to `Backbone.history` to save a fragment into the history.
    navigate: function(fragment, options) {
      Backbone.history.navigate(fragment, options);
      return this;
    },

    // Bind all defined routes to `Backbone.history`. We have to reverse the
    // order of the routes here to support behavior where the most general
    // routes can be defined at the bottom of the route map.
    _bindRoutes: function() {
      if (!this.routes) return;
      this.routes = _.result(this, 'routes');
      var route, routes = _.keys(this.routes);
      while ((route = routes.pop()) != null) {
        this.route(route, this.routes[route]);
      }
    },

    // Convert a route string into a regular expression, suitable for matching
    // against the current location hash.
    _routeToRegExp: function(route) {
      route = route.replace(escapeRegExp, '\\$&')
                   .replace(optionalParam, '(?:$1)?')
                   .replace(namedParam, function(match, optional){
                     return optional ? match : '([^\/]+)';
                   })
                   .replace(splatParam, '(.*?)');
      return new RegExp('^' + route + '$');
    },

    // Given a route, and a URL fragment that it matches, return the array of
    // extracted decoded parameters. Empty or unmatched parameters will be
    // treated as `null` to normalize cross-browser behavior.
    _extractParameters: function(route, fragment) {
      var params = route.exec(fragment).slice(1);
      return _.map(params, function(param) {
        return param ? decodeURIComponent(param) : null;
      });
    }

  });

  // Backbone.History
  // ----------------

  // Handles cross-browser history management, based on either
  // [pushState](http://diveintohtml5.info/history.html) and real URLs, or
  // [onhashchange](https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange)
  // and URL fragments. If the browser supports neither (old IE, natch),
  // falls back to polling.
  var History = Backbone.History = function() {
    this.handlers = [];
    _.bindAll(this, 'checkUrl');

    // Ensure that `History` can be used outside of the browser.
    if (typeof window !== 'undefined') {
      this.location = window.location;
      this.history = window.history;
    }
  };

  // Cached regex for stripping a leading hash/slash and trailing space.
  var routeStripper = /^[#\/]|\s+$/g;

  // Cached regex for stripping leading and trailing slashes.
  var rootStripper = /^\/+|\/+$/g;

  // Cached regex for detecting MSIE.
  var isExplorer = /msie [\w.]+/;

  // Cached regex for removing a trailing slash.
  var trailingSlash = /\/$/;

  // Has the history handling already been started?
  History.started = false;

  // Set up all inheritable **Backbone.History** properties and methods.
  _.extend(History.prototype, Events, {

    // The default interval to poll for hash changes, if necessary, is
    // twenty times a second.
    interval: 50,

    // Gets the true hash value. Cannot use location.hash directly due to bug
    // in Firefox where location.hash will always be decoded.
    getHash: function(window) {
      var match = (window || this).location.href.match(/#(.*)$/);
      return match ? match[1] : '';
    },

    // Get the cross-browser normalized URL fragment, either from the URL,
    // the hash, or the override.
    getFragment: function(fragment, forcePushState) {
      if (fragment == null) {
        if (this._hasPushState || !this._wantsHashChange || forcePushState) {
          fragment = this.location.pathname;
          var root = this.root.replace(trailingSlash, '');
          if (!fragment.indexOf(root)) fragment = fragment.substr(root.length);
        } else {
          fragment = this.getHash();
        }
      }
      return fragment.replace(routeStripper, '');
    },

    // Start the hash change handling, returning `true` if the current URL matches
    // an existing route, and `false` otherwise.
    start: function(options) {
      if (History.started) throw new Error("Backbone.history has already been started");
      History.started = true;

      // Figure out the initial configuration. Do we need an iframe?
      // Is pushState desired ... is it available?
      this.options          = _.extend({}, {root: '/'}, this.options, options);
      this.root             = this.options.root;
      this._wantsHashChange = this.options.hashChange !== false;
      this._wantsPushState  = !!this.options.pushState;
      this._hasPushState    = !!(this.options.pushState && this.history && this.history.pushState);
      var fragment          = this.getFragment();
      var docMode           = document.documentMode;
      var oldIE             = (isExplorer.exec(navigator.userAgent.toLowerCase()) && (!docMode || docMode <= 7));

      // Normalize root to always include a leading and trailing slash.
      this.root = ('/' + this.root + '/').replace(rootStripper, '/');

      if (oldIE && this._wantsHashChange) {
        this.iframe = Backbone.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow;
        this.navigate(fragment);
      }

      // Depending on whether we're using pushState or hashes, and whether
      // 'onhashchange' is supported, determine how we check the URL state.
      if (this._hasPushState) {
        Backbone.$(window).on('popstate', this.checkUrl);
      } else if (this._wantsHashChange && ('onhashchange' in window) && !oldIE) {
        Backbone.$(window).on('hashchange', this.checkUrl);
      } else if (this._wantsHashChange) {
        this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
      }

      // Determine if we need to change the base url, for a pushState link
      // opened by a non-pushState browser.
      this.fragment = fragment;
      var loc = this.location;
      var atRoot = loc.pathname.replace(/[^\/]$/, '$&/') === this.root;

      // If we've started off with a route from a `pushState`-enabled browser,
      // but we're currently in a browser that doesn't support it...
      if (this._wantsHashChange && this._wantsPushState && !this._hasPushState && !atRoot) {
        this.fragment = this.getFragment(null, true);
        this.location.replace(this.root + this.location.search + '#' + this.fragment);
        // Return immediately as browser will do redirect to new url
        return true;

      // Or if we've started out with a hash-based route, but we're currently
      // in a browser where it could be `pushState`-based instead...
      } else if (this._wantsPushState && this._hasPushState && atRoot && loc.hash) {
        this.fragment = this.getHash().replace(routeStripper, '');
        this.history.replaceState({}, document.title, this.root + this.fragment + loc.search);
      }

      if (!this.options.silent) return this.loadUrl();
    },

    // Disable Backbone.history, perhaps temporarily. Not useful in a real app,
    // but possibly useful for unit testing Routers.
    stop: function() {
      Backbone.$(window).off('popstate', this.checkUrl).off('hashchange', this.checkUrl);
      clearInterval(this._checkUrlInterval);
      History.started = false;
    },

    // Add a route to be tested when the fragment changes. Routes added later
    // may override previous routes.
    route: function(route, callback) {
      this.handlers.unshift({route: route, callback: callback});
    },

    // Checks the current URL to see if it has changed, and if it has,
    // calls `loadUrl`, normalizing across the hidden iframe.
    checkUrl: function(e) {
      var current = this.getFragment();
      if (current === this.fragment && this.iframe) {
        current = this.getFragment(this.getHash(this.iframe));
      }
      if (current === this.fragment) return false;
      if (this.iframe) this.navigate(current);
      this.loadUrl() || this.loadUrl(this.getHash());
    },

    // Attempt to load the current URL fragment. If a route succeeds with a
    // match, returns `true`. If no defined routes matches the fragment,
    // returns `false`.
    loadUrl: function(fragmentOverride) {
      var fragment = this.fragment = this.getFragment(fragmentOverride);
      var matched = _.any(this.handlers, function(handler) {
        if (handler.route.test(fragment)) {
          handler.callback(fragment);
          return true;
        }
      });
      return matched;
    },

    // Save a fragment into the hash history, or replace the URL state if the
    // 'replace' option is passed. You are responsible for properly URL-encoding
    // the fragment in advance.
    //
    // The options object can contain `trigger: true` if you wish to have the
    // route callback be fired (not usually desirable), or `replace: true`, if
    // you wish to modify the current URL without adding an entry to the history.
    navigate: function(fragment, options) {
      if (!History.started) return false;
      if (!options || options === true) options = {trigger: options};
      fragment = this.getFragment(fragment || '');
      if (this.fragment === fragment) return;
      this.fragment = fragment;
      var url = this.root + fragment;

      // If pushState is available, we use it to set the fragment as a real URL.
      if (this._hasPushState) {
        this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);

      // If hash changes haven't been explicitly disabled, update the hash
      // fragment to store history.
      } else if (this._wantsHashChange) {
        this._updateHash(this.location, fragment, options.replace);
        if (this.iframe && (fragment !== this.getFragment(this.getHash(this.iframe)))) {
          // Opening and closing the iframe tricks IE7 and earlier to push a
          // history entry on hash-tag change.  When replace is true, we don't
          // want this.
          if(!options.replace) this.iframe.document.open().close();
          this._updateHash(this.iframe.location, fragment, options.replace);
        }

      // If you've told us that you explicitly don't want fallback hashchange-
      // based history, then `navigate` becomes a page refresh.
      } else {
        return this.location.assign(url);
      }
      if (options.trigger) this.loadUrl(fragment);
    },

    // Update the hash location, either replacing the current entry, or adding
    // a new one to the browser history.
    _updateHash: function(location, fragment, replace) {
      if (replace) {
        var href = location.href.replace(/(javascript:|#).*$/, '');
        location.replace(href + '#' + fragment);
      } else {
        // Some browsers require that `hash` contains a leading #.
        location.hash = '#' + fragment;
      }
    }

  });

  // Create the default Backbone.history.
  Backbone.history = new History;

  // Helpers
  // -------

  // Helper function to correctly set up the prototype chain, for subclasses.
  // Similar to `goog.inherits`, but uses a hash of prototype properties and
  // class properties to be extended.
  var extend = function(protoProps, staticProps) {
    var parent = this;
    var child;

    // The constructor function for the new subclass is either defined by you
    // (the "constructor" property in your `extend` definition), or defaulted
    // by us to simply call the parent's constructor.
    if (protoProps && _.has(protoProps, 'constructor')) {
      child = protoProps.constructor;
    } else {
      child = function(){ return parent.apply(this, arguments); };
    }

    // Add static properties to the constructor function, if supplied.
    _.extend(child, parent, staticProps);

    // Set the prototype chain to inherit from `parent`, without calling
    // `parent`'s constructor function.
    var Surrogate = function(){ this.constructor = child; };
    Surrogate.prototype = parent.prototype;
    child.prototype = new Surrogate;

    // Add prototype properties (instance properties) to the subclass,
    // if supplied.
    if (protoProps) _.extend(child.prototype, protoProps);

    // Set a convenience property in case the parent's prototype is needed
    // later.
    child.__super__ = parent.prototype;

    return child;
  };

  // Set up inheritance for the model, collection, router, view and history.
  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;

  // Throw an error when a URL is needed, and none is supplied.
  var urlError = function() {
    throw new Error('A "url" property or function must be specified');
  };

  // Wrap an optional error callback with a fallback error event.
  var wrapError = function (model, options) {
    var error = options.error;
    options.error = function(resp) {
      if (error) error(model, resp, options);
      model.trigger('error', model, resp, options);
    };
  };

}).call(this);

define("backbone", ["underscore"], (function (global) {
    return function () {
        var ret, fn;
        return ret || global.Backbone;
    };
}(this)));

/*global define */

define('grapher/bar-graph/bar-graph-model',['require','backbone'],function (require) {
  // Dependencies.
  var Backbone = require('backbone'),

      BarGraphModel = Backbone.Model.extend({
        defaults: {
          // Current value displayed by bar graph.
          value:     0,
          // Second value displayed by bar graph (using small triangle).
          // It can be used to show averaged or previous value.
          // null means that it shouldn't be displayed at all.
          secondValue: null,
          // Min value displayed.
          min: 0,
          // Max value displayed.
          max: 10,

          // Width of the bar graph (bar itself, labels, titles etc. are
          // NOT included).
          barWidth: "2em",

          // Height of the bar graph container (bar itself + small padding).
          height: "20em",

          // Graph title. You can also specify multiline title using array
          // of strings, e.g.:
          // ["Title", "Subtitle"]
          title: "",
          // Accepted values are "right", "top" and "bottom".
          titleOn: "right",
          // Color of the main bar.
          barColor:  "#e23c34",
          // Color of the area behind the bar.
          fillColor: "white",
          // Number of labels displayed on the left side of the graph.
          // This value is *only* a suggestion. The most clean
          // and human-readable values are used.
          // You can also specify value-label pairs, e.g.:
          // [
          //   {
          //     "value": 0,
          //     "label": "low"
          //   },
          //   {
          //     "value": 10,
          //     "label": "high"
          //   }
          // ]
          // Use 0 or null to disable labels completely.
          labels:          10,
          // Units symbol displayed next to labels.
          units: "",
          // Number of grid lines displayed on the bar.
          gridLines:      10,
          // Format of labels.
          // See the specification of this format:
          // https://github.com/mbostock/d3/wiki/Formatting#wiki-d3_format
          // or:
          // http://docs.python.org/release/3.1.3/library/string.html#formatspec
          labelFormat: "0.1f"
        }
      });

  return BarGraphModel;
});

/*global define, $ */

/**
 * Require this module to initialize Lab jQuery plugins.
 */
define('common/jquery-plugins',[],function () {
  /**
   * Allows to measure element when it isn't already added to the page.
   * @param  {Function} fn       Function which will be executed.
   * @param  {string}   selector jQuery selector.
   * @param  {Object}   parent   Element which will be used as a temporal container.
   * @return {*}                 Result of 'fn' execution.
   */
  $.fn.measure = function(fn, selector, parent) {
    var el, selection, result;
    el = $(this).clone(false);
    el.css({
      visibility: 'hidden',
      position: 'absolute'
    });
    el.appendTo(parent);
    if (selector) {
      selection = el.find(selector);
    } else {
      selection = el;
    }
    result = fn.apply(selection);
    el.remove();
    return result;
  };

  /**
   * Truncates text inside given element, so its width doesn't exceed specified
   * value (in pixels). Note that you *can* use this function even on elements
   * like <p> or <h1>, which quite often have width of its parent (not width of
   * their text). This function will create a new <span> element with the same
   * style as original text and use it to measure real width of the text.
   *
   * @param  {number} maxWidth Maximum allowed width of text.
   */
  $.fn.truncate = function (maxWidth) {
    var $el = $(this),
        $span = $('<span>'),
        width,
        newText;

    $span.text($el.text());
    $span.css({
      'font-size': $el.css('font-size'),
      'font-weight': $el.css('font-weight'),
      'white-space': 'nowrap',
      'visibility': 'hidden'
    });
    $span.appendTo($el.parent());

    width = $span.width();

    if (width > maxWidth) {
      newText = $span.text() + "...";
      $span.text(newText);
      while (width > maxWidth && newText.length > 3) {
        newText = $span.text().slice(0, -4) + "...";
        $span.text(newText);
        width = $span.width();
      }

      // Save original text content in title attribute,
      // so tooltip can be displayed.
      $el.attr("title", $el.text());
      // Update original element.
      $el.text(newText);
    }
    // Cleanup!
    $span.remove();
  };
});

/*global define, d3, $ */

define('grapher/bar-graph/bar-graph-view',['require','common/jquery-plugins','backbone'],function (require) {
  //  Dependencies.
      require('common/jquery-plugins');
  var Backbone  = require('backbone'),

      uid = 0,
      // Returns unique ID used by the bar graph view.
      getUID = function () {
        return uid++;
      },

      // Get real width SVG of element using bounding box.
      getRealWidth = function (d3selection) {
        return d3selection.node().getBBox().width;
      },

      // Bar graph scales itself according to the font size.
      // We assume some CANONICAL_FONT_SIZE. All values which should
      // be scaled, should use returned function.
      CANONICAL_FONT_SIZE = 16,
      getScaleFunc = function (fontSize) {
        var factor = fontSize / CANONICAL_FONT_SIZE;

        return function (val) {
          return val * factor;
        };
      },

      setupValueLabelPairs = function (yAxis, ticks) {
        var values = [],
            labels = {},
            i, len;

        for (i = 0, len = ticks.length; i < len; i++) {
          values[i] = ticks[i].value;
          labels[values[i]] = ticks[i].label;
        }

        yAxis
          .tickValues(values)
          .tickFormat(function (value) {
            return labels[value];
          });
      },

      getFormatFunc = function (formatString, unitsString) {
        var format = d3.format(formatString);
        return function (value) {
          return format(value) + " " + unitsString;
        };
      },

      BarGraphView = Backbone.View.extend({
        // Container is a DIV.
        tagName: "div",

        className: "bar-graph",

        initialize: function () {
          // Unique ID. Required to generate unique
          // gradient names.
          this.uid = getUID();

          this.$topArea = $('<div class="top-area">').appendTo(this.$el);

          // Create some SVG elements, which are constant and doesn't need to
          // be recreated each time during rendering.
          this.vis = d3.select(this.el).append("svg");
          this.defs = this.vis.append("defs");
          this.axisContainer = this.vis.append("g");
          this.fill = this.vis.append("rect");
          this.bar = this.vis.append("rect");
          this.gridContainer = this.vis.append("g");
          this.trianglePos = this.vis.append("g");
          this.traingle = this.trianglePos.append("polygon");
          this.titleContainer = this.vis.append("g");

          this.yScale = d3.scale.linear();
          this.heightScale = d3.scale.linear();
          this.yAxis = d3.svg.axis();

          this.scale = null;
          this.barWidth = null;

          this.$bottomArea = $('<div class="bottom-area">').appendTo(this.$el);

          // Register callbacks!
          this.model.on("change", this.modelChanged, this);
        },

        // Render whole bar graph.
        render: function () {
              // toJSON() returns all attributes of the model.
              // This is equivalent to many calls like:
              // property1 = model.get("property1");
              // property2 = model.get("property2");
              // etc.
          var options            = this.model.toJSON(),
              fontSize           = parseFloat(this.$el.css("font-size")),
              // Scale function.
              scale = this.scale = getScaleFunc(fontSize),
              renderLabels       = options.labels > 0 || options.labels.length > 0,
              // Basic padding (scaled).
              paddingTop         = renderLabels ? scale(8) : scale(3),
              paddingBottom      = renderLabels ? scale(8) : scale(3),

              offset = 0;

          // Set height of the most outer container.
          this.$el.outerHeight(options.height);

          this._setupHorizontalTitle();

          this.svgHeight = this.$el.height() - this.$topArea.height() - this.$bottomArea.height();

          // Setup SVG element.
          this.vis
            .attr({
              // Use some random width. At the end of rendering, it will be
              // updated to a valid value in ems (based on the graph content).
              "width":  600,
              "height": this.svgHeight
            });

          // Setup Y scale.
          this.yScale
            .domain([options.min, options.max])
            .range([this.svgHeight - paddingTop, paddingBottom])
            .clamp(true);

          // Setup scale used to translation of the bar height.
          this.heightScale
            .domain([options.min, options.max])
            .range([0, this.svgHeight - paddingTop - paddingBottom])
            .clamp(true);

          // Render elements from left to right.

          this.axisContainer.selectAll("*").remove();
          if (renderLabels) {
            // Setup Y axis.
            this.yAxis
              .scale(this.yScale)
              .tickValues(null)
              .tickPadding(0)
              .tickSize(0, 0, 0)
              .orient("left");

            if (typeof options.labels === "number") {
              // Just normal tics.
              this.yAxis
                .ticks(options.labels)
                .tickFormat(getFormatFunc(options.labelFormat, options.units));
            } else {
              // Array with value - label pairs.
              setupValueLabelPairs(this.yAxis, options.labels);
            }

            // Create and append Y axis.
            this.axisContainer.call(this.yAxis);

            offset += getRealWidth(this.axisContainer);

            this.axisContainer.attr("transform", "translate(" + offset + ")");

            offset += scale(5);
          }

          // Setup background of the bar.
          this.fill
            .attr({
              "width": options.barWidth,
              "height": this.heightScale(options.max),
              "x": offset,
              "y": this.yScale(options.max),
              "rx": "0.5em",
              "ry": "0.5em",
              "fill": this._getFillGradient(options.fillColor)
            });

          // Setup the main bar.
          this.bar
            .attr({
              "width": options.barWidth,
              "x": offset,
              "rx": "0.5em",
              "ry": "0.5em",
              "fill": this._getBarGradient(options.barColor)
            });

          this.barWidth = getRealWidth(this.fill);

          this.traingle
            .classed("triangle", true)
            .attr({
              "points": "15,-7 15,7 1,0",
              "transform": "translate(" + offset + ") scale(" + scale(1) + ")"
            });

          this._setupGrid(offset);

          offset += this.barWidth;

          offset = this._setupTitle(offset);

          // Convert final width in px into value in ems.
          // That ensures that the SVG will work well with semantic layout.
          this.vis.attr("width", (offset / fontSize) + "em");
          this.$el.css("min-width", (offset / fontSize) + "em");

          // work-around bug on iPad2 where container is not expanding in width
          // when SVG element rendered inside it
          // see: Bar graph rendering issues on iPad
          // https://www.pivotaltracker.com/story/show/47854951
          // This means while we are duplicating the current padding styles set
          // in _grapher.sass changes in desired style must be duplicated here.
          this.$el.css("min-width", (offset / fontSize + 0.8) + "em");

          // Finally, update displayed values.
          this.update();
        },

        // Updates only bar height.
        update: function () {
          var value       = this.model.get("value"),
              secondValue = this.model.get("secondValue");

          this.bar
            .attr("height", this.heightScale(value))
            .attr("y", this.yScale(value));

          if (typeof secondValue !== 'undefined' && secondValue !== null) {
            this.traingle.classed("hidden", false);
            this.trianglePos.attr("transform", "translate(0," + this.yScale(secondValue) + ")");
          } else {
            this.traingle.classed("hidden", true);
          }
        },

        // This function should be called whenever model attribute is changed.
        modelChanged: function () {
          var changedAttributes = this.model.changedAttributes(),
              count = 0,
              valChanged, secValChanged, name;

          // There are two possible cases:
          // - Only "value" or "secondValue" have changed, so update only values
          //   displays.
          // - Other attributes have changed, so redraw whole bar graph.

          // Case 1. Check how many attributes have been changed.
          for (name in changedAttributes) {
            if (changedAttributes.hasOwnProperty(name)) {
              count++;
              if (count > 2) {
                // If 3 or more, redraw whole bar graph.
                this.render();
                return;
              }
            }
          }

          valChanged = typeof changedAttributes.value !== 'undefined';
          secValChanged = typeof changedAttributes.secondValue !== 'undefined';
          // Case 2. 1 or 2 attributes have changed, check if they are "value" and "secondValue".
          if ((count === 1 && (valChanged || secValChanged)) ||
              (count === 2 && (valChanged && secValChanged))) {
            this.update();
          } else {
            this.render();
          }
        },

        _getBarGradient: function (color) {
          var id = "bar-gradient-" + this.uid,
              gradient = this.defs.select("#" + id);

          color = d3.rgb(color);

          if (gradient.empty()) {
            // Create a new gradient.
            gradient = this.defs.append("linearGradient")
              .attr("id", id)
              .attr("x1", "0%")
              .attr("y1", "0%")
              .attr("x2", "0%")
              .attr("y2", "100%");
          } else {
            gradient.selectAll("stop").remove();
          }

          gradient.append("stop")
            .attr("stop-color", color.brighter(2).toString())
            .attr("offset", "0%");
          gradient.append("stop")
            .attr("stop-color", color.toString())
            .attr("offset", "100%");

          return "url(#" + id + ")";
        },

        _getFillGradient: function (color) {
          var id = "fill-gradient-" + this.uid,
              gradient = this.defs.select("#" + id);

          if (gradient.empty()) {
            // Create a new gradient.
            gradient = this.defs.append("linearGradient")
              .attr("id", id)
              .attr("x1", "0%")
              .attr("y1", "0%")
              .attr("x2", "0%")
              .attr("y2", "100%");
          } else {
            gradient.selectAll("stop").remove();
          }

          gradient.append("stop")
            .attr("stop-color", color)
            .attr("offset", "0%");
          gradient.append("stop")
            .attr("stop-color", color)
            .attr("stop-opacity", 0.5)
            .attr("offset", "15%");
          gradient.append("stop")
            .attr("stop-color", color)
            .attr("stop-opacity", 0.4)
            .attr("offset", "100%");

          return "url(#" + id + ")";
        },

        _setupGrid: function (offset) {
          var gridLines = this.yScale.ticks(this.model.get("gridLines")),
              yScale = this.yScale,
              width = this.barWidth;

          // Remove first and last tick, as we don't want to draw it as grid line.
          gridLines.pop(); gridLines.shift();
          this.grid = this.gridContainer.selectAll(".grid-line").data(gridLines, String),

          this.grid.enter().append("path").attr("class", "grid-line");
          this.grid.exit().remove();
          this.grid.attr("d", function (d) {
            return "M " + offset + " " + Math.round(yScale(d)) + " h " + width;
          });

          return offset;
        },

        // Setup vertical title.
        _setupTitle: function (offset) {
              // "title" option is expected to be string
              // or array of strings.
          var title = this.model.get("title"),
              self  = this,
              isArray, lines,
              titleG, gEnter;

          if (title && this.model.get("titleOn") === "right") {
            offset += this.scale(10);

            isArray = $.isArray(title);
            lines = isArray ? title.length : 1;

            titleG = this.titleContainer.selectAll(".title").data(isArray ? title : [title]);

            titleG.exit().remove();

            gEnter = titleG.enter().append("g").attr("class", "title");
            gEnter.append("title");
            gEnter.append("text");

            titleG.each(function (d, i) {
              var g = d3.select(this);
              g.select("title").text(d);
              g.select("text")
                .text(self._processTitle(d))
                .attr("dy", -(lines - i -1) + "em");
            });

            // Transform whole container.
            this.titleContainer.attr("transform",
              "translate(" + offset + ", " + this.svgHeight / 2 + ") rotate(90)");

            // Update offset.
            offset += parseFloat($(titleG.node()).css("font-size")) * lines;
          }

          return offset;
        },

        // Setup horizontal title.
        _setupHorizontalTitle: function () {
              // "title" option is expected to be string
              // or array of strings.
          var title = this.model.get("title"),
              pos = this.model.get("titleOn"),
              $container;

          this.$topArea.empty();
          this.$bottomArea.empty();

          if (!title || title.length === 0 || pos === "right") {
            return;
          }

          title = $.isArray(title) ? title : [title];

          if (pos === "top") {
            $container = this.$topArea;
          } else if (pos === "bottom") {
            $container = this.$bottomArea;
          }

          title.forEach(function (t) {
            $container.append('<p class="title">' + t + '</p>');
          });
        },

        _processTitle: function (title) {
          var $title = $('<span class="title">' + title + '</span>').appendTo(this.$el),
              truncatedText;

          $title.truncate(this.svgHeight);
          truncatedText = $title.text();
          $title.remove();
          return truncatedText;
        }
      });

  return BarGraphView;
});

/*global $: false, define: false, model: false */

// Bar graph controller.
// It provides specific interface used in MD2D environment
// (by interactives-controller and layout module).
define('common/controllers/bar-graph-controller',['require','grapher/bar-graph/bar-graph-model','grapher/bar-graph/bar-graph-view','common/controllers/interactive-metadata','common/validator'],function (require) {
  var BarGraphModel = require('grapher/bar-graph/bar-graph-model'),
      BarGraphView  = require('grapher/bar-graph/bar-graph-view'),
      metadata      = require('common/controllers/interactive-metadata'),
      validator     = require('common/validator'),

      // Note: We always explicitly copy properties from component spec to bar graph options hash,
      // in order to avoid tighly coupling an externally-exposed API (the component spec) to an
      // internal implementation detail (the bar graph options format).
      barGraphOptionForComponentSpecProperty = {
        // Min value displayed.
        min: 'min',
        // Max value displayed.
        max: 'max',
        // Graph title.
        title: 'title',
        // Title position.
        titleOn: 'titleOn',
        // Color of the main bar.
        barColor:  'barColor',
        // Color of the area behind the bar.
        fillColor: 'fillColor',
        // Number of labels displayed on the left side of the graph.
        // This value is *only* a suggestion. The most clean
        // and human-readable values are used.
        // You can also specify value-label pairs, e.g.:
        // [
        //   {
        //     "value": 0,
        //     "label": "low"
        //   },
        //   {
        //     "value": 10,
        //     "label": "high"
        //   }
        // ]
        // Use 0 or null to disable labels completely.
        labels:      'labels',
        // Number of grid lines displayed on the bar.
        // This value is *only* a suggestion, it's similar to 'ticks'.
        gridLines:  'gridLines',
        // Format of labels.
        // See the specification of this format:
        // https://github.com/mbostock/d3/wiki/Formatting#wiki-d3_format
        // or:
        // http://docs.python.org/release/3.1.3/library/string.html#formatspec
        labelFormat: 'labelFormat',
        // Units displayed next to labels. Set it to 'true' to use units
        // automatically retrieved from property description. Set it to any
        // string to use custom unit symbol.
        units: 'units'
      },

      // Limit options only to these supported.
      filterOptions = function(inputHash) {
        var options = {},
            cName, gName;

        for (cName in barGraphOptionForComponentSpecProperty) {
          if (barGraphOptionForComponentSpecProperty.hasOwnProperty(cName)) {
            gName = barGraphOptionForComponentSpecProperty[cName];
            if (inputHash[cName] !== undefined) {
              options[gName] = inputHash[cName];
            }
          }
        }
        return options;
      };

  return function BarGraphController(component) {
    var // Object with Public API.
        controller,
        // Model with options and current value.
        barGraphModel,
        // Main view.
        barGraphView,
        // First data channel.
        property,
        // Second data channel.
        secondProperty,

        update = function () {
          barGraphModel.set({value: model.get(property)});
        },
        updateSecondProperty = function () {
          barGraphModel.set({secondValue: model.get(secondProperty)});
        };

    //
    // Initialization.
    //
    // Validate component definition, use validated copy of the properties.
    component = validator.validateCompleteness(metadata.barGraph, component);
    barGraphModel = new BarGraphModel(filterOptions(component));
    barGraphView  = new BarGraphView({model: barGraphModel, id: component.id});
    // Each interactive component has to have class "component".
    barGraphView.$el.addClass("component");
    property = component.property;
    secondProperty = component.secondProperty;

    controller = {
      // This callback should be trigger when model is loaded.
      modelLoadedCallback: function () {
        var units = "";

        // Register properties listeners.
        model.addPropertiesListener([property], update);
        if (typeof component.averagePeriod !== 'undefined' && component.averagePeriod !== null) {
          // This option is for authors convenience. It causes that filtered
          // output is automatically defined (it uses basic property as an
          // input). Author doesn't have to define it manually.
          secondProperty = property + "-bargraph-" + component.id + "-average";
          model.defineFilteredOutput(secondProperty, {}, property, "RunningAverage", component.averagePeriod);
        }
        if (secondProperty) {
          model.addPropertiesListener([secondProperty], updateSecondProperty);
        }
        // Retrieve and set units if they are enabled.
        if (component.units === true) {
          // Units automatically retrieved from property description.
          units = model.getPropertyDescription(property).getUnitAbbreviation();
        } else if (component.units) {
          // Units defined in JSON definition explicitly.
          units = component.units;
        }
        // Apply custom width and height settings.
        // Do it in modelLoadedCallback, as during its execution,
        // the view container is already added to the document and
        // calculations of the size work correctly.
        // Also, pass calculated unit type.
        barGraphModel.set({
          barWidth: component.barWidth,
          height: component.height,
          units: units
        });
        // Initial render...
        barGraphView.render();
        // and update.
        update();
      },

      // Returns view container (div).
      getViewContainer: function () {
        return barGraphView.$el;
      },

      // Method required by layout module.
      resize: function () {
        // Just render bar graph again.
        barGraphView.render();
      },

      // Returns serialized component definition.
      serialize: function () {
        var result = $.extend(true, {}, component);
        // Return updated definition.
        return result;
      }
    };

    // Return Public API object.
    return controller;
  };
});

/*globals define, d3 */
//TODO: Should change and newdomain be global variables?

define('grapher/core/axis',['require'],function (require) {
  return {
    numberWidthUsingFormatter: function (elem, cx, cy, fontSizeInPixels, numberStr) {
      var testSVG,
          testText,
          bbox,
          width,
          height,
          node;

      testSVG = elem.append("svg")
        .attr("width",  cx)
        .attr("height", cy)
        .attr("class", "graph");

      testText = testSVG.append('g')
        .append("text")
          .attr("class", "axis")
          .attr("x", -fontSizeInPixels/4 + "px")
          .attr("dy", ".35em")
          .attr("text-anchor", "end")
          .text(numberStr);

      node = testText.node();

      // This code is sometimes called by tests that use d3's jsdom-based mock SVG DOm, which
      // doesn't implement getBBox.
      if (node.getBBox) {
        bbox = testText.node().getBBox();
        width = bbox.width;
        height = bbox.height;
      } else {
        width = 0;
        height = 0;
      }

      testSVG.remove();
      return [width, height];
    },
    axisProcessDrag: function(dragstart, currentdrag, domain) {
      var originExtent, maxDragIn,
          newdomain = domain,
          origin = 0,
          axis1 = domain[0],
          axis2 = domain[1],
          extent = axis2 - axis1;
      if (currentdrag !== 0) {
        if  ((axis1 >= 0) && (axis2 > axis1)) {                 // example: (20, 10, [0, 40]) => [0, 80]
          origin = axis1;
          originExtent = dragstart-origin;
          maxDragIn = originExtent * 0.4 + origin;
          if (currentdrag > maxDragIn) {
            change = originExtent / (currentdrag-origin);
            extent = axis2 - origin;
            newdomain = [axis1, axis1 + (extent * change)];
          }
        } else if ((axis1 < 0) && (axis2 > 0)) {                // example: (20, 10, [-40, 40])       => [-80, 80]
          origin = 0;                                           //          (-0.4, -0.2, [-1.0, 0.4]) => [-1.0, 0.4]
          originExtent = dragstart-origin;
          maxDragIn = originExtent * 0.4 + origin;
          if ((dragstart >= 0 && currentdrag > maxDragIn) || (dragstart  < 0  && currentdrag < maxDragIn)) {
            change = originExtent / (currentdrag-origin);
            newdomain = [axis1 * change, axis2 * change];
          }
        } else if ((axis1 < 0) && (axis2 < 0)) {                // example: (-60, -50, [-80, -40]) => [-120, -40]
          origin = axis2;
          originExtent = dragstart-origin;
          maxDragIn = originExtent * 0.4 + origin;
          if (currentdrag < maxDragIn) {
            change = originExtent / (currentdrag-origin);
            extent = axis1 - origin;
            newdomain = [axis2 + (extent * change), axis2];
          }
        }
      }
      return newdomain;
    }
  };
});

/*global define, d3, $ self */

define('grapher/core/graph',['require','grapher/core/axis'],function (require) {
  // Dependencies.
  var axis = require('grapher/core/axis'),
      tooltips = {
        autoscale: "Show all data (autoscale)"
      };

  return function Graph(idOrElement, options, message, tabindex) {
    var api = {},   // Public API object to be returned.

        // D3 selection of the containing DOM element the graph is placed in
        elem,

        // Regular representation of containing DOM element the graph is placed in
        node,

        // JQuerified version of DOM element
        $node,

        // Size of containing DOM element
        cx, cy,

        // Calculated padding between edges of DOM container and interior plot area of graph.
        padding,

        // Object containing width and height in pixels of interior plot area of graph
        size,

        // D3 objects representing SVG elements/containers in graph
        svg,
        vis,
        plot,
        viewbox,
        title,
        xlabel,
        ylabel,
        selectedRulerX,
        selectedRulerY,

        // Strings used as tooltips when labels are visible but are truncated because
        // they are too big to be rendered into the space the graph allocates
        titleTooltip,
        xlabelTooltip,
        ylabelTooltip,

        // Instantiated D3 scale functions
        // currently either d3.scale.linear, d3.scale.log, or d3.scale.pow
        xScale,
        yScale,

        // The approximate number of gridlines in the plot, passed to d3.scale.ticks() function
        xTickCount,
        yTickCount,

        // Instantiated D3 line function: d3.svg.line()
        line,

        // Instantiated D3 numeric format functions: d3.format()
        fx,
        fy,

        // Function for stroke styling of major and minor grid lines
        gridStroke = function(d) { return d ? "#ccc" : "#666"; },

        // Functions for translation of grid lines and associated numeric labels
        tx = function(d) { return "translate(" + xScale(d) + ",0)"; },
        ty = function(d) { return "translate(0," + yScale(d) + ")"; },

        // Div created and placed with z-index above all other graph layers that holds
        // graph action/mode buttons.
        buttonLayer,

        // Div created and placed with z-index under all other graph layers
        background,

        // Optional string which can be displayed in background of interior plot area of graph.
        notification,

        // An array of strings holding 0 or more lines for the title of the graph
        titles = [],

        // D3 selection containing canvas
        graphCanvas,

        // HTML5 Canvas object containing just plotted lines
        gcanvas,
        gctx,
        canvasFillStyle = "rgba(255,255,255, 0.0)",
        cplot = {},

        // Function dynamically created when X axis domain shift is in progress
        domainShift,
        // Boolean indicating X axis domain shif is in progress
        shiftingX = false,
        // Easing function used during X axis domain shift
        cubicEase = d3.ease('cubic'),
        // These are used to implement fluid X axis domain shifting.
        // This is used when plotting samples/points and extent of plotted
        // data approach extent of X axis.
        // Domain shifting can also occur when the current sample point is moved.
        // This most often occurs when using a graph to examine data from a model
        // and movingthe current sample point backwards and forwards in data that
        // have already been collected.

        // The style of the cursor when hovering over a sample.point marker.
        // The cursor changes depending on the operations that can be performed.
        markerCursorStyle,

        // Metrics calculated to support layout of titles, axes as
        // well as text and numeric labels for axes.
        fontSizeInPixels,
        halfFontSizeInPixels,
        quarterFontSizeInPixels,
        titleFontSizeInPixels,
        axisFontSizeInPixels,
        xlabelFontSizeInPixels,
        ylabelFontSizeInPixels,

        // Array objects containing width and height of X and Y axis labels
        xlabelMetrics,
        yLabelMetrics,

        // Width of widest numeric labels on X and Y axes
        xAxisNumberWidth,
        yAxisNumberWidth,

        // Height of numeric labels on X and Y axes
        xAxisNumberHeight,
        yAxisNumberHeight,

        // Padding necessary for X and Y axis labels to leave enough room for numeric labels
        xAxisVerticalPadding,
        yAxisHorizontalPadding,

        // Padding necessary between right side of interior plot and edge of graph so
        // make room for numeric lanel on right edge of X axis.
        xAxisLabelHorizontalPadding,

        // Baselines calculated for positioning of X and Y axis labels.
        xAxisLabelBaseline,
        yAxisLabelBaseline,

        // Thickness of draggable areas for rescaling axes, these surround numeric labels
        xAxisDraggableHeight,
        yAxisDraggableWidth,

        // D3 SVG rects used to implement axis dragging
        xAxisDraggable,
        yAxisDraggable,

        // Strings used as tooltips when numeric axis draggables are visible but responsive
        // layout system has removed the axis labels because of small size of graph.
        xAxisDraggableTooltip,
        yAxisDraggableTooltip,

        // Used to calculate styles for markers appearing on samples/points (normally circles)
        markerRadius,
        markerStrokeWidth,

        // Stroke width used for lines in graph
        strokeWidth,

        // Used to categorize size of graphs in responsive layout mode where
        // certain graph chrome is removed when graph is rendered smaller.
        sizeType = {
          category: "medium",
          value: 3,
          icon: 120,
          tiny: 240,
          small: 480,
          medium: 960,
          large: 1920
        },

        // State variables indicating whether an axis drag operation is in place.
        // NaN values are used to indicate operation not in progress and
        // checked like this: if (!isNaN(downx)) { resacle operation in progress }
        //
        // When drag/rescale operation is occuring values contain plot
        // coordinates of start of drag (0 is a valid value).
        downx = NaN,
        downy = NaN,

        // State variable indicating whether a data point is being dragged.
        // When data point drag operation is occuring value contain two element
        // array wiith plot coordinates of drag position.
        draggedPoint = null,

        // When a data point is selected contains two element array wiith plot coordinates
        // of selected data point.
        selected = null,

        // An array of data points in the plot which are near the cursor.
        // Normally used to temporarily display data point markers when cursor
        // is nearby when markAllDataPoints is disabled.
        selectable = [],

        // An array containing two-element arrays consisting of X and Y values for samples/points
        points = [],

        // An array containing 1 or more points arrays to be plotted.
        pointArray,

        // Index into points array for current sample/point.
        // Normally references data point last added.
        // Current sample can refer to earlier points. This is
        // represented in the view by using a desaturated styling for
        // plotted data after te currentSample.
        currentSample,

        // When graphing data samples as opposed to [x, y] data pairs contains
        // the fixed time interval between subsequent samples.
        sampleInterval,

        // The default options for a graph
        default_options = {
          // Enables the button layer with: AutoScale ...
          showButtons:    true,

          // Responsive Layout provides pregressive removal of
          // graph elements when size gets smaller
          responsiveLayout: false,

          // Font sizes for graphs are normally specified using ems.
          // When fontScaleRelativeToParent to true the font-size of the
          // containing element is set based on the size of the containing
          // element. hs means whn the containing element is smaller the
          // foint-size of the labels in thegraph will be smaller.
          fontScaleRelativeToParent: true,

          //
          // dataType can be either 'points or 'samples'
          //
          dataType: 'points',
          //
          // dataType: 'points'
          //
          // Arrays of two-element arrays of x, y data pairs, this is the internal
          // format the graphers uses to represent data.
          dataPoints:      [],
          //
          // dataType: 'samples'
          //
          // An array of samples (or an array or arrays of samples)
          dataSamples:     [],
          // The constant time interval between sample values
          sampleInterval:  1,
          // Normally data sent to graph as samples starts at an X value of 0
          // A different starting x value can be set
          dataSampleStart: 0,

          // title can be a string or an array of strings, if an
          // array of strings each element is on a separate line.
          title:          "graph",

          // The labels for the axes, these are separate from the numeric labels.
          xlabel:         "x-axis",
          ylabel:         "y-axis",

          // Initial extent of the X and Y axes.
          xmax:            10,
          xmin:            0,
          ymax:            10,
          ymin:            0,

          // Approximate values for how many gridlines should appear on the axes.
          xTickCount:      10,
          yTickCount:      10,

          // The formatter used to convert numbers into strings.
          // see: https://github.com/mbostock/d3/wiki/Formatting#wiki-d3_format
          xFormatter:      ".3s",
          yFormatter:      ".3r",

          // Scale type: options are:
          //   linear: https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-linear
          //   log:    https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-log
          //   pow:    https://github.com/mbostock/d3/wiki/Quantitative-Scales#wiki-pow
          xscale:         'linear',
          yscale:         'linear',

          // Used when scale type is set to "pow"
          xscaleExponent:  0.5,
          yscaleExponent:  0.5,

          // How many samples/points over which a graph shift should take place
          // when the data being plotted gets close to the edge of the X axis.
          axisShift:       10,

          // selectablePoints: false,

          // true if data points should be marked ... currently marked with a circle.
          markAllDataPoints:   false,

          // only show circles when hovering near them with the mouse or
          // tapping near then on a tablet
          markNearbyDataPoints: false,

          // number of circles to show on each side of the central point
          extraCirclesVisibleOnHover: 2,

          // true to show dashed horizontal and vertical rulers when a circle is selected
          showRulersOnSelection: false,

          // width of the line used for plotting
          strokeWidth:      2.0,

          // Enable values of data points to be changed by selecting and dragging.
          dataChange:      false,

          // Enables adding of data to a graph by option/alt clicking in the graph.
          addData:         false,

          // Set value to a string and it will be rendered in background of graph.
          notification:    false,

          // Render lines between samples/points
          lines:           true,

          // Render vertical bars extending up to samples/points
          bars:            false
        },

        // brush selection variables
        selection_region = {
          xmin: null,
          xmax: null,
          ymin: null,
          ymax: null
        },
        has_selection = false,
        selection_visible = false,
        selection_enabled = true,
        selection_listener,
        brush_element,
        brush_control;


    // ------------------------------------------------------------
    //
    // Initialization
    //
    // ------------------------------------------------------------

    function initialize(idOrElement, opts, mesg) {
      if (opts || !options) {
        options = setupOptions(opts);
      }

      initializeLayout(idOrElement, mesg);

      options.xrange = options.xmax - options.xmin;
      options.yrange = options.ymax - options.ymin;

      if (Object.prototype.toString.call(options.title) === "[object Array]") {
        titles = options.title;
      } else {
        titles = [options.title];
      }
      titles.reverse();

      fx = d3.format(options.xFormatter);
      fy = d3.format(options.yFormatter);

      // use local variables for both access speed and for responsive over-riding
      sampleInterval = options.sampleInterval;
      dataSampleStart = options.dataSampleStart;
      strokeWidth = options.strokeWidth;

      xTickCount = options.xTickCount;
      yTickCount = options.yTickCount;

      pointArray = [];
      switch(options.dataType) {
        case "fake":
        points = fakeDataPoints();
        pointArray = [points];
        break;

        case 'points':
        resetDataPoints(options.dataPoints);
        break;

        case 'samples':
        resetDataSamples(options.dataSamples, sampleInterval, dataSampleStart);
        break;
      }

      selectable = [];
      selected = null;

      setCurrentSample(points.length);
    }

    function initializeLayout(idOrElement, mesg) {
      if (idOrElement) {
        // d3.select works both for element ID (e.g. "#grapher")
        // and for DOM element.
        elem = d3.select(idOrElement);
        node = elem.node();
        $node = $(node);
        // cx = $node.width();
        // cy = $node.height();
        cx = elem.property("clientWidth");
        cy = elem.property("clientHeight");
      }

      if (mesg) {
        message = mesg;
      }

      if (svg !== undefined) {
        svg.remove();
        svg = undefined;
      }

      if (background !== undefined) {
        background.remove();
        background = undefined;
      }

      if (graphCanvas !== undefined) {
        graphCanvas.remove();
        graphCanvas = undefined;
      }

      if (options.dataChange) {
        markerCursorStyle = "ns-resize";
      } else {
        markerCursorStyle = "crosshair";
      }

      scale();

      // drag axis logic
      downx = NaN;
      downy = NaN;
      draggedPoint = null;
    }

    function scale(w, h) {
      if (!w && !h) {
        cx = Math.max(elem.property("clientWidth"), 60);
        cy = Math.max(elem.property("clientHeight"),60);
      } else {
        cx = w;
        node.style.width =  cx +"px";
        if (!h) {
          node.style.height = "100%";
          h = elem.property("clientHeight");
          cy = h;
          node.style.height = cy +"px";
        } else {
          cy = h;
          node.style.height = cy +"px";
        }
      }
      calculateSizeType();
    }

    function calculateLayout() {
      scale();

      fontSizeInPixels = parseFloat($node.css("font-size"));

      if (!options.fontScaleRelativeToParent) {
        $node.css("font-size", 0.5 + sizeType.value/6 + 'em');
      }

      fontSizeInPixels = parseFloat($node.css("font-size"));

      halfFontSizeInPixels = fontSizeInPixels/2;
      quarterFontSizeInPixels = fontSizeInPixels/4;

      if (svg === undefined) {
        titleFontSizeInPixels =  fontSizeInPixels;
        axisFontSizeInPixels =   fontSizeInPixels;
        xlabelFontSizeInPixels = fontSizeInPixels;
        ylabelFontSizeInPixels = fontSizeInPixels;
      } else {
        titleFontSizeInPixels =  parseFloat($("svg.graph text.title").css("font-size"));
        axisFontSizeInPixels =   parseFloat($("svg.graph text.axis").css("font-size"));
        xlabelFontSizeInPixels = parseFloat($("svg.graph text.xlabel").css("font-size"));
        ylabelFontSizeInPixels = parseFloat($("svg.graph text.ylabel").css("font-size"));
      }

      if (xScale === undefined) {
        xlabelMetrics = [fontSizeInPixels, fontSizeInPixels];
        ylabelMetrics = [fontSizeInPixels*2, fontSizeInPixels];
      } else {
        xlabelMetrics = axis.numberWidthUsingFormatter(elem, cx, cy, axisFontSizeInPixels,
          longestNumber(xScale.ticks(xTickCount), fx));

        ylabelMetrics = axis.numberWidthUsingFormatter(elem, cx, cy, axisFontSizeInPixels,
          longestNumber(yScale.ticks(yTickCount), fy));
      }

      xAxisNumberWidth  = xlabelMetrics[0];
      xAxisNumberHeight = xlabelMetrics[1];
      yAxisNumberWidth  = ylabelMetrics[0];
      yAxisNumberHeight = ylabelMetrics[0];

      xAxisLabelHorizontalPadding = xAxisNumberWidth * 0.6;
      xAxisDraggableHeight = xAxisNumberHeight * 1.1;
      xAxisVerticalPadding = xAxisDraggableHeight + xAxisNumberHeight*1.3;
      xAxisLabelBaseline = xAxisVerticalPadding-xAxisNumberHeight/3;

      yAxisDraggableWidth    = yAxisNumberWidth + xAxisNumberHeight/4;
      yAxisHorizontalPadding = yAxisDraggableWidth + yAxisNumberHeight;
      yAxisLabelBaseline     = -(yAxisDraggableWidth+yAxisNumberHeight/4);

      switch(sizeType.value) {
        case 0:         // icon
        padding = {
          "top":    halfFontSizeInPixels,
          "right":  halfFontSizeInPixels,
          "bottom": fontSizeInPixels,
          "left":   fontSizeInPixels
        };
        break;

        case 1:         // tiny
        padding = {
          "top":    options.title  ? titleFontSizeInPixels*1.8 : fontSizeInPixels,
          "right":  halfFontSizeInPixels,
          "bottom": fontSizeInPixels,
          "left":   fontSizeInPixels
        };
        break;

        case 2:         // small
        padding = {
          "top":    options.title  ? titleFontSizeInPixels*1.8 : fontSizeInPixels,
          "right":  xAxisLabelHorizontalPadding,
          "bottom": axisFontSizeInPixels*1.25,
          "left":   yAxisNumberWidth*1.25
        };
        xTickCount = Math.max(6, options.xTickCount/2);
        yTickCount = Math.max(6, options.yTickCount/2);
        break;

        case 3:         // medium
        padding = {
          "top":    options.title  ? titleFontSizeInPixels*1.8 : fontSizeInPixels,
          "right":  xAxisLabelHorizontalPadding,
          "bottom": options.xlabel ? xAxisVerticalPadding : axisFontSizeInPixels*1.25,
          "left":   options.ylabel ? yAxisHorizontalPadding : yAxisNumberWidth
        };
        break;

        default:         // large
        padding = {
          "top":    options.title  ? titleFontSizeInPixels*1.8 : fontSizeInPixels,
          "right":  xAxisLabelHorizontalPadding,
          "bottom": options.xlabel ? xAxisVerticalPadding : axisFontSizeInPixels*1.25,
          "left":   options.ylabel ? yAxisHorizontalPadding : yAxisNumberWidth
        };
        break;
      }

      if (sizeType.value > 2 ) {
        padding.top += (titles.length-1) * sizeType.value/3 * sizeType.value/3 * fontSizeInPixels;
      } else {
        titles = [titles[0]];
      }

      size = {
        "width":  Math.max(cx - padding.left - padding.right, 60),
        "height": Math.max(cy - padding.top  - padding.bottom, 60)
      };

      xScale = d3.scale[options.xscale]()
        .domain([options.xmin, options.xmax])
        .range([0, size.width]);

      if (options.xscale === "pow") {
        xScale.exponent(options.xscaleExponent);
      }

      yScale = d3.scale[options.yscale]()
        .domain([options.ymin, options.ymax]).nice()
        .range([size.height, 0]).nice();

      if (options.yscale === "pow") {
        yScale.exponent(options.yscaleExponent);
      }

      updateXScale();
      updateYScale();

      line = d3.svg.line()
          .x(function(d, i) { return xScale(points[i][0]); })
          .y(function(d, i) { return yScale(points[i][1]); });

    }

    function setupOptions(options) {
      if (options) {
        for(var p in default_options) {
          if (options[p] === undefined) {
            options[p] = default_options[p];
          }
        }
      } else {
        options = default_options;
      }
      if (options.axisShift < 1) options.axisShift = 1;
      return options;
    }

    function calculateSizeType() {
      if (options.responsiveLayout) {
        if (cx <= sizeType.icon) {
          sizeType.category = 'icon';
          sizeType.value = 0;
        } else if (cx <= sizeType.tiny) {
          sizeType.category = 'tiny';
          sizeType.value = 1;
        } else if (cx <= sizeType.small) {
          sizeType.category = 'small';
          sizeType.value = 2;
        } else if (cx <= sizeType.medium) {
          sizeType.category = 'medium';
          sizeType.value = 3;
        } else {
          sizeType.category = 'large';
          sizeType.value = 4;
        }
      } else {
        sizeType.category = 'large';
        sizeType.value = 4;
      }
    }

    function longestNumber(array, formatter, precision) {
      var longest = 0,
          index = 0,
          str,
          len,
          i;
      precision = precision || 5;
      for (i = 0; i < array.length; i++) {
        str = formatter(+array[i].toPrecision(precision));
        str = str.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
        len = str.length;
        if (len > longest) {
          longest = len;
          index = i;
        }
      }
      return formatter(array[index]);
    }

    // Update the x-scale.
    function updateXScale() {
      xScale.domain([options.xmin, options.xmax])
            .range([0, size.width]);
    }

    // Update the y-scale.
    function updateYScale() {
      yScale.domain([options.ymin, options.ymax])
            .range([size.height, 0]);
    }

    function persistScaleChangesToOptions() {
      var xdomain = xScale.domain(),
          ydomain = yScale.domain();
      options.xmax = xdomain[1];
      options.xmin = xdomain[0];
      options.ymax = ydomain[1];
      options.ymin = ydomain[0];
    }

    function fakeDataPoints() {
      var yrange2 = options.yrange / 2,
          yrange4 = yrange2 / 2,
          pnts;

      options.datacount = size.width/30;
      options.xtic = options.xrange / options.datacount;
      options.ytic = options.yrange / options.datacount;

      pnts = d3.range(options.datacount).map(function(i) {
        return [i * options.xtic + options.xmin, options.ymin + yrange4 + Math.random() * yrange2 ];
      });
      return pnts;
    }

    function setCurrentSample(samplePoint) {
      if (typeof samplePoint === "number") {
        currentSample = samplePoint;
      }
      if (typeof currentSample !== "number") {
        currentSample = points.length-1;
      }
      return currentSample;
    }

    // converts data samples into an array of points
    function indexedData(samples, interval, start) {
      var i = 0,
          pnts = [];
      interval = interval || 1;
      start = start || 0;
      for (i = 0; i < samples.length;  i++) {
        pnts.push([i * interval + start, samples[i]]);
      }
      return pnts;
    }

    //
    // Update notification message
    //
    function notify(mesg) {
      message = mesg;
      if (mesg) {
        notification.text(mesg);
      } else {
        notification.text('');
      }
    }


    function createButtonLayer() {
      buttonLayer = elem.append("div");

      buttonLayer
        .attr("class", "button-layer")
        .style("z-index", 3)
        .append('a')
          .attr({
            "class": "autoscale-button",
            "title": tooltips.autoscale
          })
          .on("click", function() {
            autoscale();
          })
          .append("i")
            .attr("class", "icon-picture");

      resizeButtonLayer();
    }

    function resizeButtonLayer() {
      buttonLayer
        .style({
          "width":   fontSizeInPixels*1.75 + "px",
          "height":  fontSizeInPixels*1.25 + "px",
          "top":     padding.top + halfFontSizeInPixels + "px",
          "left":    padding.left + (size.width - fontSizeInPixels*2.0) + "px"
        });
    }

    // ------------------------------------------------------------
    //
    // Rendering
    //
    // ------------------------------------------------------------

    //
    // Render a new graph by creating the SVG and Canvas elements
    //
    function renderNewGraph() {
      svg = elem.append("svg")
          .attr("width",  cx)
          .attr("height", cy)
          .attr("class", "graph")
          .style('z-index', 2);
          // .attr("tabindex", tabindex || 0);

      vis = svg.append("g")
          .attr("transform", "translate(" + padding.left + "," + padding.top + ")");

      plot = vis.append("rect")
        .attr("class", "plot")
        .attr("width", size.width)
        .attr("height", size.height)
        .attr("pointer-events", "all")
        .attr("fill", "rgba(255,255,255,0)")
        .on("mousemove", plotMousemove)
        .on("mousedown", plotDrag)
        .on("touchstart", plotDrag);

      plot.call(d3.behavior.zoom().x(xScale).y(yScale).on("zoom", redraw));

      background = elem.append("div")
          .attr("class", "background")
          .style({
            "width":   size.width + "px",
            "height":  size.height + "px",
            "top":     padding.top + "px",
            "left":    padding.left + "px",
            "z-index": 0
          });

      createGraphCanvas();

      viewbox = vis.append("svg")
        .attr("class", "viewbox")
        .attr("top", 0)
        .attr("left", 0)
        .attr("width", size.width)
        .attr("height", size.height)
        .attr("viewBox", "0 0 "+size.width+" "+size.height);

      selectedRulerX = viewbox.append("line")
        .attr("stroke", gridStroke)
        .attr("stroke-dasharray", "2,2")
        .attr("y1", 0)
        .attr("y2", size.height)
        .attr("x1", function(d) { return selected === null ? 0 : selected[0]; } )
        .attr("x2", function(d) { return selected === null ? 0 : selected[0]; } )
        .attr("class", "ruler hidden");

      selectedRulerY = viewbox.append("line")
        .attr("stroke", gridStroke)
        .attr("stroke-dasharray", "2,2")
        .attr("x1", 0)
        .attr("x2", size.width)
        .attr("y1", function(d) { return selected === null ? 0 : selected[1]; } )
        .attr("y2", function(d) { return selected === null ? 0 : selected[1]; } )
        .attr("class", "ruler hidden");

      yAxisDraggable = svg.append("rect")
        .attr("class", "draggable-axis")
        .attr("x", padding.left-yAxisDraggableWidth)
        .attr("y", padding.top)
        .attr("rx", yAxisNumberHeight/6)
        .attr("width", yAxisDraggableWidth)
        .attr("height", size.height)
        .attr("pointer-events", "all")
        .style("cursor", "row-resize")
        .on("mousedown", yAxisDrag)
        .on("touchstart", yAxisDrag);

      yAxisDraggableTooltip = yAxisDraggable.append("title");

      xAxisDraggable = svg.append("rect")
        .attr("class", "draggable-axis")
        .attr("x", padding.left)
        .attr("y", size.height+padding.top)
        .attr("rx", yAxisNumberHeight/6)
        .attr("width", size.width)
        .attr("height", xAxisDraggableHeight)
        .attr("pointer-events", "all")
        .style("cursor", "col-resize")
        .on("mousedown", xAxisDrag)
        .on("touchstart", xAxisDrag);

      xAxisDraggableTooltip = xAxisDraggable.append("title");

      if (sizeType.value <= 2 && options.ylabel) {
        xAxisDraggableTooltip.text(options.xlabel);
      }

      if (sizeType.catefory && options.ylabel) {
        yAxisDraggableTooltip.text(options.ylabel);
      }

      adjustAxisDraggableFill();

      brush_element = viewbox.append("g")
            .attr("class", "brush");

      // add Chart Title
      if (options.title && sizeType.value > 0) {
        title = vis.selectAll("text")
          .data(titles, function(d) { return d; });
        title.enter().append("text")
            .attr("class", "title")
            .text(function(d) { return d; })
            .attr("x", function(d) { return size.width/2 - Math.min(size.width, getComputedTextLength(this))/2; })
            .attr("dy", function(d, i) { return -i * titleFontSizeInPixels - halfFontSizeInPixels + "px"; });
        titleTooltip = title.append("title")
            .text("");
      } else if (options.title) {
        titleTooltip = plot.append("title")
            .text(options.title);
      }

      // Add the x-axis label
      if (options.xlabel && sizeType.value > 2) {
        xlabel = vis.append("text")
            .attr("class", "axis")
            .attr("class", "xlabel")
            .text(options.xlabel)
            .attr("x", size.width/2)
            .attr("y", size.height)
            .attr("dy", xAxisLabelBaseline + "px")
            .style("text-anchor","middle");
      }

      // add y-axis label
      if (options.ylabel && sizeType.value > 2) {
        ylabel = vis.append("g").append("text")
            .attr("class", "axis")
            .attr("class", "ylabel")
            .text( options.ylabel)
            .style("text-anchor","middle")
            .attr("transform","translate(" + yAxisLabelBaseline + " " + size.height/2+") rotate(-90)");
        if (sizeType.category === "small") {
          yAxisDraggable.append("title")
            .text(options.ylabel);
        }
      }

      d3.select(node)
          .on("mousemove.drag", mousemove)
          .on("touchmove.drag", mousemove)
          .on("mouseup.drag",   mouseup)
          .on("touchend.drag",  mouseup);

      notification = vis.append("text")
          .attr("class", "graph-notification")
          .text(message)
          .attr("x", size.width/2)
          .attr("y", size.height/2)
          .style("text-anchor","middle");

      updateMarkers();
      updateRulers();
    }

    //
    // Repaint an existing graph by rescaling/updating the SVG and Canvas elements
    //
    function repaintExistingGraph() {
      vis
        .attr("width",  cx)
        .attr("height", cy)
        .attr("transform", "translate(" + padding.left + "," + padding.top + ")");

      plot
        .attr("width", size.width)
        .attr("height", size.height);

      background
        .style({
          "width":   size.width + "px",
          "height":  size.height + "px",
          "top":     padding.top + "px",
          "left":    padding.left + "px",
          "z-index": 0
        });

      viewbox
          .attr("top", 0)
          .attr("left", 0)
          .attr("width", size.width)
          .attr("height", size.height)
          .attr("viewBox", "0 0 "+size.width+" "+size.height);

      yAxisDraggable
          .attr("x", padding.left-yAxisDraggableWidth)
          .attr("y", padding.top-yAxisNumberHeight/2)
          .attr("width", yAxisDraggableWidth)
          .attr("height", size.height+yAxisNumberHeight);

      xAxisDraggable
          .attr("x", padding.left)
          .attr("y", size.height+padding.top)
          .attr("width", size.width)
          .attr("height", xAxisDraggableHeight);

      adjustAxisDraggableFill();

      if (options.title && sizeType.value > 0) {
        title
            .attr("x", function(d) { return size.width/2 - Math.min(size.width, getComputedTextLength(this))/2; })
            .attr("dy", function(d, i) { return -i * titleFontSizeInPixels - halfFontSizeInPixels + "px"; });
        titleTooltip
            .text("");
      } else if (options.title) {
        titleTooltip
            .text(options.title);
      }

      if (options.xlabel && sizeType.value > 2) {
        xlabel
            .attr("x", size.width/2)
            .attr("y", size.height)
            .attr("dy", xAxisLabelBaseline + "px");
        xAxisDraggableTooltip
            .text("");
      } else {
        xAxisDraggableTooltip
            .text(options.xlabel);
      }

      if (options.ylabel && sizeType.value > 2) {
        ylabel
            .attr("transform","translate(" + yAxisLabelBaseline + " " + size.height/2+") rotate(-90)");
        yAxisDraggableTooltip
            .text("");
      } else {
        yAxisDraggableTooltip
          .text(options.ylabel);
      }

      notification
        .attr("x", size.width/2)
        .attr("y", size.height/2);

      vis.selectAll("g.x").remove();
      vis.selectAll("g.y").remove();

      updateMarkers();
      updateRulers();
      resizeCanvas();
    }

    function getComputedTextLength(el) {
      if (el.getComputedTextLength) {
        return el.getComputedTextLength();
      } else {
        return 100;
      }
    }

    function adjustAxisDraggableFill() {
      if (sizeType.value <= 1) {
        xAxisDraggable
          .style({
            "fill":       "rgba(196, 196, 196, 0.2)"
          });
        yAxisDraggable
          .style({
            "fill":       "rgba(196, 196, 196, 0.2)"
          });
      } else {
        xAxisDraggable
          .style({
            "fill":       null
          });
        yAxisDraggable
          .style({
            "fill":       null
          });
      }
    }

    //
    // Redraw the plot and axes when plot is translated or axes are re-scaled
    //
    function redraw() {
      // Regenerate x-ticks
      var gx = vis.selectAll("g.x")
          .data(xScale.ticks(xTickCount), String)
          .attr("transform", tx);

      var gxe = gx.enter().insert("g", "a")
          .attr("class", "x")
          .attr("transform", tx);

      gxe.append("line")
          .attr("stroke", gridStroke)
          .attr("y1", 0)
          .attr("y2", size.height);

      if (sizeType.value > 1) {
        gxe.append("text")
            .attr("class", "axis")
            .attr("y", size.height)
            .attr("dy", axisFontSizeInPixels + "px")
            .attr("text-anchor", "middle")
            .text(fx)
            .on("mouseover", function() { d3.select(this).style("font-weight", "bold");})
            .on("mouseout",  function() { d3.select(this).style("font-weight", "normal");});
      }

      gx.exit().remove();

      // Regenerate y-ticks
      var gy = vis.selectAll("g.y")
          .data(yScale.ticks(yTickCount), String)
          .attr("transform", ty);

      var gye = gy.enter().insert("g", "a")
          .attr("class", "y")
          .attr("transform", ty)
          .attr("background-fill", "#FFEEB6");

      gye.append("line")
          .attr("stroke", gridStroke)
          .attr("x1", 0)
          .attr("x2", size.width);

      if (sizeType.value > 1) {
        if (options.yscale === "log") {
          var gye_length = gye[0].length;
          if (gye_length > 100) {
            gye = gye.filter(function(d) { return !!d.toString().match(/(\.[0]*|^)[1]/);});
          } else if (gye_length > 50) {
            gye = gye.filter(function(d) { return !!d.toString().match(/(\.[0]*|^)[12]/);});
          } else {
            gye = gye.filter(function(d) {
              return !!d.toString().match(/(\.[0]*|^)[125]/);});
          }
        }
        gye.append("text")
            .attr("class", "axis")
            .attr("x", -axisFontSizeInPixels/4 + "px")
            .attr("dy", ".35em")
            .attr("text-anchor", "end")
            .style("cursor", "ns-resize")
            .text(fy)
            .on("mouseover", function() { d3.select(this).style("font-weight", "bold");})
            .on("mouseout",  function() { d3.select(this).style("font-weight", "normal");});
      }

      gy.exit().remove();
      plot.call(d3.behavior.zoom().x(xScale).y(yScale).on("zoom", redraw));
      update();
    }

    // ------------------------------------------------------------
    //
    // Rendering: Updating samples/data points in the plot
    //
    // ------------------------------------------------------------


    //
    // Update plotted data, optionally pass in new samplePoint
    //
    function update(samplePoint) {
      setCurrentSample(samplePoint);
      updateCanvasFromPoints(currentSample);
      updateMarkers();
      if (d3.event && d3.event.keyCode) {
        d3.event.preventDefault();
        d3.event.stopPropagation();
      }
    }

    // samplePoint is optional argument
    function updateOrRescale(samplePoint) {
      setCurrentSample(samplePoint);
      updateOrRescalePoints();
    }

    // samplePoint is optional argument
    function updateOrRescalePoints(samplePoint) {
      var i,
          domain = xScale.domain(),
          xAxisStart = Math.round(domain[0]),
          xAxisEnd = Math.round(domain[1]),
          start = Math.max(0, xAxisStart),
          xextent = domain[1] - domain[0],
          shiftPoint = xextent * 0.95,
          currentExtent;

      setCurrentSample(samplePoint);
      currentExtent = points[currentSample-1][0];
      if (shiftingX) {
        shiftingX = domainShift();
        if (shiftingX) {
          cancelAxisRescale();
          redraw();
        } else {
          update(currentSample);
        }
      } else {
        if (currentExtent > domain[0] + shiftPoint) {
          domainShift = shiftXDomainRealTime(shiftPoint*0.9, options.axisShift);
          shiftingX = domainShift();
          redraw();
        } else if ( currentExtent < domain[1] - shiftPoint && currentSample < points.length && xAxisStart > 0) {
          domainShift = shiftXDomainRealTime(shiftPoint*0.9, options.axisShift, -1);
          shiftingX = domainShift();
          redraw();
        } else if (currentExtent < domain[0]) {
          domainShift = shiftXDomainRealTime(shiftPoint*0.1, 1, -1);
          shiftingX = domainShift();
          redraw();
        } else {
          update(currentSample);
        }
      }
    }

    function shiftXDomainRealTime(shift, steps, direction) {
      var d0 = xScale.domain()[0],
          d1 = xScale.domain()[1],
          increment = 1/steps,
          index = 0;
      return function() {
        var factor;
        direction = direction || 1;
        index += increment;
        factor = shift * cubicEase(index);
        if (direction > 0) {
          xScale.domain([d0 + factor, d1 + factor]);
          persistScaleChangesToOptions();
          return xScale.domain()[0] < (d0 + shift);
        } else {
          xScale.domain([d0 - factor, d1 - factor]);
          persistScaleChangesToOptions();
          return xScale.domain()[0] > (d0 - shift);
        }
      };
    }

    function cancelAxisRescale() {
      if (!isNaN(downx)) {
        downx = NaN;
      }
      if (!isNaN(downy)) {
        downy = NaN;
      }
    }

    function circleClasses(d) {
      cs = [];
      if (d === selected) {
        cs.push("selected");
      }
      if (cs.length === 0) {
        return null;
      } else {
        return cs.join(" ");
      }
    }

    function updateMarkerRadius() {
      var d = xScale.domain(),
          r = xScale.range();
      markerRadius = (r[1] - r[0]) / ((d[1] - d[0]));
      markerRadius = Math.min(markerRadius, 6);
      markerStrokeWidth = markerRadius/4;
    }

    function updateMarkers() {
      var marker,
          markedPoints = null;
      if (options.markAllDataPoints && sizeType.value > 1) {
        markedPoints = points;
      } else if (options.markNearbyDataPoints && sizeType.value > 1) {
        markedPoints = selectable.slice(0);
        if (selected !== null && markedPoints.indexOf(selected) == -1) {
          markedPoints.push(selected);
        }
      }
      if (markedPoints !== null) {
        updateMarkerRadius();
        marker = vis.select("svg").selectAll("circle").data(markedPoints);
        marker.enter().append("circle")
            .attr("class", circleClasses)
            .attr("cx",    function(d) { return xScale(d[0]); })
            .attr("cy",    function(d) { return yScale(d[1]); })
            .attr("r", markerRadius)
            .style("stroke-width", markerStrokeWidth)
            .style("cursor", markerCursorStyle)
            .on("mousedown.drag",  dataPointDrag)
            .on("touchstart.drag", dataPointDrag)
            .append("title")
            .text(function(d) { return "( " + fx(d[0]) + ", " + fy(d[1]) + " )"; });

        marker
            .attr("class", circleClasses)
            .attr("cx",    function(d) { return xScale(d[0]); })
            .attr("cy",    function(d) { return yScale(d[1]); })
            .select("title")
            .text(function(d) { return "( " + fx(d[0]) + ", " + fy(d[1]) + " )"; });

        marker.exit().remove();
      }

      updateRulers();
    }

    function updateRulers() {
      if (options.showRulersOnSelection && selected !== null) {
        selectedRulerX
          .attr("y1", 0)
          .attr("y2", size.height)
          .attr("x1", function(d) { return selected === null ? 0 : xScale(selected[0]); } )
          .attr("x2", function(d) { return selected === null ? 0 : xScale(selected[0]); } )
          .attr("class", function(d) { return "ruler" + (selected === null ? " hidden" : ""); } );

        selectedRulerY
          .attr("x1", 0)
          .attr("x2", size.width)
          .attr("y1", function(d) { return selected === null ? 0 : yScale(selected[1]); } )
          .attr("y2", function(d) { return selected === null ? 0 : yScale(selected[1]); } )
          .attr("class", function(d) { return "ruler" + (selected === null ? " hidden" : ""); } );
      } else {
        selectedRulerX.attr("class", "ruler hidden");
        selectedRulerY.attr("class", "ruler hidden");
      }
    }


    // ------------------------------------------------------------
    //
    // UI Interaction: Plot dragging and translation; Axis re-scaling
    //
    // ------------------------------------------------------------

    function plotMousemove() {
      if (options.markNearbyDataPoints) {
        var mousePoint = d3.mouse(vis.node()),
            translatedMousePointX = xScale.invert(Math.max(0, Math.min(size.width, mousePoint[0]))),
            p,
            idx, pMin, pMax;
        // highlight the central point, and also points to the left and right
        // TODO Handle multiple data sets/lines
        selectable = [];
        for (i = 0; i < pointArray.length; i++) {
          points = pointArray[i];
          p = findClosestPointByX(translatedMousePointX, i);
          if (p !== null) {
            idx = points.indexOf(p);
            pMin = idx - (options.extraCirclesVisibleOnHover);
            pMax = idx + (options.extraCirclesVisibleOnHover + 1);
            if (pMin < 0) { pMin = 0; }
            if (pMax > points.length - 1) { pMax = points.length; }
            selectable = selectable.concat(points.slice(pMin, pMax));
          }
        }
        update();
      }
    }

    function findClosestPointByX(x, line) {
      if (typeof(line) == "undefined" || line === null) { line = 0; }
      // binary search through points.
      // This assumes points is sorted ascending by x value, which for realTime graphs is true.
      points = pointArray[line];
      if (points.length === 0) { return null; }
      var min = 0,
          max = points.length - 1,
          mid, diff, p1, p2, p3;
      while (min < max) {
        mid = Math.floor((min + max)/2.0);
        if (points[mid][0] < x) {
          min = mid + 1;
        } else {
          max = mid;
        }
      }

      // figure out which point is actually closest.
      // we have to compare 3 points, to account for floating point rounding errors.
      // if the mouse moves off the left edge of the graph, p1 may not exist.
      // if the mouse moves off the right edge of the graph, p3 may not exist.
      p1 = points[mid - 1];
      p2 = points[mid];
      p3 = points[mid + 1];
      if (typeof(p1) !== "undefined" && Math.abs(p1[0] - x) <= Math.abs(p2[0] - x)) {
        return p1;
      } else if (typeof(p3) === "undefined" || Math.abs(p2[0] - x) <= Math.abs(p3[0] - x)) {
        return p2;
      } else {
        return p3;
      }
    }

    function plotDrag() {
      var p;
      d3.event.preventDefault();
      d3.select('body').style("cursor", "move");
      if (d3.event.altKey) {
        plot.style("cursor", "nesw-resize");
        if (d3.event.shiftKey && options.addData) {
          p = d3.mouse(vis.node());
          var newpoint = [];
          newpoint[0] = xScale.invert(Math.max(0, Math.min(size.width,  p[0])));
          newpoint[1] = yScale.invert(Math.max(0, Math.min(size.height, p[1])));
          points.push(newpoint);
          points.sort(function(a, b) {
            if (a[0] < b[0]) { return -1; }
            if (a[0] > b[0]) { return  1; }
            return 0;
          });
          selected = newpoint;
          update();
        } else {
          p = d3.mouse(vis.node());
          downx = xScale.invert(p[0]);
          downy = yScale.invert(p[1]);
          draggedPoint = false;
          d3.event.stopPropagation();
        }
        // d3.event.stopPropagation();
      }
    }

    function falseFunction() {
      return false;
    }

    function xAxisDrag() {
      node.focus();
      document.onselectstart = falseFunction;
      d3.event.preventDefault();
      var p = d3.mouse(vis.node());
      downx = xScale.invert(p[0]);
    }

    function yAxisDrag() {
      node.focus();
      d3.event.preventDefault();
      document.onselectstart = falseFunction;
      var p = d3.mouse(vis.node());
      downy = yScale.invert(p[1]);
    }

    function dataPointDrag(d) {
      node.focus();
      d3.event.preventDefault();
      document.onselectstart = falseFunction;
      if (selected === d) {
        selected = draggedPoint = null;
      } else {
        selected = draggedPoint = d;
      }
      update();
    }

    function mousemove() {
      var p = d3.mouse(vis.node()),
          index,
          px,
          x,
          nextPoint,
          prevPoint,
          minusHalf,
          plusHalf;

      // t = d3.event.changedTouches;

      document.onselectstart = function() { return true; };
      d3.event.preventDefault();
      if (draggedPoint) {
        if (options.dataChange) {
          draggedPoint[1] = yScale.invert(Math.max(0, Math.min(size.height, p[1])));
        } else {
          index = points.indexOf(draggedPoint);
          if (index && index < (points.length-1)) {
            px = xScale.invert(p[0]);
            x = draggedPoint[0];
            nextPoint = points[index+1];
            prevPoint = points[index-1];
            minusHalf = x - (x - prevPoint[0])/2;
            plusHalf =  x + (nextPoint[0] - x)/2;
            if (px < minusHalf) {
              draggedPoint = prevPoint;
              selected = draggedPoint;
            } else if (px > plusHalf) {
              draggedPoint = nextPoint;
              selected = draggedPoint;
            }
          }
        }
        persistScaleChangesToOptions();
        update();
      }

      if (!isNaN(downx)) {
        d3.select('body').style("cursor", "col-resize");
        plot.style("cursor", "col-resize");
        if (shiftingX) {
          xScale.domain(axis.axisProcessDrag(downx, xScale.invert(p[0]), xScale.domain()));
        } else {
          xScale.domain(axis.axisProcessDrag(downx, xScale.invert(p[0]), xScale.domain()));
        }
        persistScaleChangesToOptions();
        updateMarkerRadius();
        redraw();
        d3.event.stopPropagation();
      }

      if (!isNaN(downy)) {
        d3.select('body').style("cursor", "row-resize");
        plot.style("cursor", "row-resize");
        yScale.domain(axis.axisProcessDrag(downy, yScale.invert(p[1]), yScale.domain()));
        persistScaleChangesToOptions();
        redraw();
        d3.event.stopPropagation();
      }
    }

    function mouseup() {
      d3.select('body').style("cursor", "auto");
      plot.style("cursor", "auto");
      document.onselectstart = function() { return true; };
      if (!isNaN(downx)) {
        redraw();
        downx = NaN;
      }
      if (!isNaN(downy)) {
        redraw();
        downy = NaN;
      }
      draggedPoint = null;
    }

    //------------------------------------------------------
    //
    // Autoscale
    //
    // ------------------------------------------------------------

    /**
      If there are more than 1 data points, scale the x axis to contain all x values,
      and scale the y axis so that the y values lie in the middle 80% of the visible y range.

      Then nice() the x and y scales (which means that the x and y domains will likely expand
      somewhat).
    */
    function autoscale() {
      var i,
          j,
          len,
          point,
          x,
          y,
          xmin = Infinity,
          xmax = -Infinity,
          ymin = Infinity,
          ymax = -Infinity,
          transform,
          pow;

      if (points.length < 2) return;

      for (i = 0; i < pointArray.length; i++) {
        points = pointArray[i];
        for (j = 0, len = points.length; j < len; j++){
          point = points[j];
          x = point[0];
          y = point[1];

          if (x < xmin) xmin = x;
          if (x > xmax) xmax = x;
          if (y < ymin) ymin = y;
          if (y > ymax) ymax = y;
        }
      }

      // Like Math.pow but returns a value with the same sign as x: pow(-1, 0.5) -> -1
      pow = function(x, exponent) {
        return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
      };

      // convert ymin, ymax to a linear scale, and set 'transform' to the function that
      // converts the new min, max to the relevant scale.
      switch (options.yscale) {
        case 'linear':
          transform = function(x) { return x; };
          break;
        case 'log':
          ymin = Math.log(ymin) / Math.log(10);
          ymax = Math.log(ymax) / Math.log(10);
          transform = function(x) { return Math.pow(10, x); };
          break;
        case 'pow':
          ymin = pow(ymin, options.yscaleExponent);
          ymax = pow(ymax, options.yscaleExponent);
          transform = function(x) { return pow(x, 1/options.yscaleExponent); };
          break;
      }

      xScale.domain([xmin, xmax]).nice();
      yScale.domain([transform(ymin - 0.15*(ymax-ymin)), transform(ymax + 0.15*(ymax-ymin))]).nice();
      persistScaleChangesToOptions();
      redraw();
    }

    // ------------------------------------------------------------
    //
    // Brush Selection
    //
    // ------------------------------------------------------------

    /**
      Set or get the selection domain (i.e., the range of x values that are selected).

      Valid domain specifiers:
        null     no current selection (selection is turned off)
        []       a current selection exists but is empty (has_selection is true)
        [x1, x2] the region between x1 and x2 is selected. Any data points between
                 x1 and x2 (inclusive) would be considered to be selected.

      Default value is null.
    */
    function selectionDomain(a) {

      if (!arguments.length) {
        if (!has_selection) {
          return null;
        }
        if (selection_region.xmax === Infinity && selection_region.xmin === Infinity ) {
          return [];
        }
        return [selection_region.xmin, selection_region.xmax];
      }

      // setter

      if (a === null) {
        has_selection = false;
      }
      else if (a.length === 0) {
        has_selection = true;
        selection_region.xmin = Infinity;
        selection_region.xmax = Infinity;
      }
      else {
        has_selection = true;
        selection_region.xmin = a[0];
        selection_region.xmax = a[1];
      }

      updateBrushElement();

      if (selection_listener) {
        selection_listener(selectionDomain());
      }
      return api;
    }

    /**
      Get whether the graph currently has a selection region. Default value is false.

      If true, it would be valid to filter the data points to return a subset within the selection
      region, although this region may be empty!

      If false the graph is not considered to have a selection region.

      Note that even if has_selection is true, the selection region may not be currently shown,
      and if shown, it may be empty.
    */
    function hasSelection() {
      return has_selection;
    }

    /**
      Set or get the visibility of the selection region. Default value is false.

      Has no effect if the graph does not currently have a selection region
      (selection_domain is null).

      If the selection_enabled property is true, the user will also be able to interact
      with the selection region.
    */
    function selectionVisible(val) {
      if (!arguments.length) {
        return selection_visible;
      }

      // setter
      val = !!val;
      if (selection_visible !== val) {
        selection_visible = val;
        updateBrushElement();
      }
      return api;
    }

    /**
      Set or get whether user manipulation of the selection region should be enabled
      when a selection region exists and is visible. Default value is true.

      Setting the value to true has no effect unless the graph has a selection region
      (selection_domain is non-null) and the region is visible (selection_visible is true).
      However, the selection_enabled setting is honored whenever those properties are
      subsequently updated.

      Setting the value to false does not affect the visibility of the selection region,
      and does not affect the ability to change the region by calling selectionDomain().

      Note that graph panning and zooming are disabled while selection manipulation is enabled.
    */
    function selectionEnabled(val) {
      if (!arguments.length) {
        return selection_enabled;
      }

      // setter
      val = !!val;
      if (selection_enabled !== val) {
        selection_enabled = val;
        updateBrushElement();
      }
      return api;
    }

    /**
      Set or get the listener to be called when the selection_domain changes.

      Both programatic and interactive updates of the selection region result in
      notification of the listener.

      The listener is called with the new selection_domain value in the first argument.
    */
    function selectionListener(cb) {
      if (!arguments.length) {
        return selection_listener;
      }
      // setter
      selection_listener = cb;
      return api;
    }

    function brushListener() {
      var extent;
      if (selection_enabled) {
        // Note there is a brush.empty() method, but it still reports true after the
        // brush extent has been programatically updated.
        extent = brush_control.extent();
        selectionDomain( extent[0] !== extent[1] ? extent : [] );
      }
    }

    function updateBrushElement() {
      if (has_selection && selection_visible) {
        brush_control = brush_control || d3.svg.brush()
          .x(xScale)
          .extent([selection_region.xmin || 0, selection_region.xmax || 0])
          .on("brush", brushListener);

        brush_element
          .call(brush_control.extent([selection_region.xmin || 0, selection_region.xmax || 0]))
          .style('display', 'inline')
          .style('pointer-events', selection_enabled ? 'all' : 'none')
          .selectAll("rect")
            .attr("height", size.height);

      } else {
        brush_element.style('display', 'none');
      }
    }

    // ------------------------------------------------------------
    //
    // Canvas-based plotting
    //
    // ------------------------------------------------------------

    function createGraphCanvas() {
      graphCanvas = elem.append("canvas");
      gcanvas = graphCanvas.node();
      resizeCanvas();
    }

    function resizeCanvas() {
      graphCanvas
        .attr("class", "overlay")
        .style({
          "position": "absolute",
          "width":    size.width + "px",
          "height":   size.height + "px",
          "top":      padding.top + "px",
          "left":     padding.left + "px",
          "z-index": 1
        });
      gcanvas = graphCanvas.node();
      gcanvas.width = size.width;
      gcanvas.height = size.height;
      gcanvas.top = padding.top;
      gcanvas.left = padding.left;
      setupCanvasContext();
      updateCanvasFromPoints(currentSample);
    }

    function clearCanvas() {
      if (gcanvas.getContext) {
        gcanvas.width = gcanvas.width;
        gctx.fillStyle = canvasFillStyle;
        gctx.fillRect(0, 0, gcanvas.width, gcanvas.height);
        gctx.strokeStyle = "rgba(255,65,0, 1.0)";
      }
    }

    function setupCanvasContext() {
      if (gcanvas.getContext) {
        gctx = gcanvas.getContext( '2d' );
        gctx.globalCompositeOperation = "source-over";
        gctx.lineWidth = 1;
        gctx.fillStyle = canvasFillStyle;
        gctx.fillRect(0, 0, gcanvas.width, gcanvas.height);
        gctx.strokeStyle = "rgba(255,65,0, 1.0)";
      }
    }

    //
    // Update Canvas plotted data from [x, y] data points
    //
    function updateCanvasFromPoints(samplePoint) {
      var i, j, k,
          dx,
          px, py,
          index,
          yOrigin = yScale(0.00001),
          lines = options.lines,
          bars = options.bars,
          twopi = 2 * Math.PI,
          pointsLength = pointArray[0].length,
          numberOfLines = pointArray.length,
          xAxisStart,
          xAxisEnd,
          start,
          lengthX;

      // hack for lack of canvas support in jsdom tests
      if (typeof gcanvas.getContext === "undefined" ) { return; }

      setCurrentSample(samplePoint);
      clearCanvas();
      gctx.fillRect(0, 0, gcanvas.width, gcanvas.height);
      if (pointsLength === 0) { return; }
      xAxisStart = xScale.domain()[0];
      xAxisEnd =   xScale.domain()[1];
      start = Math.max(0, xAxisStart);
      if (lines) {
        for (i = 0; i < numberOfLines; i++) {
          points = pointArray[i];
          index = 0;
          // find first point >= xAxisStart
          for (j = 0; j < pointsLength; j++) {
            if (points[j][0] >= xAxisStart) { break; }
            index++;
          }
          if (index > 0) { --index; }
          if (index >= pointsLength) { break; }
          px = xScale(points[index][0]);
          py = yScale(points[index][1]);
          setStrokeColor(i);
          gctx.beginPath();
          gctx.moveTo(px, py);
          dx = points[index][0];
          index++;
          // plot all ... or until one point past xAxisEnd
          // or until we reach currentSample
          for (; index < samplePoint; index++) {
            dx = points[index][0];
            px = xScale(dx);
            py = yScale(points[index][1]);
            gctx.lineTo(px, py);
            if (dx >= xAxisEnd) { break; }
          }
          gctx.stroke();
          // now plot in a desaturated style all the rest of the points
          // ... or until one point past xAxisEnd
          if (index < pointsLength && dx < xAxisEnd) {
            setStrokeColor(i, true);
            for (;index < pointsLength; index++) {
              dx = points[index][0];
              px = xScale(dx);
              py = yScale(points[index][1]);
              gctx.lineTo(px, py);
              if (dx >= xAxisEnd) { break; }
            }
            gctx.stroke();
          }
        }
      } else if (bars) {
        for (i = 0; i < numberOfLines; i++) {
          points = pointArray[i];
          setStrokeColor(i);
          pointStop = samplePoint - 1;
          for (index=start; index < pointStop; index++) {
            px = xScale(points[index][0]);
            py = yScale(points[index][1]);
            if (py === 0) {
              continue;
            }
            gctx.beginPath();
            gctx.moveTo(px, yOrigin);
            gctx.lineTo(px, py);
            gctx.stroke();
          }
          pointStop = points.length-1;
          if (index < pointStop) {
            setStrokeColor(i, true);
            for (;index < pointStop; index++) {
              px = xScale(points[index][0]);
              py = yScale(points[index][1]);
              gctx.beginPath();
              gctx.moveTo(px, yOrigin);
              gctx.lineTo(px, py);
              gctx.stroke();
            }
          }
        }
      } else {
        for (i = 0; i < numberOfLines; i++) {
          points = pointArray[i];
          lengthX = 0;
          setFillColor(i);
          setStrokeColor(i, true);
          pointStop = samplePoint - 1;
          for (index=0; index < pointStop; index++) {
            px = xScale(points[index][0]);
            py = yScale(points[index][1]);
            gctx.arc(px, py, 1, 0, twopi, false);
            gctx.fill();
          }
          pointStop = points.length-1;
          if (index < pointStop) {
            setFillColor(i, true);
            setStrokeColor(i, true);
            for (;index < pointStop; index++) {
              px = xScale(points[index][0]);
              py = yScale(points[index][1]);
              gctx.arc(px, py, 1, 0, twopi, false);
              gctx.fill();
            }
          }
        }
      }
    }

    function setStrokeColor(i, afterSamplePoint) {
      var opacity = afterSamplePoint ? 0.4 : 1.0;
      switch(i) {
        case 0:
          gctx.strokeStyle = "rgba(160,00,0," + opacity + ")";
          break;
        case 1:
          gctx.strokeStyle = "rgba(44,160,0," + opacity + ")";
          break;
        case 2:
          gctx.strokeStyle = "rgba(44,0,160," + opacity + ")";
          break;
      }
    }

    function setFillColor(i, afterSamplePoint) {
      var opacity = afterSamplePoint ? 0.4 : 1.0;
      switch(i) {
        case 0:
          gctx.fillStyle = "rgba(160,00,0," + opacity + ")";
          break;
        case 1:
          gctx.fillStyle = "rgba(44,160,0," + opacity + ")";
          break;
        case 2:
          gctx.fillStyle = "rgba(44,0,160," + opacity + ")";
          break;
      }
    }

    // ------------------------------------------------------------
    //
    // Adding samples/data points
    //
    // ------------------------------------------------------------

    // Add an array of points then update the graph.
    function addPoints(datapoints) {
      addDataPoints(datapoints);
      setCurrentSample(points.length);
      updateOrRescale();
    }

    // Add an array of samples then update the graph.
    function addSamples(datasamples) {
      addDataSamples(datasamples);
      setCurrentSample(points.length);
      updateOrRescale();
    }


    // Add a point [x, y] by processing sample (Y value) synthesizing
    // X value from sampleInterval and number of points
    function addSample(sample) {
      var index = points.length,
          xvalue = (index + dataSampleStart) * sampleInterval,
          point = [ xvalue, sample ];
      points.push(point);
      setCurrentSample(points.length);
      updateOrRescale();
    }

    // Add a point [x, y] to points array
    function addPoint(pnt) {
      points.push(pnt);
      setCurrentSample(points.length);
      updateOrRescale();
    }

    // Add an array (or arrays) of points.
    function addDataPoints(datapoints) {
      if (Object.prototype.toString.call(datapoints[0]) === "[object Array]") {
        for (var i = 0; i < datapoints.length; i++) {
          points = pointArray[i];
          points.push.apply(points, [datapoints[i]]);
          pointArray[i] = points;
        }
        points = pointArray[0];
      } else {
        points.push.apply(points, datapoints);
        pointArray = [points];
      }
    }

    // Add an array of points by processing an array of samples (Y values)
    // synthesizing the X value from sampleInterval interval and number of points.
    function addDataSamples(datasamples) {
      var start,
          i;
      if (Object.prototype.toString.call(datasamples[0]) === "[object Array]") {
        for (i = 0; i < datasamples.length; i++) {
          if (!pointArray[i]) { pointArray.push([]); }
          points = pointArray[i];
          start = points.length * sampleInterval;
          points.push.apply(points, indexedData(datasamples[i], sampleInterval, start));
          pointArray[i] = points;
        }
        points = pointArray[0];
      } else {
        for (i = 0; i < datasamples.length; i++) {
          if (!pointArray[i]) { pointArray.push([]); }
          start = pointArray[i].length * sampleInterval;
          pointArray[i].push([start, datasamples[i]]);
        }
      }
    }

    function resetDataPoints(datapoints) {

      function copy(array) {
        var ret = [];
        array.forEach(function(element) {
          ret.push(element);
        });
        return ret;
      }

      pointArray = [];
      if (!datapoints || datapoints.length === 0) {
        points = [];
        pointArray = [points];
        return;
      }
      if (Object.prototype.toString.call(datapoints[0]) === "[object Array]") {
        for (var i = 0; i < datapoints.length; i++) {
          pointArray.push(copy(datapoints[i]));
        }
        points = pointArray[0];
      } else {
        points = datapoints;
        pointArray = [copy(points)];
      }
    }

    function resetDataSamples(datasamples, interval, start) {
      pointArray = [];
      if (Object.prototype.toString.call(datasamples[0]) === "[object Array]") {
        for (var i = 0; i < datasamples.length; i++) {
          pointArray.push(indexedData(datasamples[i], interval, start));
        }
        points = pointArray[0];
      } else {
        points = indexedData(datasamples, interval, start);
        pointArray = [points];
      }
      sampleInterval = interval;
      dataSampleStart = start;
    }


    function resetPoints(datapoints) {
      resetDataPoints(datapoints);
    }

    function resetSamples(datasamples) {
      resetDataSamples(datasamples, sampleInterval, dataSampleStart);
    }

    function deletePoint(i) {
      if (points.length) {
        points.splice(i, 1);
        if (currentSample >= points.length) {
          currentSample = points.length-1;
        }
      }
    }

    // ------------------------------------------------------------
    //
    // Keyboard Handling
    //
    // ------------------------------------------------------------

    function registerKeyboardHandler() {
      svg.node().addEventListener("keydown", function (evt) {
        if (!selected) return false;
        if (evt.type == "keydown") {
          switch (evt.keyCode) {
            case 8:   // backspace
            case 46:  // delete
            if (options.dataChange) {
              var i = points.indexOf(selected);
              deletePoint(i);
              selected = points.length ? points[i > 0 ? i - 1 : 0] : null;
              update();
            }
            evt.preventDefault();
            evt.stopPropagation();
            break;
          }
          evt.preventDefault();
        }
      });
    }

    // ------------------------------------------------------------
    //
    // Graph attribute updaters
    //
    // ------------------------------------------------------------

    // update the title
    function updateTitle() {
      if (options.title && title) {
        title.text(options.title);
      }
    }

    // update the x-axis label
    function updateXlabel() {
      if (options.xlabel && xlabel) {
        xlabel.text(options.xlabel);
      }
    }

    // update the y-axis label
    function updateYlabel() {
      if (options.ylabel && ylabel) {
        ylabel.text(options.ylabel);
      } else {
        ylabel.style("display", "none");
      }
    }

    // ------------------------------------------------------------
    //
    // Main API functions ...
    //
    // ------------------------------------------------------------

    function renderGraph() {
      calculateLayout();
      if (svg === undefined) {
        renderNewGraph();
      } else {
        repaintExistingGraph();
      }
      if (options.showButtons) {
        if (!buttonLayer) createButtonLayer();
        resizeButtonLayer();
      }
      redraw();
    }

    function reset(idOrElement, options, message) {
      if (arguments.length) {
        initialize(idOrElement, options, message);
      } else {
        initialize();
      }
      renderGraph();
      // and then render again using actual size of SVG text elements are
      renderGraph();
      registerKeyboardHandler();
      return api;
    }

    function resize(w, h) {
      scale(w, h);
      initializeLayout();
      renderGraph();
      return api;
    }

    //
    // Public API to instantiated Graph
    //
    api = {
      update:               update,
      repaint:              renderGraph,
      reset:                reset,
      redraw:               redraw,
      resize:               resize,
      notify:               notify,

      // selection brush api
      selectionDomain:      selectionDomain,
      selectionVisible:     selectionVisible,
      selectionListener:    selectionListener,
      selectionEnabled:     selectionEnabled,
      hasSelection:         hasSelection,

      /**
        Read only getter for the d3 selection referencing the DOM elements containing the d3
        brush used to implement selection region manipulation.
      */
      brushElement: function() {
        return brush_element;
      },

      /**
        Read-only getter for the d3 brush control (d3.svg.brush() function) used to implement
        selection region manipulation.
      */
      brushControl: function() {
        return brush_control;
      },

      /**
        Read-only getter for the internal listener to the d3 'brush' event.
      */
      brushListener: function() {
        return brushListener;
      },

      // specific update functions ???
      scale:                scale,
      updateOrRescale:      updateOrRescale,

      xDomain: function(_) {
        if (!arguments.length) return xScale.domain();
        xScale.domain(_);
        if (updateXScale) {
          updateXScale();
          redraw();
        }
        return api;
      },

      yDomain: function(_) {
        if (!arguments.length) return yScale.domain();
        yScale.domain(_);
        if (updateYScale) {
          updateYScale();
          redraw();
        }
        return api;
      },

      xmin: function(_) {
        if (!arguments.length) return options.xmin;
        options.xmin = _;
        options.xrange = options.xmax - options.xmin;
        if (updateXScale) {
          updateXScale();
          redraw();
        }
        return api;
      },

      xmax: function(_) {
        if (!arguments.length) return options.xmax;
        options.xmax = _;
        options.xrange = options.xmax - options.xmin;
        if (updateXScale) {
          updateXScale();
          redraw();
        }
        return api;
      },

      ymin: function(_) {
        if (!arguments.length) return options.ymin;
        options.ymin = _;
        options.yrange = options.ymax - options.ymin;
        if (updateYScale) {
          updateYScale();
          redraw();
        }
        return api;
      },

      ymax: function(_) {
        if (!arguments.length) return options.ymax;
        options.ymax = _;
        options.yrange = options.ymax - options.ymin;
        if (updateYScale) {
          updateYScale();
          redraw();
        }
        return api;
      },

      xLabel: function(_) {
        if (!arguments.length) return options.xlabel;
        options.xlabel = _;
        updateXlabel();
        return api;
      },

      yLabel: function(_) {
        if (!arguments.length) return options.ylabel;
        options.ylabel = _;
        updateYlabel();
        return api;
      },

      title: function(_) {
        if (!arguments.length) return options.title;
        options.title = _;
        updateTitle();
        return api;
      },

      width: function(_) {
        if (!arguments.length) return size.width;
        size.width = _;
        return api;
      },

      height: function(_) {
        if (!arguments.length) return size.height;
        size.height = _;
        return api;
      },

      elem: function(_) {
        if (!arguments.length) return elem;
        elem = d3.select(_);
        graph(elem);
        return api;
      },

      numberOfPoints: function() {
        if (points) {
          return points.length;
        } else {
          return false;
        }
      },

      // Point data consist of an array (or arrays) of [x,y] arrays.
      addPoints:       addPoints,
      addPoint:        addPoint,
      resetPoints:      resetPoints,

      // Sample data consists of an array (or an array or arrays) of samples.
      // The interval between samples is assumed to have already been set
      // by specifying options.sampleInterval when creating the graph.
      addSamples:      addSamples,
      addSample:       addSample,
      resetSamples: resetSamples

    };

    // Initialization.
    initialize(idOrElement, options, message);

    if (node) {
      renderGraph();
      // Render again using actual size of SVG text elements.
      renderGraph();
    }

    return api;

  };
});

/*global define $ model*/
/*jslint boss: true eqnull: true*/

define('common/controllers/graph-controller',['require','grapher/core/graph','common/controllers/interactive-metadata','common/validator'],function (require) {
  var Graph = require('grapher/core/graph'),
      metadata  = require('common/controllers/interactive-metadata'),
      validator = require('common/validator'),

      // Note: We always explicitly copy properties from component spec to grapher options hash,
      // in order to avoid tighly coupling an externally-exposed API (the component spec) to an
      // internal implementation detail (the grapher options format).
      grapherOptionForComponentSpecProperty = {
        title: 'title',
        dataPoints: 'dataPoints',
        fontScaleRelativeToParent: 'fontScaleRelativeToParent',
        xlabel: 'xlabel',
        xmin: 'xmin',
        xmax: 'xmax',
        ylabel: 'ylabel',
        ymin: 'ymin',
        ymax: 'ymax',
        xTickCount: 'xTickCount',
        yTickCount: 'yTickCount',
        xscaleExponent: 'xscaleExponent',
        yscaleExponent: 'yscaleExponent',
        xFormatter: 'xFormatter',
        yFormatter: 'yFormatter',
        lines: 'lines',
        bars: 'bars'
      },

  graphControllerCount = 0;

  return function graphController(component, scriptingAPI, interactivesController) {
    var // HTML element containing view
        $container,
        grapher,
        controller,
        properties,
        data = [],
        namespace = "graphController" + (++graphControllerCount);


    /**
      Returns an array containing two-element arrays each containing the current model
      time and the current value of each model property specified in component.properties.
    */
    function getDataPoint() {
      var ret = [], i, len,
          time = model.get('time');

      for (i = 0, len = properties.length; i < len; i++) {
        ret.push([time, model.get(properties[i])]);
      }
      return ret;
    }

    /**
      Return an options hash for use by the grapher.
    */
    function getOptions() {
      var options = {},
          cProp,
          gOption;

      // update grapher options from component spec & defaults
      for (cProp in grapherOptionForComponentSpecProperty) {
        if (grapherOptionForComponentSpecProperty.hasOwnProperty(cProp)) {
          gOption = grapherOptionForComponentSpecProperty[cProp];
          options[gOption] = component[cProp];
        }
      }
      return options;
    }

    /**
      Resets the cached data array to a single, initial data point, and pushes that data into graph.
    */
    function resetData() {
      var dataPoint = getDataPoint(),
          i;

      for (i = 0; i < dataPoint.length; i++) {
        data[i] = [dataPoint[i]];
      }
      grapher.resetPoints(data);
    }

    /**
      Appends the current data point (as returned by getDataPoint()) to the graph and to the cached
      data array
    */
    function appendDataPoint() {
      var dataPoint = getDataPoint(),
          i;

      for (i = 0; i < dataPoint.length; i++) {
        data[i].push(dataPoint[i]);
      }
      // The grapher considers each individual (property, time) pair to be a "point", and therefore
      // considers the set of properties at any 1 time (what we consider a "point") to be "points".
      grapher.addPoints(dataPoint);
    }

    /**
      Removes all data from the graph that correspond to steps following the current step pointer.
      This is used when a change is made that invalidates the future data.
    */
    function removeDataAfterStepPointer() {
      var i;

      for (i = 0; i < properties.length; i++) {
        // Account for initial data, which corresponds to stepCounter == 0
        data[i].length = model.stepCounter() + 1;
      }
      grapher.resetPoints(data);
    }

    /**
      Causes the graph to move the "current" pointer to the current model step. This desaturates
      the graph region corresponding to times after the current point.
    */
    function redrawCurrentStepPointer() {
      grapher.updateOrRescale(model.stepCounter());
    }

    /**
      Ask the grapher to reset itself, without adding new data.
    */
    function resetGrapher() {
      grapher.reset('#' + component.id, getOptions());
    }


    function registerModelListeners() {
      // Namespace listeners to '.graphController' so we can eventually remove them all at once
      model.on('tick.'+namespace, appendDataPoint);
      model.on('stepBack.'+namespace, redrawCurrentStepPointer);
      model.on('stepForward.'+namespace, redrawCurrentStepPointer);
      model.on('seek.'+namespace, redrawCurrentStepPointer);
      model.on('reset.'+namespace, function() {
        resetGrapher();
        resetData();
      });
      model.on('play.'+namespace, function() {
        if (grapher.numberOfPoints() && model.stepCounter() < grapher.numberOfPoints()) {
          removeDataAfterStepPointer();
        }
      });
      model.on('invalidation.'+namespace, removeDataAfterStepPointer);
    }

    //
    // Initialization.
    //
    // Validate component definition, use validated copy of the properties.
    component = validator.validateCompleteness(metadata.graph, component);
    // The list of properties we are being asked to graph.
    properties = component.properties.slice();
    $container = $('<div>').attr('id', component.id).addClass('graph');
    // Each interactive component has to have class "component".
    $container.addClass("component");
    // Apply custom width and height settings.
    $container.css({
      width: component.width,
      height: component.height
    });


    return controller = {

      /**
        Called by the interactives controller when the model finishes loading.
      */
      modelLoadedCallback: function() {
        if (grapher) {
          resetGrapher();
        } else {
          grapher = new Graph($container[0], getOptions(), undefined, interactivesController.getNextTabIndex());
        }
        resetData();
        registerModelListeners();
      },

      /**
        Returns the grapher object itself.
      */
      getView: function() {
        return grapher;
      },

      /**
        Returns a jQuery selection containing the div which contains the graph.
      */
      getViewContainer: function() {
        return $container;
      },

      resize: function () {
        // For now only "fit to parent" behavior is supported.
        if (grapher) {
          grapher.resize();
        }
      },

      /**
        Returns serialized component definition.
      */
      serialize: function () {
        // The only thing which needs to be updated is scaling of axes.
        // Note however that the serialized definition should always have
        // 'xmin' set to initial value, as after deserialization we assume
        // that there is no previous data and simulations should start from the beginning.
        var result = $.extend(true, {}, component),
            // Get current domains settings, e.g. after dragging performed by the user.
            // TODO: this should be reflected somehow in the grapher model,
            // not grabbed directly from the view as now. Waiting for refactoring.
            xDomain = grapher.xDomain(),
            yDomain = grapher.yDomain(),
            startX  = component.xmin;

        result.ymin = yDomain[0];
        result.ymax = yDomain[1];
        // Shift graph back to the original origin, but keep scale of the X axis.
        // This is not very clear, but follows the rule of least surprise for the user.
        result.xmin = startX;
        result.xmax = startX + xDomain[1] - xDomain[0];

        return result;
      }
    };
  };

});

/*jshint eqnull: true */
/*global define */

define('import-export/dg-exporter',['require','common/console'],function(require) {

  var console = require('common/console');

  return {
    gameName: 'Next Gen MW',
    parentCollectionName: 'Summary of Run',
    childCollectionName: 'Time Series of Run',

    perRunColumnLabelCount: 0,
    perRunColumnLabelPositions: {},

    mockDGController: {
      doCommand: function(obj) {
        console.log("action: ", obj.action);
        console.log("args: ", obj.args);
        return { caseID: 0 };
      }
    },

    isDgGameControllerDefined: function() {
      return !!(window.parent && window.parent.DG && window.parent.DG.currGameController);
    },

    // Synonym...
    isExportAvailable: function() {
      return this.isDgGameControllerDefined();
    },

    getDGGameController: function() {
      if (!this.isDgGameControllerDefined()) {
        return this.mockDGController;
      }
      return window.parent.DG.currGameController;
    },

    doCommand: function(name, args) {
      var controller = this.getDGGameController();

      return controller.doCommand({
        action: name,
        args: args
      });
    },


    /**
      Exports the summary data about a run and timeseries data from the run to DataGames as 2
      linked tables.

      perRunLabels: list of column labels for the "left" table which contains a summary of the run
        (this can contain parameters that define the run, as well as )

      perRunData: list containing 1 row of data to be added to the left table

      timeSeriesLabels: list of column labels for the "right" table which contains a set of time
        points that will be linked to the single row which is added to the "left", run-summary table

      timeSeriesData: a list of lists, each of which contains 1 row of data to be added to the
        right table.

      This method automatically adds, as the first column of the run-summary table, a column
      labeled "Number of Time Points", which contains the number of time points in the timeseries
      that is associated with the run.

      Note: Call this method once per run, or row of data to be added to the left table.
      This method "does the right thing" if per-run column labels are added, removed, and/or
      reordered between calls to the method. However, currently, it does not handle the removal
      of time series labels (except from the end of the list) and it does not handle reordering of
      time series labels.
    */
    exportData: function(perRunLabels, perRunData, timeSeriesLabels, timeSeriesData) {
      var label,
          value,
          position,
          perRunColumnLabels = [],
          perRunColumnValues = [],
          timeSeriesColumnLabels = [],
          parentCase,
          parentCollectionValues,
          i;

      // Extract metadata in the forms needed for export, ie values need to be an array of values,
      // labels need to be an array of {name: label} objects.
      // Furthermore note that during a DG session, the value for a given label needs to be in the
      // same position in the array every time the DG collection is 'created' (or reopened as the
      // case may be.)

      for (i = 0; i < perRunData.length; i++) {
        label = perRunLabels[i];
        value = perRunData[i];

        if ( this.perRunColumnLabelPositions[label] == null ) {
          this.perRunColumnLabelPositions[label] = this.perRunColumnLabelCount++;
        }
        position = this.perRunColumnLabelPositions[label];

        perRunColumnLabels[position] = { name: label };
        perRunColumnValues[position] = value;
      }

      // Extract list of data column labels into form needed for export (needs to be an array of
      // name: label objects)
      for (i = 0; i < timeSeriesLabels.length; i++) {
        timeSeriesColumnLabels.push({ name: timeSeriesLabels[i] });
      }

      // Export.

      // Step 1. Tell DG we're a "game".
      this.doCommand('initGame', {
        name: this.gameName
      });

      // Step 2. Create a parent table. Each row will have the value of each of the perRunData,
      // plus the number of time series points that are being exported for combination of
      // parameter values.
      // (It seems to be ok to call this multiple times with the same collection name, e.g., for
      // multiple exports during a single DG session.)
      this.doCommand('createCollection', {
        name: this.parentCollectionName,
        attrs: [{name: 'Number of Time Points'}].concat(perRunColumnLabels),
        childAttrName: 'contents'
      });

      // Step 3. Create a table to be the child of the parent table; each row of the child
      // has a single time series reading (time, property1, property2...)
      // (Again, it seems to be ok to call this for the same table multiple times per DG session)
      this.doCommand('createCollection', {
        name: this.childCollectionName,
        attrs: timeSeriesColumnLabels
      });

      // Step 4. Open a row in the parent table. This will contain the individual time series
      // readings as children.
      parentCollectionValues = [timeSeriesData.length].concat(perRunColumnValues);
      parentCase = this.doCommand('openCase', {
        collection: this.parentCollectionName,
        values: parentCollectionValues
      });

      // Step 5. Create rows in the child table for each data point. Using 'createCases' we can
      // do this inline, so we don't need to call openCase, closeCase for each row.
      this.doCommand('createCases', {
        collection: this.childCollectionName,
        values: timeSeriesData,
        parent: parentCase.caseID
      });

      // Step 6. Close the case.
      this.doCommand('closeCase', {
        collection: this.parentCollectionName,
        values: parentCollectionValues,
        caseID: parentCase.caseID
      });
    },

    /**
      Call this to cause DataGames to open the 'case table" containing the all the data exported by
      exportData() so far.
    */
    openTable: function() {
      this.doCommand('createComponent', {
        type: 'DG.TableView',
        log: false
      });
    },

    /**
      Call any time to log an event to DataGames
    */
    logAction: function(logString) {
      this.doCommand('logAction', {
        formatStr: logString
      });
    }
  };
});

/*global define model*/
/*jslint boss: true*/

define('common/controllers/export-controller',['require','import-export/dg-exporter'],function (require) {

  var dgExporter = require('import-export/dg-exporter');

  var ExportController = function exportController(spec) {
    var perRun  = (spec.perRun || []).slice(),
        perTick = ['displayTime'].concat(spec.perTick.slice()),
        perTickValues,
        controller;

    function getDataPoint() {
      var ret = [], i, len;

      for (i = 0, len = perTick.length; i < len; i++) {
        ret.push(model.get(perTick[i]));
      }
      return ret;
    }

    function resetData() {
      perTickValues = [getDataPoint()];
    }

    function appendDataPoint() {
      perTickValues.push(getDataPoint());
    }

    function removeDataAfterStepPointer() {
      // Account for initial data, which corresponds to stepCounter == 0
      perTickValues.length = model.stepCounter() + 1;
    }

    function logAction(action) {
      var logString,
          perRunPropertyLabels = [],
          perRunPropertyValues = [],
          i;

      for (i = 0; i < perRun.length; i++) {
        perRunPropertyLabels[i] = getLabelForProperty(perRun[i]);
        perRunPropertyValues[i] = model.get(perRun[i]);
      }

      logString = "User " + action + " model. ";
      logString += "Per-run Settings and Data: ";
      logString += JSON.stringify({
        action: action,
        type: "model",
        fields: perRunPropertyLabels,
        values: perRunPropertyValues
      });

      dgExporter.logAction(logString);
    }

    function registerModelListeners() {
      // Namespace listeners to '.exportController' so we can eventually remove them all at once
      model.on('tick.exportController', appendDataPoint);
      model.on('reset.exportController', resetData);
      model.on('play.exportController', removeDataAfterStepPointer);
      model.on('invalidation.exportController', removeDataAfterStepPointer);

      model.on('play.exportController', function() {
        logAction('started');
      });

      model.on('willReset.exportController', function() {
        logAction('reset');
      });

    }

    function getLabelForProperty(property) {
      var desc  = model.getPropertyDescription(property),
          label = desc.getLabel(),
          units = desc.getUnitAbbreviation(),
          ret   = "";

      if (label.length > 0) {
        ret += label;
      } else {
        ret += property;
      }

      if (units && units.length > 0) {
        ret += " (";
        ret += units;
        ret += ")";
      }
      return ret;
    }

    return controller = {

      modelLoadedCallback: function() {
        // put per-run parameters before per-run outputs
        function is(type) {
          return function(p) { return model.getPropertyType(p) === type; };
        }
        perRun = perRun.filter(is('parameter')).concat(perRun.filter(is('output')));

        resetData();
        registerModelListeners();
      },

      exportData: function() {
        var perRunPropertyLabels = [],
            perRunPropertyValues = [],
            perTickLabels = [],
            i;

        logAction('exported');

        for (i = 0; i < perRun.length; i++) {
          perRunPropertyLabels[i] = getLabelForProperty(perRun[i]);
          perRunPropertyValues[i] = model.get(perRun[i]);
        }

        for (i = 0; i < perTick.length; i++) {
          perTickLabels[i] = getLabelForProperty(perTick[i]);
        }

        dgExporter.exportData(perRunPropertyLabels, perRunPropertyValues, perTickLabels, perTickValues);
        dgExporter.openTable();
      }
    };
  };

  // "Class method" (want to be able to call this before instantiating)
  // Do we have a sink
  ExportController.isExportAvailable = function() {
    return dgExporter.isExportAvailable();
  };

  return ExportController;
});
/*global d3, $, define, model */

define('common/controllers/scripting-api',['require','common/alert'],function (require) {

  var alert = require('common/alert');

  //
  // Define the scripting API used by 'action' scripts on interactive elements.
  //
  // The properties of the object below will be exposed to the interactive's
  // 'action' scripts as if they were local vars. All other names (including
  // all globals, but exluding Javascript builtins) will be unavailable in the
  // script context; and scripts are run in strict mode so they don't
  // accidentally expose or read globals.
  //
  return function ScriptingAPI (interactivesController) {

    var controller = {

      api: (function() {

        function isInteger(n) {
          // Exploits the facts that (1) NaN !== NaN, and (2) parseInt(Infinity, 10) is NaN
          return typeof n === "number" && (parseFloat(n) === parseInt(n, 10));
        }

        function isArray(obj) {
          return typeof obj === 'object' && obj.slice === Array.prototype.slice;
        }

        /** return a number randomly chosen between 0..max */
        function randomFloat(max) {
          if (max) {
            return Math.random() * max;
          } else {
            return Math.random();
          }
        }

        /** return an integer randomly chosen from the set of integers 0..n-1 */
        function randomInteger(n) {
          return Math.floor(Math.random() * n);
        }

        function swapElementsOfArray(array, i, j) {
          var tmp = array[i];
          array[i] = array[j];
          array[j] = tmp;
        }

        /** Return an array of n randomly chosen members of the set of integers 0..N-1 */
        function choose(n, N) {
          var values = [],
              i;

          for (i = 0; i < N; i++) { values[i] = i; }

          for (i = 0; i < n; i++) {
            swapElementsOfArray(values, i, i + randomInteger(N-i));
          }
          values.length = n;

          return values;
        }

        /* Send a tracking event to Google Analytics */
        function trackEvent(category, action, label) {
          var googleAnalytics;

          if (typeof _gaq === 'undefined'){
            // console.error("Google Analytics not defined, Can not send trackEvent");
            return;
          }
          googleAnalytics = _gaq;
          if (!category) {
            category = "Interactive";
          }
          // console.log("Sending a track page event Google Analytics (category:action:label):");
          // console.log("(" + category + ":"  + action + ":" + label + ")");
          googleAnalytics.push(['_trackEvent', category, action, label]);
        }

        return {

          isInteger: isInteger,
          isArray: isArray,
          randomInteger: randomInteger,
          randomFloat: randomFloat,
          swapElementsOfArray: swapElementsOfArray,
          choose: choose,

          deg2rad: Math.PI/180,
          rad2deg: 180/Math.PI,

          trackEvent: trackEvent,

          format: d3.format,



          get: function get() {
            return model.get.apply(model, arguments);
          },

          set: function set() {
            return model.set.apply(model, arguments);
          },

          loadModel: function loadModel(modelId, cb) {
            model.stop();

            interactivesController.loadModel(modelId);

            if (typeof cb === 'function') {
              interactivesController.pushOnLoadScript(cb);
            }
          },

          /**
            Observe property `propertyName` on the model, and perform `action` when it changes.
            Pass property value to action.
          */
          onPropertyChange: function onPropertyChange(propertyName, action) {
            model.addPropertiesListener([propertyName], function() {
              action( model.get(propertyName) );
            });
          },

          /**
           * Performs a user-defined script at any given time.
           *
           * callAt(t, ...) guarantees that script will be executed, but not necessarily
           * at exactly chosen time (as this can be impossible due to simulation settings).
           * User scripts cannot interrupt the model "tick", the most inner integration loop.
           * e.g. callAt(23, ...) in MD2D model context will be executed at time 50,
           * if timeStepsPerTick = 50 and timeStep = 1.
           *
           * callAt action will only occur the first time the model reaches the specified time,
           * but not after the model is scrubbed forward and backward (using tick history).
           *
           * @param  {number} time     Time defined in model native time unit (e.g. fs for MD2D).
           * @param  {function} action Function containing user-defined script.
           */
          callAt: function callAt(time, action) {
            var actionTimeout = {
              time: time,
              action: action,
              check: function() {
                if (model.get("time") >= this.time) {
                  this.action();
                  // Optimization - when function was once executed, replace
                  // check with empty function.
                  // removePropertiesListener() method could be useful, but it
                  // isn't available yet.
                  this.check = function () {};
                }
              }
            };
            model.addPropertiesListener("time", function () {
              actionTimeout.check();
            });
          },

          /**
           * Performs a user-defined script repeatedly, with a fixed time delay
           * between each call.
           *
           * callEvery(t, ...) guarantees that script will be executed *correct number of times*,
           * but not necessarily at exactly chosen intervals (as this can be impossible due to
           * simulation settings). User scripts cannot interrupt the model "tick", the most
           * inner integration loop.
           * e.g. callEvery(23, ...) in MD2D model context will be executed *twice* at time 50,
           * if timeStepsPerTick = 50 and timeStep = 1.
           *
           * callEvery action for time N * interval (for any integer N >= 1) will only be called
           * the first time the model time exceeds N * interval time. After the model is scrubbed
           * forward and backward using (using tick history), action *won't* be called again.
           *
           * @param {number}   interval Interval on how often to execute the script,
           *                            defined in model native time unit (e.g. fs for MD2D).
           * @param {function} action   Function containing user-defined script.
           */
          callEvery: function callEvery(interval, action) {
            var actionInterval = {
              lastCall: 0,
              interval: interval,
              action: action,
              execute: function() {
                var time = model.get("time");
                while (time - this.lastCall >= this.interval) {
                  this.action();
                  this.lastCall += this.interval;
                }
              }
            };
            model.addPropertiesListener("time", function () {
              actionInterval.execute();
            });
          },

          /**
           * Sets a custom click handler for objects of a given type.
           * Basic type which is always supported is "plot". It is empty
           * area of a model. Various models can support different clickable
           * types. Please see the model documentation to check what
           * other object types are supported.
           *
           * Behind the scenes this functions uses class selector. So you can
           * also inspect SVG image and check what is class of interesting
           * object and try to use it.
           *
           * MD2D specific notes:
           * Supported types: "plot", "atom", "obstacle", "image", "textBox".
           * TODO: move it to MD2D related docs in the future.
           *
           * @param {string}   type    Name of the type of clickable objects.
           * @param {Function} handler Custom click handler. It will be called
           *                           when object is clicked with (x, y, d, i) arguments:
           *                             x - x coordinate in model units,
           *                             y - y coordinate in model units,
           *                             d - data associated with a given object (can be undefined!),
           *                             i - ID of clicked object (usually its value makes sense if d is defined).
           */
          onClick: function onClick(type, handler) {
            // Append '.' to make API simpler.
            // So authors can just specify onClick("atom", ...) instead of class selectors.
            interactivesController.getModelController().modelContainer.setClickHandler("." + type, handler);
          },

          /**
           * Sets custom select handler. It enables select action and lets author provide custom handler
           * which is executed when select action is finished. The area of selection is passed to handler
           * as arguments. It is defined by rectangle - its lower left corner coordinates, width and height.
           *
           * @param {Function} handler Custom select handler. It will be called
           *                           when select action is finished with (x, y, w, h) arguments:
           *                             x - x coordinate of lower left selection corner (in model units),
           *                             y - y coordinate of lower left selection corner (in model units),
           *                             width  - width of selection rectangle (in model units),
           *                             height - height of selection rectangle (in model units).
           */
          onSelect: function onSelect(handler) {
            interactivesController.getModelController().modelContainer.setSelectHandler(handler);
          },

          start: function start() {
            model.start();
            trackEvent('Interactive', "Start", "Starting interactive: " + interactivesController.get('title') );
          },

          stop: function stop() {
            model.stop();
          },

          reset: function reset() {
            model.stop();
            interactivesController.modelController.reload();
          },

          stepForward: function stepForward() {
            model.stepForward();
            if (!model.isNewStep()) {
              interactivesController.modelController.modelContainer.update();
            }
          },

          stepBack: function stepBack() {
            model.stepBack();
            interactivesController.modelController.modelContainer.update();
          },

          tick: function tick() {
            model.tick();
          },

          isStopped: function isStopped() {
            return model.isStopped();
          },

          getTime: function getTime() {
            return model.get('time');
          },

          /**
           * Returns number of frames per second.
           * @return {number} frames per second.
           */
          getFPS: function getFPS() {
            return model.getFPS();
          },

          /**
           * Returns "simulation progress rate".
           * It indicates how much of simulation time is calculated for
           * one second of real time.
           * @return {number} simulation progress rate.
           */
          getSimulationProgressRate: function getSimulationProgressRate() {
            return model.getSimulationProgressRate();
          },

          startPerformanceTuning: function startPerformanceTuning() {
            model.performanceOptimizer.enable();
          },

          repaint: function repaint() {
            interactivesController.getModelController().repaint();
          },

          exportData: function exportData() {
            var dgExport = interactivesController.getDGExportController();
            if (!dgExport)
              throw new Error("No exports have been specified.");
            dgExport.exportData();
          },

          Math: Math,

          // Prevent us from overwriting window.undefined.
          "undefined": undefined,

          // Rudimentary debugging functionality. Use Lab alert helper function.
          alert: alert,

          console: window.console !== null ? window.console : {
            log: function() {},
            error: function() {},
            warn: function() {},
            dir: function() {}
          }
        };
      }()),

      /**
        Freeze Scripting API
        Make the scripting API immutable once defined
      */
      freeze: function () {
        Object.freeze(this.api);
      },

      /**
        Extend Scripting API
      */
      extend: function (ModelScriptingAPI) {
        $.extend(this.api, new ModelScriptingAPI(this.api));
      },

      /**
        Allow console users to try script actions
      */
      exposeScriptingAPI: function () {
        window.script = $.extend({}, this.api);
        window.script.run = function(source, args) {
          var prop,
              argNames = [],
              argVals = [];

          for (prop in args) {
            if (args.hasOwnProperty(prop)) {
              argNames.push(prop);
              argVals.push(args[prop]);
            }
          }
          return controller.makeFunctionInScriptContext.apply(null, argNames.concat(source)).apply(null, argVals);
        };
      },

      /**
        Given a script string, return a function that executes that script in a
        context containing *only* the bindings to names we supply.

        This isn't intended for XSS protection (in particular it relies on strict
        mode.) Rather, it's so script authors don't get too clever and start relying
        on accidentally exposed functionality, before we've made decisions about
        what scripting API and semantics we want to support.
      */
      makeFunctionInScriptContext: function () {

            // This object is the outer context in which the script is executed. Every time the script
            // is executed, it contains the value 'undefined' for all the currently defined globals.
            // This prevents at least inadvertent reliance by the script on unintentinally exposed
            // globals.

        var shadowedGlobals = {},

            // First n-1 arguments to this function are the names of the arguments to the script.
            argumentsToScript = Array.prototype.slice.call(arguments, 0, arguments.length - 1),

            // Last argument is the function body of the script, as a string or array of strings.
            scriptSource = arguments[arguments.length - 1],

            scriptFunctionMakerSource,
            scriptFunctionMaker,
            scriptFunction;

        if (typeof scriptSource !== 'string') scriptSource = scriptSource.join('      \n');

        // Make shadowedGlobals contain keys for all globals (properties of 'window')
        // Also make set and get of any such property throw a ReferenceError exactly like
        // reading or writing an undeclared variable in strict mode.
        function setShadowedGlobals() {
          var keys = Object.getOwnPropertyNames(window),
              key,
              i,
              len,
              err;

          for (i = 0, len = keys.length; i < len; i++) {
            key = keys[i];
            if (!shadowedGlobals.hasOwnProperty(key)) {
              err = (function(key) {
                return function() { throw new ReferenceError(key + " is not defined"); };
              }(key));

              Object.defineProperty(shadowedGlobals, key, {
                set: err,
                get: err
              });
            }
          }
        }

        scriptFunctionMakerSource =
          "with (shadowedGlobals) {\n" +
          "  with (scriptingAPI) {\n" +
          "    return function(" + argumentsToScript.join(',') +  ") {\n" +
          "      'use " + "strict';\n" +
          "      " + scriptSource + "\n" +
          "    };\n" +
          "  }\n" +
          "}";

        try {
          scriptFunctionMaker = new Function('shadowedGlobals', 'scriptingAPI', 'scriptSource', scriptFunctionMakerSource);
          scriptFunction = scriptFunctionMaker(shadowedGlobals, this.api, scriptSource);
        } catch (e) {
          alert("Error compiling script: \"" + e.toString() + "\"\nScript:\n\n" + scriptSource);
          return function() {
            throw new Error("Cannot run a script that could not be compiled");
          };
        }

        // This function runs the script with all globals shadowed:
        return function() {
          setShadowedGlobals();
          try {
            // invoke the script, passing only enough arguments for the whitelisted names
            return scriptFunction.apply(null, Array.prototype.slice.call(arguments));
          } catch (e) {
            alert("Error running script: \"" + e.toString() + "\"\nScript:\n\n" + scriptSource);
          }
        };
      }
    };
    return controller;
  };
});

/*global define $ */

define('common/controllers/button-controller',['common/controllers/interactive-metadata','common/validator'],function () {

  var metadata  = require('common/controllers/interactive-metadata'),
      validator = require('common/validator');

  return function ButtonController(component, scriptingAPI, interactivesController) {
    var $button,
        controller;

    // Validate component definition, use validated copy of the properties.
    component = validator.validateCompleteness(metadata.button, component);

    $button = $('<button>')
        .attr('tabindex', interactivesController.getNextTabIndex())
        .attr('id', component.id).html(component.text);
    // Each interactive component has to have class "component".
    $button.addClass("component");

    // Custom dimensions.
    $button.css({
      width: component.width,
      height: component.height
    });

    $button.click(scriptingAPI.makeFunctionInScriptContext(component.action));

    // Public API.
    controller = {
      // No modelLoadeCallback is defined. In case of need:
      // modelLoadedCallback: function () {
      //   (...)
      // },

      // Returns view container.
      getViewContainer: function () {
        return $button;
      },

      // Returns serialized component definition.
      serialize: function () {
        // Return the initial component definition.
        // Button doesn't have any state, which can be changed.
        return $.extend(true, {}, component);
      }
    };
    // Return Public API object.
    return controller;
  };
});

/*global define, $, model */

define('common/controllers/checkbox-controller',['common/controllers/interactive-metadata','common/validator'],function () {

  var metadata  = require('common/controllers/interactive-metadata'),
      validator = require('common/validator');

  return function CheckboxController(component, scriptingAPI, interactivesController) {
    var propertyName,
        onClickScript,
        initialValue,
        $checkbox,
        $fakeCheckable,
        $label,
        $element,
        controller;

    // Updates checkbox using model property. Used in modelLoadedCallback.
    // Make sure that this function is only called when:
    // a) model is loaded,
    // b) checkbox is bound to some property.
    function updateCheckbox () {
      setCheckbox(model.get(propertyName));
    }

    function setCheckbox(value) {
      if (value) {
        $checkbox.prop('checked', true);
        $fakeCheckable.addClass('checked');
      } else {
        $checkbox.prop('checked', false);
        $fakeCheckable.removeClass('checked');
      }
    }

    function customClickEvent (e) {
      e.preventDefault();

      if ($checkbox.prop('checked')) {
        setCheckbox(false);
      } else {
        setCheckbox(true);
      }
      // Trigger change event!
      $checkbox.trigger('change');
    }

    // Validate component definition, use validated copy of the properties.
    component = validator.validateCompleteness(metadata.checkbox, component);
    propertyName  = component.property;
    onClickScript = component.onClick;
    initialValue  = component.initialValue;

    $label = $('<label>').append('<span>' + component.text + '</span>');
    $label.attr('for', component.id);
    $checkbox = $('<input type="checkbox">').attr('id', component.id);

    if (interactivesController) {
      $checkbox.attr('tabindex', interactivesController.getNextTabIndex());
    }

    $fakeCheckable = $('<div class="fakeCheckable">');
    // Hide native input, use fake checkable.
    $checkbox.css("display", "none");

    // default is to have label on right of checkbox
    if (component.textOn === "left") {
      $element = $('<div>').append($label).append($checkbox).append($fakeCheckable.addClass("right"));
    } else {
      $element = $('<div>').append($checkbox).append($fakeCheckable).append($label);
    }

    // Append class to the most outer container.
    $element.addClass("interactive-checkbox");
    // Each interactive component has to have class "component".
    $element.addClass("component");

    // Ensure that custom div (used for styling) is clickable.
    $fakeCheckable.on('touchstart click', customClickEvent);
    // Label also requires custom event handler to ensure that click updates
    // fake clickable element too.
    $label.on('touchstart click', customClickEvent);

    // Custom dimensions.
    $element.css({
      width: component.width,
      height: component.height
    });

    // Process onClick script if it is defined.
    if (onClickScript) {
      // Create a function which assumes we pass it a parameter called 'value'.
      onClickScript = scriptingAPI.makeFunctionInScriptContext('value', onClickScript);
    }

    // Register handler for change event.
    $checkbox.on('change', function () {
      var value = false,
          propObj;
      // $(this) will contain a reference to the checkbox.
      if ($(this).is(':checked')) {
        value = true;
      }
      // Change property value if checkbox is connected
      // with model's property.
      if (propertyName !== undefined) {
        propObj = {};
        propObj[propertyName] = value;
        model.set(propObj);
      }
      // Finally, if checkbox has onClick script attached,
      // call it in script context with checkbox status passed.
      if (onClickScript !== undefined) {
        onClickScript(value);
      }
    });

    // Public API.
    controller = {
      // This callback should be trigger when model is loaded.
      modelLoadedCallback: function () {
        // Connect checkbox with model's property if its name is defined.
        if (propertyName !== undefined) {
          // Register listener for 'propertyName'.
          model.addPropertiesListener([propertyName], updateCheckbox);
          // Perform initial checkbox setup.
          updateCheckbox();
        }
        else if (initialValue !== undefined) {
          setCheckbox(initialValue);
          onClickScript(initialValue);
        }
      },

      // Returns view container. Label tag, as it contains checkbox anyway.
      getViewContainer: function () {
        return $element;
      },

      // Returns serialized component definition.
      serialize: function () {
        var result = $.extend(true, {}, component);

        if (propertyName === undefined) {
          // No property binding. Just action script.
          // Update "initialValue" to represent current
          // value of the slider.
          result.initialValue = $checkbox.is(':checked') ? true : false;
        }

        return result;
      }
    };
    // Return Public API object.
    return controller;
  };
});

// Released under MIT license
// Copyright (c) 2009-2010 Dominic Baggott
// Copyright (c) 2009-2010 Ash Berlin
// Copyright (c) 2011 Christoph Dorn <christoph@christophdorn.com> (http://www.christophdorn.com)

(function( expose ) {

/**
 *  class Markdown
 *
 *  Markdown processing in Javascript done right. We have very particular views
 *  on what constitutes 'right' which include:
 *
 *  - produces well-formed HTML (this means that em and strong nesting is
 *    important)
 *
 *  - has an intermediate representation to allow processing of parsed data (We
 *    in fact have two, both as [JsonML]: a markdown tree and an HTML tree).
 *
 *  - is easily extensible to add new dialects without having to rewrite the
 *    entire parsing mechanics
 *
 *  - has a good test suite
 *
 *  This implementation fulfills all of these (except that the test suite could
 *  do with expanding to automatically run all the fixtures from other Markdown
 *  implementations.)
 *
 *  ##### Intermediate Representation
 *
 *  *TODO* Talk about this :) Its JsonML, but document the node names we use.
 *
 *  [JsonML]: http://jsonml.org/ "JSON Markup Language"
 **/
var Markdown = expose.Markdown = function Markdown(dialect) {
  switch (typeof dialect) {
    case "undefined":
      this.dialect = Markdown.dialects.Gruber;
      break;
    case "object":
      this.dialect = dialect;
      break;
    default:
      if (dialect in Markdown.dialects) {
        this.dialect = Markdown.dialects[dialect];
      }
      else {
        throw new Error("Unknown Markdown dialect '" + String(dialect) + "'");
      }
      break;
  }
  this.em_state = [];
  this.strong_state = [];
  this.debug_indent = "";
};

/**
 *  parse( markdown, [dialect] ) -> JsonML
 *  - markdown (String): markdown string to parse
 *  - dialect (String | Dialect): the dialect to use, defaults to gruber
 *
 *  Parse `markdown` and return a markdown document as a Markdown.JsonML tree.
 **/
expose.parse = function( source, dialect ) {
  // dialect will default if undefined
  var md = new Markdown( dialect );
  return md.toTree( source );
};

/**
 *  toHTML( markdown, [dialect]  ) -> String
 *  toHTML( md_tree ) -> String
 *  - markdown (String): markdown string to parse
 *  - md_tree (Markdown.JsonML): parsed markdown tree
 *
 *  Take markdown (either as a string or as a JsonML tree) and run it through
 *  [[toHTMLTree]] then turn it into a well-formated HTML fragment.
 **/
expose.toHTML = function toHTML( source , dialect , options ) {
  var input = expose.toHTMLTree( source , dialect , options );

  return expose.renderJsonML( input );
};

/**
 *  toHTMLTree( markdown, [dialect] ) -> JsonML
 *  toHTMLTree( md_tree ) -> JsonML
 *  - markdown (String): markdown string to parse
 *  - dialect (String | Dialect): the dialect to use, defaults to gruber
 *  - md_tree (Markdown.JsonML): parsed markdown tree
 *
 *  Turn markdown into HTML, represented as a JsonML tree. If a string is given
 *  to this function, it is first parsed into a markdown tree by calling
 *  [[parse]].
 **/
expose.toHTMLTree = function toHTMLTree( input, dialect , options ) {
  // convert string input to an MD tree
  if ( typeof input ==="string" ) input = this.parse( input, dialect );

  // Now convert the MD tree to an HTML tree

  // remove references from the tree
  var attrs = extract_attr( input ),
      refs = {};

  if ( attrs && attrs.references ) {
    refs = attrs.references;
  }

  var html = convert_tree_to_html( input, refs , options );
  merge_text_nodes( html );
  return html;
};

// For Spidermonkey based engines
function mk_block_toSource() {
  return "Markdown.mk_block( " +
          uneval(this.toString()) +
          ", " +
          uneval(this.trailing) +
          ", " +
          uneval(this.lineNumber) +
          " )";
}

// node
function mk_block_inspect() {
  var util = require('util');
  return "Markdown.mk_block( " +
          util.inspect(this.toString()) +
          ", " +
          util.inspect(this.trailing) +
          ", " +
          util.inspect(this.lineNumber) +
          " )";

}

var mk_block = Markdown.mk_block = function(block, trail, line) {
  // Be helpful for default case in tests.
  if ( arguments.length == 1 ) trail = "\n\n";

  var s = new String(block);
  s.trailing = trail;
  // To make it clear its not just a string
  s.inspect = mk_block_inspect;
  s.toSource = mk_block_toSource;

  if (line != undefined)
    s.lineNumber = line;

  return s;
};

function count_lines( str ) {
  var n = 0, i = -1;
  while ( ( i = str.indexOf('\n', i+1) ) !== -1) n++;
  return n;
}

// Internal - split source into rough blocks
Markdown.prototype.split_blocks = function splitBlocks( input, startLine ) {
  // [\s\S] matches _anything_ (newline or space)
  var re = /([\s\S]+?)($|\n(?:\s*\n|$)+)/g,
      blocks = [],
      m;

  var line_no = 1;

  if ( ( m = /^(\s*\n)/.exec(input) ) != null ) {
    // skip (but count) leading blank lines
    line_no += count_lines( m[0] );
    re.lastIndex = m[0].length;
  }

  while ( ( m = re.exec(input) ) !== null ) {
    blocks.push( mk_block( m[1], m[2], line_no ) );
    line_no += count_lines( m[0] );
  }

  return blocks;
};

/**
 *  Markdown#processBlock( block, next ) -> undefined | [ JsonML, ... ]
 *  - block (String): the block to process
 *  - next (Array): the following blocks
 *
 * Process `block` and return an array of JsonML nodes representing `block`.
 *
 * It does this by asking each block level function in the dialect to process
 * the block until one can. Succesful handling is indicated by returning an
 * array (with zero or more JsonML nodes), failure by a false value.
 *
 * Blocks handlers are responsible for calling [[Markdown#processInline]]
 * themselves as appropriate.
 *
 * If the blocks were split incorrectly or adjacent blocks need collapsing you
 * can adjust `next` in place using shift/splice etc.
 *
 * If any of this default behaviour is not right for the dialect, you can
 * define a `__call__` method on the dialect that will get invoked to handle
 * the block processing.
 */
Markdown.prototype.processBlock = function processBlock( block, next ) {
  var cbs = this.dialect.block,
      ord = cbs.__order__;

  if ( "__call__" in cbs ) {
    return cbs.__call__.call(this, block, next);
  }

  for ( var i = 0; i < ord.length; i++ ) {
    //D:this.debug( "Testing", ord[i] );
    var res = cbs[ ord[i] ].call( this, block, next );
    if ( res ) {
      //D:this.debug("  matched");
      if ( !isArray(res) || ( res.length > 0 && !( isArray(res[0]) ) ) )
        this.debug(ord[i], "didn't return a proper array");
      //D:this.debug( "" );
      return res;
    }
  }

  // Uhoh! no match! Should we throw an error?
  return [];
};

Markdown.prototype.processInline = function processInline( block ) {
  return this.dialect.inline.__call__.call( this, String( block ) );
};

/**
 *  Markdown#toTree( source ) -> JsonML
 *  - source (String): markdown source to parse
 *
 *  Parse `source` into a JsonML tree representing the markdown document.
 **/
// custom_tree means set this.tree to `custom_tree` and restore old value on return
Markdown.prototype.toTree = function toTree( source, custom_root ) {
  var blocks = source instanceof Array ? source : this.split_blocks( source );

  // Make tree a member variable so its easier to mess with in extensions
  var old_tree = this.tree;
  try {
    this.tree = custom_root || this.tree || [ "markdown" ];

    blocks:
    while ( blocks.length ) {
      var b = this.processBlock( blocks.shift(), blocks );

      // Reference blocks and the like won't return any content
      if ( !b.length ) continue blocks;

      this.tree.push.apply( this.tree, b );
    }
    return this.tree;
  }
  finally {
    if ( custom_root ) {
      this.tree = old_tree;
    }
  }
};

// Noop by default
Markdown.prototype.debug = function () {
  var args = Array.prototype.slice.call( arguments);
  args.unshift(this.debug_indent);
  if (typeof print !== "undefined")
      print.apply( print, args );
  if (typeof console !== "undefined" && typeof console.log !== "undefined")
      console.log.apply( null, args );
}

Markdown.prototype.loop_re_over_block = function( re, block, cb ) {
  // Dont use /g regexps with this
  var m,
      b = block.valueOf();

  while ( b.length && (m = re.exec(b) ) != null) {
    b = b.substr( m[0].length );
    cb.call(this, m);
  }
  return b;
};

/**
 * Markdown.dialects
 *
 * Namespace of built-in dialects.
 **/
Markdown.dialects = {};

/**
 * Markdown.dialects.Gruber
 *
 * The default dialect that follows the rules set out by John Gruber's
 * markdown.pl as closely as possible. Well actually we follow the behaviour of
 * that script which in some places is not exactly what the syntax web page
 * says.
 **/
Markdown.dialects.Gruber = {
  block: {
    atxHeader: function atxHeader( block, next ) {
      var m = block.match( /^(#{1,6})\s*(.*?)\s*#*\s*(?:\n|$)/ );

      if ( !m ) return undefined;

      var header = [ "header", { level: m[ 1 ].length } ];
      Array.prototype.push.apply(header, this.processInline(m[ 2 ]));

      if ( m[0].length < block.length )
        next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );

      return [ header ];
    },

    setextHeader: function setextHeader( block, next ) {
      var m = block.match( /^(.*)\n([-=])\2\2+(?:\n|$)/ );

      if ( !m ) return undefined;

      var level = ( m[ 2 ] === "=" ) ? 1 : 2;
      var header = [ "header", { level : level }, m[ 1 ] ];

      if ( m[0].length < block.length )
        next.unshift( mk_block( block.substr( m[0].length ), block.trailing, block.lineNumber + 2 ) );

      return [ header ];
    },

    code: function code( block, next ) {
      // |    Foo
      // |bar
      // should be a code block followed by a paragraph. Fun
      //
      // There might also be adjacent code block to merge.

      var ret = [],
          re = /^(?: {0,3}\t| {4})(.*)\n?/,
          lines;

      // 4 spaces + content
      if ( !block.match( re ) ) return undefined;

      block_search:
      do {
        // Now pull out the rest of the lines
        var b = this.loop_re_over_block(
                  re, block.valueOf(), function( m ) { ret.push( m[1] ); } );

        if (b.length) {
          // Case alluded to in first comment. push it back on as a new block
          next.unshift( mk_block(b, block.trailing) );
          break block_search;
        }
        else if (next.length) {
          // Check the next block - it might be code too
          if ( !next[0].match( re ) ) break block_search;

          // Pull how how many blanks lines follow - minus two to account for .join
          ret.push ( block.trailing.replace(/[^\n]/g, '').substring(2) );

          block = next.shift();
        }
        else {
          break block_search;
        }
      } while (true);

      return [ [ "code_block", ret.join("\n") ] ];
    },

    horizRule: function horizRule( block, next ) {
      // this needs to find any hr in the block to handle abutting blocks
      var m = block.match( /^(?:([\s\S]*?)\n)?[ \t]*([-_*])(?:[ \t]*\2){2,}[ \t]*(?:\n([\s\S]*))?$/ );

      if ( !m ) {
        return undefined;
      }

      var jsonml = [ [ "hr" ] ];

      // if there's a leading abutting block, process it
      if ( m[ 1 ] ) {
        jsonml.unshift.apply( jsonml, this.processBlock( m[ 1 ], [] ) );
      }

      // if there's a trailing abutting block, stick it into next
      if ( m[ 3 ] ) {
        next.unshift( mk_block( m[ 3 ] ) );
      }

      return jsonml;
    },

    // There are two types of lists. Tight and loose. Tight lists have no whitespace
    // between the items (and result in text just in the <li>) and loose lists,
    // which have an empty line between list items, resulting in (one or more)
    // paragraphs inside the <li>.
    //
    // There are all sorts weird edge cases about the original markdown.pl's
    // handling of lists:
    //
    // * Nested lists are supposed to be indented by four chars per level. But
    //   if they aren't, you can get a nested list by indenting by less than
    //   four so long as the indent doesn't match an indent of an existing list
    //   item in the 'nest stack'.
    //
    // * The type of the list (bullet or number) is controlled just by the
    //    first item at the indent. Subsequent changes are ignored unless they
    //    are for nested lists
    //
    lists: (function( ) {
      // Use a closure to hide a few variables.
      var any_list = "[*+-]|\\d+\\.",
          bullet_list = /[*+-]/,
          number_list = /\d+\./,
          // Capture leading indent as it matters for determining nested lists.
          is_list_re = new RegExp( "^( {0,3})(" + any_list + ")[ \t]+" ),
          indent_re = "(?: {0,3}\\t| {4})";

      // TODO: Cache this regexp for certain depths.
      // Create a regexp suitable for matching an li for a given stack depth
      function regex_for_depth( depth ) {

        return new RegExp(
          // m[1] = indent, m[2] = list_type
          "(?:^(" + indent_re + "{0," + depth + "} {0,3})(" + any_list + ")\\s+)|" +
          // m[3] = cont
          "(^" + indent_re + "{0," + (depth-1) + "}[ ]{0,4})"
        );
      }
      function expand_tab( input ) {
        return input.replace( / {0,3}\t/g, "    " );
      }

      // Add inline content `inline` to `li`. inline comes from processInline
      // so is an array of content
      function add(li, loose, inline, nl) {
        if (loose) {
          li.push( [ "para" ].concat(inline) );
          return;
        }
        // Hmmm, should this be any block level element or just paras?
        var add_to = li[li.length -1] instanceof Array && li[li.length - 1][0] == "para"
                   ? li[li.length -1]
                   : li;

        // If there is already some content in this list, add the new line in
        if (nl && li.length > 1) inline.unshift(nl);

        for (var i=0; i < inline.length; i++) {
          var what = inline[i],
              is_str = typeof what == "string";
          if (is_str && add_to.length > 1 && typeof add_to[add_to.length-1] == "string" ) {
            add_to[ add_to.length-1 ] += what;
          }
          else {
            add_to.push( what );
          }
        }
      }

      // contained means have an indent greater than the current one. On
      // *every* line in the block
      function get_contained_blocks( depth, blocks ) {

        var re = new RegExp( "^(" + indent_re + "{" + depth + "}.*?\\n?)*$" ),
            replace = new RegExp("^" + indent_re + "{" + depth + "}", "gm"),
            ret = [];

        while ( blocks.length > 0 ) {
          if ( re.exec( blocks[0] ) ) {
            var b = blocks.shift(),
                // Now remove that indent
                x = b.replace( replace, "");

            ret.push( mk_block( x, b.trailing, b.lineNumber ) );
          }
          break;
        }
        return ret;
      }

      // passed to stack.forEach to turn list items up the stack into paras
      function paragraphify(s, i, stack) {
        var list = s.list;
        var last_li = list[list.length-1];

        if (last_li[1] instanceof Array && last_li[1][0] == "para") {
          return;
        }
        if (i+1 == stack.length) {
          // Last stack frame
          // Keep the same array, but replace the contents
          last_li.push( ["para"].concat( last_li.splice(1) ) );
        }
        else {
          var sublist = last_li.pop();
          last_li.push( ["para"].concat( last_li.splice(1) ), sublist );
        }
      }

      // The matcher function
      return function( block, next ) {
        var m = block.match( is_list_re );
        if ( !m ) return undefined;

        function make_list( m ) {
          var list = bullet_list.exec( m[2] )
                   ? ["bulletlist"]
                   : ["numberlist"];

          stack.push( { list: list, indent: m[1] } );
          return list;
        }


        var stack = [], // Stack of lists for nesting.
            list = make_list( m ),
            last_li,
            loose = false,
            ret = [ stack[0].list ],
            i;

        // Loop to search over block looking for inner block elements and loose lists
        loose_search:
        while( true ) {
          // Split into lines preserving new lines at end of line
          var lines = block.split( /(?=\n)/ );

          // We have to grab all lines for a li and call processInline on them
          // once as there are some inline things that can span lines.
          var li_accumulate = "";

          // Loop over the lines in this block looking for tight lists.
          tight_search:
          for (var line_no=0; line_no < lines.length; line_no++) {
            var nl = "",
                l = lines[line_no].replace(/^\n/, function(n) { nl = n; return ""; });

            // TODO: really should cache this
            var line_re = regex_for_depth( stack.length );

            m = l.match( line_re );
            //print( "line:", uneval(l), "\nline match:", uneval(m) );

            // We have a list item
            if ( m[1] !== undefined ) {
              // Process the previous list item, if any
              if ( li_accumulate.length ) {
                add( last_li, loose, this.processInline( li_accumulate ), nl );
                // Loose mode will have been dealt with. Reset it
                loose = false;
                li_accumulate = "";
              }

              m[1] = expand_tab( m[1] );
              var wanted_depth = Math.floor(m[1].length/4)+1;
              //print( "want:", wanted_depth, "stack:", stack.length);
              if ( wanted_depth > stack.length ) {
                // Deep enough for a nested list outright
                //print ( "new nested list" );
                list = make_list( m );
                last_li.push( list );
                last_li = list[1] = [ "listitem" ];
              }
              else {
                // We aren't deep enough to be strictly a new level. This is
                // where Md.pl goes nuts. If the indent matches a level in the
                // stack, put it there, else put it one deeper then the
                // wanted_depth deserves.
                var found = false;
                for (i = 0; i < stack.length; i++) {
                  if ( stack[ i ].indent != m[1] ) continue;
                  list = stack[ i ].list;
                  stack.splice( i+1 );
                  found = true;
                  break;
                }

                if (!found) {
                  //print("not found. l:", uneval(l));
                  wanted_depth++;
                  if (wanted_depth <= stack.length) {
                    stack.splice(wanted_depth);
                    //print("Desired depth now", wanted_depth, "stack:", stack.length);
                    list = stack[wanted_depth-1].list;
                    //print("list:", uneval(list) );
                  }
                  else {
                    //print ("made new stack for messy indent");
                    list = make_list(m);
                    last_li.push(list);
                  }
                }

                //print( uneval(list), "last", list === stack[stack.length-1].list );
                last_li = [ "listitem" ];
                list.push(last_li);
              } // end depth of shenegains
              nl = "";
            }

            // Add content
            if (l.length > m[0].length) {
              li_accumulate += nl + l.substr( m[0].length );
            }
          } // tight_search

          if ( li_accumulate.length ) {
            add( last_li, loose, this.processInline( li_accumulate ), nl );
            // Loose mode will have been dealt with. Reset it
            loose = false;
            li_accumulate = "";
          }

          // Look at the next block - we might have a loose list. Or an extra
          // paragraph for the current li
          var contained = get_contained_blocks( stack.length, next );

          // Deal with code blocks or properly nested lists
          if (contained.length > 0) {
            // Make sure all listitems up the stack are paragraphs
            forEach( stack, paragraphify, this);

            last_li.push.apply( last_li, this.toTree( contained, [] ) );
          }

          var next_block = next[0] && next[0].valueOf() || "";

          if ( next_block.match(is_list_re) || next_block.match( /^ / ) ) {
            block = next.shift();

            // Check for an HR following a list: features/lists/hr_abutting
            var hr = this.dialect.block.horizRule( block, next );

            if (hr) {
              ret.push.apply(ret, hr);
              break;
            }

            // Make sure all listitems up the stack are paragraphs
            forEach( stack, paragraphify, this);

            loose = true;
            continue loose_search;
          }
          break;
        } // loose_search

        return ret;
      };
    })(),

    blockquote: function blockquote( block, next ) {
      if ( !block.match( /^>/m ) )
        return undefined;

      var jsonml = [];

      // separate out the leading abutting block, if any
      if ( block[ 0 ] != ">" ) {
        var lines = block.split( /\n/ ),
            prev = [];

        // keep shifting lines until you find a crotchet
        while ( lines.length && lines[ 0 ][ 0 ] != ">" ) {
            prev.push( lines.shift() );
        }

        // reassemble!
        block = lines.join( "\n" );
        jsonml.push.apply( jsonml, this.processBlock( prev.join( "\n" ), [] ) );
      }

      // if the next block is also a blockquote merge it in
      while ( next.length && next[ 0 ][ 0 ] == ">" ) {
        var b = next.shift();
        block = new String(block + block.trailing + b);
        block.trailing = b.trailing;
      }

      // Strip off the leading "> " and re-process as a block.
      var input = block.replace( /^> ?/gm, '' ),
          old_tree = this.tree;
      jsonml.push( this.toTree( input, [ "blockquote" ] ) );

      return jsonml;
    },

    referenceDefn: function referenceDefn( block, next) {
      var re = /^\s*\[(.*?)\]:\s*(\S+)(?:\s+(?:(['"])(.*?)\3|\((.*?)\)))?\n?/;
      // interesting matches are [ , ref_id, url, , title, title ]

      if ( !block.match(re) )
        return undefined;

      // make an attribute node if it doesn't exist
      if ( !extract_attr( this.tree ) ) {
        this.tree.splice( 1, 0, {} );
      }

      var attrs = extract_attr( this.tree );

      // make a references hash if it doesn't exist
      if ( attrs.references === undefined ) {
        attrs.references = {};
      }

      var b = this.loop_re_over_block(re, block, function( m ) {

        if ( m[2] && m[2][0] == '<' && m[2][m[2].length-1] == '>' )
          m[2] = m[2].substring( 1, m[2].length - 1 );

        var ref = attrs.references[ m[1].toLowerCase() ] = {
          href: m[2]
        };

        if (m[4] !== undefined)
          ref.title = m[4];
        else if (m[5] !== undefined)
          ref.title = m[5];

      } );

      if (b.length)
        next.unshift( mk_block( b, block.trailing ) );

      return [];
    },

    para: function para( block, next ) {
      // everything's a para!
      return [ ["para"].concat( this.processInline( block ) ) ];
    }
  }
};

Markdown.dialects.Gruber.inline = {

    __oneElement__: function oneElement( text, patterns_or_re, previous_nodes ) {
      var m,
          res,
          lastIndex = 0;

      patterns_or_re = patterns_or_re || this.dialect.inline.__patterns__;
      var re = new RegExp( "([\\s\\S]*?)(" + (patterns_or_re.source || patterns_or_re) + ")" );

      m = re.exec( text );
      if (!m) {
        // Just boring text
        return [ text.length, text ];
      }
      else if ( m[1] ) {
        // Some un-interesting text matched. Return that first
        return [ m[1].length, m[1] ];
      }

      var res;
      if ( m[2] in this.dialect.inline ) {
        res = this.dialect.inline[ m[2] ].call(
                  this,
                  text.substr( m.index ), m, previous_nodes || [] );
      }
      // Default for now to make dev easier. just slurp special and output it.
      res = res || [ m[2].length, m[2] ];
      return res;
    },

    __call__: function inline( text, patterns ) {

      var out = [],
          res;

      function add(x) {
        //D:self.debug("  adding output", uneval(x));
        if (typeof x == "string" && typeof out[out.length-1] == "string")
          out[ out.length-1 ] += x;
        else
          out.push(x);
      }

      while ( text.length > 0 ) {
        res = this.dialect.inline.__oneElement__.call(this, text, patterns, out );
        text = text.substr( res.shift() );
        forEach(res, add )
      }

      return out;
    },

    // These characters are intersting elsewhere, so have rules for them so that
    // chunks of plain text blocks don't include them
    "]": function () {},
    "}": function () {},

    "\\": function escaped( text ) {
      // [ length of input processed, node/children to add... ]
      // Only esacape: \ ` * _ { } [ ] ( ) # * + - . !
      if ( text.match( /^\\[\\`\*_{}\[\]()#\+.!\-]/ ) )
        return [ 2, text[1] ];
      else
        // Not an esacpe
        return [ 1, "\\" ];
    },

    "![": function image( text ) {

      // Unlike images, alt text is plain text only. no other elements are
      // allowed in there

      // ![Alt text](/path/to/img.jpg "Optional title")
      //      1          2            3       4         <--- captures
      var m = text.match( /^!\[(.*?)\][ \t]*\([ \t]*(\S*)(?:[ \t]+(["'])(.*?)\3)?[ \t]*\)/ );

      if ( m ) {
        if ( m[2] && m[2][0] == '<' && m[2][m[2].length-1] == '>' )
          m[2] = m[2].substring( 1, m[2].length - 1 );

        m[2] = this.dialect.inline.__call__.call( this, m[2], /\\/ )[0];

        var attrs = { alt: m[1], href: m[2] || "" };
        if ( m[4] !== undefined)
          attrs.title = m[4];

        return [ m[0].length, [ "img", attrs ] ];
      }

      // ![Alt text][id]
      m = text.match( /^!\[(.*?)\][ \t]*\[(.*?)\]/ );

      if ( m ) {
        // We can't check if the reference is known here as it likely wont be
        // found till after. Check it in md tree->hmtl tree conversion
        return [ m[0].length, [ "img_ref", { alt: m[1], ref: m[2].toLowerCase(), original: m[0] } ] ];
      }

      // Just consume the '!['
      return [ 2, "![" ];
    },

    "[": function link( text ) {

      var orig = String(text);
      // Inline content is possible inside `link text`
      var res = Markdown.DialectHelpers.inline_until_char.call( this, text.substr(1), ']' );

      // No closing ']' found. Just consume the [
      if ( !res ) return [ 1, '[' ];

      var consumed = 1 + res[ 0 ],
          children = res[ 1 ],
          link,
          attrs;

      // At this point the first [...] has been parsed. See what follows to find
      // out which kind of link we are (reference or direct url)
      text = text.substr( consumed );

      // [link text](/path/to/img.jpg "Optional title")
      //                 1            2       3         <--- captures
      // This will capture up to the last paren in the block. We then pull
      // back based on if there a matching ones in the url
      //    ([here](/url/(test))
      // The parens have to be balanced
      var m = text.match( /^\s*\([ \t]*(\S+)(?:[ \t]+(["'])(.*?)\2)?[ \t]*\)/ );
      if ( m ) {
        var url = m[1];
        consumed += m[0].length;

        if ( url && url[0] == '<' && url[url.length-1] == '>' )
          url = url.substring( 1, url.length - 1 );

        // If there is a title we don't have to worry about parens in the url
        if ( !m[3] ) {
          var open_parens = 1; // One open that isn't in the capture
          for (var len = 0; len < url.length; len++) {
            switch ( url[len] ) {
            case '(':
              open_parens++;
              break;
            case ')':
              if ( --open_parens == 0) {
                consumed -= url.length - len;
                url = url.substring(0, len);
              }
              break;
            }
          }
        }

        // Process escapes only
        url = this.dialect.inline.__call__.call( this, url, /\\/ )[0];

        attrs = { href: url || "" };
        if ( m[3] !== undefined)
          attrs.title = m[3];

        link = [ "link", attrs ].concat( children );
        return [ consumed, link ];
      }

      // [Alt text][id]
      // [Alt text] [id]
      m = text.match( /^\s*\[(.*?)\]/ );

      if ( m ) {

        consumed += m[ 0 ].length;

        // [links][] uses links as its reference
        attrs = { ref: ( m[ 1 ] || String(children) ).toLowerCase(),  original: orig.substr( 0, consumed ) };

        link = [ "link_ref", attrs ].concat( children );

        // We can't check if the reference is known here as it likely wont be
        // found till after. Check it in md tree->hmtl tree conversion.
        // Store the original so that conversion can revert if the ref isn't found.
        return [ consumed, link ];
      }

      // [id]
      // Only if id is plain (no formatting.)
      if ( children.length == 1 && typeof children[0] == "string" ) {

        attrs = { ref: children[0].toLowerCase(),  original: orig.substr( 0, consumed ) };
        link = [ "link_ref", attrs, children[0] ];
        return [ consumed, link ];
      }

      // Just consume the '['
      return [ 1, "[" ];
    },


    "<": function autoLink( text ) {
      var m;

      if ( ( m = text.match( /^<(?:((https?|ftp|mailto):[^>]+)|(.*?@.*?\.[a-zA-Z]+))>/ ) ) != null ) {
        if ( m[3] ) {
          return [ m[0].length, [ "link", { href: "mailto:" + m[3] }, m[3] ] ];

        }
        else if ( m[2] == "mailto" ) {
          return [ m[0].length, [ "link", { href: m[1] }, m[1].substr("mailto:".length ) ] ];
        }
        else
          return [ m[0].length, [ "link", { href: m[1] }, m[1] ] ];
      }

      return [ 1, "<" ];
    },

    "`": function inlineCode( text ) {
      // Inline code block. as many backticks as you like to start it
      // Always skip over the opening ticks.
      var m = text.match( /(`+)(([\s\S]*?)\1)/ );

      if ( m && m[2] )
        return [ m[1].length + m[2].length, [ "inlinecode", m[3] ] ];
      else {
        // TODO: No matching end code found - warn!
        return [ 1, "`" ];
      }
    },

    "  \n": function lineBreak( text ) {
      return [ 3, [ "linebreak" ] ];
    }

};

// Meta Helper/generator method for em and strong handling
function strong_em( tag, md ) {

  var state_slot = tag + "_state",
      other_slot = tag == "strong" ? "em_state" : "strong_state";

  function CloseTag(len) {
    this.len_after = len;
    this.name = "close_" + md;
  }

  return function ( text, orig_match ) {

    if (this[state_slot][0] == md) {
      // Most recent em is of this type
      //D:this.debug("closing", md);
      this[state_slot].shift();

      // "Consume" everything to go back to the recrusion in the else-block below
      return[ text.length, new CloseTag(text.length-md.length) ];
    }
    else {
      // Store a clone of the em/strong states
      var other = this[other_slot].slice(),
          state = this[state_slot].slice();

      this[state_slot].unshift(md);

      //D:this.debug_indent += "  ";

      // Recurse
      var res = this.processInline( text.substr( md.length ) );
      //D:this.debug_indent = this.debug_indent.substr(2);

      var last = res[res.length - 1];

      //D:this.debug("processInline from", tag + ": ", uneval( res ) );

      var check = this[state_slot].shift();
      if (last instanceof CloseTag) {
        res.pop();
        // We matched! Huzzah.
        var consumed = text.length - last.len_after;
        return [ consumed, [ tag ].concat(res) ];
      }
      else {
        // Restore the state of the other kind. We might have mistakenly closed it.
        this[other_slot] = other;
        this[state_slot] = state;

        // We can't reuse the processed result as it could have wrong parsing contexts in it.
        return [ md.length, md ];
      }
    }
  }; // End returned function
}

Markdown.dialects.Gruber.inline["**"] = strong_em("strong", "**");
Markdown.dialects.Gruber.inline["__"] = strong_em("strong", "__");
Markdown.dialects.Gruber.inline["*"]  = strong_em("em", "*");
Markdown.dialects.Gruber.inline["_"]  = strong_em("em", "_");


// Build default order from insertion order.
Markdown.buildBlockOrder = function(d) {
  var ord = [];
  for ( var i in d ) {
    if ( i == "__order__" || i == "__call__" ) continue;
    ord.push( i );
  }
  d.__order__ = ord;
};

// Build patterns for inline matcher
Markdown.buildInlinePatterns = function(d) {
  var patterns = [];

  for ( var i in d ) {
    // __foo__ is reserved and not a pattern
    if ( i.match( /^__.*__$/) ) continue;
    var l = i.replace( /([\\.*+?|()\[\]{}])/g, "\\$1" )
             .replace( /\n/, "\\n" );
    patterns.push( i.length == 1 ? l : "(?:" + l + ")" );
  }

  patterns = patterns.join("|");
  d.__patterns__ = patterns;
  //print("patterns:", uneval( patterns ) );

  var fn = d.__call__;
  d.__call__ = function(text, pattern) {
    if (pattern != undefined) {
      return fn.call(this, text, pattern);
    }
    else
    {
      return fn.call(this, text, patterns);
    }
  };
};

Markdown.DialectHelpers = {};
Markdown.DialectHelpers.inline_until_char = function( text, want ) {
  var consumed = 0,
      nodes = [];

  while ( true ) {
    if ( text[ consumed ] == want ) {
      // Found the character we were looking for
      consumed++;
      return [ consumed, nodes ];
    }

    if ( consumed >= text.length ) {
      // No closing char found. Abort.
      return null;
    }

    res = this.dialect.inline.__oneElement__.call(this, text.substr( consumed ) );
    consumed += res[ 0 ];
    // Add any returned nodes.
    nodes.push.apply( nodes, res.slice( 1 ) );
  }
}

// Helper function to make sub-classing a dialect easier
Markdown.subclassDialect = function( d ) {
  function Block() {}
  Block.prototype = d.block;
  function Inline() {}
  Inline.prototype = d.inline;

  return { block: new Block(), inline: new Inline() };
};

Markdown.buildBlockOrder ( Markdown.dialects.Gruber.block );
Markdown.buildInlinePatterns( Markdown.dialects.Gruber.inline );

Markdown.dialects.Maruku = Markdown.subclassDialect( Markdown.dialects.Gruber );

Markdown.dialects.Maruku.processMetaHash = function processMetaHash( meta_string ) {
  var meta = split_meta_hash( meta_string ),
      attr = {};

  for ( var i = 0; i < meta.length; ++i ) {
    // id: #foo
    if ( /^#/.test( meta[ i ] ) ) {
      attr.id = meta[ i ].substring( 1 );
    }
    // class: .foo
    else if ( /^\./.test( meta[ i ] ) ) {
      // if class already exists, append the new one
      if ( attr['class'] ) {
        attr['class'] = attr['class'] + meta[ i ].replace( /./, " " );
      }
      else {
        attr['class'] = meta[ i ].substring( 1 );
      }
    }
    // attribute: foo=bar
    else if ( /\=/.test( meta[ i ] ) ) {
      var s = meta[ i ].split( /\=/ );
      attr[ s[ 0 ] ] = s[ 1 ];
    }
  }

  return attr;
}

function split_meta_hash( meta_string ) {
  var meta = meta_string.split( "" ),
      parts = [ "" ],
      in_quotes = false;

  while ( meta.length ) {
    var letter = meta.shift();
    switch ( letter ) {
      case " " :
        // if we're in a quoted section, keep it
        if ( in_quotes ) {
          parts[ parts.length - 1 ] += letter;
        }
        // otherwise make a new part
        else {
          parts.push( "" );
        }
        break;
      case "'" :
      case '"' :
        // reverse the quotes and move straight on
        in_quotes = !in_quotes;
        break;
      case "\\" :
        // shift off the next letter to be used straight away.
        // it was escaped so we'll keep it whatever it is
        letter = meta.shift();
      default :
        parts[ parts.length - 1 ] += letter;
        break;
    }
  }

  return parts;
}

Markdown.dialects.Maruku.block.document_meta = function document_meta( block, next ) {
  // we're only interested in the first block
  if ( block.lineNumber > 1 ) return undefined;

  // document_meta blocks consist of one or more lines of `Key: Value\n`
  if ( ! block.match( /^(?:\w+:.*\n)*\w+:.*$/ ) ) return undefined;

  // make an attribute node if it doesn't exist
  if ( !extract_attr( this.tree ) ) {
    this.tree.splice( 1, 0, {} );
  }

  var pairs = block.split( /\n/ );
  for ( p in pairs ) {
    var m = pairs[ p ].match( /(\w+):\s*(.*)$/ ),
        key = m[ 1 ].toLowerCase(),
        value = m[ 2 ];

    this.tree[ 1 ][ key ] = value;
  }

  // document_meta produces no content!
  return [];
};

Markdown.dialects.Maruku.block.block_meta = function block_meta( block, next ) {
  // check if the last line of the block is an meta hash
  var m = block.match( /(^|\n) {0,3}\{:\s*((?:\\\}|[^\}])*)\s*\}$/ );
  if ( !m ) return undefined;

  // process the meta hash
  var attr = this.dialect.processMetaHash( m[ 2 ] );

  var hash;

  // if we matched ^ then we need to apply meta to the previous block
  if ( m[ 1 ] === "" ) {
    var node = this.tree[ this.tree.length - 1 ];
    hash = extract_attr( node );

    // if the node is a string (rather than JsonML), bail
    if ( typeof node === "string" ) return undefined;

    // create the attribute hash if it doesn't exist
    if ( !hash ) {
      hash = {};
      node.splice( 1, 0, hash );
    }

    // add the attributes in
    for ( a in attr ) {
      hash[ a ] = attr[ a ];
    }

    // return nothing so the meta hash is removed
    return [];
  }

  // pull the meta hash off the block and process what's left
  var b = block.replace( /\n.*$/, "" ),
      result = this.processBlock( b, [] );

  // get or make the attributes hash
  hash = extract_attr( result[ 0 ] );
  if ( !hash ) {
    hash = {};
    result[ 0 ].splice( 1, 0, hash );
  }

  // attach the attributes to the block
  for ( a in attr ) {
    hash[ a ] = attr[ a ];
  }

  return result;
};

Markdown.dialects.Maruku.block.definition_list = function definition_list( block, next ) {
  // one or more terms followed by one or more definitions, in a single block
  var tight = /^((?:[^\s:].*\n)+):\s+([\s\S]+)$/,
      list = [ "dl" ],
      i;

  // see if we're dealing with a tight or loose block
  if ( ( m = block.match( tight ) ) ) {
    // pull subsequent tight DL blocks out of `next`
    var blocks = [ block ];
    while ( next.length && tight.exec( next[ 0 ] ) ) {
      blocks.push( next.shift() );
    }

    for ( var b = 0; b < blocks.length; ++b ) {
      var m = blocks[ b ].match( tight ),
          terms = m[ 1 ].replace( /\n$/, "" ).split( /\n/ ),
          defns = m[ 2 ].split( /\n:\s+/ );

      // print( uneval( m ) );

      for ( i = 0; i < terms.length; ++i ) {
        list.push( [ "dt", terms[ i ] ] );
      }

      for ( i = 0; i < defns.length; ++i ) {
        // run inline processing over the definition
        list.push( [ "dd" ].concat( this.processInline( defns[ i ].replace( /(\n)\s+/, "$1" ) ) ) );
      }
    }
  }
  else {
    return undefined;
  }

  return [ list ];
};

Markdown.dialects.Maruku.inline[ "{:" ] = function inline_meta( text, matches, out ) {
  if ( !out.length ) {
    return [ 2, "{:" ];
  }

  // get the preceeding element
  var before = out[ out.length - 1 ];

  if ( typeof before === "string" ) {
    return [ 2, "{:" ];
  }

  // match a meta hash
  var m = text.match( /^\{:\s*((?:\\\}|[^\}])*)\s*\}/ );

  // no match, false alarm
  if ( !m ) {
    return [ 2, "{:" ];
  }

  // attach the attributes to the preceeding element
  var meta = this.dialect.processMetaHash( m[ 1 ] ),
      attr = extract_attr( before );

  if ( !attr ) {
    attr = {};
    before.splice( 1, 0, attr );
  }

  for ( var k in meta ) {
    attr[ k ] = meta[ k ];
  }

  // cut out the string and replace it with nothing
  return [ m[ 0 ].length, "" ];
};

Markdown.buildBlockOrder ( Markdown.dialects.Maruku.block );
Markdown.buildInlinePatterns( Markdown.dialects.Maruku.inline );

var isArray = Array.isArray || function(obj) {
  return Object.prototype.toString.call(obj) == '[object Array]';
};

var forEach;
// Don't mess with Array.prototype. Its not friendly
if ( Array.prototype.forEach ) {
  forEach = function( arr, cb, thisp ) {
    return arr.forEach( cb, thisp );
  };
}
else {
  forEach = function(arr, cb, thisp) {
    for (var i = 0; i < arr.length; i++) {
      cb.call(thisp || arr, arr[i], i, arr);
    }
  }
}

function extract_attr( jsonml ) {
  return isArray(jsonml)
      && jsonml.length > 1
      && typeof jsonml[ 1 ] === "object"
      && !( isArray(jsonml[ 1 ]) )
      ? jsonml[ 1 ]
      : undefined;
}



/**
 *  renderJsonML( jsonml[, options] ) -> String
 *  - jsonml (Array): JsonML array to render to XML
 *  - options (Object): options
 *
 *  Converts the given JsonML into well-formed XML.
 *
 *  The options currently understood are:
 *
 *  - root (Boolean): wether or not the root node should be included in the
 *    output, or just its children. The default `false` is to not include the
 *    root itself.
 */
expose.renderJsonML = function( jsonml, options ) {
  options = options || {};
  // include the root element in the rendered output?
  options.root = options.root || false;

  var content = [];

  if ( options.root ) {
    content.push( render_tree( jsonml ) );
  }
  else {
    jsonml.shift(); // get rid of the tag
    if ( jsonml.length && typeof jsonml[ 0 ] === "object" && !( jsonml[ 0 ] instanceof Array ) ) {
      jsonml.shift(); // get rid of the attributes
    }

    while ( jsonml.length ) {
      content.push( render_tree( jsonml.shift() ) );
    }
  }

  return content.join( "\n\n" );
};

function escapeHTML( text ) {
  return text.replace( /&/g, "&amp;" )
             .replace( /</g, "&lt;" )
             .replace( />/g, "&gt;" )
             .replace( /"/g, "&quot;" )
             .replace( /'/g, "&#39;" );
}

function render_tree( jsonml ) {
  // basic case
  if ( typeof jsonml === "string" ) {
    return escapeHTML( jsonml );
  }

  var tag = jsonml.shift(),
      attributes = {},
      content = [];

  if ( jsonml.length && typeof jsonml[ 0 ] === "object" && !( jsonml[ 0 ] instanceof Array ) ) {
    attributes = jsonml.shift();
  }

  while ( jsonml.length ) {
    content.push( arguments.callee( jsonml.shift() ) );
  }

  var tag_attrs = "";
  for ( var a in attributes ) {
    tag_attrs += " " + a + '="' + escapeHTML( attributes[ a ] ) + '"';
  }

  // be careful about adding whitespace here for inline elements
  if ( tag == "img" || tag == "br" || tag == "hr" ) {
    return "<"+ tag + tag_attrs + "/>";
  }
  else {
    return "<"+ tag + tag_attrs + ">" + content.join( "" ) + "</" + tag + ">";
  }
}

function convert_tree_to_html( tree, references, options ) {
  var i;
  options = options || {};

  // shallow clone
  var jsonml = tree.slice( 0 );

  if (typeof options.preprocessTreeNode === "function") {
      jsonml = options.preprocessTreeNode(jsonml, references);
  }

  // Clone attributes if they exist
  var attrs = extract_attr( jsonml );
  if ( attrs ) {
    jsonml[ 1 ] = {};
    for ( i in attrs ) {
      jsonml[ 1 ][ i ] = attrs[ i ];
    }
    attrs = jsonml[ 1 ];
  }

  // basic case
  if ( typeof jsonml === "string" ) {
    return jsonml;
  }

  // convert this node
  switch ( jsonml[ 0 ] ) {
    case "header":
      jsonml[ 0 ] = "h" + jsonml[ 1 ].level;
      delete jsonml[ 1 ].level;
      break;
    case "bulletlist":
      jsonml[ 0 ] = "ul";
      break;
    case "numberlist":
      jsonml[ 0 ] = "ol";
      break;
    case "listitem":
      jsonml[ 0 ] = "li";
      break;
    case "para":
      jsonml[ 0 ] = "p";
      break;
    case "markdown":
      jsonml[ 0 ] = "html";
      if ( attrs ) delete attrs.references;
      break;
    case "code_block":
      jsonml[ 0 ] = "pre";
      i = attrs ? 2 : 1;
      var code = [ "code" ];
      code.push.apply( code, jsonml.splice( i ) );
      jsonml[ i ] = code;
      break;
    case "inlinecode":
      jsonml[ 0 ] = "code";
      break;
    case "img":
      jsonml[ 1 ].src = jsonml[ 1 ].href;
      delete jsonml[ 1 ].href;
      break;
    case "linebreak":
      jsonml[ 0 ] = "br";
    break;
    case "link":
      jsonml[ 0 ] = "a";
      break;
    case "link_ref":
      jsonml[ 0 ] = "a";

      // grab this ref and clean up the attribute node
      var ref = references[ attrs.ref ];

      // if the reference exists, make the link
      if ( ref ) {
        delete attrs.ref;

        // add in the href and title, if present
        attrs.href = ref.href;
        if ( ref.title ) {
          attrs.title = ref.title;
        }

        // get rid of the unneeded original text
        delete attrs.original;
      }
      // the reference doesn't exist, so revert to plain text
      else {
        return attrs.original;
      }
      break;
    case "img_ref":
      jsonml[ 0 ] = "img";

      // grab this ref and clean up the attribute node
      var ref = references[ attrs.ref ];

      // if the reference exists, make the link
      if ( ref ) {
        delete attrs.ref;

        // add in the href and title, if present
        attrs.src = ref.href;
        if ( ref.title ) {
          attrs.title = ref.title;
        }

        // get rid of the unneeded original text
        delete attrs.original;
      }
      // the reference doesn't exist, so revert to plain text
      else {
        return attrs.original;
      }
      break;
  }

  // convert all the children
  i = 1;

  // deal with the attribute node, if it exists
  if ( attrs ) {
    // if there are keys, skip over it
    for ( var key in jsonml[ 1 ] ) {
      i = 2;
    }
    // if there aren't, remove it
    if ( i === 1 ) {
      jsonml.splice( i, 1 );
    }
  }

  for ( ; i < jsonml.length; ++i ) {
    jsonml[ i ] = arguments.callee( jsonml[ i ], references, options );
  }

  return jsonml;
}


// merges adjacent text nodes into a single node
function merge_text_nodes( jsonml ) {
  // skip the tag name and attribute hash
  var i = extract_attr( jsonml ) ? 2 : 1;

  while ( i < jsonml.length ) {
    // if it's a string check the next item too
    if ( typeof jsonml[ i ] === "string" ) {
      if ( i + 1 < jsonml.length && typeof jsonml[ i + 1 ] === "string" ) {
        // merge the second string into the first and remove it
        jsonml[ i ] += jsonml.splice( i + 1, 1 )[ 0 ];
      }
      else {
        ++i;
      }
    }
    // if it's not a string recurse
    else {
      arguments.callee( jsonml[ i ] );
      ++i;
    }
  }
}

} )( (function() {
  if ( typeof exports === "undefined" ) {
    window.markdown = {};
    return window.markdown;
  }
  else {
    return exports;
  }
} )() );

define("markdown", (function (global) {
    return function () {
        var ret, fn;
        return ret || global.markdown;
    };
}(this)));

/*global define: false */
/**
 * Inherit the prototype methods from one constructor into another.
 *
 * Usage:
 * function ParentClass(a, b) { }
 * ParentClass.prototype.foo = function(a) { }
 *
 * function ChildClass(a, b, c) {
 *   goog.base(this, a, b);
 * }
 *
 * inherit(ChildClass, ParentClass);
 *
 * var child = new ChildClass('a', 'b', 'see');
 * child.foo(); // works
 *
 * In addition, a superclass' implementation of a method can be invoked
 * as follows:
 *
 * ChildClass.prototype.foo = function(a) {
 *   ChildClass.superClass.foo.call(this, a);
 *   // other code
 * };
 *
 * @param {Function} Child Child class.
 * @param {Function} Parent Parent class.
 */
define('common/inherit',[],function() {
  return function inherit(Child, Parent) {
    function F() {}
    F.prototype = Parent.prototype;
    Child.prototype = new F();
    Child.superClass = Parent.prototype;
    Child.prototype.constructor = Child;
  };
});

/*global define, $ */

define('common/controllers/interactive-component',['require','common/controllers/interactive-metadata','common/validator'],function (require) {

  var metadata  = require('common/controllers/interactive-metadata'),
      validator = require('common/validator');

  /**
   * Basic class for all interactive components.
   *
   * @constructor
   * @param {string} type Component type, should match definition in interactive metadata.
   * @param {Object} component Component JSON definition.
   * @param {ScriptingAPI} scriptingAPI
   */
  function InteractiveComponent(type, component, scriptingAPI) {
    var onClickFunction;

    /**
     * Validated component definition.
     * @type {Object}
     */
    this.component = validator.validateCompleteness(metadata[type], component);
    /**
     * The most outer element. Subclasses should append content to this element.
     * @type {jQuery}
     */
    this.$element = $('<div>').attr("id", component.id).addClass("component");

    // Optionally setup dimensions of the most outer component.
    // Only when metadata and component JSON specifies width and height
    // properties.
    if (this.component.width) {
      this.$element.css("width", this.component.width);
    }
    if (this.component.height) {
      this.$element.css("height", this.component.height);
    }

    // optionally add onClick handler. If components such as buttons and sliders
    // start inheriting from InteractiveComponent, we should think further on this.
    if (this.component.onClick) {
      if (typeof this.component.onClick !== "function") {
        // Create function from the string or array of strings.
        onClickFunction = scriptingAPI.makeFunctionInScriptContext(this.component.onClick);
      } else {
        // Just assign ready function.
        onClickFunction = this.component.onClick;
      }
      this.$element.on("click", onClickFunction);
      // Also add a special class indicating that this text node is a clickable.
      this.$element.addClass("clickable");
    }

    // optionally add new css classes
    if (this.component.classes && this.component.classes.length) {
      this.$element.addClass(this.component.classes.join(" "))
    }

    // optionally add tooltip as title text
    if (this.component.tooltip) {
      this.$element.attr("title", this.component.tooltip)
    }
  }

  /**
   * @return {jQuery} The most outer element.
   */
  InteractiveComponent.prototype.getViewContainer = function() {
    return this.$element;
  };

  /**
   * @return {Object} Serialized component definition.
   */
  InteractiveComponent.prototype.serialize = function() {
    return this.component;
  };

  return InteractiveComponent;
});

/*global define, $ */

define('common/controllers/text-controller',['require','markdown','common/inherit','common/controllers/interactive-component'],function (require) {

  var markdown             = require('markdown'),
      inherit              = require('common/inherit'),
      InteractiveComponent = require('common/controllers/interactive-component');

  /**
   * Text controller.
   * It supports markdown (syntax: http://daringfireball.net/projects/markdown/syntax).
   *
   * @constructor
   * @extends InteractiveComponent
   * @param {Object} component Component JSON definition.
   * @param {ScriptingAPI} scriptingAPI
   */
  function TextController(component, scriptingAPI) {
    var text, $element, content, html,
        openInNewWindow = 'class="opens-in-new-window" target="blank"';
    // Call super constructor.
    InteractiveComponent.call(this, "text", component, scriptingAPI);
    // Setup custom class.
    this.$element.addClass("interactive-text");
    // Ensure that common typography for markdown-generated content is used.
    this.$element.addClass("markdown-typography");
    // Use markdown to parse the 'text' content.
    text = $.isArray(this.component.text) ? this.component.text : [this.component.text];
    $element = this.$element;
    content = "";
    $.each(text, function (idx, val) {
      content += val + "\n";
    });
    html = markdown.toHTML(content);
    html = html.replace(/<a(.*?)>/g, "<a$1 " + openInNewWindow + ">");
    $element.append(html);
  }
  inherit(TextController, InteractiveComponent);

  return TextController;
});

/*global Lab, define, $ */

define('common/controllers/image-controller',['require','lab.config','common/inherit','common/controllers/interactive-component'],function (require) {

  var labConfig            = require('lab.config'),
      inherit              = require('common/inherit'),
      InteractiveComponent = require('common/controllers/interactive-component'),

      externalUrl  = /^https?:\/\//i,
      // any url starting with "{resources}/..." will be directed to public/resources
      resourcesUrl = /^{resources}\//i;

  /**
   * Image controller.
   *
   * @constructor
   * @extends InteractiveComponent
   * @param {Object} component Component JSON definition.
   * @param {ScriptingAPI} scriptingAPI
   * @param {InteractiveController} controller
   */
  function ImageController(component, scriptingAPI, controller) {
    var root = typeof Lab !== "undefined" ? Lab.config.actualRoot : "";

    // Call super constructor.
    InteractiveComponent.call(this, "image", component, scriptingAPI);

    /** @private */
    this._controller = controller;
    /** @private */
    this._$img = $("<img>");
    /** @private */
    this._externalUrl = externalUrl.test(this.component.src);
    this._resourcesUrl = resourcesUrl.test(this.component.src);

    if (this._externalUrl) {
      // If URL is external, we can setup it just once.
      this._$img.attr("src", this.component.src);
    } else if (this._resourcesUrl) {
      this._$img.attr("src", this.component.src.replace(resourcesUrl, root + "/resources/"));
    }

    // When a dimension is different from "auto",
    // ensure that image fits its parent container.
    if (this.component.width !== "auto") {
      this._$img.css("width", "100%");
    }
    if (this.component.height !== "auto") {
      this._$img.css("height", "100%");
    }
    this._$img.appendTo(this.$element);
  }
  inherit(ImageController, InteractiveComponent);

  /**
   * Implements optional callback supported by Interactive Controller.
   */
  ImageController.prototype.modelLoadedCallback = function() {
    var src, modelUrl;
    // It's necessary to update path only if its relative (as it's relative to
    // model file).
    if (!this._externalUrl) {
      src = this.component.src;
      // Relative path should be relative to the model definition file, to
      // follow pattern used for images inside model container.
      // TODO: not sure if it makes sense for the Interactive images. When web
      // application is ready, probably it will be changed anyway.
      modelUrl = this._controller.getModelController().modelUrl;
      // Remove <model-name>.json from url.
      modelUrl = modelUrl.slice(0, modelUrl.lastIndexOf("/") + 1);
      src = labConfig.actualRoot + modelUrl + src;
      this._$img.attr("src", src);
    }
  };

  return ImageController;
});

/*global define, $, model */

define('common/controllers/radio-controller',['common/controllers/interactive-metadata','common/validator'],function () {

  var metadata  = require('common/controllers/interactive-metadata'),
      validator = require('common/validator');

  return function RadioController(component, scriptingAPI, interactivesController) {
        // Public API.
    var controller,
        // DOM elements.
        $div, $span,
        // Options definitions from component JSON definition.
        options,
        // List of jQuery objects wrapping <input type="radio"> elements.
        $options = [],
        // List of jQuery objects wrapping <div> used for radio styling.
        $fakeCheckables = [];

    // Updates radio using model property. Used in modelLoadedCallback.
    // Make sure that this function is only called when:
    // a) model is loaded,
    // b) radio is bound to some property.
    function updateRadio() {
      var value = model.get(component.property),
          i, len;

      for (i = 0, len = options.length; i < len; i++) {
        if (options[i].value === value) {
          $options[i].attr("checked", true);
          $fakeCheckables[i].addClass('checked');
        } else {
          $options[i].removeAttr("checked");
          $fakeCheckables[i].removeClass('checked');
        }
      }
    }

    function customClickEvent (e) {
      var $clickedParent = $(this).closest('span'),
          $input = $clickedParent.find('input'),
          $fakeCheckable = $clickedParent.find('.fakeCheckable'),
          i, len;

      e.preventDefault();

      if ($input.attr("disabled") !== undefined) {
        // Do nothing when option is disabled.
        return;
      }

      for (i = 0, len = $options.length; i < len; i++) {
        $options[i].removeAttr('checked');
        $fakeCheckables[i].removeClass('checked');
      }

      if ($input.attr('checked') !== undefined) {
        $input.removeAttr('checked');
        $fakeCheckable.removeClass('checked');
      } else {
        $input.attr('checked', 'checked');
        $fakeCheckable.addClass('checked');
      }

      // Trigger change event!
      $input.trigger('change');
    }

    function initialize() {
      var $option, $fakeCheckable, $label,
          option, i, len;

      // Validate component definition, use validated copy of the properties.
      component = validator.validateCompleteness(metadata.radio, component);
      // Validate radio options too.
      options = component.options;
      for (i = 0, len = options.length; i < len; i++) {
        options[i] = validator.validateCompleteness(metadata.radioOption, options[i]);
      }

      // Create HTML elements.
      $div = $('<div>').attr('id', component.id);
      $div.addClass("interactive-radio");
      // Each interactive component has to have class "component".
      $div.addClass("component");
      // Add class defining component orientation - "horizontal" or "vertical".
      $div.addClass(component.orientation);

      if (component.label) {
        $label = $("<span>").text(component.label);
        $label.addClass("label");
        $label.addClass(component.labelOn === "top" ? "on-top" : "on-left");
        $div.append($label);
      }

      // Create options (<input type="radio">)
      for (i = 0, len = options.length; i < len; i++) {
        option = options[i];
        $option = $('<input>')
          .attr('type', "radio")
          .attr('name', component.id)
          .attr('tabindex', interactivesController.getNextTabIndex())
          .attr('id', component.id + '-' + i);
        $options.push($option);

        $label = $('<label>')
          .attr("for", component.id + '-' + i)
          .text(option.text);

        $fakeCheckable = $('<div class="fakeCheckable">');
        $fakeCheckables.push($fakeCheckable);

        if (option.disabled) {
          $option.attr("disabled", option.disabled);
          $fakeCheckable.addClass("disabled");
        }
        if (option.selected) {
          $option.attr("checked", option.selected);
          $fakeCheckable.addClass("checked");
        }
        $span = $('<span>')
          .addClass('option')
          .append($option)
          .append($fakeCheckable)
          .append($label);
        $div.append($span);

        // Ensure that custom div (used for styling) is clickable.
        $fakeCheckable.on('touchstart click', customClickEvent);
        // Label also requires custom event handler to ensure that click updates
        // fake clickable element too.
        $label.on('touchstart click', customClickEvent);

        $option.change((function(option) {
          return function() {
            if (option.action){
              scriptingAPI.makeFunctionInScriptContext(option.action)();
            } else if (option.loadModel){
              model.stop();
              interactivesController.loadModel(option.loadModel);
            } else if (option.value !== undefined) {
              model.set(component.property, option.value);
            }
          };
        })(option));
      }
    }

    // Public API.
    controller = {
      modelLoadedCallback: function () {
        // Connect radio with model's property if its name is defined.
        if (component.property !== undefined) {
          // Register listener for property.
          model.addPropertiesListener([component.property], updateRadio);
          // Perform initial radio setup.
          updateRadio();
        }
      },

      // Returns view container.
      getViewContainer: function () {
        return $div;
      },

      // Returns serialized component definition.
      serialize: function () {
        var i, len;
        if (component.property === undefined) {
          // When property binding is not defined, we need to keep track
          // which option is currently selected.
          for (i = 0, len = options.length; i < len; i++) {
            if ($options[i].attr("checked")) {
              options[i].selected = true;
            } else {
              delete options[i].selected;
            }
          }
        }
        // Note that 'options' array above is a reference to component.options array.
        // Every thing is updated, return a copy.
        return $.extend(true, {}, component);
      }
    };

    initialize();

    // Return Public API object.
    return controller;
  };
});

/*global define, $, model*/

define('common/controllers/slider-controller',['common/controllers/interactive-metadata','common/validator'],function () {

  var metadata  = require('common/controllers/interactive-metadata'),
      validator = require('common/validator');

  return function SliderController(component, scriptingAPI, interactivesController) {
    var min, max, steps, propertyName,
        action, initialValue,
        title, labels, displayValue,
        i, label,
        // View elements.
        $elem,
        $title,
        $label,
        $slider,
        $sliderHandle,
        $container,
        // Public API object.
        controller,

        // Updates slider using model property. Used in modelLoadedCallback.
        // Make sure that this function is only called when:
        // a) model is loaded,
        // b) slider is bound to some property.
        updateSlider = function  () {
          var value = model.get(propertyName);
          $slider.slider('value', value);
          if (displayValue) {
            $sliderHandle.text(displayValue(value));
          }
        };

    // Public API.
    controller = {
      // This callback should be trigger when model is loaded.
      modelLoadedCallback: function () {
        if (propertyName) {
          model.addPropertiesListener([propertyName], updateSlider);
        }

        if (initialValue !== undefined && initialValue !== null) {
          // Make sure to call the action with the startup value of slider. (The script action may
          // manipulate the model, so we have to make sure it runs after the model loads.)
          if (action) {
            $slider.slider('value', initialValue);
            action(initialValue);
            if (displayValue) {
              $sliderHandle.text(displayValue(initialValue));
            }
          }
        } else if (propertyName) {
          updateSlider();
        }
      },

      // Returns view container (div).
      getViewContainer: function () {
        return $elem;
      },

      resize: function () {
        var remainingHeight, emSize;
        if (component.height !== "auto") {
          // Height calculation is more complex when height is different from
          // "auto". Calculate dynamically available height for slider itself.
          // Note that component.height refers to the height of the *whole*
          // component!
          remainingHeight = $elem.height() - $title.outerHeight(true);
          if ($label !== undefined) {
            remainingHeight -= $label.outerHeight(true);
          }
          $container.css("height", remainingHeight);
          $slider.css("top", 0.5 * remainingHeight);
          // Handle also requires dynamic styling.
          emSize = parseFloat($sliderHandle.css("font-size"));
          $sliderHandle.css("height", remainingHeight + emSize * 0.4);
          $sliderHandle.css("top", -0.5 * remainingHeight - emSize * 0.4);
        }
      },

      // Returns serialized component definition.
      serialize: function () {
        var result = $.extend(true, {}, component);

        if (!propertyName) {
          // No property binding. Just action script.
          // Update "initialValue" to represent current
          // value of the slider.
          result.initialValue = $slider.slider('value');
        }

        return result;
      }
    };

    //
    // Initialize.
    //
    // Validate component definition, use validated copy of the properties.
    component = validator.validateCompleteness(metadata.slider, component);
    min = component.min;
    max = component.max;
    steps = component.steps;
    action = component.action;
    propertyName = component.property;
    initialValue = component.initialValue;
    title = component.title;
    labels = component.labels;
    displayValue = component.displayValue;

    // Setup view.
    if (min === undefined) min = 0;
    if (max === undefined) max = 10;
    if (steps === undefined) steps = 10;

    $title = $('<p class="title">' + title + '</p>');
    // we pick up the SVG slider component CSS if we use the generic class name 'slider'
    $container = $('<div class="container">');
    $slider = $('<div class="html-slider">').attr('id', component.id);
    $slider.appendTo($container);

    $slider.slider({
      min: min,
      max: max,
      step: (max - min) / steps
    });

    $sliderHandle = $slider.find(".ui-slider-handle");

    $sliderHandle.attr('tabindex', interactivesController.getNextTabIndex());

    $elem = $('<div class="interactive-slider">')
              .append($title)
              .append($container);
    // Each interactive component has to have class "component".
    $elem.addClass("component");

    for (i = 0; i < labels.length; i++) {
      label = labels[i];
      $label = $('<p class="label">' + label.label + '</p>');
      $label.css('left', (label.value-min) / (max-min) * 100 + '%');
      $container.append($label);
    }

    // Bind action or/and property, process other options.
    if (action) {
      // The 'action' property is a source of a function which assumes we pass it a parameter
      // called 'value'.
      action = scriptingAPI.makeFunctionInScriptContext('value', action);
      $slider.bind('slide', function(event, ui) {
        action(ui.value);
        if (displayValue) {
          $sliderHandle.text(displayValue(ui.value));
        }
      });
    }

    if (propertyName) {
      $slider.bind('slide', function(event, ui) {
        // Just ignore slide events that occur before the model is loaded.
        var obj = {};
        obj[propertyName] = ui.value;
        if (model) model.set(obj);
        if (displayValue) {
          $sliderHandle.text(displayValue(ui.value));
        }
      });
    }

    if (displayValue) {
      displayValue = scriptingAPI.makeFunctionInScriptContext('value', displayValue);
    }

    // Apply custom width and height settings.
    // Also not that we set dimensions of the most outer container, not slider.
    // Slider itself will always follow dimensions of container DIV.
    // We have to do it that way to ensure that labels refer correct dimensions.
    $elem.css({
      "width": component.width,
      "height": component.height
    });
    if (component.width === "auto") {
      // Ensure that min width is 12em, when width is set to "auto".
      // Prevent from situation when all sliders with short labels have
      // different widths, what looks distracting.
      $elem.css("min-width", "12em");
    }
    // Call resize function to support complex resizing when height is different from "auto".
    controller.resize();

    // Return Public API object.
    return controller;
  };
});

/*global require, define, $, model */

define('common/controllers/pulldown-controller',['common/controllers/interactive-metadata','common/validator','common/jquery-plugins'],function () {

  var metadata  = require('common/controllers/interactive-metadata'),
      validator = require('common/validator');
      require('common/jquery-plugins');

  return function PulldownController(component, scriptingAPI, interactivesController) {
        // Public API.
    var controller,
        // DOM elements.
        $wrapper, $pulldown, $option,
        // Options definitions from component JSON definition.
        options,
        // List of jQuery objects wrapping <select> elements.
        $options = [],
        // Indicates which change event are caused by the user and which are
        // caused by select box update after property change.
        ignoreChangeEvent = false;

    // Updates pulldown using model property. Used in modelLoadedCallback.
    // Make sure that this function is only called when:
    // a) model is loaded,
    // b) pulldown is bound to some property.
    function updatePulldown() {
      // Set flag indicating that change event should be ignored by our own
      // change listener. It prevents from infinite loop like: pulldown update
      // => property update => pulldown update => ...
      // It's necessary as selectOption() call below will trigger change event
      // of original select. It's used by selectBoxIt to update its view.
      ignoreChangeEvent = true;
      // Retrieve all of the SelectBoxIt methods and call selectOption(). Note
      // that we have to call .toString() as numeric values are interpreted as
      // option index by selectBoxIt. See:
      // http://gregfranko.com/jquery.selectBoxIt.js/#Methods
      $pulldown.data("selectBox-selectBoxIt").selectOption(model.get(component.property).toString());
    }

    function initialize() {
      var parent = interactivesController.interactiveContainer,
          $label, ulWidth, arrowWidth, boxWidth,
          i, len, option;

      // Validate component definition, use validated copy of the properties.
      component = validator.validateCompleteness(metadata.pulldown, component);
      // Validate pulldown options too.
      options = component.options;
      for (i = 0, len = options.length; i < len; i++) {
        options[i] = validator.validateCompleteness(metadata.pulldownOption, options[i]);
      }

      $pulldown = $('<select>');

      for (i = 0, len = options.length; i < len; i++) {
        option = options[i];
        $option = $('<option>').html(option.text);
        $options.push($option);
        if (option.disabled) {
          $option.prop("disabled", option.disabled);
        }
        if (option.selected) {
          $option.prop("selected", option.selected);
        }
        // allow pulldowns to have "falsy" values (e.g. "0")
        if (typeof option.value !== 'undefined') {
          $option.prop("value", option.value);
        }
        $pulldown.append($option);
      }

      $pulldown.change(function() {
        if (ignoreChangeEvent) {
          // Ignore change event caused by the pulldown menu update. It
          // prevents from infinite loop of pulldown - property updates.
          ignoreChangeEvent = false;
          return;
        }

        var index = $(this).prop('selectedIndex'),
            action = component.options[index].action,
            value = component.options[index].value;

        if (action){
          scriptingAPI.makeFunctionInScriptContext(action)();
        } else if (component.options[index].loadModel){
          model.stop();
          interactivesController.loadModel(component.options[index].loadModel);
        } else if (value !== undefined) {
          model.set(component.property, value);
        }
      });

      $wrapper = $('<div>')
        .attr('id', component.id)
        .addClass("interactive-pulldown")
        .addClass("component");

      if (component.label) {
        $label = $("<span>").text(component.label);
        $label.addClass("label");
        $label.addClass(component.labelOn === "top" ? "on-top" : "on-left");
        $wrapper.append($label);
      }

      // Add $pulldown to a wrapping div. This way $pulldown.selectBoxIt() will create
      // a selectBox element which will also be in the span, and then we can return
      // this element to be embedded in the interactive
      $wrapper.append($pulldown);

      $pulldown.selectBoxIt();

      $wrapper.find(".selectboxit").css("width", "auto");

      // SelectBoxIt assumes that all select boxes are always going to have a width
      // set in CSS (default 220px). This doesn't work for us, as we don't know how
      // wide the content is going to be. Instead we have to measure the needed width
      // of the internal ul list, and use that to define the width of the select box.
      //
      // This issue has been raised in SelectBoxIt:
      // https://github.com/gfranko/jquery.selectBoxIt.js/issues/129
      //
      // However, this is still problematic because we haven't added the element to
      // the page yet. This $().measure function allows us to embed the element hidden
      // on the page first to allow us to check the required width.
      ulWidth    = $wrapper.measure(function(){ return this.width(); }, "ul", parent );
      arrowWidth = $wrapper.measure(function(){ return this.width(); }, ".selectboxit-arrow-container", parent );

      // ems for a given pixel size
      function pxToEm(input) {
        var emSize = parseFloat(parent.css("font-size"));
        return (input / emSize);
      }

      boxWidth = (pxToEm(ulWidth+arrowWidth)+0.3)+"em";

      $wrapper.find(".selectboxit").css("width", boxWidth);
      $wrapper.find(".selectboxit-text").css("max-width", pxToEm(ulWidth)+"em");

      // set hidden select box dimensions too, for mobile devices
      $wrapper.find(".selectboxit-container select").css({width: boxWidth, height: "100%"});
    }

    // Public API.
    controller = {
      modelLoadedCallback: function () {
        // Connect pulldown with model's property if its name is defined.
        if (component.property !== undefined) {
          // Register listener for property.
          model.addPropertiesListener([component.property], updatePulldown);
          // Perform initial pulldown setup.
          updatePulldown();
        }
      },

      // Returns view container.
      getViewContainer: function () {
        return $wrapper;
      },

      // Returns serialized component definition.
      serialize: function () {
        var i, len;
        if (component.property === undefined) {
          // When property binding is not defined, we need to keep track
          // which option is currently selected.
          for (i = 0, len = options.length; i < len; i++) {
            if ($options[i].prop("selected")) {
              options[i].selected = true;
            } else {
              delete options[i].selected;
            }
          }
        }
        // Note that 'options' array above is a reference to component.options array.
        // Every thing is updated, return a copy.
        return $.extend(true, {}, component);
      }
    };

    initialize();

    // Return Public API object.
    return controller;
  };
});

/*global define $ model */

define('common/controllers/numeric-output-controller',['common/controllers/interactive-metadata','common/validator'],function () {

  var metadata  = require('common/controllers/interactive-metadata'),
      validator = require('common/validator');

  return function NumericOutputController(component, scriptingAPI) {
    var propertyName,
        label,
        units,
        displayValue,
        $numericOutput,
        $label,
        $number,
        $units,
        propertyDescription,
        controller,

        renderValue = function () {
          var value = model.get(propertyName);
          if (displayValue) {
            $number.text(displayValue(value));
          } else {
            $number.text(value);
          }
        };

    //
    // Initialization.
    //
    // Validate component definition, use validated copy of the properties.
    component = validator.validateCompleteness(metadata.numericOutput, component);
    propertyName = component.property;
    label = component.label;
    units = component.units;
    displayValue = component.displayValue;

    // Setup view.
    $label  = $('<span class="label"></span>');
    $output = $('<span class="output"></span>');
    $number = $('<span class="value"></span>');
    $units  = $('<span class="units"></span>');
    if (label) { $label.html(label); }
    if (units) { $units.html(units); }
    $numericOutput = $('<div class="numeric-output">').attr('id', component.id)
        .append($label)
        .append($output
          .append($number)
          .append($units)
        );

    // Each interactive component has to have class "component".
    $numericOutput.addClass("component");

    // Add class defining component orientation - "horizontal" or "vertical".
    $numericOutput.addClass(component.orientation);

    // Custom dimensions.
    $numericOutput.css({
      width: component.width,
      height: component.height
    });

    if (displayValue) {
      displayValue = scriptingAPI.makeFunctionInScriptContext('value', displayValue);
    }

    // Public API.
    controller = {
      // This callback should be trigger when model is loaded.
      modelLoadedCallback: function () {
        if (propertyName) {
          propertyDescription = model.getPropertyDescription(propertyName);
          if (propertyDescription) {
            if (!label) { $label.html(propertyDescription.getLabel()); }
            if (!units) { $units.html(propertyDescription.getUnitAbbreviation()); }
          }
          renderValue();
          model.addPropertiesListener([propertyName], renderValue);
        }
      },

      // Returns view container. Label tag, as it contains checkbox anyway.
      getViewContainer: function () {
        return $numericOutput;
      },

      // Returns serialized component definition.
      serialize: function () {
        // Return the initial component definition.
        // Numeric output component doesn't have any state, which can be changed.
        // It's value is defined by underlying model.
        return $.extend(true, {}, component);
      }
    };
    // Return Public API object.
    return controller;
  };
});

/*global define: false */
/*jshint boss: true */

define('common/parent-message-controller',[],function() {

  var parentOrigin,
      listeners = {},
      controller;

  function postToTarget(message, target) {
    // See http://dev.opera.com/articles/view/window-postmessage-messagechannel/#crossdoc
    //     https://github.com/Modernizr/Modernizr/issues/388
    //     http://jsfiddle.net/ryanseddon/uZTgD/2/
    if (Lab.structuredClone.supported()) {
      window.parent.postMessage(message, target);
    } else {
      window.parent.postMessage(JSON.stringify(message), target);
    }
  }

  function post(message) {
    postToTarget(message, parentOrigin);
  }

  // Only the initial 'hello' message goes permissively to a '*' target (because due to cross origin
  // restrictions we can't find out our parent's origin until they voluntarily send us a message
  // with it.)
  function postHello(message) {
    postToTarget(message, '*');
  }

  function addListener(type, fn) {
    listeners[type] = fn;
  }

  function removeAllListeners() {
    listeners = {};
  }

  function getListenerNames() {
    return Object.keys(listeners);
  }

  function messageListener(message) {
      // Anyone can send us a message. Only pay attention to messages from parent.
      if (message.source !== window.parent) return;

      var messageData = message.data;

      if (typeof messageData === 'string') messageData = JSON.parse(messageData);

      // We don't know origin property of parent window until it tells us.
      if (!parentOrigin) {
        // This is the return handshake from the embedding window.
        if (messageData.type === 'hello') {
          parentOrigin = messageData.origin;
        }
      }

      // Perhaps-redundantly insist on checking origin as well as source window of message.
      if (message.origin === parentOrigin) {
        if (listeners[messageData.type]) listeners[messageData.type](messageData);
      }
   }

  function initialize() {
    if (window.parent === window) return;

    // We kick off communication with the parent window by sending a "hello" message. Then we wait
    // for a handshake (another "hello" message) from the parent window.
    postHello({
      type: 'hello',
      origin: document.location.href.match(/(.*?\/\/.*?)\//)[1]
    });

    // Make sure that even if initialize() is called many times,
    // only one instance of messageListener will be registered as listener.
    // So, add closure function instead of anonymous function created here.
    window.addEventListener('message', messageListener, false);
  }

  return controller = {
    initialize         : initialize,
    getListenerNames   : getListenerNames,
    addListener        : addListener,
    removeAllListeners : removeAllListeners,
    post               : post
  };

});

/*global define: false, d3: false */
/*jshint loopfunc: true*/

/*
  ------------------------------------------------------------

  Simple benchmark runner and results generator

    see: https://gist.github.com/1364172

  ------------------------------------------------------------

  Runs benchmarks and generates the results in a table.

  Setup benchmarks to run in an array of objects with two properties:

    name: a title for the table column of results
    numeric: boolean, used to decide what columns should be used to calculate averages
    formatter: (optional) a function that takes a number and returns a formmatted string, example: d3.format("5.1f")
    run: a function that is called to run the benchmark and call back with a value.
         It should accept a single argument, the callback to be called when the
         benchmark completes. It should pass the benchmark value to the callback.

  Start the benchmarks by passing the table element where the results are to
  be placed and an array of benchmarks to run.

  Example:

    var benchmarks_table = document.getElementById("benchmarks-table");

    var benchmarks_to_run = [
      {
        name: "molecules",
        run: function(done) {
          done(mol_number);
        }
      },
      {
        name: "100 Steps (steps/s)",
        run: function(done) {
          modelStop();
          var start = +Date.now();
          var i = -1;
          while (i++ < 100) {
            model.tick();
          }
          elapsed = Date.now() - start;
          done(d3.format("5.1f")(100/elapsed*1000));
        }
      },
    ];

    benchmark.run(benchmarks_table, benchmarks_to_run)

  You can optionally pass two additional arguments to the run method: start_callback, end_callback

    function run(benchmarks_table, benchmarks_to_run, start_callback, end_callback)

  These arguments are used when the last benchmark test is run using the browsers scheduling and re-painting mechanisms.

  For example this test runs a model un the browser and calculates actual frames per second combining the
  model, view, and browser scheduling and repaint operations.

    {
      name: "fps",
      numeric: true,
      formatter: d3.format("5.1f"),
      run: function(done) {
        // warmup
        model.start();
        setTimeout(function() {
          model.stop();
          var start = model.get('time');
          setTimeout(function() {
            // actual fps calculation
            model.start();
            setTimeout(function() {
              model.stop();
              var elapsedModelTime = model.get('time') - start;
              done( elapsedModelTime / (model.get('timeStepsPerTick') * model.get('timeStep')) / 2 );
            }, 2000);
          }, 100);
        }, 1000);
      }
    }

  Here's an example calling the benchmark.run method and passing in start_callback, end_callback functions:

    benchmark.run(document.getElementById("model-benchmark-results"), benchmarksToRun, function() {
      $runBenchmarksButton.attr('disabled', true);
    }, function() {
      $runBenchmarksButton.attr('disabled', false);
    });

  The "Run Benchmarks" button is disabled until the browser finishes running thelast queued test.

  The first five columns in the generated table consist of:

    browser, version, cpu/os, date, and commit

  These columns are followed by a column for each benchmark passed in.

  Subsequent calls to: benchmark.run(benchmarks_table, benchmarks_to_run) will
  add additional rows to the table.

  A special second row is created in the table which displays averages of all tests
  that generate numeric results.

  Here are some css styles for the table:

    table {
      font: 11px/24px Verdana, Arial, Helvetica, sans-serif;
      border-collapse: collapse; }
    th {
      padding: 0 1em;
      text-align: left; }
    td {
      border-top: 1px solid #cccccc;
      padding: 0 1em; }

*/

define('common/benchmark/benchmark',[],function () {

  var version = "0.0.1",
      windows_platform_token = {
        "Windows NT 6.2": "Windows 8",
        "Windows NT 6.1": "Windows 7",
        "Windows NT 6.0": "Windows Vista",
        "Windows NT 5.2": "Windows Server 2003; Windows XP x64 Edition",
        "Windows NT 5.1": "Windows XP",
        "Windows NT 5.01": "Windows 2000, Service Pack 1 (SP1)",
        "Windows NT 5.0": "Windows 2000",
        "Windows NT 4.0": "Microsoft Windows NT 4.0"
      },
      windows_feature_token = {
        "WOW64":       "64/32",
        "Win64; IA64": "64",
        "Win64; x64":  "64"
      },
      average_row;

  function what_browser() {
    var chromematch  = / (Chrome)\/(.*?) /,
        ffmatch      = / (Firefox)\/([0123456789ab.]+)/,
        safarimatch  = / AppleWebKit\/([0123456789.+]+) \(KHTML, like Gecko\) Version\/([0123456789.]+) (Safari)\/([0123456789.]+)/,
        iematch      = / (MSIE) ([0123456789.]+);/,
        operamatch   = /^(Opera)\/.+? Version\/([0123456789.]+)$/,
        iphonematch  = /.+?\((iPhone); CPU.+?OS .+?Version\/([0123456789._]+)/,
        ipadmatch    = /.+?\((iPad); CPU.+?OS .+?Version\/([0123456789._]+)/,
        ipodmatch    = /.+?\((iPod); CPU (iPhone.+?) like.+?Version\/([0123456789ab._]+)/,
        androidchromematch = /.+?(Android) ([0123456789.]+).*?; (.+?)\).+? Chrome\/([0123456789.]+)/,
        androidfirefoxmatch = /.+?(Android.+?\)).+? Firefox\/([0123456789.]+)/,
        androidmatch = /.+?(Android) ([0123456789ab.]+).*?; (.+?)\)/,
        match;

    match = navigator.userAgent.match(chromematch);
    if (match && match[1]) {
      return {
        browser: match[1],
        version: match[2],
        oscpu: os_platform()
      };
    }
    match = navigator.userAgent.match(ffmatch);
    if (match && match[1]) {
      var buildID = navigator.buildID,
          buildDate = "";
      if (buildID && buildID.length >= 8) {
        buildDate = "(" + buildID.slice(0,4) + "-" + buildID.slice(4,6) + "-" + buildID.slice(6,8) + ")";
      }
      return {
        browser: match[1],
        version: match[2] + ' ' + buildDate,
        oscpu: os_platform()
      };
    }
    match = navigator.userAgent.match(androidchromematch);
    if (match && match[1]) {
      return {
        browser: "Chrome",
        version: match[4],
        oscpu: match[1] + "/" + match[2] + "/" + match[3]
      };
    }
    match = navigator.userAgent.match(androidfirefoxmatch);
    if (match && match[1]) {
      return {
        browser: "Firefox",
        version: match[2],
        oscpu: match[1]
      };
    }
    match = navigator.userAgent.match(androidmatch);
    if (match && match[1]) {
      return {
        browser: "Android",
        version: match[2],
        oscpu: match[1] + "/" + match[2] + "/" + match[3]
      };
    }
    match = navigator.userAgent.match(safarimatch);
    if (match && match[3]) {
      return {
        browser: match[3],
        version: match[2] + '/' + match[1],
        oscpu: os_platform()
      };
    }
    match = navigator.userAgent.match(iematch);
    if (match && match[1]) {
      var platform_match = navigator.userAgent.match(/\(.*?(Windows.+?); (.+?)[;)].*/);
      return {
        browser: match[1],
        version: match[2],
        oscpu: windows_platform_token[platform_match[1]] + "/" + navigator.cpuClass + "/" + navigator.platform
      };
    }
    match = navigator.userAgent.match(operamatch);
    if (match && match[1]) {
      return {
        browser: match[1],
        version: match[2],
        oscpu: os_platform()
      };
    }
    match = navigator.userAgent.match(iphonematch);
    if (match && match[1]) {
      return {
        browser: "Mobile Safari",
        version: match[2],
        oscpu: match[1] + "/" + "iOS" + "/" + match[2]
      };
    }
    match = navigator.userAgent.match(ipadmatch);
    if (match && match[1]) {
      return {
        browser: "Mobile Safari",
        version: match[2],
        oscpu: match[1] + "/" + "iOS" + "/" + match[2]
      };
    }
    match = navigator.userAgent.match(ipodmatch);
    if (match && match[1]) {
      return {
        browser: "Mobile Safari",
        version: match[3],
        oscpu: match[1] + "/" + "iOS" + "/" + match[2]
      };
    }
    return {
      browser: "",
      version: navigator.appVersion,
      oscpu:   ""
    };
  }

  function os_platform() {
    var match = navigator.userAgent.match(/\((.+?)[;)] (.+?)[;)].*/);
    if (!match) { return "na"; }
    if (match[1] === "Macintosh") {
      return match[2];
    } else if (match[1].match(/^Windows/)) {
      var arch  = windows_feature_token[match[2]] || "32",
          token = navigator.userAgent.match(/\(.*?(Windows NT.+?)[;)]/);
      return windows_platform_token[token[1]] + "/" + arch;
    }
  }

  function renderToTable(benchmarks_table, benchmarksThatWereRun, results) {
    var i = 0,
        results_row,
        result,
        col_number = 0,
        col_numbers = {},
        title_row,
        title_cells,
        len,
        rows = benchmarks_table.getElementsByTagName("tr");

    benchmarks_table.style.display = "";

    function add_column(title) {
      var title_row = benchmarks_table.getElementsByTagName("tr")[0],
          cell = title_row.appendChild(document.createElement("th"));

      cell.innerHTML = title;
      col_numbers[title] = col_number++;
    }

    function add_row(num_cols) {
      num_cols = num_cols || 0;
      var tr =  benchmarks_table.appendChild(document.createElement("tr")),
          i;

      for (i = 0; i < num_cols; i++) {
        tr.appendChild(document.createElement("td"));
      }
      return tr;
    }

    function add_result(name, content, row) {
      var cell;
      row = row || results_row;
      cell = row.getElementsByTagName("td")[col_numbers[name]];
      if (typeof content === "string" && content.slice(0,1) === "<") {
        cell.innerHTML = content;
      } else {
        cell.textContent = content;
      }
    }

    function update_averages() {
      var i, j,
          b,
          row,
          num_rows = rows.length,
          cell,
          cell_index,
          average_elements = average_row.getElementsByTagName("td"),
          total,
          average,
          genericDecimalFormatter = d3.format("5.1f"),
          genericIntegerFormatter = d3.format("f");

      function isInteger(i) {
        return Math.floor(i) === i;
      }

      for (i = 0; i < benchmarksThatWereRun.length; i++) {
        b = benchmarksThatWereRun[i];
        cell_index = col_numbers[b.name];
        if (b.numeric === false) {
          row = rows[2];
          cell = row.getElementsByTagName("td")[cell_index];
          average_elements[cell_index].innerHTML = cell.innerHTML;
        } else {
          total = 0;
          for (j = 2; j < num_rows; j++) {
            row = rows[j];
            cell = row.getElementsByTagName("td")[cell_index];
            total += (+cell.textContent);
          }
          average = total/(num_rows-2);
          if (b.formatter) {
            average = b.formatter(average);
          } else {
            if (isInteger(average)) {
              average = genericIntegerFormatter(total/(num_rows-2));
            } else {
              average = genericDecimalFormatter(total/(num_rows-2));
            }
          }
          average_elements[cell_index].textContent = average;
        }
      }
    }

    if (rows.length === 0) {
      add_row();
      add_column("browser");
      add_column("version");
      add_column("cpu/os");
      add_column("date");
      for (i = 0; i < benchmarksThatWereRun.length; i++) {
        add_column(benchmarksThatWereRun[i].name);
      }
      average_row = add_row(col_number);
      average_row.className = 'average';
    } else {
      title_row = rows[0];
      title_cells = title_row.getElementsByTagName("th");
      for (i = 0, len = title_cells.length; i < len; i++) {
        col_numbers[title_cells[i].innerHTML] = col_number++;
      }
    }

    results_row = add_row(col_number);
    results_row.className = 'sample';

    for (i = 0; i < 4; i++) {
      result = results[i];
      add_result(result[0], result[1]);
      add_result(result[0], result[1], average_row);
    }

    for(i = 4; i < results.length; i++) {
      result = results[i];
      add_result(result[0], result[1]);
    }
    update_averages();
  }

  function bench(benchmarks_to_run, resultsCallback, start_callback, end_callback) {
    var bencharks_queue = benchmarks_to_run.slice(),
        results = [],
        browser_info = what_browser(),
        formatter = d3.time.format("%Y-%m-%d %H:%M");

    results.push([ "browser", browser_info.browser]);
    results.push([ "version", browser_info.version]);
    results.push([ "cpu/os", browser_info.oscpu]);
    results.push([ "date", formatter(new Date())]);

    if (start_callback) start_callback();

    runBenchmark(bencharks_queue.shift());

    function runBenchmark(b) {
      b.run(doneCallback);

      function doneCallback(result) {
        if (b.formatter) {
          results.push([ b.name, b.formatter(result) ]);
        } else {
          results.push([ b.name, result ]);
        }

        if (bencharks_queue.length > 0) {
          runBenchmark(bencharks_queue.shift());
        } else {
          if (end_callback) end_callback();
          if (resultsCallback) resultsCallback(results);
        }
      }
    }

    return results;
  }

  function run(benchmarks_to_run, benchmarks_table, resultsCallback, start_callback, end_callback) {
    var results;
    bench(benchmarks_to_run, function(results) {
      renderToTable(benchmarks_table, benchmarks_to_run, results);
      resultsCallback(results);
    }, start_callback, end_callback);
    return results;
  }

  // Return Public API.
  return {
    version: version,
    what_browser: function() {
      return what_browser();
    },
    // run benchmarks, add row to table, update averages row
    run: function(benchmarks_to_run, benchmarks_table, resultsCallback, start_callback, end_callback) {
      run(benchmarks_to_run, benchmarks_table, resultsCallback, start_callback, end_callback);
    },
    // run benchmarks, return results in object
    bench: function(benchmarks_to_run, resultsCallback, start_callback, end_callback) {
      return bench(benchmarks_to_run, resultsCallback, start_callback, end_callback);
    },
    // run benchmarks, add row to table, update averages row
    renderToTable: function(benchmarks_table, benchmarksThatWereRun, results) {
      renderToTable(benchmarks_table, benchmarksThatWereRun, results);
    }
  };
});

/*global define:false*/

define('common/controllers/parent-message-api',['require','common/parent-message-controller','common/benchmark/benchmark'],function(require) {
  var parentMessageController = require('common/parent-message-controller'),
      benchmark               = require('common/benchmark/benchmark');

  // Defines the default postMessage API used to communicate with parent window (i.e., an embedder)
  return function(model, view, controller) {
    parentMessageController.removeAllListeners();

    function sendPropertyValue(propertyName) {
      parentMessageController.post({
        type: 'propertyValue',
        name:  propertyName,
        values: model.get(propertyName)
      });
    }

    // on message 'setFocus' call view.setFocus
    parentMessageController.addListener('setFocus', function(message) {
      if (view && view.setFocus) {
        view.setFocus();
      }
    });

   // on message 'loadInteractive' call controller.loadInteractive
    parentMessageController.addListener('loadInteractive', function(message) {
      if (controller && controller.loadInteractive) {
        controller.loadInteractive(message.data);
      }
    });

    // on message 'loadModel' call controller.loadModel
    parentMessageController.addListener('loadModel', function(message) {
      if (controller && controller.loadModel) {
        controller.loadModel(message.data.modelId, message.data.modelObject);
      }
    });

    // on message 'getModelState' call and return controller.getModelController().state()
    parentMessageController.addListener('getModelState', function(message) {
      if (controller && controller.getModelController) {
        parentMessageController.post({
          type:  'modelState',
          values: controller.getModelController().state()
        });
      }
    });

    // on message 'getInteractiveState' call and return controller.serialize() result
    parentMessageController.addListener('getInteractiveState', function(message) {
      if (controller && controller.getModelController) {
        parentMessageController.post({
          type:  'interactiveState',
          values: controller.serialize()
        });
      }
    });

    // on message 'runBenchmarks' call controller.runBenchmarks
    parentMessageController.addListener('runBenchmarks', function() {
      var modelController;
      if (controller && controller.getModelController) {
        modelController = controller.getModelController();
        benchmark.bench(modelController.benchmarks, function(results) {
          console.log(results);
          parentMessageController.post({
            'type':   'returnBenchmarks',
            'values': { 'results': results, 'benchmarks': modelController.benchmarks }
          }, function() {}, function() {});
        });
      }
    });

    // Listen for events in the model, and notify using message.post
    // uses D3 disaptch on model to trigger events
    // pass in message.properties ([names]) to also send model properties
    // in values object when triggering in parent Frame
    parentMessageController.addListener('listenForDispatchEvent', function(message) {
      var eventName    = message.eventName,
          properties   = message.properties,
          values       = {},
          i            = 0,
          propertyName = null;

      model.on(eventName, function() {
        if (properties) {
          for (i = 0 ; i < properties.length; i++) {
            propertyName = properties[i];
            values[propertyName] = model.get(propertyName);
          }
        }
        parentMessageController.post({
          'type':   eventName,
          'values': values
        });
      });
    });

    // Remove an existing Listener for events in the model
    parentMessageController.addListener('removeListenerForDispatchEvent', function(message) {
      var eventName    = message.eventName,
          properties   = message.properties,
          values       = {},
          i            = 0,
          propertyName = null;

      model.on(eventName, null);
    });

    // on message 'get' propertyName: return a 'propertyValue' message
    parentMessageController.addListener('get', function(message) {
      sendPropertyValue(message.propertyName);
    });

    // on message 'observe' propertyName: send 'propertyValue' once, and then every time
    // the property changes.
    parentMessageController.addListener('observe', function(message) {
      model.addPropertiesListener(message.propertyName, function() {
        sendPropertyValue(message.propertyName);
      });
      // Don't forget to send the initial value of the property too:
      sendPropertyValue(message.propertyName);
    });

    // on message 'set' propertyName: set the relevant property
    parentMessageController.addListener('set', function(message) {
      var setter = {};
      setter[message.propertyName] = message.propertyValue;
      model.set(setter);
    });

    parentMessageController.addListener('tick', function(message) {
      model.tick(message.numTimes);
    });

    parentMessageController.addListener('play', function(message) {
      model.start();
    });

    parentMessageController.initialize();
  };
});

/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */

/*global define: false*/

(function (root, factory) {
  if (typeof exports === "object" && exports) {
    module.exports = factory; // CommonJS
  } else if (typeof define === "function" && define.amd) {
    define('mustache',factory); // AMD
  } else {
    root.Mustache = factory; // <script>
  }
}(this, (function () {

  var exports = {};

  exports.name = "mustache.js";
  exports.version = "0.7.2";
  exports.tags = ["{{", "}}"];

  exports.Scanner = Scanner;
  exports.Context = Context;
  exports.Writer = Writer;

  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var nonSpaceRe = /\S/;
  var eqRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;

  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
  // See https://github.com/janl/mustache.js/issues/189
  function testRe(re, string) {
    return RegExp.prototype.test.call(re, string);
  }

  function isWhitespace(string) {
    return !testRe(nonSpaceRe, string);
  }

  var isArray = Array.isArray || function (obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };

  function escapeRe(string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  }

  var entityMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': '&quot;',
    "'": '&#39;',
    "/": '&#x2F;'
  };

  function escapeHtml(string) {
    return String(string).replace(/[&<>"'\/]/g, function (s) {
      return entityMap[s];
    });
  }

  // Export the escaping function so that the user may override it.
  // See https://github.com/janl/mustache.js/issues/244
  exports.escape = escapeHtml;

  function Scanner(string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }

  /**
   * Returns `true` if the tail is empty (end of string).
   */
  Scanner.prototype.eos = function () {
    return this.tail === "";
  };

  /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */
  Scanner.prototype.scan = function (re) {
    var match = this.tail.match(re);

    if (match && match.index === 0) {
      this.tail = this.tail.substring(match[0].length);
      this.pos += match[0].length;
      return match[0];
    }

    return "";
  };

  /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */
  Scanner.prototype.scanUntil = function (re) {
    var match, pos = this.tail.search(re);

    switch (pos) {
    case -1:
      match = this.tail;
      this.pos += this.tail.length;
      this.tail = "";
      break;
    case 0:
      match = "";
      break;
    default:
      match = this.tail.substring(0, pos);
      this.tail = this.tail.substring(pos);
      this.pos += pos;
    }

    return match;
  };

  function Context(view, parent) {
    this.view = view;
    this.parent = parent;
    this.clearCache();
  }

  Context.make = function (view) {
    return (view instanceof Context) ? view : new Context(view);
  };

  Context.prototype.clearCache = function () {
    this._cache = {};
  };

  Context.prototype.push = function (view) {
    return new Context(view, this);
  };

  Context.prototype.lookup = function (name) {
    var value = this._cache[name];

    if (!value) {
      if (name === ".") {
        value = this.view;
      } else {
        var context = this;

        while (context) {
          if (name.indexOf(".") > 0) {
            var names = name.split("."), i = 0;

            value = context.view;

            while (value && i < names.length) {
              value = value[names[i++]];
            }
          } else {
            value = context.view[name];
          }

          if (value != null) {
            break;
          }

          context = context.parent;
        }
      }

      this._cache[name] = value;
    }

    if (typeof value === "function") {
      value = value.call(this.view);
    }

    return value;
  };

  function Writer() {
    this.clearCache();
  }

  Writer.prototype.clearCache = function () {
    this._cache = {};
    this._partialCache = {};
  };

  Writer.prototype.compile = function (template, tags) {
    var fn = this._cache[template];

    if (!fn) {
      var tokens = exports.parse(template, tags);
      fn = this._cache[template] = this.compileTokens(tokens, template);
    }

    return fn;
  };

  Writer.prototype.compilePartial = function (name, template, tags) {
    var fn = this.compile(template, tags);
    this._partialCache[name] = fn;
    return fn;
  };

  Writer.prototype.compileTokens = function (tokens, template) {
    var fn = compileTokens(tokens);
    var self = this;

    return function (view, partials) {
      if (partials) {
        if (typeof partials === "function") {
          self._loadPartial = partials;
        } else {
          for (var name in partials) {
            self.compilePartial(name, partials[name]);
          }
        }
      }

      return fn(self, Context.make(view), template);
    };
  };

  Writer.prototype.render = function (template, view, partials) {
    return this.compile(template)(view, partials);
  };

  Writer.prototype._section = function (name, context, text, callback) {
    var value = context.lookup(name);

    switch (typeof value) {
    case "object":
      if (isArray(value)) {
        var buffer = "";

        for (var i = 0, len = value.length; i < len; ++i) {
          buffer += callback(this, context.push(value[i]));
        }

        return buffer;
      }

      return value ? callback(this, context.push(value)) : "";
    case "function":
      var self = this;
      var scopedRender = function (template) {
        return self.render(template, context);
      };

      var result = value.call(context.view, text, scopedRender);
      return result != null ? result : "";
    default:
      if (value) {
        return callback(this, context);
      }
    }

    return "";
  };

  Writer.prototype._inverted = function (name, context, callback) {
    var value = context.lookup(name);

    // Use JavaScript's definition of falsy. Include empty arrays.
    // See https://github.com/janl/mustache.js/issues/186
    if (!value || (isArray(value) && value.length === 0)) {
      return callback(this, context);
    }

    return "";
  };

  Writer.prototype._partial = function (name, context) {
    if (!(name in this._partialCache) && this._loadPartial) {
      this.compilePartial(name, this._loadPartial(name));
    }

    var fn = this._partialCache[name];

    return fn ? fn(context) : "";
  };

  Writer.prototype._name = function (name, context) {
    var value = context.lookup(name);

    if (typeof value === "function") {
      value = value.call(context.view);
    }

    return (value == null) ? "" : String(value);
  };

  Writer.prototype._escaped = function (name, context) {
    return exports.escape(this._name(name, context));
  };

  /**
   * Low-level function that compiles the given `tokens` into a function
   * that accepts three arguments: a Writer, a Context, and the template.
   */
  function compileTokens(tokens) {
    var subRenders = {};

    function subRender(i, tokens, template) {
      if (!subRenders[i]) {
        var fn = compileTokens(tokens);
        subRenders[i] = function (writer, context) {
          return fn(writer, context, template);
        };
      }

      return subRenders[i];
    }

    return function (writer, context, template) {
      var buffer = "";
      var token, sectionText;

      for (var i = 0, len = tokens.length; i < len; ++i) {
        token = tokens[i];

        switch (token[0]) {
        case "#":
          sectionText = template.slice(token[3], token[5]);
          buffer += writer._section(token[1], context, sectionText, subRender(i, token[4], template));
          break;
        case "^":
          buffer += writer._inverted(token[1], context, subRender(i, token[4], template));
          break;
        case ">":
          buffer += writer._partial(token[1], context);
          break;
        case "&":
          buffer += writer._name(token[1], context);
          break;
        case "name":
          buffer += writer._escaped(token[1], context);
          break;
        case "text":
          buffer += token[1];
          break;
        }
      }

      return buffer;
    };
  }

  /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */
  function nestTokens(tokens) {
    var tree = [];
    var collector = tree;
    var sections = [];

    var token;
    for (var i = 0, len = tokens.length; i < len; ++i) {
      token = tokens[i];
      switch (token[0]) {
      case '#':
      case '^':
        sections.push(token);
        collector.push(token);
        collector = token[4] = [];
        break;
      case '/':
        var section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : tree;
        break;
      default:
        collector.push(token);
      }
    }

    return tree;
  }

  /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */
  function squashTokens(tokens) {
    var squashedTokens = [];

    var token, lastToken;
    for (var i = 0, len = tokens.length; i < len; ++i) {
      token = tokens[i];
      if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
        lastToken[1] += token[1];
        lastToken[3] = token[3];
      } else {
        lastToken = token;
        squashedTokens.push(token);
      }
    }

    return squashedTokens;
  }

  function escapeTags(tags) {
    return [
      new RegExp(escapeRe(tags[0]) + "\\s*"),
      new RegExp("\\s*" + escapeRe(tags[1]))
    ];
  }

  /**
   * Breaks up the given `template` string into a tree of token objects. If
   * `tags` is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. ["<%", "%>"]). Of
   * course, the default is to use mustaches (i.e. Mustache.tags).
   */
  exports.parse = function (template, tags) {
    template = template || '';
    tags = tags || exports.tags;

    if (typeof tags === 'string') tags = tags.split(spaceRe);
    if (tags.length !== 2) {
      throw new Error('Invalid tags: ' + tags.join(', '));
    }

    var tagRes = escapeTags(tags);
    var scanner = new Scanner(template);

    var sections = [];     // Stack to hold section tokens
    var tokens = [];       // Buffer to hold the tokens
    var spaces = [];       // Indices of whitespace tokens on the current line
    var hasTag = false;    // Is there a {{tag}} on the current line?
    var nonSpace = false;  // Is there a non-space char on the current line?

    // Strips all whitespace tokens array for the current line
    // if there was a {{#tag}} on it and otherwise only space.
    function stripSpace() {
      if (hasTag && !nonSpace) {
        while (spaces.length) {
          tokens.splice(spaces.pop(), 1);
        }
      } else {
        spaces = [];
      }

      hasTag = false;
      nonSpace = false;
    }

    var start, type, value, chr;
    while (!scanner.eos()) {
      start = scanner.pos;
      value = scanner.scanUntil(tagRes[0]);

      if (value) {
        for (var i = 0, len = value.length; i < len; ++i) {
          chr = value.charAt(i);

          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
          } else {
            nonSpace = true;
          }

          tokens.push(["text", chr, start, start + 1]);
          start += 1;

          if (chr === "\n") {
            stripSpace(); // Check for whitespace on the current line.
          }
        }
      }

      start = scanner.pos;

      // Match the opening tag.
      if (!scanner.scan(tagRes[0])) {
        break;
      }

      hasTag = true;
      type = scanner.scan(tagRe) || "name";

      // Skip any whitespace between tag and value.
      scanner.scan(whiteRe);

      // Extract the tag value.
      if (type === "=") {
        value = scanner.scanUntil(eqRe);
        scanner.scan(eqRe);
        scanner.scanUntil(tagRes[1]);
      } else if (type === "{") {
        var closeRe = new RegExp("\\s*" + escapeRe("}" + tags[1]));
        value = scanner.scanUntil(closeRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(tagRes[1]);
        type = "&";
      } else {
        value = scanner.scanUntil(tagRes[1]);
      }

      // Match the closing tag.
      if (!scanner.scan(tagRes[1])) {
        throw new Error('Unclosed tag at ' + scanner.pos);
      }

      // Check section nesting.
      if (type === '/') {
        if (sections.length === 0) {
          throw new Error('Unopened section "' + value + '" at ' + start);
        }

        var section = sections.pop();

        if (section[1] !== value) {
          throw new Error('Unclosed section "' + section[1] + '" at ' + start);
        }
      }

      var token = [type, value, start, scanner.pos];
      tokens.push(token);

      if (type === '#' || type === '^') {
        sections.push(token);
      } else if (type === "name" || type === "{" || type === "&") {
        nonSpace = true;
      } else if (type === "=") {
        // Set the tags for the next time around.
        tags = value.split(spaceRe);

        if (tags.length !== 2) {
          throw new Error('Invalid tags at ' + start + ': ' + tags.join(', '));
        }

        tagRes = escapeTags(tags);
      }
    }

    // Make sure there are no open sections when we're done.
    var section = sections.pop();
    if (section) {
      throw new Error('Unclosed section "' + section[1] + '" at ' + scanner.pos);
    }

    return nestTokens(squashTokens(tokens));
  };

  // The high-level clearCache, compile, compilePartial, and render functions
  // use this default writer.
  var _writer = new Writer();

  /**
   * Clears all cached templates and partials in the default writer.
   */
  exports.clearCache = function () {
    return _writer.clearCache();
  };

  /**
   * Compiles the given `template` to a reusable function using the default
   * writer.
   */
  exports.compile = function (template, tags) {
    return _writer.compile(template, tags);
  };

  /**
   * Compiles the partial with the given `name` and `template` to a reusable
   * function using the default writer.
   */
  exports.compilePartial = function (name, template, tags) {
    return _writer.compilePartial(name, template, tags);
  };

  /**
   * Compiles the given array of tokens (the output of a parse) to a reusable
   * function using the default writer.
   */
  exports.compileTokens = function (tokens, template) {
    return _writer.compileTokens(tokens, template);
  };

  /**
   * Renders the `template` with the given `view` and `partials` using the
   * default writer.
   */
  exports.render = function (template, view, partials) {
    return _writer.render(template, view, partials);
  };

  // This is here for backwards compatibility with 0.4.x.
  exports.to_html = function (template, view, partials, send) {
    var result = exports.render(template, view, partials);

    if (typeof send === "function") {
      send(result);
    } else {
      return result;
    }
  };

  return exports;

}())));

/**
 * @license RequireJS text 2.0.2 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/requirejs/text for details
 */
/*jslint regexp: true */
/*global require: false, XMLHttpRequest: false, ActiveXObject: false,
  define: false, window: false, process: false, Packages: false,
  java: false, location: false */

define('text',['module'], function (module) {
    'use strict';

    var text, fs,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        xmlRegExp = /^\s*<\?xml(\s)+version=[\'\"](\d)*.(\d)*[\'\"](\s)*\?>/im,
        bodyRegExp = /<body[^>]*>\s*([\s\S]+)\s*<\/body>/im,
        hasLocation = typeof location !== 'undefined' && location.href,
        defaultProtocol = hasLocation && location.protocol && location.protocol.replace(/\:/, ''),
        defaultHostName = hasLocation && location.hostname,
        defaultPort = hasLocation && (location.port || undefined),
        buildMap = [],
        masterConfig = (module.config && module.config()) || {};

    text = {
        version: '2.0.2',

        strip: function (content) {
            //Strips <?xml ...?> declarations so that external SVG and XML
            //documents can be added to a document without worry. Also, if the string
            //is an HTML document, only the part inside the body tag is returned.
            if (content) {
                content = content.replace(xmlRegExp, "");
                var matches = content.match(bodyRegExp);
                if (matches) {
                    content = matches[1];
                }
            } else {
                content = "";
            }
            return content;
        },

        jsEscape: function (content) {
            return content.replace(/(['\\])/g, '\\$1')
                .replace(/[\f]/g, "\\f")
                .replace(/[\b]/g, "\\b")
                .replace(/[\n]/g, "\\n")
                .replace(/[\t]/g, "\\t")
                .replace(/[\r]/g, "\\r")
                .replace(/[\u2028]/g, "\\u2028")
                .replace(/[\u2029]/g, "\\u2029");
        },

        createXhr: masterConfig.createXhr || function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else if (typeof ActiveXObject !== "undefined") {
                for (i = 0; i < 3; i += 1) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            return xhr;
        },

        /**
         * Parses a resource name into its component parts. Resource names
         * look like: module/name.ext!strip, where the !strip part is
         * optional.
         * @param {String} name the resource name
         * @returns {Object} with properties "moduleName", "ext" and "strip"
         * where strip is a boolean.
         */
        parseName: function (name) {
            var strip = false, index = name.indexOf("."),
                modName = name.substring(0, index),
                ext = name.substring(index + 1, name.length);

            index = ext.indexOf("!");
            if (index !== -1) {
                //Pull off the strip arg.
                strip = ext.substring(index + 1, ext.length);
                strip = strip === "strip";
                ext = ext.substring(0, index);
            }

            return {
                moduleName: modName,
                ext: ext,
                strip: strip
            };
        },

        xdRegExp: /^((\w+)\:)?\/\/([^\/\\]+)/,

        /**
         * Is an URL on another domain. Only works for browser use, returns
         * false in non-browser environments. Only used to know if an
         * optimized .js version of a text resource should be loaded
         * instead.
         * @param {String} url
         * @returns Boolean
         */
        useXhr: function (url, protocol, hostname, port) {
            var uProtocol, uHostName, uPort,
                match = text.xdRegExp.exec(url);
            if (!match) {
                return true;
            }
            uProtocol = match[2];
            uHostName = match[3];

            uHostName = uHostName.split(':');
            uPort = uHostName[1];
            uHostName = uHostName[0];

            return (!uProtocol || uProtocol === protocol) &&
                   (!uHostName || uHostName.toLowerCase() === hostname.toLowerCase()) &&
                   ((!uPort && !uHostName) || uPort === port);
        },

        finishLoad: function (name, strip, content, onLoad) {
            content = strip ? text.strip(content) : content;
            if (masterConfig.isBuild) {
                buildMap[name] = content;
            }
            onLoad(content);
        },

        load: function (name, req, onLoad, config) {
            //Name has format: some.module.filext!strip
            //The strip part is optional.
            //if strip is present, then that means only get the string contents
            //inside a body tag in an HTML string. For XML/SVG content it means
            //removing the <?xml ...?> declarations so the content can be inserted
            //into the current doc without problems.

            // Do not bother with the work if a build and text will
            // not be inlined.
            if (config.isBuild && !config.inlineText) {
                onLoad();
                return;
            }

            masterConfig.isBuild = config.isBuild;

            var parsed = text.parseName(name),
                nonStripName = parsed.moduleName + '.' + parsed.ext,
                url = req.toUrl(nonStripName),
                useXhr = (masterConfig.useXhr) ||
                         text.useXhr;

            //Load the text. Use XHR if possible and in a browser.
            if (!hasLocation || useXhr(url, defaultProtocol, defaultHostName, defaultPort)) {
                text.get(url, function (content) {
                    text.finishLoad(name, parsed.strip, content, onLoad);
                }, function (err) {
                    if (onLoad.error) {
                        onLoad.error(err);
                    }
                });
            } else {
                //Need to fetch the resource across domains. Assume
                //the resource has been optimized into a JS module. Fetch
                //by the module name + extension, but do not include the
                //!strip part to avoid file system issues.
                req([nonStripName], function (content) {
                    text.finishLoad(parsed.moduleName + '.' + parsed.ext,
                                    parsed.strip, content, onLoad);
                });
            }
        },

        write: function (pluginName, moduleName, write, config) {
            if (buildMap.hasOwnProperty(moduleName)) {
                var content = text.jsEscape(buildMap[moduleName]);
                write.asModule(pluginName + "!" + moduleName,
                               "define(function () { return '" +
                                   content +
                               "';});\n");
            }
        },

        writeFile: function (pluginName, moduleName, req, write, config) {
            var parsed = text.parseName(moduleName),
                nonStripName = parsed.moduleName + '.' + parsed.ext,
                //Use a '.js' file name so that it indicates it is a
                //script that can be loaded across domains.
                fileName = req.toUrl(parsed.moduleName + '.' +
                                     parsed.ext) + '.js';

            //Leverage own load() method to load plugin value, but only
            //write out values that do not have the strip argument,
            //to avoid any potential issues with ! in file names.
            text.load(nonStripName, req, function (value) {
                //Use own write() method to construct full module value.
                //But need to create shell that translates writeFile's
                //write() to the right interface.
                var textWrite = function (contents) {
                    return write(fileName, contents);
                };
                textWrite.asModule = function (moduleName, contents) {
                    return write.asModule(moduleName, fileName, contents);
                };

                text.write(pluginName, nonStripName, textWrite, config);
            }, config);
        }
    };

    if (typeof process !== "undefined" &&
             process.versions &&
             !!process.versions.node) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');

        text.get = function (url, callback) {
            var file = fs.readFileSync(url, 'utf8');
            //Remove BOM (Byte Mark Order) from utf8 files if it is there.
            if (file.indexOf('\uFEFF') === 0) {
                file = file.substring(1);
            }
            callback(file);
        };
    } else if (typeof Packages !== 'undefined' && typeof java !== 'undefined') {
        //Why Java, why is this so awkward?
        text.get = function (url, callback) {
            var stringBuffer, line,
                encoding = "utf-8",
                file = new java.io.File(url),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                stringBuffer.append(line);

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    } else if (text.createXhr()) {
        text.get = function (url, callback, errback) {
            var xhr = text.createXhr();
            xhr.open('GET', url, true);

            //Allow overrides specified in config
            if (masterConfig.onXhr) {
                masterConfig.onXhr(xhr, url);
            }

            xhr.onreadystatechange = function (evt) {
                var status, err;
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    status = xhr.status;
                    if (status > 399 && status < 600) {
                        //An http 4xx or 5xx error. Signal an error.
                        err = new Error(url + ' HTTP status: ' + status);
                        err.xhr = xhr;
                        errback(err);
                    } else {
                        callback(xhr.responseText);
                    }
                }
            };
            xhr.send(null);
        };
    }

    return text;
});

define('text!common/controllers/thermometer.tpl',[],function () { return '<div class="interactive-thermometer component" id="{{id}}">\n  <div class="thermometer-main-container">\n    <div class="thermometer">\n      <div class="thermometer-fill"></div>\n    </div>\n    <p class="label">{{labelText}}</p>\n  </div>\n  <div class="labels-container">\n    {{#labels}}\n      <span class="value-label" style="bottom: {{position}}">{{label}}</span>\n    {{/labels}}\n  </div>\n</div>';});

/*global define, $, model */

define('common/controllers/thermometer-controller',['require','mustache','text!common/controllers/thermometer.tpl','common/controllers/interactive-metadata','common/validator','common/jquery-plugins'],function (require) {

  var mustache       = require('mustache'),
      thermometerTpl = require('text!common/controllers/thermometer.tpl'),
      metadata       = require('common/controllers/interactive-metadata'),
      validator      = require('common/validator');
      require('common/jquery-plugins');

  /**
    An 'interactive thermometer' object, that wraps a base Thermometer with a label for use
    in Interactives.

    Properties are:

     modelLoadedCallback:  Standard interactive component callback, called as soon as the model is loaded.
     getViewContainer:     DOM element containing the Thermometer div and the label div.
     getView:              Returns base Thermometer object, with no label.
  */
  return function ThermometerController(component, scriptingAPI, interactivesController) {
    var units,
        digits,
        // Returns scaled value using provided 'scale' and 'offset' component properties.
        scaleFunc,
        // Returns value between 0% and 100% using provided 'min' and 'max' component properties.
        normalize,

        labelIsReading,
        fitWidth,
        $elem,
        $thermometer,
        $thermometerFill,
        $bottomLabel,
        $labelsContainer,

        controller,

        updateLabel = function (temperature) {
          temperature = scaleFunc(temperature);
          $bottomLabel.text(temperature.toFixed(digits) + " " + units);
        },

        // Updates thermometer using model property. Used in modelLoadedCallback.
        // Make sure that this function is only called when model is loaded.
        updateThermometer = function () {
          var t = model.get('targetTemperature');
          $thermometerFill.css("height", normalize(scaleFunc(t)));
          if (labelIsReading) updateLabel(t);
        };

    //
    // Initialization.
    //
    function initialize() {
      var reading, offset, scale,
          view, labelText, labels,
          longestLabelIdx, maxLength,
          max, min, i, len;

      component = validator.validateCompleteness(metadata.thermometer, component);
      reading = component.reading;
      units = reading.units;
      offset = reading.offset;
      scale  = reading.scale;
      digits = reading.digits;
      min = component.min;
      max = component.max;

      scaleFunc = function (val) {
        return scale * val + offset;
      };

      normalize = function (val) {
        return ((val - min) / (max - min) * 100) + "%";
      };

      labelIsReading = component.labelIsReading;
      labelText = labelIsReading ? "" : "Thermometer";

      // Calculate view.
      view = {
        id: component.id,
        labelText: labelIsReading ? "" : "Thermometer"
      };
      // Calculate tick labels positions.
      labels = component.labels;
      maxLength = -Infinity;
      view.labels = [];
      for (i = 0, len = labels.length; i < len; i++) {
        view.labels.push({
          label: labels[i].label,
          position: normalize(scaleFunc(labels[i].value))
        });
        if (labels[i].label.length > maxLength) {
          maxLength = labels[i].label.length;
          longestLabelIdx = i;
        }
      }
      // Render view.
      $elem = $(mustache.render(thermometerTpl, view));
      // Save useful references.
      $thermometer = $elem.find(".thermometer");
      $thermometerFill = $elem.find(".thermometer-fill");
      $bottomLabel = $elem.find(".label");
      $labelsContainer = $elem.find(".labels-container");

      // Calculate size of the "labels container" div.
      // It's used to ensure that wrapping DIV ($elem) has correct width
      // so layout system can work fine. We have to explicitly set its
      // width, as absolutely positioned elements (labels) are excluded
      // from the layout workflow.
      maxLength = $elem.measure(function() {
        // Calculate width of the longest label in ems (!).
        return (this.width() / parseFloat(this.css("font-size"))) + "em";
      }, ".value-label:eq(" + longestLabelIdx + ")", interactivesController.interactiveContainer);
      $labelsContainer.css("width", maxLength);

      // Support custom dimensions. Implementation may seem unclear,
      // but the goal is to provide most obvious behavior for authors.
      // We can simply set height of the most outer container.
      // Thermometer will adjusts itself appropriately.
      $elem.css("height", component.height);
      // Width is more tricky.
      fitWidth = false;
      if (!/%$/.test(component.width)) {
        // When it's ems or px, its enough to set thermometer width.
        $thermometer.css("width", component.width);
      } else {
        // Whet it's defined in %, set width of the most outer container
        // to that value and thermometer should use all available space
        // (100% or 100% - labels width).
        $elem.css("width", component.width);
        fitWidth = true;
      }
    }

    // Public API.
    controller = {
      // No modelLoadeCallback is defined. In case of need:
      modelLoadedCallback: function () {
        // TODO: update to observe actual system temperature once output properties are observable
        model.addPropertiesListener('targetTemperature', function() {
          updateThermometer();
        });
        updateThermometer();
      },

      // Returns view container.
      getViewContainer: function () {
        return $elem;
      },

      resize: function () {
        var thermometerHeight = $elem.height() - $bottomLabel.height();
        $thermometer.height(thermometerHeight);
        $labelsContainer.height(thermometerHeight);
        if (fitWidth) {
          // When user sets width in %, it means that the most outer container
          // width is equal to this value and thermometer shape should try to
          // use maximum available space.
          $thermometer.width($elem.width() - $labelsContainer.width());
        }
      },

      // Returns serialized component definition.
      serialize: function () {
        // Return the initial component definition.
        // Displayed value is always defined by the model,
        // so it shouldn't be serialized.
        return component;
      }
    };

    initialize();

    // Return Public API object.
    return controller;
  };
});

/*global define, $, model */

define('common/controllers/playback-controller',['require','common/inherit','common/controllers/interactive-component'],function (require) {

  var inherit              = require('common/inherit'),
      InteractiveComponent = require('common/controllers/interactive-component');

  /**
   * Playback controller.
   *
   * @constructor
   * @extends InteractiveComponent
   * @param {Object} component Component JSON definition.
   * @param {ScriptingAPI} scriptingAPI
   */
  function PlaybackController(component, scriptingAPI) {
    // Call super constructor.
    InteractiveComponent.call(this, "playback", component, scriptingAPI);

    this.$element.addClass("interactive-playback");

    /** @private */
    this._modelStopped = true;
    /** @private */
    this._modelPlayable = true;
    /** @private */
    this._showClock = true;
    /** @private */
    this._timeDesc = null;
    /** @private */
    this._$reset = $('<a class="reset"><i class="icon-step-backward"></i></a>').appendTo(this.$element);
    /** @private */
    this._$playPause = $('<a class="play-pause"><i class="icon-play"></i><i class="icon-pause"></i></a>').appendTo(this.$element);
    /** @private */
    this._$timeDisplay = $('<span class="time-display">').appendTo(this._$playPause);

    /** @private */
    this._$stepBackward = $('<a class="step"><i class="icon-backward"></i></a>').insertBefore(this._$playPause);
    /** @private */
    this._$stepForward = $('<a class="step"><i class="icon-forward"></i></a>').insertAfter(this._$playPause);

    this._$reset.after('<div class="spacer reset">');
    this._$stepBackward.after('<div class="spacer step">');
    this._$stepForward.before('<div class="spacer step">');

    // Bind click handlers.
    this._$reset.on("click", function () {
      scriptingAPI.api.reset();
    });
    this._$playPause.on("click", $.proxy(function () {
      if (this._modelStopped) {
        if (this._modelPlayable) {
          scriptingAPI.api.start();
        }
      } else {
        scriptingAPI.api.stop();
      }
    }, this));
    this._$stepBackward.on("click", function () {
      scriptingAPI.api.stepBack();
    });
    this._$stepForward.on("click", function () {
      scriptingAPI.api.stepForward();
    });
  }
  inherit(PlaybackController, InteractiveComponent);

  /**
   * Updates play / pause button.
   * @private
   */
  PlaybackController.prototype._simulationStateChanged = function () {
    this._modelStopped = model.isStopped();
    if (this._modelStopped) {
      this._$playPause.removeClass("playing");
    } else {
      this._$playPause.addClass("playing");
    }

    // Coerce undefined to *true* for models that don't have isPlayable property
    this._modelPlayable = model.properties.isPlayable === false ? false : true;
    if (this._modelPlayable) {
      this._$playPause.removeClass("disabled");
    } else {
      this._$playPause.addClass("disabled");
    }
  };

  /**
   * Enables or disables time display.
   * @private
   */
  PlaybackController.prototype._showClockChanged = function () {
    this._showClock = model.get("showClock");
    if (this._showClock) {
      this._$playPause.addClass("with-clock");
      // Update 'displayTime' description (used for formatting).
      this._timeDesc =  model.getPropertyDescription("displayTime");
      // Update clock immediately.
      this._timeChanged();
    } else {
      this._$playPause.removeClass("with-clock");
    }
  };

  /**
   * Updates time display.
   * @private
   */
  PlaybackController.prototype._timeChanged = function () {
    if (!this._showClock) {
      return;
    }
    this._$timeDisplay.html(this._timeDesc.format(model.get("displayTime")));
  };

  /**
   * Updates playback controller mode ("play", "play_reset" or "play_reset_step").
   * @private
   */
  PlaybackController.prototype._displayModeChanged = function () {
    var mode = model.get("controlButtons"),
        $buttons;
    if (!mode) { // mode === "" || mode === null || mode === false
      this.$element.find(".step, .reset, .play-pause").addClass("hidden");
    } else if (mode === "play") {
      this.$element.find(".play-pause").removeClass("hidden");
      this.$element.find(".spacer, .step, .reset").addClass("hidden");
    } else if (mode === "reset") {
      this.$element.find(".reset").removeClass("hidden");
      this.$element.find(".spacer, .play-pause, .step").addClass("hidden");
    } else if (mode === "play_reset") {
      this.$element.find(".spacer, .play-pause, .reset").removeClass("hidden");
      this.$element.find(".step").addClass("hidden");
    } else if (mode === "play_reset_step") {
      this.$element.find(".spacer, .step, .reset, .play-pause").removeClass("hidden");
    }
    $buttons = this.$element.find("a");
    $buttons.removeClass("first");
    $buttons.removeClass("last");
    $buttons = $buttons.not(".hidden");
    $buttons.first().addClass("first");
    $buttons.last().addClass("last");
  };

  /**
   * Implements optional callback supported by Interactive Controller.
   */
  PlaybackController.prototype.modelLoadedCallback = function () {
    // Update play / pause button.
    // Use event namespace to let multiple playbacks work fine with one model.
    model.on('play.' + this.component.id, $.proxy(this._simulationStateChanged, this));
    model.on('stop.' + this.component.id, $.proxy(this._simulationStateChanged, this));
    model.addPropertiesListener(["isPlayable"], $.proxy(this._simulationStateChanged, this));
    this._simulationStateChanged();
    model.addPropertiesListener(["showClock"], $.proxy(this._showClockChanged, this));
    model.addPropertiesListener(["displayTime"], $.proxy(this._timeChanged, this));
    this._showClockChanged();
    // Update display mode (=> buttons are hidden or visible).
    model.addPropertiesListener(["controlButtons"], $.proxy(this._displayModeChanged, this));
    this._displayModeChanged();
  };

  return PlaybackController;
});

/*global define */

define('common/controllers/div-controller',['require','common/inherit','common/controllers/interactive-component'],function (require) {

  var inherit              = require('common/inherit'),
      InteractiveComponent = require('common/controllers/interactive-component');

  /**
   * Simplest component controller which just inherits from InteractiveComponent, simply
   * creating a div element. Component can have dimensions, css classes and on onClick
   * function.
   * @param {Object} component Component JSON definition.
   * @param {ScriptingAPI} scriptingAPI
   */
  function DivController(component, scriptingAPI) {

    // Call super constructor.
    InteractiveComponent.call(this, "div", component);

  }
  inherit(DivController, InteractiveComponent);

  return DivController;
});

/*global define, $ */

define('common/controllers/setup-banner',['lab.config','common/controllers/text-controller','common/controllers/image-controller','common/controllers/div-controller','common/controllers/playback-controller'],function () {

  var labConfig          = require('lab.config'),
      TextController     = require('common/controllers/text-controller'),
      ImageController    = require('common/controllers/image-controller'),
      DivController      = require('common/controllers/div-controller'),
      PlaybackController = require('common/controllers/playback-controller'),

      topBarHeight    = 1.5,
      topBarFontScale = topBarHeight*0.65,
      topBarVerticalPadding = topBarHeight/10;

  /**
   * Returns a hash containing:
   *  - components,
   *  - containers,
   *  - layout definition (components location).
   * All these things are used to build the interactive banner.
   *
   * @param {ScriptingAPI} scriptingAPI Initialized ScriptingAPI object.
   * @param {Object} interactive Interactive JSON definition.
   * @param {CreditsDialog} creditsDialog
   * @param {AboutDialog} aboutDialog
   * @param {ShareDialog} shareDialog
   */
  return function setupBanner(scriptingAPI, interactive, creditsDialog, aboutDialog, shareDialog) {
    var components = {},
        template = [],
        layout = {},
        // About link visible if there is about section or subtitle.
        haveAboutText = interactive.about || interactive.subtitle,
        body, requestFullscreenMethod;

    template.push({
      "id": "top-bar",
      "top": "0",
      "left": "0",
      "height": topBarHeight + "em",
      "padding-top": topBarVerticalPadding + "em",
      "padding-bottom": topBarVerticalPadding + "em",
      "width": "container.width",
      "aboveOthers": true
    });

    template.push({
      "id": "bottom-bar",
      "bottom": "container.height",
      "left": "0",
      "width": "container.width",
      "height": "2.5em",
      "belowOthers": true
    });

    function createElementInContainer(element, container) {
      var Controller;

      if (element.type === "text") {
        Controller = TextController;
      } else if (element.type === "image") {
        Controller = ImageController;
      } else if (element.type === "div") {
        Controller = DivController;
      } else if (element.type === "playback") {
        Controller = PlaybackController;
      }

      components[element.id] = new Controller(element, scriptingAPI);
      template.push(container);
      layout[container.id] = [element.id];
    }

    // Define about link only if "about" or "subtitle" section is available.
    aboutDialog.update(interactive);
    createElementInContainer({
      "type": "text",
      "id": "about-link",
      "text": "About",
      "onClick": function () {
        if (haveAboutText) {
          aboutDialog.open();
        } else {
          creditsDialog.open();
        }
      }
    },
    {
      "id": "banner-right",
      "fontScale": topBarFontScale,
      "top": "0",
      "height": topBarHeight + "em",
      "padding-top": topBarVerticalPadding + "em",
      "padding-bottom": topBarVerticalPadding + "em",
      "right": "interactive.width",
      "padding-left": "1em",
      "padding-right": "0.75em",
      "align": "right",
      "aboveOthers": true
    });

    // Define sharing link only if sharing is enabled.
    // Note that due to layout limitations, banner-middle container
    // has to be defined *after* banner-right container which is used
    // in its specification!
    if (labConfig.sharing) {
      shareDialog.update(interactive);
      createElementInContainer(
      {
        "type": "text",
        "id": "share-link",
        "text": "Share",
        "onClick": function () { shareDialog.open(); }
      },
      {
        "id": "banner-middle",
        "fontScale": topBarFontScale,
        "top": "0",
        "height": topBarHeight + "em",
        "padding-top": topBarVerticalPadding + "em",
        "padding-bottom": topBarVerticalPadding + "em",
        // "banner-right" can be undefined, so check it.
        "right": "banner-right.left",
        "padding-right": "1em",
        "align": "right",
        "aboveOthers": true
      });
    }

    // bottom bar
    creditsDialog.update(interactive);
    createElementInContainer(
    {
      "type": "div",
      "id": "credits-link",
      "height": "2.5em",
      "width": "8.1em",
      "classes": ["credits"],
      "tooltip": "Credits",
      "onClick": function () { creditsDialog.open(); }
    },
    {
      "id": "banner-bottom-left",
      "bottom": "container.height",
      "left": "0",
      "padding-left": "0.3em",
      "align": "left",
      "belowOthers": true
    });

    // see if we can go fullscreen. If we can, add a fullscreen button.
    // Note: This requires iframe to be embedded with 'allowfullscreen=true' (and
    // browser-specific variants). If iframe is not embedded with this property, button
    // will show but will not work. It is not clear whether we can find out at this moment
    // whether iframe was embedded appropriately.
    body = document.body;

    requestFullscreenMethod =
         body.requestFullScreen ||
         body.webkitRequestFullScreen ||
         body.mozRequestFullScreen ||
         body.msRequestFullScreen;

    document.cancelFullscreenMethod =
         document.cancelFullScreen ||
         document.webkitCancelFullScreen ||
         document.mozCancelFullScreen ||
         document.msCancelFullScreen;

    function isFullscreen() {
      // this doesn't yet exist in Safari
      if (document.fullscreenElement||
          document.webkitFullscreenElement ||
          document.mozFullScreenElement) {
        return true;
      }
      // annoying hack to check Safari
      return ~$(".fullscreen").css("background-image").indexOf("exit");
    }

    if (requestFullscreenMethod) {
      createElementInContainer(
      {
        "type": "div",
        "id": "fullsize-link",
        "height": "2.5em",
        "width": "2.5em",
        "classes": ["fullscreen"],
        "tooltip": "Open interactive in full-screen mode",
        "onClick": function () {
          if (!isFullscreen()) {
            requestFullscreenMethod.call(body);
          } else {
            document.cancelFullscreenMethod();
          }
        }
      },
      {
        "id": "banner-bottom-right",
        "bottom": "container.height",
        "right": "container.width",
        "align": "left",
        "padding-left": "1em",
        "belowOthers": true
      });
    }

      createElementInContainer(
      {
        "type": "playback",
        "id": "playback"
      },
      {
        "id": "interactive-playback-container",
        "bottom": "container.height",
        "left": "container.width/2 - interactive-playback-container.width/2",
        "height": "banner-bottom-left.height",
        "belowOthers": true
      });

    return {
      components: components,
      template: template,
      layout: layout
    };
  };
});

/*global define, $ */

define('common/controllers/basic-dialog',[],function () {

  var defOptions = {
    autoOpen: false,
    dialogClass: "interactive-dialog",
    // Ensure that font is being scaled dynamically!
    appendTo: "#responsive-content",
    width: "80%"
  };

  /**
   * Simple wrapper around the jQuery UI Dialog,
   * which provides useful defaults and simple interface.
   *
   * @constructor
   * @param {Object} options jQuery UI Dialog options.
   */
  function BasicDialog(options) {
    /**
     * Basic dialog elements.
     * @type {jQuery}
     */
    this.$element = $('<div>');
    // Create jQuery UI Dialog.
    this.$element.dialog($.extend({}, defOptions, options));
  }

  /**
   * Opens the dialog.
   */
  BasicDialog.prototype.open = function() {
    this.$element.dialog("open");
  };

  /**
   * Sets jQuery UI Dialog option.
   *
   * @param {string} key
   * @param {Object} value
   */
  BasicDialog.prototype.set = function(key, value) {
    this.$element.dialog("option", key, value);
  };

  /**
   * Sets content of the dialog.
   *
   * @param {jQuery|DOM|string} $content Any value that can be accepted by the jQuery constructor.
   */
  BasicDialog.prototype.setContent = function ($content) {
    this.$element.empty();
    // Not very pretty, but probably the simplest and most reliable way to
    // disable autofocus in jQuery UI dialogs. See:
    // http://jqueryui.com/upgrade-guide/1.10/#added-ability-to-specify-which-element-to-focus-on-open
    this.$element.append('<input type="hidden" autofocus="autofocus" />');
    this.$element.append($content);
  };

  return BasicDialog;
});

/*global define, $ */
define('common/controllers/about-dialog',['require','arrays','markdown','common/inherit','common/controllers/basic-dialog'],function (require) {

  var arrays      = require('arrays'),
      markdown    = require('markdown'),
      inherit     = require('common/inherit'),
      BasicDialog = require('common/controllers/basic-dialog');

  /**
   * About Dialog. Inherits from Basic Dialog.
   *
   * @constructor
   */
  function AboutDialog() {
    BasicDialog.call(this, {dialogClass: "about-dialog"});
  }
  inherit(AboutDialog, BasicDialog);

  /**
   * Updates dialog content using interactive JSON definition.
   *
   * @param {Object} interactive Interactive JSON definition.
   */
  AboutDialog.prototype.update = function(interactive) {
    var $aboutContent = $("<div>"),
        about,
        content,
        html,
        openInNewWindow = 'class="opens-in-new-window" target="blank"';

    this.set("title", "About: " + interactive.title);

    // Ensure that common typography for markdown-generated content is used.
    $aboutContent.addClass("markdown-typography");
    if (interactive.subtitle) {
      html = markdown.toHTML(interactive.subtitle);
      html = html.replace(/<a(.*?)>/, "<a$1 " + openInNewWindow + ">");
      $aboutContent.append(html);
    }
    about = arrays.isArray(interactive.about) ? interactive.about : [interactive.about];
    content = "";
    $.each(about, function(idx, val) {
      content += val + "\n";
    });
    html = markdown.toHTML(content);
    html = html.replace(/<a(.*?)>/g, "<a$1 " + openInNewWindow + ">");
    $aboutContent.append(html);

    this.setContent($aboutContent);
  };

  return AboutDialog;
});

define('text!common/controllers/share-dialog.tpl',[],function () { return '<div>\n  <h2>\n    Paste this\n    <a class=\'opens-in-new-window\' href=\'{{embeddableSharingUrl}}\' target=\'_blank\'>link</a>\n    in email or IM.\n  </h2>\n  <textarea>{{embeddableSharingUrl}}</textarea>\n  <h2>Paste HTML to embed in website or blog.</h2>\n  <p>Select Size:\n    <select id=\'iframe-size\'>\n      <option value=\'smaller\'>30% smaller</option>\n      <option selected value=\'actual\'>actual</option>\n      <option value=\'larger\'>50% larger</option>\n    </select>\n  </p>\n  <textarea id=\'share-iframe-content\'></textarea>\n  {{> copyright}}\n</div>\n';});

define('text!common/controllers/copyright.tpl',[],function () { return '<div class="copyright-section"><strong>Copyright  2013&nbsp;</strong><a class="opens-in-new-window" href="http://concord.org" id="share-license-link" target="_blank">The Concord Consortium</a>. All rights reserved. The software is licensed under&nbsp;<a class="opens-in-new-window" href="http://opensource.org/licenses/BSD-2-Clause" id="share-license-link" target="_blank">Simplified BSD</a>, <a class="opens-in-new-window" href="http://opensource.org/licenses/MIT" id="share-license-link" target="_blank">MIT</a> or <a class="opens-in-new-window" href="http://opensource.org/licenses/Apache-2.0" id="share-license-link" target="_blank">Apache 2.0</a> licenses. Please provide attribution to the Concord Consortium and the URL&nbsp;<a class="opens-in-new-window" href="http://concord.org/" id="share-license-link" target="_blank">http://concord.org</a>.</div>';});

/*global define, $ */
define('common/controllers/share-dialog',['require','lab.config','mustache','common/inherit','common/controllers/basic-dialog','text!common/controllers/share-dialog.tpl','text!common/controllers/copyright.tpl'],function (require) {

  var labConfig      = require('lab.config'),
      mustache       = require('mustache'),
      inherit        = require('common/inherit'),
      BasicDialog    = require('common/controllers/basic-dialog'),
      shareDialogTpl = require('text!common/controllers/share-dialog.tpl'),
      copyrightTpl   = require('text!common/controllers/copyright.tpl'),

      location = document.location,

      // A tiny template, so define it inline and compile immediately.
      iframeTpl = mustache.compile('<iframe width="{{width}}px" height="{{height}}px" ' +
        'frameborder="no" scrolling="no" allowfullscreen="true" webkitallowfullscreen="true"' +
        ' mozallowfullscreen="true" src="{{{embeddableSharingUrl}}}"></iframe>');

  /**
   * Share Dialog. Inherits from Basic Dialog.
   *
   * @constructor
   * @param {Object} interactive Interactive JSON definition.
   * @param {InteractivesController} interactivesController
   */
  function ShareDialog() {
    var hash           = location.hash,
        origin         = location.href.match(/(.*?\/\/.*?)\//)[1],
        embeddablePath = location.pathname.replace(/\/[^\/]+$/, "/embeddable.html");

    BasicDialog.call(this, {dialogClass: "share-dialog"});

    /** @private */
    this._view = {};

    if (labConfig.homeForSharing) {
      this._view.embeddableSharingUrl = labConfig.homeForSharing + labConfig.homeEmbeddablePath + hash;
    } else {
      this._view.embeddableSharingUrl = origin + embeddablePath + hash;
    }

    this.setContent(mustache.render(shareDialogTpl, this._view, {copyright: copyrightTpl}));

    /** @private */
    this._$interactiveContainer = $("#responsive-content");
    /** @private */
    this._$iframeSize = this.$element.find("#iframe-size");
    /** @private */
    this._$iframeContent = this.$element.find("#share-iframe-content");

    this._$iframeSize.on('change', $.proxy(this.updateIframeSize, this));
    this.updateIframeSize();
  }
  inherit(ShareDialog, BasicDialog);

  /**
   * Updates size of the Interactive iframe in the share dialog.
   */
  ShareDialog.prototype.updateIframeSize = function () {
    var actualWidth = this._$interactiveContainer.innerWidth(),
        actualHeight = this._$interactiveContainer.innerHeight(),
        sizeChoice = this._$iframeSize.val();

    switch(sizeChoice) {
    case "smaller":
      this._view.width = Math.floor(actualWidth * 0.7);
      this._view.height = Math.floor(actualHeight  * 0.7);
      break;
    case "larger":
      this._view.width = Math.floor(actualWidth * 1.5);
      this._view.height = Math.floor(actualHeight  * 1.5);
      break;
    default:
      this._view.width = actualWidth;
      this._view.height = actualHeight;
      break;
    }

    this._$iframeContent.val(iframeTpl(this._view));
  };

  /**
   * Updates dialog content using interactive JSON definition.
   *
   * @param {Object} interactive Interactive JSON definition.
   */
  ShareDialog.prototype.update = function(interactive) {
    this.set("title", "Share: " + interactive.title);
  };

  return ShareDialog;
});

define('text!common/controllers/credits-dialog.tpl',[],function () { return '<div>\n  <p>\n    This interactive was created by the <a href="{{concordUrl}}" target="_blank">Concord Consortium</a>\n    using our <a href="{{nextGenUrl}}" target="_blank">Next-Generation Molecular Workbench</a> software,\n    with funding by a grant from <a href="http://www.google.org/" target="_blank">Google.org</a>.\n   </p>\n   {{#showShareable}}\n   <p>\n      Find a <a href="{{interactiveCreditsUrl}}" class="opens-in-new-window" target="_blank">shareable version</a>\n      of this interactive along with dozens of other open-source interactives for science, math and engineering at\n      <a href="{{concordUrl}}" class="opens-in-new-window" target="_blank">concord.org</a>.\n    </p>\n    {{/showShareable}}\n  {{> copyright}}\n</div>\n';});

/*global define */
define('common/controllers/credits-dialog',['require','lab.config','mustache','common/inherit','common/controllers/basic-dialog','text!common/controllers/credits-dialog.tpl','text!common/controllers/copyright.tpl'],function (require) {

  var labConfig        = require('lab.config'),
      mustache         = require('mustache'),
      inherit          = require('common/inherit'),
      BasicDialog      = require('common/controllers/basic-dialog'),
      creditsDialogTpl = require('text!common/controllers/credits-dialog.tpl'),
      copyrightTpl     = require('text!common/controllers/copyright.tpl');

  /**
   * Credits Dialog. Inherits from Basic Dialog.
   *
   * @constructor
   */
  function CreditsDialog() {
    BasicDialog.call(this, {dialogClass: "credits-dialog"});
  }
  inherit(CreditsDialog, BasicDialog);

  /**
   * Updates dialog content using interactive JSON definition.
   *
   * @param {Object} interactive Interactive JSON definition.
   */
  CreditsDialog.prototype.update = function(interactive) {
    var view = {
          concordUrl: 'http://concord.org',
          nextGenUrl: 'http://mw.concord.org/nextgen/'
        },
        hash = document.location.hash,
        utmString;

    this.set("title", "Credits: " + interactive.title);

    if (labConfig.homeForSharing) {
      view.interactiveCreditsUrl = labConfig.homeForSharing + labConfig.homeEmbeddablePath + hash;
    } else {
      view.interactiveCreditsUrl = labConfig.home + labConfig.homeEmbeddablePath + hash;
    }

    if (labConfig.utmCampaign) {
      utmString = "utm_source=" + encodeURIComponent(interactive.title.replace(/ /gi,"+")) +
        "&utm_medium=embedded_interactive&utm_campaign=" + labConfig.utmCampaign;
      view.concordUrl += "?" + utmString;
      view.nextGenUrl += "?" + utmString;
      view.interactiveCreditsUrl += "&" + encodeURI("utm_source=embed_link&utm_medium=embedded_interactive&utm_campaign=" + labConfig.utmCampaign);
    }

    if (!labConfig.sharing) {
      view.showShareable = true;
    }

    this.setContent(mustache.render(creditsDialogTpl, view, {copyright: copyrightTpl}));
  };

  return CreditsDialog;
});

/*global define: false */
// ------------------------------------------------------------
//
//   Semantic Layout Configuration
//
// ------------------------------------------------------------

define('common/layout/semantic-layout-config',[],function () {
  return {
    /**
      Maximum number of iterations of the layout algorithm during single layoutInteractive() call.
    */
    iterationsLimit: 35,
    /**
      Minimum width of the model.
    */
    minModelWidth: 150,
    /**
      Minimum font size (in ems).
    */
    minFontSize: 0.65,
    /**
      Canoncical font size (in ems).
    */
    canonicalFontSize: 0.9,
    /**
      Canonical dimensions of the interactive, they decide about font size.
      (canoncicalFontSize * fontScale) em is used for the interactive which fits this container:
    */
    canonicalInteractiveWidth: 600,
    canonicalInteractiveHeight: 420,
    /**
      Colors used to mark layout containers in the authoring mode.
    */
    containerColors: [
      "rgba(0,0,255,0.1)", "rgba(255,0,0,0.1)", "rgba(0,255,0,0.1)", "rgba(255,255,0,0.1)",
      "rgba(0,255,255,0.1)", "rgba(255,255,128,0.1)", "rgba(128,255,0,0.1)", "rgba(255,128,0,0.1)"
    ]
  };
});
/*global define: false, $: false */
// ------------------------------------------------------------
//
//   Semantic Layout
//
// ------------------------------------------------------------

define('common/layout/semantic-layout',['require','lab.config','common/layout/semantic-layout-config','arrays','common/console','common/alert'],function (require) {

  var labConfig    = require('lab.config'),
      layoutConfig = require('common/layout/semantic-layout-config'),
      arrays       = require('arrays'),
      console      = require('common/console'),
      alert        = require('common/alert');

  return function SemanticLayout($interactiveContainer) {
        // Public API.
    var layout,

        // Array of containers specifications.
        containerSpecList,
        // Hash containing content of container for a given container ID.
        containersContent,
        // Hash of component controllers.
        componentByID,
        modelController,
        fontScale,

        // Container specifications by ID.
        containerSpecByID,
        // Container jQuery objects by ID.
        $containerByID,
        // Model container jQuery object.
        $modelContainer,

        // Interactive dimensions which fits canonical dimensions.
        // So, basic dimensions are <= canonical dimensions.
        // They are required to correctly determine font size
        // (as we can't simply use canonical dimensions).
        basicInteractiveWidth,
        basicInteractiveHeight,

        // Interactive aspect ratio. It's used to determine font size.
        // Note that it may change a little bit during resizing (as there are
        // some dimensions defined in px, like borders, user agent styles etc.),
        // however this slight differences don't have any significant impact on result.
        interactiveAspectRatio,

        // Dimensions of the container.
        availableWidth,
        availableHeight,

        // Amount to inset the model and components from the top left
        padding = 10,

        // Most important variables.
        // In fact they define state of the layout.
        modelWidth,
        modelTop,
        modelLeft,
        topBoundary,
        leftBoundary,
        bottomBarWidth;

    function reset() {
      modelWidth = layoutConfig.minModelWidth;
      modelTop = 0;
      modelLeft = 0;
      topBoundary = 0;
      leftBoundary = 0;
      bottomBarWidth = 0;
    }

    function getDimensionOfContainer($container, dim) {
      var position = $container.position();

      switch (dim) {
        case "top":
          return position.top;
        case "bottom":
          return position.top + $container.outerHeight();
        case "left":
          return position.left;
        case "right":
          return position.left + $container.outerWidth();
        case "height":
          return $container.outerHeight();
        case "width":
          return $container.outerWidth();
      }
    }

    function setFontSize() {
      var containerAspectRatio = $interactiveContainer.width() / $interactiveContainer.height(),
          containerScale, font;

      if (interactiveAspectRatio <= containerAspectRatio) {
        containerScale = $interactiveContainer.height() / basicInteractiveHeight;
      } else {
        containerScale = $interactiveContainer.width() / basicInteractiveWidth;
      }

      padding = containerScale * 10;

      font = layoutConfig.canonicalFontSize * fontScale * containerScale;

      // Ensure min font size (in 'em').
      if (font < layoutConfig.minFontSize) {
        font = layoutConfig.minFontSize;
      }

      // Set font-size of #responsive-content element. So, if application author
      // wants to avoid rescaling of font-size for some elements, they should not
      // be included in #responsive-content DIV.
      // TODO: #responsive-content ID is hardcoded, change it?
      $("#responsive-content").css("font-size", font + "em");
    }

    function setupBackground() {
      var colors = layoutConfig.containerColors,
          id, i, len;

      for (i = 0, len = containerSpecList.length; i < len; i++) {
        id = containerSpecList[i].id;
        $containerByID[id].css("background", labConfig.authoring ? colors[i % colors.length] : "");
      }
    }

    function createContainers() {
      var container, id, prop, i, ii;

      // Cleanup interactive container.
      $interactiveContainer.empty();

      $containerByID = {};
      containerSpecByID = {};

      for (i = 0, ii = containerSpecList.length; i < ii; i++) {
        container = containerSpecList[i];
        id = container.id;
        containerSpecByID[id] = container;
        $containerByID[id] = $("<div id='" + id + "'>").appendTo($interactiveContainer);
        $containerByID[id].css({
          "display": "inline-block",
          "position": "absolute"
        });

        if (container.width === undefined) {
          // Disable wrapping of elements in a container, which
          // doesn't define explicit width. It's required to calculate
          // layout correctly.
          $containerByID[id].css("white-space", "nowrap");
        }

        for (prop in container) {
          if (!container.hasOwnProperty(prop)) continue;
          // Add any padding-* properties directly to the container's style.
          if (/^padding-/.test(prop)) {
            $containerByID[id].css(prop, container[prop]);
          }
          // Support also "align" property.
          else if (prop === "align") {
            $containerByID[id].css("text-align", container[prop]);
          }
          else if (prop === "min-width") {
            $containerByID[id].css("min-width", container[prop]);
          }
          else if (prop === "fontScale") {
            $containerByID[id].css("font-size", container[prop] + "em");
          }
        }
      }
    }

    function placeComponentsInContainers() {
      var id, containerID, divContents, items,
          $row, $rows, $containerComponents,
          lastContainer, comps, errMsg,
          i, ii, j, jj, k, kk;

      comps = $.extend({}, componentByID);

      for (containerID in containersContent) {
        if (!containersContent.hasOwnProperty(containerID)) continue;

        if (!$containerByID[containerID]) {
          // Inform an author and skip this container.
          errMsg = "Incorrect layout definition - '" + containerID + "' container does not exist.";
          alert(errMsg);
          continue;
        }

        divContents = containersContent[containerID];

        if (!arrays.isArray(divContents)) {
          // Inform an author and skip this container.
          errMsg = "Incorrect layout definition for '" + containerID + "' container. It should specify " +
                   "an array of components or an array of arrays of components (multiple rows).";
          alert(errMsg);
          continue;
        }

        if (!arrays.isArray(divContents[0])) {
          // Only one row specified. Wrap it into array to process it easier.
          divContents = [divContents];
        }

        for (j = 0, jj = divContents.length; j < jj; j++) {
          items = divContents[j];
          $row = $('<div class="interactive-row"/>');
          // Each row should have width 100% of its parent container.
          $row.css("width", "100%");
          // When there is only one row, ensure that it fills whole container.
          if (jj === 1) {
            $row.css("height", "100%");
          }
          $containerByID[containerID].append($row);
          for (k = 0, kk = items.length; k < kk; k++) {
            id = items[k];
            if (comps[id] === undefined) {
              // Inform an author and skip this definition.
              alert("Incorrect layout definition. Component with ID '" + id + "'' is not defined.");
              continue;
            }
            $row.append(comps[id].getViewContainer());
            delete comps[id];
          }
        }
      }

      // Add any remaining components to "bottom" or last container.
      lastContainer = containerSpecByID.bottom || containerSpecList[containerSpecList.length-1];
      $rows = $containerByID[lastContainer.id].children();
      $row = $rows.last();
      if (!$row.length) {
        $row = $('<div class="interactive-row"/>');
        $containerByID[lastContainer.id].append($row);
      }
      for (id in comps) {
        if (!comps.hasOwnProperty(id)) continue;
        $row.append(comps[id].getViewContainer());
      }

      // When there are multiple components in a container, ensure that there
      // is spacing between them.
      // See src/sass/lab/_semantic-layout.sass for .component-spacing class definition.
      for (i = 0, ii = containerSpecList.length; i < ii; i++) {
        // First children() call returns rows, second one components.
        $containerComponents = $containerByID[containerSpecList[i].id].children().children();
        if ($containerComponents.length > 1) {
          $containerComponents.addClass("component-spacing");
        }
      }
    }

    function positionContainers() {
      var container, $container,
          left, top, right, bottom, height, i, ii, id;

      $modelContainer.css({
        width:  modelWidth,
        height: modelController.getHeightForWidth(modelWidth),
        left:   modelLeft,
        top:    modelTop
      });

      for (i = 0, ii = containerSpecList.length; i<ii; i++) {
        container = containerSpecList[i];
        $container = $containerByID[container.id];

        if (!container.left && !container.right) {
          container.left = "0";
        }
        if (!container.top && !container.bottom) {
          container.top = "0";
        }

        if (container.left) {
          left = parseDimension(container.left);
          $container.css("left", left);
        }
        if (container.top) {
          top = parseDimension(container.top);
          $container.css("top", top);
        }
        if (container.height) {
          $container.css("height", parseDimension(container.height));
        }
        if (container.width) {
          $container.css("width", parseDimension(container.width));
        }
        if (container.right) {
          right = parseDimension(container.right);
          if (container.left) {
            $container.css("width", right - left);
          } else {
            left = right - $container.outerWidth();
            $container.css("left", left);
          }
        }
        if (container.bottom) {
          bottom = parseDimension(container.bottom);
          if (container.top) {
            $container.css("height", bottom - top);
          } else {
            top = bottom - $container.outerHeight();
            $container.css("top", top);
          }
        }

        // Containers with "aboveOthers" property should be treated in a special
        // way. It's a group of absolutely positioned containers, which is always
        // placed above other containers. So, in fact they define topBoundary
        // for other components.
        if (container.aboveOthers) {
          bottom = getDimensionOfContainer($container, "bottom") + padding;
          if (bottom > topBoundary) {
            topBoundary = bottom;
          }
        }
        if (container.belowOthers) {
          height = getDimensionOfContainer($container, "height") + padding;
          if (height > bottomBarWidth) {
            bottomBarWidth = height;
          }
        }
      }

      leftBoundary = padding;

      // Shift typical containers (aboveOther == false) according to the top boundary.
      for (id in $containerByID) {
        if (!$containerByID.hasOwnProperty(id)) continue;
        if (containerSpecByID[id] && containerSpecByID[id].aboveOthers) continue;
        if (containerSpecByID[id] && containerSpecByID[id].belowOthers) continue;
        $container = $containerByID[id];
        top = getDimensionOfContainer($container, "top");
        $container.css("top", top + topBoundary);
        left = getDimensionOfContainer($container, "left");
        $container.css("left", left + leftBoundary);
      }
    }

    // shrinks the model to fit in the interactive, given the sizes
    // of the other containers around it.
    function resizeModelContainer() {
      var maxX = -Infinity,
          maxY = -Infinity,
          minX = Infinity,
          minY = Infinity,
          id, $container,
          right, bottom, top, left, ratio;

      for (id in $containerByID) {
        if (!$containerByID.hasOwnProperty(id)) continue;
        if (containerSpecByID[id] && containerSpecByID[id].aboveOthers) continue;
        if (containerSpecByID[id] && containerSpecByID[id].belowOthers) continue;
        $container = $containerByID[id];
        right = getDimensionOfContainer($container, "right");
        if (right > maxX) {
          maxX = right;
        }
        bottom = getDimensionOfContainer($container, "bottom");
        if (bottom > maxY) {
          maxY = bottom;
        }
        left = getDimensionOfContainer($container, "left");
        if (left < minX) {
          minX = left;
        }
        top = getDimensionOfContainer($container, "top");
        if (top < minY) {
          minY = top;
        }
      }

      // TODO: this is quite naive approach.
      // It should be changed to some fitness function defining quality of the layout.
      // Using current algorithm, very often we follow some local minima.
      if ((maxX <= availableWidth && maxY <= (availableHeight-bottomBarWidth)) &&
          (Math.abs(availableWidth - maxX) < 1 || Math.abs((availableHeight-bottomBarWidth) - maxY) < 1) &&
          (Math.abs(minX - leftBoundary) < 1 && Math.abs(minY - topBoundary) < 1)) {
        // Perfect solution found!
        // (TODO: not so perfect, see above)
        return true;
      }

      ratio = Math.min(availableWidth / maxX, (availableHeight-bottomBarWidth) / maxY);
      if (!isNaN(ratio)) {
        modelWidth = modelWidth * ratio;
      }
      if (modelWidth < layoutConfig.minModelWidth) {
        modelWidth = layoutConfig.minModelWidth;
      }

      modelLeft -= minX - leftBoundary;
      modelTop -= minY - topBoundary;

      return false;
    }

    // parses arithmetic such as "model.height/2"
    function parseDimension(dim) {
      var vars, i, ii, value;

      if (typeof dim === "number" || /^[0-9]+\.?[0-9]*(em)?$/.test(dim)) {
        return dim;
      }

      // find all strings of the form x.y
      vars = dim.match(/[a-zA-Z\-]+\.[a-zA-Z]+/g);

      // replace all x.y's with the actual dimension
      for (i=0, ii=vars.length; i<ii; i++) {
        value = getDimension(vars[i]);
        dim = dim.replace(vars[i], value);
      }
      // eval only if we contain no more alphabetic letters
      if (/^[^a-zA-Z]*$/.test(dim)) {
        return eval(dim);
      } else {
        return 0;
      }
    }

    // Parses a container's dimension, such as "model.height".
    function getDimension(dim) {
      switch(dim) {
        case "container.width":
          return availableWidth;
        case "container.height":
          return availableHeight;
        case "interactive.width":
          return availableWidth - leftBoundary;
        case "interactive.height":
          return availableHeight - topBoundary - bottomBarWidth;
        default:
          dim = dim.split(".");
          return getDimensionOfContainer($containerByID[dim[0]], dim[1]);
      }
    }

    function calcInteractiveAspectRatio() {
      var redraws = layoutConfig.iterationsLimit,
          canonicalInteractiveWidth = layoutConfig.canonicalInteractiveWidth,
          canonicalInteractiveHeight = layoutConfig.canonicalInteractiveHeight,
          canonicalAspectRatio = canonicalInteractiveWidth / canonicalInteractiveHeight,
          maxX = -Infinity,
          maxY = -Infinity,
          id, $container, val;

      reset();
      availableWidth = canonicalInteractiveWidth;
      availableHeight = canonicalInteractiveHeight;
      modelWidth = availableWidth;

      // Set basic interactive dimensions to default values to ensure that default font will be used.
      basicInteractiveWidth = canonicalInteractiveWidth;
      basicInteractiveHeight = canonicalInteractiveHeight;

      // Set font size to ensure that "fontScale" and "canonicalFontSize" are taken into account.
      setFontSize();

      positionContainers();
      while (--redraws > 0 && !resizeModelContainer()) {
        positionContainers();
      }

      console.log('[layout] aspect ratio calc: ' + (layoutConfig.iterationsLimit - redraws) + ' iterations');

      for (id in $containerByID) {
        if (!$containerByID.hasOwnProperty(id)) continue;
        $container = $containerByID[id];
        val = getDimensionOfContainer($container, "right");
        if (val > maxX) {
          maxX = val;
        }
        val = getDimensionOfContainer($container, "bottom");
        if (val > maxY) {
          maxY = val;
        }
      }

      interactiveAspectRatio = maxX / maxY;
      if (interactiveAspectRatio < canonicalAspectRatio) {
        basicInteractiveWidth = canonicalInteractiveHeight * interactiveAspectRatio;
        basicInteractiveHeight = canonicalInteractiveHeight;
      } else {
        basicInteractiveWidth = canonicalInteractiveWidth;
        basicInteractiveHeight = canonicalInteractiveWidth / interactiveAspectRatio;
      }
    }

    // Public API.
    layout = {
      /**
       * Setups interactive layout. Cleanups interactive container, creates new containers and places
       * components inside them.
       *
       * This method should be called each time when at least one of the following objects is changed:
       *  - layout template,
       *  - component locations,
       *  - components,
       *  - model controller,
       *  - font scale.
       *
       * @param {array} newContainers List of layout containers.
       * @param {Object} newContainersContent Hash of components locations, e.g. {"bottom": ["button", "textLabel"]}.
       * @param {Object} newComponents Hash of components controllers. Keys are IDs of the components.
       *
       * @param {number} newFontScale Font scale, floating point number, typically between 0.5 and 1.5.
       */
      initialize: function(newContainers, newContainersContent, newComponents, newFontScale) {
        containerSpecList = newContainers;
        containersContent = newContainersContent;
        componentByID = newComponents;
        fontScale = newFontScale;

        createContainers();
        placeComponentsInContainers();

        // Clear previous aspect ratio, as new components
        // can completely change it.
        interactiveAspectRatio = null;
      },

      /**
       * Setups model controller, as well as model container provided by it.
       * Model Controller should implement getViewVontainer() method.
       * Always call this function after initialize()!
       *
       * @param {ModelController} newModelController Model Controller object.
       */
      setupModel: function (newModelController) {
        modelController = newModelController;
        // Clear previous aspect ratio, as new model
        // can completely change it.
        interactiveAspectRatio = null;

        if ($containerByID.model) {
          if ($containerByID.model === modelController.getViewContainer()) {
            // Do nothing, the valid model container is already inside interactive container.
            return;
          }
          // If there is an old model container, remove it.
          $containerByID.model.remove();
        }

        $modelContainer = modelController.getViewContainer();
        $modelContainer.css({
          "display": "inline-block",
          "position": "absolute",
          "z-index": "0"
        });
        $modelContainer.appendTo($interactiveContainer);
        $containerByID.model = $modelContainer;
      },

      /**
       * Layouts interactive. Adjusts size of the model container to ensure that all components are inside the
       * interactive container and all available space is used in the best way.
       */
      layoutInteractive: function () {
        var redraws = layoutConfig.iterationsLimit,
            id;

        console.time('[layout] update');

        if (!interactiveAspectRatio) {
          // Calculate aspect ratio when it's needed.
          // Adding a new component or model change can invalidate current
          // aspect ratio.
          calcInteractiveAspectRatio();
        }

        reset();
        availableWidth  = $interactiveContainer.width();
        availableHeight = $interactiveContainer.height();
        modelWidth = availableWidth; // optimization

        // 0. Set font size of the interactive-container based on its size.
        setFontSize();

        // 1. Calculate optimal layout.
        positionContainers();
        while (--redraws > 0 && !resizeModelContainer()) {
          positionContainers();
        }
        console.log('[layout] update: ' + (layoutConfig.iterationsLimit - redraws) + ' iterations');

        // 2. Notify components that their containers have new sizes.
        modelController.resize();
        for (id in componentByID) {
          if (componentByID.hasOwnProperty(id) && componentByID[id].resize !== undefined) {
            componentByID[id].resize();
          }
        }

        // 3. Set / remove colors of containers depending on the value of Lab.config.authoring
        setupBackground();

        console.timeEnd('[layout] update');
      }
    };

    return layout;
  };

});
/*global define*/
define('common/layout/templates',[],function () {
  return {
    "simple": [
      {
        "id": "top",
        "bottom": "model.top",
        "width": "interactive.width"
      },
      {
        "id": "right",
        "top": "model.top",
        "left": "model.right",
        "height": "model.height",
        "padding-left": "1em",
        "padding-right": "0.5em"
      },
      {
        "id": "bottom",
        "top": "model.bottom",
        "width": "interactive.width",
        "padding-top": "0.5em"
      }
    ],
    "narrow-right": [
      {
        "id": "top",
        "bottom": "model.top",
        "width": "interactive.width"
      },
      {
        "id": "right",
        "top": "model.top",
        "left": "model.right",
        "height": "model.height",
        "padding-left": "1em",
        "padding-right": "0.5em",
        "width": "model.width / 4",
        "min-width": "6em"
      },
      {
        "id": "bottom",
        "top": "model.bottom",
        "width": "interactive.width",
        "padding-top": "0.5em"
      }
    ],
    "wide-right": [
      {
        "id": "top",
        "bottom": "model.top",
        "width": "interactive.width"
      },
      {
        "id": "right",
        "top": "model.top",
        "left": "model.right",
        "height": "model.height",
        "padding-left": "1em",
        "padding-right": "0.5em",
        "width": "model.width",
        "min-width": "6em"
      },
      {
        "id": "bottom",
        "top": "model.bottom",
        "width": "interactive.width",
        "padding-top": "0.5em"
      }
    ],
    "left-right-bottom": [
      {
        "id": "left",
        "top": "model.top",
        "height": "model.height",
        "right": "model.left",
        "padding-right": "0.5em"
      },
      {
        "id": "right",
        "top": "model.top",
        "height": "model.height",
        "left": "model.right",
        "padding-left": "1em",
        "padding-right": "0.5em"
      },
      {
        "id": "bottom",
        "top": "model.bottom",
        "left": "model.left",
        "width": "model.width"
      }
    ]
  };
});

/*global define, d3, alert, model: true */

define('common/controllers/model-controller',['require','lab.config'],function (require) {

  var labConfig = require('lab.config');

  return function ModelController(modelUrl, modelOptions, interactivesController,
                                  Model, ModelContainer, ScriptingAPI, Benchmarks) {
    var controller = {},

        // event dispatcher
        dispatch = d3.dispatch('modelLoaded');

    // ------------------------------------------------------------
    //
    // Main callback from model process
    //
    // Pass this function to be called by the model on every model step
    //
    // ------------------------------------------------------------
    function tickHandler() {
      controller.modelContainer.update();
    }

    // ------------------------------------------------------------
    //
    //   Benchmarks Setup
    //
    function setupBenchmarks() {
      controller.benchmarks = new Benchmarks(controller);
    }

    // ------------------------------------------------------------
    //
    //   Model Setup
    // ------------------------------------------------------------
    function setupModel() {
      model = new Model(modelOptions);
      model.on('tick', tickHandler);
    }

    // ------------------------------------------------------------
    //
    // Create Model Player
    //
    // ------------------------------------------------------------
    function setupModelPlayer() {

      // ------------------------------------------------------------
      //
      // Create container view for model
      //
      // ------------------------------------------------------------
      controller.modelContainer = new ModelContainer(model, controller.modelUrl);
    }

    /**
      Note: newModelConfig, newinteractiveViewConfig are optional. Calling this without
      arguments will simply reload the current model.
    */
    function reload(newModelUrl, newModelOptions, suppressEvents) {
      controller.modelUrl = newModelUrl || controller.modelUrl;
      modelOptions = newModelOptions || modelOptions;
      setupModel();
      controller.modelContainer.bindModel(model, controller.modelUrl);

      if (!suppressEvents) dispatch.modelLoaded();
    }

    function repaint() {
      controller.modelContainer.repaint();
    }

    function resize() {
      controller.modelContainer.resize();
    }

    function state() {
      return model.serialize();
    }

    // ------------------------------------------------------------
    //
    // Public methods
    //
    // ------------------------------------------------------------

    controller.on = function(type, listener) {
      dispatch.on(type, listener);
    };

    controller.getViewContainer = function () {
      return controller.modelContainer.$el;
    };

    controller.getHeightForWidth = function (width) {
      return controller.modelContainer.getHeightForWidth(width);
    };

    controller.enableKeyboardHandlers = function () {
      return model.get("enableKeyboardHandlers");
    };

    controller.modelInDOM = function () {
      controller.modelContainer.setup();
    };

    controller.reload = reload;
    controller.repaint = repaint;
    controller.resize = resize;
    controller.state = state;
    controller.ScriptingAPI = ScriptingAPI;

    // ------------------------------------------------------------
    //
    // Public variables
    //
    // ------------------------------------------------------------
    controller.modelContainer = null;
    controller.benchmarks = null;
    controller.type = Model.type;
    controller.modelUrl = modelUrl;

    // ------------------------------------------------------------
    //
    // Initial setup of this modelController:
    //
    // ------------------------------------------------------------

    if (labConfig.environment === 'production') {
      try {
        setupModel();
      } catch(e) {
        alert(e);
        throw new Error(e);
      }
    } else {
      setupModel();
    }

    setupBenchmarks();
    setupModelPlayer();

    return controller;
  };
});

/*global define, performance, $ */

define('common/performance',[],function () {
  var nowFunc;

  if (typeof performance !== 'undefined' && typeof performance.now !== 'undefined') {
    nowFunc = $.proxy(performance.now, performance);
  } else {
    nowFunc = $.proxy(Date.now, Date);
  }

  return {
    /**
     * window.performance.now or Date.now when performance.now is not available.
     * @type {Function}
     */
    now: nowFunc
  };

});

/*global define: true */

// Tiny module which contains definition of preferred
// array types used across whole Lab project.
// It checks whether typed arrays are available and type of browser
// (as typed arrays are slower in Safari).

define('common/array-types',['require','arrays'],function (require) {
  // Dependencies.
  var arrays = require('arrays'),

      // Check for Safari. Typed arrays are faster almost everywhere ... except Safari.
      notSafari = (function() {
        // Node.js?
        if (typeof navigator === 'undefined')
          return true;
        // Safari?
        var safarimatch  = / AppleWebKit\/([0123456789.+]+) \(KHTML, like Gecko\) Version\/([0123456789.]+) (Safari)\/([0123456789.]+)/,
            match = navigator.userAgent.match(safarimatch);
        return !match || !match[3];
      }()),

      useTyped = arrays.typed && notSafari;

  // Return all available types of arrays.
  // If you need to use new type, declare it here.
  return {
    floatType:  useTyped ? 'Float32Array' : 'regular',
    int32Type:  useTyped ? 'Int32Array'   : 'regular',
    int16Type:  useTyped ? 'Int16Array'   : 'regular',
    int8Type:   useTyped ? 'Int8Array'    : 'regular',
    uint16Type: useTyped ? 'Uint16Array'  : 'regular',
    uint8Type:  useTyped ? 'Uint8Array'   : 'regular'
  };

});

/*global define: true */
/** Provides a few simple helper functions for converting related unit types.

    This sub-module doesn't do unit conversion between compound unit types (e.g., knowing that kg*m/s^2 = N)
    only simple scaling between units measuring the same type of quantity.
*/

// Prefer the "per" formulation to the "in" formulation.
//
// If KILOGRAMS_PER_AMU is 1.660540e-27 we know the math is:
// "1 amu * 1.660540e-27 kg/amu = 1.660540e-27 kg"
// (Whereas the "in" forumulation might be slighty more error prone:
// given 1 amu and 6.022e-26 kg in an amu, how do you get kg again?)

// These you might have to look up...

// Module can be used both in Node.js environment and in Web browser
// using RequireJS. RequireJS Optimizer will strip out this if statement.


define('md2d/models/engine/constants/units',['require','exports','module'],function (require, exports, module) {

  var KILOGRAMS_PER_DALTON  = 1.660540e-27,
      COULOMBS_PER_ELEMENTARY_CHARGE = 1.602177e-19,

      // 1 eV = 1 e * 1 V = (COULOMBS_PER_ELEMENTARY_CHARGE) C * 1 J/C
      JOULES_PER_EV = COULOMBS_PER_ELEMENTARY_CHARGE,

      // though these are equally important!
      SECONDS_PER_FEMTOSECOND = 1e-15,
      METERS_PER_NANOMETER    = 1e-9,
      ANGSTROMS_PER_NANOMETER = 10,
      GRAMS_PER_KILOGRAM      = 1000,

      types = {
        TIME: "time",
        LENGTH: "length",
        MASS: "mass",
        ENERGY: "energy",
        ENTROPY: "entropy",
        CHARGE: "charge",
        INVERSE_QUANTITY: "inverse quantity",

        FARADS_PER_METER: "farads per meter",
        METERS_PER_FARAD: "meters per farad",

        FORCE: "force",
        VELOCITY: "velocity",

        // unused as of yet
        AREA: "area",
        PRESSURE: "pressure"
      },

    unit,
    ratio,
    convert;

  /**
    In each of these units, the reference type we actually use has value 1, and conversion
    ratios for the others are listed.
  */
  exports.unit = unit = {

    FEMTOSECOND: { name: "femtosecond", value: 1,                       type: types.TIME },
    SECOND:      { name: "second",      value: SECONDS_PER_FEMTOSECOND, type: types.TIME },

    NANOMETER:   { name: "nanometer", value: 1,                           type: types.LENGTH },
    ANGSTROM:    { name: "Angstrom",  value: 1 * ANGSTROMS_PER_NANOMETER, type: types.LENGTH },
    METER:       { name: "meter",     value: 1 * METERS_PER_NANOMETER,    type: types.LENGTH },

    DALTON:   { name: "Dalton",   value: 1,                                             type: types.MASS },
    GRAM:     { name: "gram",     value: 1 * KILOGRAMS_PER_DALTON * GRAMS_PER_KILOGRAM, type: types.MASS },
    KILOGRAM: { name: "kilogram", value: 1 * KILOGRAMS_PER_DALTON,                      type: types.MASS },

    MW_ENERGY_UNIT: {
      name: "MW Energy Unit (Dalton * nm^2 / fs^2)",
      value: 1,
      type: types.ENERGY
    },

    JOULE: {
      name: "Joule",
      value: KILOGRAMS_PER_DALTON *
             METERS_PER_NANOMETER * METERS_PER_NANOMETER *
             (1/SECONDS_PER_FEMTOSECOND) * (1/SECONDS_PER_FEMTOSECOND),
      type: types.ENERGY
    },

    EV: {
      name: "electron volt",
      value: KILOGRAMS_PER_DALTON *
              METERS_PER_NANOMETER * METERS_PER_NANOMETER *
              (1/SECONDS_PER_FEMTOSECOND) * (1/SECONDS_PER_FEMTOSECOND) *
              (1/JOULES_PER_EV),
      type: types.ENERGY
    },

    EV_PER_KELVIN:     { name: "electron volts per Kelvin", value: 1,                 type: types.ENTROPY },
    JOULES_PER_KELVIN: { name: "Joules per Kelvin",         value: 1 * JOULES_PER_EV, type: types.ENTROPY },

    ELEMENTARY_CHARGE: { name: "elementary charge", value: 1,                             type: types.CHARGE },
    COULOMB:           { name: "Coulomb",           value: COULOMBS_PER_ELEMENTARY_CHARGE, type: types.CHARGE },

    INVERSE_MOLE: { name: "inverse moles", value: 1, type: types.INVERSE_QUANTITY },

    FARADS_PER_METER: { name: "Farads per meter", value: 1, type: types.FARADS_PER_METER },

    METERS_PER_FARAD: { name: "meters per Farad", value: 1, type: types.METERS_PER_FARAD },

    MW_FORCE_UNIT: {
      name: "MW force units (Dalton * nm / fs^2)",
      value: 1,
      type: types.FORCE
    },

    NEWTON: {
      name: "Newton",
      value: 1 * KILOGRAMS_PER_DALTON * METERS_PER_NANOMETER * (1/SECONDS_PER_FEMTOSECOND) * (1/SECONDS_PER_FEMTOSECOND),
      type: types.FORCE
    },

    EV_PER_NM: {
      name: "electron volts per nanometer",
      value: 1 * KILOGRAMS_PER_DALTON * METERS_PER_NANOMETER * METERS_PER_NANOMETER *
             (1/SECONDS_PER_FEMTOSECOND) * (1/SECONDS_PER_FEMTOSECOND) *
             (1/JOULES_PER_EV),
      type: types.FORCE
    },

    MW_VELOCITY_UNIT: {
      name: "MW velocity units (nm / fs)",
      value: 1,
      type: types.VELOCITY
    },

    METERS_PER_SECOND: {
      name: "meters per second",
      value: 1 * METERS_PER_NANOMETER * (1 / SECONDS_PER_FEMTOSECOND),
      type: types.VELOCITY
    }

  };


  /** Provide ratios for conversion of one unit to an equivalent unit type.

     Usage: ratio(units.GRAM, { per: units.KILOGRAM }) === 1000
            ratio(units.GRAM, { as: units.KILOGRAM }) === 0.001
  */
  exports.ratio = ratio = function(from, to) {
    var checkCompatibility = function(fromUnit, toUnit) {
      if (fromUnit.type !== toUnit.type) {
        throw new Error("Attempt to convert incompatible type '" + fromUnit.name + "'' to '" + toUnit.name + "'");
      }
    };

    if (to.per) {
      checkCompatibility(from, to.per);
      return from.value / to.per.value;
    } else if (to.as) {
      checkCompatibility(from, to.as);
      return to.as.value / from.value;
    } else {
      throw new Error("units.ratio() received arguments it couldn't understand.");
    }
  };

  /** Scale 'val' to a different unit of the same type.

    Usage: convert(1, { from: unit.KILOGRAM, to: unit.GRAM }) === 1000
  */
  exports.convert = convert = function(val, fromTo) {
    var from = fromTo && fromTo.from,
        to   = fromTo && fromTo.to;

    if (!from) {
      throw new Error("units.convert() did not receive a \"from\" argument");
    }
    if (!to) {
      throw new Error("units.convert() did not receive a \"to\" argument");
    }

    return val * ratio(to, { per: from });
  };
});

/*global define: true */
/*jslint loopfunc: true */

/** A list of physical constants. To access any given constant, require() this module
    and call the 'as' method of the desired constant to get the constant in the desired unit.

    This module also provides a few helper functions for unit conversion.

    Usage:
      var constants = require('./constants'),

          ATOMIC_MASS_IN_GRAMS = constants.ATOMIC_MASS.as(constants.unit.GRAM),

          GRAMS_PER_KILOGRAM = constants.ratio(constants.unit.GRAM, { per: constants.unit.KILOGRAM }),

          // this works for illustration purposes, although the preferred method would be to pass
          // constants.unit.KILOGRAM to the 'as' method:

          ATOMIC_MASS_IN_KILOGRAMS = constants.convert(ATOMIC_MASS_IN_GRAMS, {
            from: constants.unit.GRAM,
            to:   constants.unit.KILOGRAM
          });
*/

// Module can be used both in Node.js environment and in Web browser
// using RequireJS. RequireJS Optimizer will strip out this if statement.


define('md2d/models/engine/constants/index',['require','exports','module','./units'],function (require, exports, module) {

  var units = require('./units'),
      unit  = units.unit,
      ratio = units.ratio,
      convert = units.convert,

      constants = {

        ELEMENTARY_CHARGE: {
          value: 1,
          unit: unit.ELEMENTARY_CHARGE
        },

        ATOMIC_MASS: {
          value: 1,
          unit: unit.DALTON
        },

        BOLTZMANN_CONSTANT: {
          value: 1.380658e-23,
          unit: unit.JOULES_PER_KELVIN
        },

        AVAGADRO_CONSTANT: {
          // N_A is numerically equal to Dalton per gram
          value: ratio( unit.DALTON, { per: unit.GRAM }),
          unit: unit.INVERSE_MOLE
        },

        PERMITTIVITY_OF_FREE_SPACE: {
          value: 8.854187e-12,
          unit: unit.FARADS_PER_METER
        }
      },

      constantName, constant;


  // Derived units
  constants.COULOMB_CONSTANT = {
    value: 1 / (4 * Math.PI * constants.PERMITTIVITY_OF_FREE_SPACE.value),
    unit: unit.METERS_PER_FARAD
  };

  // Exports

  exports.unit = unit;
  exports.ratio = ratio;
  exports.convert = convert;

  // Require explicitness about units by publishing constants as a set of objects with only an 'as' property,
  // which will return the constant in the specified unit.

  for (constantName in constants) {
    if (constants.hasOwnProperty(constantName)) {
      constant = constants[constantName];

      exports[constantName] = (function(constant) {
        return {
          as: function(toUnit) {
            return units.convert(constant.value, { from: constant.unit, to: toUnit });
          }
        };
      }(constant));
    }
  }
});

/**
 * CoffeeScript Compiler v1.3.3
 * http://coffeescript.org
 *
 * Copyright 2011, Jeremy Ashkenas
 * Released under the MIT License
 */
(function(root){var CoffeeScript=function(){function require(a){return require[a]}require["./helpers"]=new function(){var a=this;(function(){var b,c;a.starts=function(a,b,c){return b===a.substr(c,b.length)},a.ends=function(a,b,c){var d;d=b.length;return b===a.substr(a.length-d-(c||0),d)},a.compact=function(a){var b,c,d,e;e=[];for(c=0,d=a.length;c<d;c++)b=a[c],b&&e.push(b);return e},a.count=function(a,b){var c,d;c=d=0;if(!b.length)return 1/0;while(d=1+a.indexOf(b,d))c++;return c},a.merge=function(a,c){return b(b({},a),c)},b=a.extend=function(a,b){var c,d;for(c in b)d=b[c],a[c]=d;return a},a.flatten=c=function(a){var b,d,e,f;d=[];for(e=0,f=a.length;e<f;e++)b=a[e],b instanceof Array?d=d.concat(c(b)):d.push(b);return d},a.del=function(a,b){var c;c=a[b],delete a[b];return c},a.last=function(a,b){return a[a.length-(b||0)-1]}}).call(this)},require["./rewriter"]=new function(){var a=this;(function(){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t=[].indexOf||function(a){for(var b=0,c=this.length;b<c;b++)if(b in this&&this[b]===a)return b;return-1},u=[].slice;a.Rewriter=function(){function a(){}a.prototype.rewrite=function(a){this.tokens=a,this.removeLeadingNewlines(),this.removeMidExpressionNewlines(),this.closeOpenCalls(),this.closeOpenIndexes(),this.addImplicitIndentation(),this.tagPostfixConditionals(),this.addImplicitBraces(),this.addImplicitParentheses();return this.tokens},a.prototype.scanTokens=function(a){var b,c,d;d=this.tokens,b=0;while(c=d[b])b+=a.call(this,c,b,d);return!0},a.prototype.detectEnd=function(a,b,c){var f,g,h,i,j;h=this.tokens,f=0;while(g=h[a]){if(f===0&&b.call(this,g,a))return c.call(this,g,a);if(!g||f<0)return c.call(this,g,a-1);if(i=g[0],t.call(e,i)>=0)f+=1;else if(j=g[0],t.call(d,j)>=0)f-=1;a+=1}return a-1},a.prototype.removeLeadingNewlines=function(){var a,b,c,d,e;e=this.tokens;for(a=c=0,d=e.length;c<d;a=++c){b=e[a][0];if(b!=="TERMINATOR")break}if(a)return this.tokens.splice(0,a)},a.prototype.removeMidExpressionNewlines=function(){return this.scanTokens(function(a,b,d){var e;if(!(a[0]==="TERMINATOR"&&(e=this.tag(b+1),t.call(c,e)>=0)))return 1;d.splice(b,1);return 0})},a.prototype.closeOpenCalls=function(){var a,b;b=function(a,b){var c;return(c=a[0])===")"||c==="CALL_END"||a[0]==="OUTDENT"&&this.tag(b-1)===")"},a=function(a,b){return this.tokens[a[0]==="OUTDENT"?b-1:b][0]="CALL_END"};return this.scanTokens(function(c,d){c[0]==="CALL_START"&&this.detectEnd(d+1,b,a);return 1})},a.prototype.closeOpenIndexes=function(){var a,b;b=function(a,b){var c;return(c=a[0])==="]"||c==="INDEX_END"},a=function(a,b){return a[0]="INDEX_END"};return this.scanTokens(function(c,d){c[0]==="INDEX_START"&&this.detectEnd(d+1,b,a);return 1})},a.prototype.addImplicitBraces=function(){var a,b,c,f,g,i,j,k;f=[],g=null,k=null,c=!0,i=0,j=0,b=function(a,b){var d,e,f,g,i,m;i=this.tokens.slice(b+1,b+3+1||9e9),d=i[0],g=i[1],f=i[2];if("HERECOMMENT"===(d!=null?d[0]:void 0))return!1;e=a[0],t.call(l,e)>=0&&(c=!1);return(e==="TERMINATOR"||e==="OUTDENT"||t.call(h,e)>=0&&c&&b-j!==1)&&(!k&&this.tag(b-1)!==","||(g!=null?g[0]:void 0)!==":"&&((d!=null?d[0]:void 0)!=="@"||(f!=null?f[0]:void 0)!==":"))||e===","&&d&&(m=d[0])!=="IDENTIFIER"&&m!=="NUMBER"&&m!=="STRING"&&m!=="@"&&m!=="TERMINATOR"&&m!=="OUTDENT"},a=function(a,b){var c;c=this.generate("}","}",a[2]);return this.tokens.splice(b,0,c)};return this.scanTokens(function(h,i,m){var n,o,p,q,r,s,u,v;if(u=q=h[0],t.call(e,u)>=0){f.push([q==="INDENT"&&this.tag(i-1)==="{"?"{":q,i]);return 1}if(t.call(d,q)>=0){g=f.pop();return 1}if(q!==":"||(n=this.tag(i-2))!==":"&&((v=f[f.length-1])!=null?v[0]:void 0)==="{")return 1;c=!0,j=i+1,f.push(["{"]),o=n==="@"?i-2:i-1;while(this.tag(o-2)==="HERECOMMENT")o-=2;p=this.tag(o-1),k=!p||t.call(l,p)>=0,s=new String("{"),s.generated=!0,r=this.generate("{",s,h[2]),m.splice(o,0,r),this.detectEnd(i+2,b,a);return 2})},a.prototype.addImplicitParentheses=function(){var a,b,c,d,e;c=e=d=!1,b=function(a,b){var c,g,i,j;g=a[0];if(!e&&a.fromThen)return!0;if(g==="IF"||g==="ELSE"||g==="CATCH"||g==="->"||g==="=>"||g==="CLASS")e=!0;if(g==="IF"||g==="ELSE"||g==="SWITCH"||g==="TRY"||g==="=")d=!0;if((g==="."||g==="?."||g==="::")&&this.tag(b-1)==="OUTDENT")return!0;return!a.generated&&this.tag(b-1)!==","&&(t.call(h,g)>=0||g==="INDENT"&&!d)&&(g!=="INDENT"||(i=this.tag(b-2))!=="CLASS"&&i!=="EXTENDS"&&(j=this.tag(b-1),t.call(f,j)<0)&&(!(c=this.tokens[b+1])||!c.generated||c[0]!=="{"))},a=function(a,b){return this.tokens.splice(b,0,this.generate("CALL_END",")",a[2]))};return this.scanTokens(function(f,h,k){var m,n,o,p,q,r,s,u;q=f[0];if(q==="CLASS"||q==="IF"||q==="FOR"||q==="WHILE")c=!0;r=k.slice(h-1,h+1+1||9e9),p=r[0],n=r[1],o=r[2],m=!c&&q==="INDENT"&&o&&o.generated&&o[0]==="{"&&p&&(s=p[0],t.call(i,s)>=0),e=!1,d=!1,t.call(l,q)>=0&&(c=!1),p&&!p.spaced&&q==="?"&&(f.call=!0);if(f.fromThen)return 1;if(!(m||(p!=null?p.spaced:void 0)&&(p.call||(u=p[0],t.call(i,u)>=0))&&(t.call(g,q)>=0||!f.spaced&&!f.newLine&&t.call(j,q)>=0)))return 1;k.splice(h,0,this.generate("CALL_START","(",f[2])),this.detectEnd(h+1,b,a),p[0]==="?"&&(p[0]="FUNC_EXIST");return 2})},a.prototype.addImplicitIndentation=function(){var a,b,c,d,e;e=c=d=null,b=function(a,b){var c;return a[1]!==";"&&(c=a[0],t.call(m,c)>=0)&&(a[0]!=="ELSE"||e==="IF"||e==="THEN")},a=function(a,b){return this.tokens.splice(this.tag(b-1)===","?b-1:b,0,d)};return this.scanTokens(function(f,g,h){var i,j,k;i=f[0];if(i==="TERMINATOR"&&this.tag(g+1)==="THEN"){h.splice(g,1);return 0}if(i==="ELSE"&&this.tag(g-1)!=="OUTDENT"){h.splice.apply(h,[g,0].concat(u.call(this.indentation(f))));return 2}if(i==="CATCH"&&((j=this.tag(g+2))==="OUTDENT"||j==="TERMINATOR"||j==="FINALLY")){h.splice.apply(h,[g+2,0].concat(u.call(this.indentation(f))));return 4}if(t.call(n,i)>=0&&this.tag(g+1)!=="INDENT"&&(i!=="ELSE"||this.tag(g+1)!=="IF")){e=i,k=this.indentation(f,!0),c=k[0],d=k[1],e==="THEN"&&(c.fromThen=!0),h.splice(g+1,0,c),this.detectEnd(g+2,b,a),i==="THEN"&&h.splice(g,1);return 1}return 1})},a.prototype.tagPostfixConditionals=function(){var a,b,c;c=null,b=function(a,b){var c;return(c=a[0])==="TERMINATOR"||c==="INDENT"},a=function(a,b){if(a[0]!=="INDENT"||a.generated&&!a.fromThen)return c[0]="POST_"+c[0]};return this.scanTokens(function(d,e){if(d[0]!=="IF")return 1;c=d,this.detectEnd(e+1,b,a);return 1})},a.prototype.indentation=function(a,b){var c,d;b==null&&(b=!1),c=["INDENT",2,a[2]],d=["OUTDENT",2,a[2]],b&&(c.generated=d.generated=!0);return[c,d]},a.prototype.generate=function(a,b,c){var d;d=[a,b,c],d.generated=!0;return d},a.prototype.tag=function(a){var b;return(b=this.tokens[a])!=null?b[0]:void 0};return a}(),b=[["(",")"],["[","]"],["{","}"],["INDENT","OUTDENT"],["CALL_START","CALL_END"],["PARAM_START","PARAM_END"],["INDEX_START","INDEX_END"]],a.INVERSES=k={},e=[],d=[];for(q=0,r=b.length;q<r;q++)s=b[q],o=s[0],p=s[1],e.push(k[p]=o),d.push(k[o]=p);c=["CATCH","WHEN","ELSE","FINALLY"].concat(d),i=["IDENTIFIER","SUPER",")","CALL_END","]","INDEX_END","@","THIS"],g=["IDENTIFIER","NUMBER","STRING","JS","REGEX","NEW","PARAM_START","CLASS","IF","TRY","SWITCH","THIS","BOOL","NULL","UNDEFINED","UNARY","SUPER","@","->","=>","[","(","{","--","++"],j=["+","-"],f=["->","=>","{","[",","],h=["POST_IF","FOR","WHILE","UNTIL","WHEN","BY","LOOP","TERMINATOR"],n=["ELSE","->","=>","TRY","FINALLY","THEN"],m=["TERMINATOR","CATCH","FINALLY","ELSE","OUTDENT","LEADING_WHEN"],l=["TERMINATOR","INDENT","OUTDENT"]}).call(this)},require["./lexer"]=new function(){var a=this;(function(){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X=[].indexOf||function(a){for(var b=0,c=this.length;b<c;b++)if(b in this&&this[b]===a)return b;return-1};V=require("./rewriter"),J=V.Rewriter,r=V.INVERSES,W=require("./helpers"),R=W.count,U=W.starts,Q=W.compact,T=W.last,a.Lexer=y=function(){function a(){}a.prototype.tokenize=function(a,b){var c,d;b==null&&(b={}),P.test(a)&&(a="\n"+a),a=a.replace(/\r/g,"").replace(N,""),this.code=a,this.line=b.line||0,this.indent=0,this.indebt=0,this.outdebt=0,this.indents=[],this.ends=[],this.tokens=[],c=0;while(this.chunk=a.slice(c))c+=this.identifierToken()||this.commentToken()||this.whitespaceToken()||this.lineToken()||this.heredocToken()||this.stringToken()||this.numberToken()||this.regexToken()||this.jsToken()||this.literalToken();this.closeIndentation(),(d=this.ends.pop())&&this.error("missing "+d);if(b.rewrite===!1)return this.tokens;return(new J).rewrite(this.tokens)},a.prototype.identifierToken=function(){var a,b,c,d,h,i,j,k,l;if(!(h=p.exec(this.chunk)))return 0;d=h[0],c=h[1],a=h[2];if(c==="own"&&this.tag()==="FOR"){this.token("OWN",c);return c.length}b=a||(i=T(this.tokens))&&((k=i[0])==="."||k==="?."||k==="::"||!i.spaced&&i[0]==="@"),j="IDENTIFIER",!b&&(X.call(u,c)>=0||X.call(g,c)>=0)&&(j=c.toUpperCase(),j==="WHEN"&&(l=this.tag(),X.call(v,l)>=0)?j="LEADING_WHEN":j==="FOR"?this.seenFor=!0:j==="UNLESS"?j="IF":X.call(O,j)>=0?j="UNARY":X.call(H,j)>=0&&(j!=="INSTANCEOF"&&this.seenFor?(j="FOR"+j,this.seenFor=!1):(j="RELATION",this.value()==="!"&&(this.tokens.pop(),c="!"+c)))),X.call(t,c)>=0&&(b?(j="IDENTIFIER",c=new String(c),c.reserved=!0):X.call(I,c)>=0&&this.error('reserved word "'+c+'"')),b||(X.call(e,c)>=0&&(c=f[c]),j=function(){switch(c){case"!":return"UNARY";case"==":case"!=":return"COMPARE";case"&&":case"||":return"LOGIC";case"true":case"false":return"BOOL";case"break":case"continue":return"STATEMENT";default:return j}}()),this.token(j,c),a&&this.token(":",":");return d.length},a.prototype.numberToken=function(){var a,b,c,d,e;if(!(c=E.exec(this.chunk)))return 0;d=c[0],/^0[BOX]/.test(d)?this.error("radix prefix '"+d+"' must be lowercase"):/E/.test(d)&&!/^0x/.test(d)?this.error("exponential notation '"+d+"' must be indicated with a lowercase 'e'"):/^0\d*[89]/.test(d)?this.error("decimal literal '"+d+"' must not be prefixed with '0'"):/^0\d+/.test(d)&&this.error("octal literal '"+d+"' must be prefixed with '0o'"),b=d.length;if(e=/^0o([0-7]+)/.exec(d))d="0x"+parseInt(e[1],8).toString(16);if(a=/^0b([01]+)/.exec(d))d="0x"+parseInt(a[1],2).toString(16);this.token("NUMBER",d);return b},a.prototype.stringToken=function(){var a,b,c;switch(this.chunk.charAt(0)){case"'":if(!(a=L.exec(this.chunk)))return 0;this.token("STRING",(c=a[0]).replace(A,"\\\n"));break;case'"':if(!(c=this.balancedString(this.chunk,'"')))return 0;0<c.indexOf("#{",1)?this.interpolateString(c.slice(1,-1)):this.token("STRING",this.escapeLines(c));break;default:return 0}(b=/^(?:\\.|[^\\])*\\(?:0[0-7]|[1-7])/.test(c))&&this.error("octal escape sequences "+c+" are not allowed"),this.line+=R(c,"\n");return c.length},a.prototype.heredocToken=function(){var a,b,c,d;if(!(c=k.exec(this.chunk)))return 0;b=c[0],d=b.charAt(0),a=this.sanitizeHeredoc(c[2],{quote:d,indent:null}),d==='"'&&0<=a.indexOf("#{")?this.interpolateString(a,{heredoc:!0}):this.token("STRING",this.makeString(a,d,!0)),this.line+=R(b,"\n");return b.length},a.prototype.commentToken=function(){var a,b,c;if(!(c=this.chunk.match(h)))return 0;a=c[0],b=c[1],b&&this.token("HERECOMMENT",this.sanitizeHeredoc(b,{herecomment:!0,indent:Array(this.indent+1).join(" ")})),this.line+=R(a,"\n");return a.length},a.prototype.jsToken=function(){var a,b;if(this.chunk.charAt(0)!=="`"||!(a=s.exec(this.chunk)))return 0;this.token("JS",(b=a[0]).slice(1,-1));return b.length},a.prototype.regexToken=function(){var a,b,c,d,e,f,g;if(this.chunk.charAt(0)!=="/")return 0;if(c=n.exec(this.chunk)){b=this.heregexToken(c),this.line+=R(c[0],"\n");return b}d=T(this.tokens);if(d&&(f=d[0],X.call(d.spaced?C:D,f)>=0))return 0;if(!(c=G.exec(this.chunk)))return 0;g=c,c=g[0],e=g[1],a=g[2],e.slice(0,2)==="/*"&&this.error("regular expressions cannot begin with `*`"),e==="//"&&(e="/(?:)/"),this.token("REGEX",""+e+a);return c.length},a.prototype.heregexToken=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n;d=a[0],b=a[1],c=a[2];if(0>b.indexOf("#{")){e=b.replace(o,"").replace(/\//g,"\\/"),e.match(/^\*/)&&this.error("regular expressions cannot begin with `*`"),this.token("REGEX","/"+(e||"(?:)")+"/"+c);return d.length}this.token("IDENTIFIER","RegExp"),this.tokens.push(["CALL_START","("]),g=[],k=this.interpolateString(b,{regex:!0});for(i=0,j=k.length;i<j;i++){l=k[i],f=l[0],h=l[1];if(f==="TOKENS")g.push.apply(g,h);else{if(!(h=h.replace(o,"")))continue;h=h.replace(/\\/g,"\\\\"),g.push(["STRING",this.makeString(h,'"',!0)])}g.push(["+","+"])}g.pop(),((m=g[0])!=null?m[0]:void 0)!=="STRING"&&this.tokens.push(["STRING",'""'],["+","+"]),(n=this.tokens).push.apply(n,g),c&&this.tokens.push([",",","],["STRING",'"'+c+'"']),this.token(")",")");return d.length},a.prototype.lineToken=function(){var a,b,c,d,e,f;if(!(c=B.exec(this.chunk)))return 0;b=c[0],this.line+=R(b,"\n"),this.seenFor=!1,e=T(this.tokens,1),f=b.length-1-b.lastIndexOf("\n"),d=this.unfinished();if(f-this.indebt===this.indent){d?this.suppressNewlines():this.newlineToken();return b.length}if(f>this.indent){if(d){this.indebt=f-this.indent,this.suppressNewlines();return b.length}a=f-this.indent+this.outdebt,this.token("INDENT",a),this.indents.push(a),this.ends.push("OUTDENT"),this.outdebt=this.indebt=0}else this.indebt=0,this.outdentToken(this.indent-f,d);this.indent=f;return b.length},a.prototype.outdentToken=function(a,b){var c,d;while(a>0)d=this.indents.length-1,this.indents[d]===void 0?a=0:this.indents[d]===this.outdebt?(a-=this.outdebt,this.outdebt=0):this.indents[d]<this.outdebt?(this.outdebt-=this.indents[d],a-=this.indents[d]):(c=this.indents.pop()-this.outdebt,a-=c,this.outdebt=0,this.pair("OUTDENT"),this.token("OUTDENT",c));c&&(this.outdebt-=a);while(this.value()===";")this.tokens.pop();this.tag()!=="TERMINATOR"&&!b&&this.token("TERMINATOR","\n");return this},a.prototype.whitespaceToken=function(){var a,b,c;if(!(a=P.exec(this.chunk))&&!(b=this.chunk.charAt(0)==="\n"))return 0;c=T(this.tokens),c&&(c[a?"spaced":"newLine"]=!0);return a?a[0].length:0},a.prototype.newlineToken=function(){while(this.value()===";")this.tokens.pop();this.tag()!=="TERMINATOR"&&this.token("TERMINATOR","\n");return this},a.prototype.suppressNewlines=function(){this.value()==="\\"&&this.tokens.pop();return this},a.prototype.literalToken=function(){var a,b,e,f,g,h,k,l;(a=F.exec(this.chunk))?(f=a[0],d.test(f)&&this.tagParameters()):f=this.chunk.charAt(0),e=f,b=T(this.tokens);if(f==="="&&b){!b[1].reserved&&(g=b[1],X.call(t,g)>=0)&&this.error('reserved word "'+this.value()+"\" can't be assigned");if((h=b[1])==="||"||h==="&&"){b[0]="COMPOUND_ASSIGN",b[1]+="=";return f.length}}if(f===";")this.seenFor=!1,e="TERMINATOR";else if(X.call(z,f)>=0)e="MATH";else if(X.call(i,f)>=0)e="COMPARE";else if(X.call(j,f)>=0)e="COMPOUND_ASSIGN";else if(X.call(O,f)>=0)e="UNARY";else if(X.call(K,f)>=0)e="SHIFT";else if(X.call(x,f)>=0||f==="?"&&(b!=null?b.spaced:void 0))e="LOGIC";else if(b&&!b.spaced)if(f==="("&&(k=b[0],X.call(c,k)>=0))b[0]==="?"&&(b[0]="FUNC_EXIST"),e="CALL_START";else if(f==="["&&(l=b[0],X.call(q,l)>=0)){e="INDEX_START";switch(b[0]){case"?":b[0]="INDEX_SOAK"}}switch(f){case"(":case"{":case"[":this.ends.push(r[f]);break;case")":case"}":case"]":this.pair(f)}this.token(e,f);return f.length},a.prototype.sanitizeHeredoc=function(a,b){var c,d,e,f,g;e=b.indent,d=b.herecomment;if(d){l.test(a)&&this.error('block comment cannot contain "*/", starting');if(a.indexOf("\n")<=0)return a}else while(f=m.exec(a)){c=f[1];if(e===null||0<(g=c.length)&&g<e.length)e=c}e&&(a=a.replace(RegExp("\\n"+e,"g"),"\n")),d||(a=a.replace(/^\n/,""));return a},a.prototype.tagParameters=function(){var a,b,c,d;if(this.tag()!==")")return this;b=[],d=this.tokens,a=d.length,d[--a][0]="PARAM_END";while(c=d[--a])switch(c[0]){case")":b.push(c);break;case"(":case"CALL_START":if(b.length)b.pop();else{if(c[0]==="("){c[0]="PARAM_START";return this}return this}}return this},a.prototype.closeIndentation=function(){return this.outdentToken(this.indent)},a.prototype.balancedString=function(a,b){var c,d,e,f,g,h,i,j;c=0,h=[b];for(d=i=1,j=a.length;1<=j?i<j:i>j;d=1<=j?++i:--i){if(c){--c;continue}switch(e=a.charAt(d)){case"\\":++c;continue;case b:h.pop();if(!h.length)return a.slice(0,d+1||9e9);b=h[h.length-1];continue}b!=="}"||e!=='"'&&e!=="'"?b==="}"&&e==="/"&&(f=n.exec(a.slice(d))||G.exec(a.slice(d)))?c+=f[0].length-1:b==="}"&&e==="{"?h.push(b="}"):b==='"'&&g==="#"&&e==="{"&&h.push(b="}"):h.push(b=e),g=e}return this.error("missing "+h.pop()+", starting")},a.prototype.interpolateString=function(b,c){var d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u;c==null&&(c={}),e=c.heredoc,m=c.regex,o=[],l=0,f=-1;while(j=b.charAt(f+=1)){if(j==="\\"){f+=1;continue}if(j!=="#"||b.charAt(f+1)!=="{"||!(d=this.balancedString(b.slice(f+1),"}")))continue;l<f&&o.push(["NEOSTRING",b.slice(l,f)]),g=d.slice(1,-1);if(g.length){k=(new a).tokenize(g,{line:this.line,rewrite:!1}),k.pop(),((s=k[0])!=null?s[0]:void 0)==="TERMINATOR"&&k.shift();if(i=k.length)i>1&&(k.unshift(["(","(",this.line]),k.push([")",")",this.line])),o.push(["TOKENS",k])}f+=d.length,l=f+1}f>l&&l<b.length&&o.push(["NEOSTRING",b.slice(l)]);if(m)return o;if(!o.length)return this.token("STRING",'""');o[0][0]!=="NEOSTRING"&&o.unshift(["",""]),(h=o.length>1)&&this.token("(","(");for(f=q=0,r=o.length;q<r;f=++q)t=o[f],n=t[0],p=t[1],f&&this.token("+","+"),n==="TOKENS"?(u=this.tokens).push.apply(u,p):this.token("STRING",this.makeString(p,'"',e));h&&this.token(")",")");return o},a.prototype.pair=function(a){var b,c;if(a!==(c=T(this.ends))){"OUTDENT"!==c&&this.error("unmatched "+a),this.indent-=b=T(this.indents),this.outdentToken(b,!0);return this.pair(a)}return this.ends.pop()},a.prototype.token=function(a,b){return this.tokens.push([a,b,this.line])},a.prototype.tag=function(a,b){var c;return(c=T(this.tokens,a))&&(b?c[0]=b:c[0])},a.prototype.value=function(a,b){var c;return(c=T(this.tokens,a))&&(b?c[1]=b:c[1])},a.prototype.unfinished=function(){var a;return w.test(this.chunk)||(a=this.tag())==="\\"||a==="."||a==="?."||a==="UNARY"||a==="MATH"||a==="+"||a==="-"||a==="SHIFT"||a==="RELATION"||a==="COMPARE"||a==="LOGIC"||a==="THROW"||a==="EXTENDS"},a.prototype.escapeLines=function(a,b){return a.replace(A,b?"\\n":"")},a.prototype.makeString=function(a,b,c){if(!a)return b+b;a=a.replace(/\\([\s\S])/g,function(a,c){return c==="\n"||c===b?c:a}),a=a.replace(RegExp(""+b,"g"),"\\$&");return b+this.escapeLines(a,c)+b},a.prototype.error=function(a){throw SyntaxError(""+a+" on line "+(this.line+1))};return a}(),u=["true","false","null","this","new","delete","typeof","in","instanceof","return","throw","break","continue","debugger","if","else","switch","for","while","do","try","catch","finally","class","extends","super"],g=["undefined","then","unless","until","loop","of","by","when"],f={and:"&&",or:"||",is:"==",isnt:"!=",not:"!",yes:"true",no:"false",on:"true",off:"false"},e=function(){var a;a=[];for(S in f)a.push(S);return a}(),g=g.concat(e),I=["case","default","function","var","void","with","const","let","enum","export","import","native","__hasProp","__extends","__slice","__bind","__indexOf","implements","interface","let","package","private","protected","public","static","yield"],M=["arguments","eval"],t=u.concat(I).concat(M),a.RESERVED=I.concat(u).concat(g).concat(M),a.STRICT_PROSCRIBED=M,p=/^([$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)([^\n\S]*:(?!:))?/,E=/^0b[01]+|^0o[0-7]+|^0x[\da-f]+|^\d*\.?\d+(?:e[+-]?\d+)?/i,k=/^("""|''')([\s\S]*?)(?:\n[^\n\S]*)?\1/,F=/^(?:[-=]>|[-+*\/%<>&|^!?=]=|>>>=?|([-+:])\1|([&|<>])\2=?|\?\.|\.{2,3})/,P=/^[^\n\S]+/,h=/^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)|^(?:\s*#(?!##[^#]).*)+/,d=/^[-=]>/,B=/^(?:\n[^\n\S]*)+/,L=/^'[^\\']*(?:\\.[^\\']*)*'/,s=/^`[^\\`]*(?:\\.[^\\`]*)*`/,G=/^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/,n=/^\/{3}([\s\S]+?)\/{3}([imgy]{0,4})(?!\w)/,o=/\s+(?:#.*)?/g,A=/\n/g,m=/\n+([^\n\S]*)/g,l=/\*\//,w=/^\s*(?:,|\??\.(?![.\d])|::)/,N=/\s+$/,j=["-=","+=","/=","*=","%=","||=","&&=","?=","<<=",">>=",">>>=","&=","^=","|="],O=["!","~","NEW","TYPEOF","DELETE","DO"],x=["&&","||","&","|","^"],K=["<<",">>",">>>"],i=["==","!=","<",">","<=",">="],z=["*","/","%"],H=["IN","OF","INSTANCEOF"],b=["TRUE","FALSE"],C=["NUMBER","REGEX","BOOL","NULL","UNDEFINED","++","--","]"],D=C.concat(")","}","THIS","IDENTIFIER","STRING"),c=["IDENTIFIER","STRING","REGEX",")","]","}","?","::","@","THIS","SUPER"],q=c.concat("NUMBER","BOOL","NULL","UNDEFINED"),v=["INDENT","OUTDENT","TERMINATOR"]}).call(this)},require["./parser"]=new function(){var a=this,b=function(){var a={trace:function(){},yy:{},symbols_:{error:2,Root:3,Body:4,Block:5,TERMINATOR:6,Line:7,Expression:8,Statement:9,Return:10,Comment:11,STATEMENT:12,Value:13,Invocation:14,Code:15,Operation:16,Assign:17,If:18,Try:19,While:20,For:21,Switch:22,Class:23,Throw:24,INDENT:25,OUTDENT:26,Identifier:27,IDENTIFIER:28,AlphaNumeric:29,NUMBER:30,STRING:31,Literal:32,JS:33,REGEX:34,DEBUGGER:35,UNDEFINED:36,NULL:37,BOOL:38,Assignable:39,"=":40,AssignObj:41,ObjAssignable:42,":":43,ThisProperty:44,RETURN:45,HERECOMMENT:46,PARAM_START:47,ParamList:48,PARAM_END:49,FuncGlyph:50,"->":51,"=>":52,OptComma:53,",":54,Param:55,ParamVar:56,"...":57,Array:58,Object:59,Splat:60,SimpleAssignable:61,Accessor:62,Parenthetical:63,Range:64,This:65,".":66,"?.":67,"::":68,Index:69,INDEX_START:70,IndexValue:71,INDEX_END:72,INDEX_SOAK:73,Slice:74,"{":75,AssignList:76,"}":77,CLASS:78,EXTENDS:79,OptFuncExist:80,Arguments:81,SUPER:82,FUNC_EXIST:83,CALL_START:84,CALL_END:85,ArgList:86,THIS:87,"@":88,"[":89,"]":90,RangeDots:91,"..":92,Arg:93,SimpleArgs:94,TRY:95,Catch:96,FINALLY:97,CATCH:98,THROW:99,"(":100,")":101,WhileSource:102,WHILE:103,WHEN:104,UNTIL:105,Loop:106,LOOP:107,ForBody:108,FOR:109,ForStart:110,ForSource:111,ForVariables:112,OWN:113,ForValue:114,FORIN:115,FOROF:116,BY:117,SWITCH:118,Whens:119,ELSE:120,When:121,LEADING_WHEN:122,IfBlock:123,IF:124,POST_IF:125,UNARY:126,"-":127,"+":128,"--":129,"++":130,"?":131,MATH:132,SHIFT:133,COMPARE:134,LOGIC:135,RELATION:136,COMPOUND_ASSIGN:137,$accept:0,$end:1},terminals_:{2:"error",6:"TERMINATOR",12:"STATEMENT",25:"INDENT",26:"OUTDENT",28:"IDENTIFIER",30:"NUMBER",31:"STRING",33:"JS",34:"REGEX",35:"DEBUGGER",36:"UNDEFINED",37:"NULL",38:"BOOL",40:"=",43:":",45:"RETURN",46:"HERECOMMENT",47:"PARAM_START",49:"PARAM_END",51:"->",52:"=>",54:",",57:"...",66:".",67:"?.",68:"::",70:"INDEX_START",72:"INDEX_END",73:"INDEX_SOAK",75:"{",77:"}",78:"CLASS",79:"EXTENDS",82:"SUPER",83:"FUNC_EXIST",84:"CALL_START",85:"CALL_END",87:"THIS",88:"@",89:"[",90:"]",92:"..",95:"TRY",97:"FINALLY",98:"CATCH",99:"THROW",100:"(",101:")",103:"WHILE",104:"WHEN",105:"UNTIL",107:"LOOP",109:"FOR",113:"OWN",115:"FORIN",116:"FOROF",117:"BY",118:"SWITCH",120:"ELSE",122:"LEADING_WHEN",124:"IF",125:"POST_IF",126:"UNARY",127:"-",128:"+",129:"--",130:"++",131:"?",132:"MATH",133:"SHIFT",134:"COMPARE",135:"LOGIC",136:"RELATION",137:"COMPOUND_ASSIGN"},productions_:[0,[3,0],[3,1],[3,2],[4,1],[4,3],[4,2],[7,1],[7,1],[9,1],[9,1],[9,1],[8,1],[8,1],[8,1],[8,1],[8,1],[8,1],[8,1],[8,1],[8,1],[8,1],[8,1],[8,1],[5,2],[5,3],[27,1],[29,1],[29,1],[32,1],[32,1],[32,1],[32,1],[32,1],[32,1],[32,1],[17,3],[17,4],[17,5],[41,1],[41,3],[41,5],[41,1],[42,1],[42,1],[42,1],[10,2],[10,1],[11,1],[15,5],[15,2],[50,1],[50,1],[53,0],[53,1],[48,0],[48,1],[48,3],[48,4],[48,6],[55,1],[55,2],[55,3],[56,1],[56,1],[56,1],[56,1],[60,2],[61,1],[61,2],[61,2],[61,1],[39,1],[39,1],[39,1],[13,1],[13,1],[13,1],[13,1],[13,1],[62,2],[62,2],[62,2],[62,1],[62,1],[69,3],[69,2],[71,1],[71,1],[59,4],[76,0],[76,1],[76,3],[76,4],[76,6],[23,1],[23,2],[23,3],[23,4],[23,2],[23,3],[23,4],[23,5],[14,3],[14,3],[14,1],[14,2],[80,0],[80,1],[81,2],[81,4],[65,1],[65,1],[44,2],[58,2],[58,4],[91,1],[91,1],[64,5],[74,3],[74,2],[74,2],[74,1],[86,1],[86,3],[86,4],[86,4],[86,6],[93,1],[93,1],[94,1],[94,3],[19,2],[19,3],[19,4],[19,5],[96,3],[24,2],[63,3],[63,5],[102,2],[102,4],[102,2],[102,4],[20,2],[20,2],[20,2],[20,1],[106,2],[106,2],[21,2],[21,2],[21,2],[108,2],[108,2],[110,2],[110,3],[114,1],[114,1],[114,1],[114,1],[112,1],[112,3],[111,2],[111,2],[111,4],[111,4],[111,4],[111,6],[111,6],[22,5],[22,7],[22,4],[22,6],[119,1],[119,2],[121,3],[121,4],[123,3],[123,5],[18,1],[18,3],[18,3],[18,3],[16,2],[16,2],[16,2],[16,2],[16,2],[16,2],[16,2],[16,2],[16,3],[16,3],[16,3],[16,3],[16,3],[16,3],[16,3],[16,3],[16,5],[16,3]],performAction:function(a,b,c,d,e,f,g){var h=f.length-1;switch(e){case 1:return this.$=new d.Block;case 2:return this.$=f[h];case 3:return this.$=f[h-1];case 4:this.$=d.Block.wrap([f[h]]);break;case 5:this.$=f[h-2].push(f[h]);break;case 6:this.$=f[h-1];break;case 7:this.$=f[h];break;case 8:this.$=f[h];break;case 9:this.$=f[h];break;case 10:this.$=f[h];break;case 11:this.$=new d.Literal(f[h]);break;case 12:this.$=f[h];break;case 13:this.$=f[h];break;case 14:this.$=f[h];break;case 15:this.$=f[h];break;case 16:this.$=f[h];break;case 17:this.$=f[h];break;case 18:this.$=f[h];break;case 19:this.$=f[h];break;case 20:this.$=f[h];break;case 21:this.$=f[h];break;case 22:this.$=f[h];break;case 23:this.$=f[h];break;case 24:this.$=new d.Block;break;case 25:this.$=f[h-1];break;case 26:this.$=new d.Literal(f[h]);break;case 27:this.$=new d.Literal(f[h]);break;case 28:this.$=new d.Literal(f[h]);break;case 29:this.$=f[h];break;case 30:this.$=new d.Literal(f[h]);break;case 31:this.$=new d.Literal(f[h]);break;case 32:this.$=new d.Literal(f[h]);break;case 33:this.$=new d.Undefined;break;case 34:this.$=new d.Null;break;case 35:this.$=new d.Bool(f[h]);break;case 36:this.$=new d.Assign(f[h-2],f[h]);break;case 37:this.$=new d.Assign(f[h-3],f[h]);break;case 38:this.$=new d.Assign(f[h-4],f[h-1]);break;case 39:this.$=new d.Value(f[h]);break;case 40:this.$=new d.Assign(new d.Value(f[h-2]),f[h],"object");break;case 41:this.$=new d.Assign(new d.Value(f[h-4]),f[h-1],"object");break;case 42:this.$=f[h];break;case 43:this.$=f[h];break;case 44:this.$=f[h];break;case 45:this.$=f[h];break;case 46:this.$=new d.Return(f[h]);break;case 47:this.$=new d.Return;break;case 48:this.$=new d.Comment(f[h]);break;case 49:this.$=new d.Code(f[h-3],f[h],f[h-1]);break;case 50:this.$=new d.Code([],f[h],f[h-1]);break;case 51:this.$="func";break;case 52:this.$="boundfunc";break;case 53:this.$=f[h];break;case 54:this.$=f[h];break;case 55:this.$=[];break;case 56:this.$=[f[h]];break;case 57:this.$=f[h-2].concat(f[h]);break;case 58:this.$=f[h-3].concat(f[h]);break;case 59:this.$=f[h-5].concat(f[h-2]);break;case 60:this.$=new d.Param(f[h]);break;case 61:this.$=new d.Param(f[h-1],null,!0);break;case 62:this.$=new d.Param(f[h-2],f[h]);break;case 63:this.$=f[h];break;case 64:this.$=f[h];break;case 65:this.$=f[h];break;case 66:this.$=f[h];break;case 67:this.$=new d.Splat(f[h-1]);break;case 68:this.$=new d.Value(f[h]);break;case 69:this.$=f[h-1].add(f[h]);break;case 70:this.$=new d.Value(f[h-1],[].concat(f[h]));break;case 71:this.$=f[h];break;case 72:this.$=f[h];break;case 73:this.$=new d.Value(f[h]);break;case 74:this.$=new d.Value(f[h]);break;case 75:this.$=f[h];break;case 76:this.$=new d.Value(f[h]);break;case 77:this.$=new d.Value(f[h]);break;case 78:this.$=new d.Value(f[h]);break;case 79:this.$=f[h];break;case 80:this.$=new d.Access(f[h]);break;case 81:this.$=new d.Access(f[h],"soak");break;case 82:this.$=[new d.Access(new d.Literal("prototype")),new d.Access(f[h])];break;case 83:this.$=new d.Access(new d.Literal("prototype"));break;case 84:this.$=f[h];break;case 85:this.$=f[h-1];break;case 86:this.$=d.extend(f[h],{soak:!0});break;case 87:this.$=new d.Index(f[h]);break;case 88:this.$=new d.Slice(f[h]);break;case 89:this.$=new d.Obj(f[h-2],f[h-3].generated);break;case 90:this.$=[];break;case 91:this.$=[f[h]];break;case 92:this.$=f[h-2].concat(f[h]);break;case 93:this.$=f[h-3].concat(f[h]);break;case 94:this.$=f[h-5].concat(f[h-2]);break;case 95:this.$=new d.Class;break;case 96:this.$=new d.Class(null,null,f[h]);break;case 97:this.$=new d.Class(null,f[h]);break;case 98:this.$=new d.Class(null,f[h-1],f[h]);break;case 99:this.$=new d.Class(f[h]);break;case 100:this.$=new d.Class(f[h-1],null,f[h]);break;case 101:this.$=new d.Class(f[h-2],f[h]);break;case 102:this.$=new d.Class(f[h-3],f[h-1],f[h]);break;case 103:this.$=new d.Call(f[h-2],f[h],f[h-1]);break;case 104:this.$=new d.Call(f[h-2],f[h],f[h-1]);break;case 105:this.$=new d.Call("super",[new d.Splat(new d.Literal("arguments"))]);break;case 106:this.$=new d.Call("super",f[h]);break;case 107:this.$=!1;break;case 108:this.$=!0;break;case 109:this.$=[];break;case 110:this.$=f[h-2];break;case 111:this.$=new d.Value(new d.Literal("this"));break;case 112:this.$=new d.Value(new d.Literal("this"));break;case 113:this.$=new d.Value(new d.Literal("this"),[new d.Access(f[h])],"this");break;case 114:this.$=new d.Arr([]);break;case 115:this.$=new d.Arr(f[h-2]);break;case 116:this.$="inclusive";break;case 117:this.$="exclusive";break;case 118:this.$=new d.Range(f[h-3],f[h-1],f[h-2]);break;case 119:this.$=new d.Range(f[h-2],f[h],f[h-1]);break;case 120:this.$=new d.Range(f[h-1],null,f[h]);break;case 121:this.$=new d.Range(null,f[h],f[h-1]);break;case 122:this.$=new d.Range(null,null,f[h]);break;case 123:this.$=[f[h]];break;case 124:this.$=f[h-2].concat(f[h]);break;case 125:this.$=f[h-3].concat(f[h]);break;case 126:this.$=f[h-2];break;case 127:this.$=f[h-5].concat(f[h-2]);break;case 128:this.$=f[h];break;case 129:this.$=f[h];break;case 130:this.$=f[h];break;case 131:this.$=[].concat(f[h-2],f[h]);break;case 132:this.$=new d.Try(f[h]);break;case 133:this.$=new d.Try(f[h-1],f[h][0],f[h][1]);break;case 134:this.$=new d.Try(f[h-2],null,null,f[h]);break;case 135:this.$=new d.Try(f[h-3],f[h-2][0],f[h-2][1],f[h]);break;case 136:this.$=[f[h-1],f[h]];break;case 137:this.$=new d.Throw(f[h]);break;case 138:this.$=new d.Parens(f[h-1]);break;case 139:this.$=new d.Parens(f[h-2]);break;case 140:this.$=new d.While(f[h]);break;case 141:this.$=new d.While(f[h-2],{guard:f[h]});break;case 142:this.$=new d.While(f[h],{invert:!0});break;case 143:this.$=new d.While(f[h-2],{invert:!0,guard:f[h]});break;case 144:this.$=f[h-1].addBody(f[h]);break;case 145:this.$=f[h].addBody(d.Block.wrap([f[h-1]]));break;case 146:this.$=f[h].addBody(d.Block.wrap([f[h-1]]));break;case 147:this.$=f[h];break;case 148:this.$=(new d.While(new d.Literal("true"))).addBody(f[h]);break;case 149:this.$=(new d.While(new d.Literal("true"))).addBody(d.Block.wrap([f[h]]));break;case 150:this.$=new d.For(f[h-1],f[h]);break;case 151:this.$=new d.For(f[h-1],f[h]);break;case 152:this.$=new d.For(f[h],f[h-1]);break;case 153:this.$={source:new d.Value(f[h])};break;case 154:this.$=function(){f[h].own=f[h-1].own,f[h].name=f[h-1][0],f[h].index=f[h-1][1];return f[h]}();break;case 155:this.$=f[h];break;case 156:this.$=function(){f[h].own=!0;return f[h]}();break;case 157:this.$=f[h];break;case 158:this.$=f[h];break;case 159:this.$=new d.Value(f[h]);break;case 160:this.$=new d.Value(f[h]);break;case 161:this.$=[f[h]];break;case 162:this.$=[f[h-2],f[h]];break;case 163:this.$={source:f[h]};break;case 164:this.$={source:f[h],object:!0};break;case 165:this.$={source:f[h-2],guard:f[h]};break;case 166:this.$={source:f[h-2],guard:f[h],object:!0};break;case 167:this.$={source:f[h-2],step:f[h]};break;case 168:this.$={source:f[h-4],guard:f[h-2],step:f[h]};break;case 169:this.$={source:f[h-4],step:f[h-2],guard:f[h]};break;case 170:this.$=new d.Switch(f[h-3],f[h-1]);break;case 171:this.$=new d.Switch(f[h-5],f[h-3],f[h-1]);break;case 172:this.$=new d.Switch(null,f[h-1]);break;case 173:this.$=new d.Switch(null,f[h-3],f[h-1]);break;case 174:this.$=f[h];break;case 175:this.$=f[h-1].concat(f[h]);break;case 176:this.$=[[f[h-1],f[h]]];break;case 177:this.$=[[f[h-2],f[h-1]]];break;case 178:this.$=new d.If(f[h-1],f[h],{type:f[h-2]});break;case 179:this.$=f[h-4].addElse(new d.If(f[h-1],f[h],{type:f[h-2]}));break;case 180:this.$=f[h];break;case 181:this.$=f[h-2].addElse(f[h]);break;case 182:this.$=new d.If(f[h],d.Block.wrap([f[h-2]]),{type:f[h-1],statement:!0});break;case 183:this.$=new d.If(f[h],d.Block.wrap([f[h-2]]),{type:f[h-1],statement:!0});break;case 184:this.$=new d.Op(f[h-1],f[h]);break;case 185:this.$=new d.Op("-",f[h]);break;case 186:this.$=new d.Op("+",f[h]);break;case 187:this.$=new d.Op("--",f[h]);break;case 188:this.$=new d.Op("++",f[h]);break;case 189:this.$=new d.Op("--",f[h-1],null,!0);break;case 190:this.$=new d.Op("++",f[h-1],null,!0);break;case 191:this.$=new d.Existence(f[h-1]);break;case 192:this.$=new d.Op("+",f[h-2],f[h]);break;case 193:this.$=new d.Op("-",f[h-2],f[h]);break;case 194:this.$=new d.Op(f[h-1],f[h-2],f[h]);break;case 195:this.$=new d.Op(f[h-1],f[h-2],f[h]);break;case 196:this.$=new d.Op(f[h-1],f[h-2],f[h]);break;case 197:this.$=new d.Op(f[h-1],f[h-2],f[h]);break;case 198:this.$=function(){return f[h-1].charAt(0)==="!"?(new d.Op(f[h-1].slice(1),f[h-2],f[h])).invert():new d.Op(f[h-1],f[h-2],f[h])}();break;case 199:this.$=new d.Assign(f[h-2],f[h],f[h-1]);break;case 200:this.$=new d.Assign(f[h-4],f[h-1],f[h-3]);break;case 201:this.$=new d.Extends(f[h-2],f[h])}},table:[{1:[2,1],3:1,4:2,5:3,7:4,8:6,9:7,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,25:[1,5],27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[3]},{1:[2,2],6:[1,74]},{6:[1,75]},{1:[2,4],6:[2,4],26:[2,4],101:[2,4]},{4:77,7:4,8:6,9:7,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,26:[1,76],27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,7],6:[2,7],26:[2,7],101:[2,7],102:87,103:[1,65],105:[1,66],108:88,109:[1,68],110:69,125:[1,86],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,8],6:[2,8],26:[2,8],101:[2,8],102:90,103:[1,65],105:[1,66],108:91,109:[1,68],110:69,125:[1,89]},{1:[2,12],6:[2,12],25:[2,12],26:[2,12],49:[2,12],54:[2,12],57:[2,12],62:93,66:[1,95],67:[1,96],68:[1,97],69:98,70:[1,99],72:[2,12],73:[1,100],77:[2,12],80:92,83:[1,94],84:[2,107],85:[2,12],90:[2,12],92:[2,12],101:[2,12],103:[2,12],104:[2,12],105:[2,12],109:[2,12],117:[2,12],125:[2,12],127:[2,12],128:[2,12],131:[2,12],132:[2,12],133:[2,12],134:[2,12],135:[2,12],136:[2,12]},{1:[2,13],6:[2,13],25:[2,13],26:[2,13],49:[2,13],54:[2,13],57:[2,13],62:102,66:[1,95],67:[1,96],68:[1,97],69:98,70:[1,99],72:[2,13],73:[1,100],77:[2,13],80:101,83:[1,94],84:[2,107],85:[2,13],90:[2,13],92:[2,13],101:[2,13],103:[2,13],104:[2,13],105:[2,13],109:[2,13],117:[2,13],125:[2,13],127:[2,13],128:[2,13],131:[2,13],132:[2,13],133:[2,13],134:[2,13],135:[2,13],136:[2,13]},{1:[2,14],6:[2,14],25:[2,14],26:[2,14],49:[2,14],54:[2,14],57:[2,14],72:[2,14],77:[2,14],85:[2,14],90:[2,14],92:[2,14],101:[2,14],103:[2,14],104:[2,14],105:[2,14],109:[2,14],117:[2,14],125:[2,14],127:[2,14],128:[2,14],131:[2,14],132:[2,14],133:[2,14],134:[2,14],135:[2,14],136:[2,14]},{1:[2,15],6:[2,15],25:[2,15],26:[2,15],49:[2,15],54:[2,15],57:[2,15],72:[2,15],77:[2,15],85:[2,15],90:[2,15],92:[2,15],101:[2,15],103:[2,15],104:[2,15],105:[2,15],109:[2,15],117:[2,15],125:[2,15],127:[2,15],128:[2,15],131:[2,15],132:[2,15],133:[2,15],134:[2,15],135:[2,15],136:[2,15]},{1:[2,16],6:[2,16],25:[2,16],26:[2,16],49:[2,16],54:[2,16],57:[2,16],72:[2,16],77:[2,16],85:[2,16],90:[2,16],92:[2,16],101:[2,16],103:[2,16],104:[2,16],105:[2,16],109:[2,16],117:[2,16],125:[2,16],127:[2,16],128:[2,16],131:[2,16],132:[2,16],133:[2,16],134:[2,16],135:[2,16],136:[2,16]},{1:[2,17],6:[2,17],25:[2,17],26:[2,17],49:[2,17],54:[2,17],57:[2,17],72:[2,17],77:[2,17],85:[2,17],90:[2,17],92:[2,17],101:[2,17],103:[2,17],104:[2,17],105:[2,17],109:[2,17],117:[2,17],125:[2,17],127:[2,17],128:[2,17],131:[2,17],132:[2,17],133:[2,17],134:[2,17],135:[2,17],136:[2,17]},{1:[2,18],6:[2,18],25:[2,18],26:[2,18],49:[2,18],54:[2,18],57:[2,18],72:[2,18],77:[2,18],85:[2,18],90:[2,18],92:[2,18],101:[2,18],103:[2,18],104:[2,18],105:[2,18],109:[2,18],117:[2,18],125:[2,18],127:[2,18],128:[2,18],131:[2,18],132:[2,18],133:[2,18],134:[2,18],135:[2,18],136:[2,18]},{1:[2,19],6:[2,19],25:[2,19],26:[2,19],49:[2,19],54:[2,19],57:[2,19],72:[2,19],77:[2,19],85:[2,19],90:[2,19],92:[2,19],101:[2,19],103:[2,19],104:[2,19],105:[2,19],109:[2,19],117:[2,19],125:[2,19],127:[2,19],128:[2,19],131:[2,19],132:[2,19],133:[2,19],134:[2,19],135:[2,19],136:[2,19]},{1:[2,20],6:[2,20],25:[2,20],26:[2,20],49:[2,20],54:[2,20],57:[2,20],72:[2,20],77:[2,20],85:[2,20],90:[2,20],92:[2,20],101:[2,20],103:[2,20],104:[2,20],105:[2,20],109:[2,20],117:[2,20],125:[2,20],127:[2,20],128:[2,20],131:[2,20],132:[2,20],133:[2,20],134:[2,20],135:[2,20],136:[2,20]},{1:[2,21],6:[2,21],25:[2,21],26:[2,21],49:[2,21],54:[2,21],57:[2,21],72:[2,21],77:[2,21],85:[2,21],90:[2,21],92:[2,21],101:[2,21],103:[2,21],104:[2,21],105:[2,21],109:[2,21],117:[2,21],125:[2,21],127:[2,21],128:[2,21],131:[2,21],132:[2,21],133:[2,21],134:[2,21],135:[2,21],136:[2,21]},{1:[2,22],6:[2,22],25:[2,22],26:[2,22],49:[2,22],54:[2,22],57:[2,22],72:[2,22],77:[2,22],85:[2,22],90:[2,22],92:[2,22],101:[2,22],103:[2,22],104:[2,22],105:[2,22],109:[2,22],117:[2,22],125:[2,22],127:[2,22],128:[2,22],131:[2,22],132:[2,22],133:[2,22],134:[2,22],135:[2,22],136:[2,22]},{1:[2,23],6:[2,23],25:[2,23],26:[2,23],49:[2,23],54:[2,23],57:[2,23],72:[2,23],77:[2,23],85:[2,23],90:[2,23],92:[2,23],101:[2,23],103:[2,23],104:[2,23],105:[2,23],109:[2,23],117:[2,23],125:[2,23],127:[2,23],128:[2,23],131:[2,23],132:[2,23],133:[2,23],134:[2,23],135:[2,23],136:[2,23]},{1:[2,9],6:[2,9],26:[2,9],101:[2,9],103:[2,9],105:[2,9],109:[2,9],125:[2,9]},{1:[2,10],6:[2,10],26:[2,10],101:[2,10],103:[2,10],105:[2,10],109:[2,10],125:[2,10]},{1:[2,11],6:[2,11],26:[2,11],101:[2,11],103:[2,11],105:[2,11],109:[2,11],125:[2,11]},{1:[2,75],6:[2,75],25:[2,75],26:[2,75],40:[1,103],49:[2,75],54:[2,75],57:[2,75],66:[2,75],67:[2,75],68:[2,75],70:[2,75],72:[2,75],73:[2,75],77:[2,75],83:[2,75],84:[2,75],85:[2,75],90:[2,75],92:[2,75],101:[2,75],103:[2,75],104:[2,75],105:[2,75],109:[2,75],117:[2,75],125:[2,75],127:[2,75],128:[2,75],131:[2,75],132:[2,75],133:[2,75],134:[2,75],135:[2,75],136:[2,75]},{1:[2,76],6:[2,76],25:[2,76],26:[2,76],49:[2,76],54:[2,76],57:[2,76],66:[2,76],67:[2,76],68:[2,76],70:[2,76],72:[2,76],73:[2,76],77:[2,76],83:[2,76],84:[2,76],85:[2,76],90:[2,76],92:[2,76],101:[2,76],103:[2,76],104:[2,76],105:[2,76],109:[2,76],117:[2,76],125:[2,76],127:[2,76],128:[2,76],131:[2,76],132:[2,76],133:[2,76],134:[2,76],135:[2,76],136:[2,76]},{1:[2,77],6:[2,77],25:[2,77],26:[2,77],49:[2,77],54:[2,77],57:[2,77],66:[2,77],67:[2,77],68:[2,77],70:[2,77],72:[2,77],73:[2,77],77:[2,77],83:[2,77],84:[2,77],85:[2,77],90:[2,77],92:[2,77],101:[2,77],103:[2,77],104:[2,77],105:[2,77],109:[2,77],117:[2,77],125:[2,77],127:[2,77],128:[2,77],131:[2,77],132:[2,77],133:[2,77],134:[2,77],135:[2,77],136:[2,77]},{1:[2,78],6:[2,78],25:[2,78],26:[2,78],49:[2,78],54:[2,78],57:[2,78],66:[2,78],67:[2,78],68:[2,78],70:[2,78],72:[2,78],73:[2,78],77:[2,78],83:[2,78],84:[2,78],85:[2,78],90:[2,78],92:[2,78],101:[2,78],103:[2,78],104:[2,78],105:[2,78],109:[2,78],117:[2,78],125:[2,78],127:[2,78],128:[2,78],131:[2,78],132:[2,78],133:[2,78],134:[2,78],135:[2,78],136:[2,78]},{1:[2,79],6:[2,79],25:[2,79],26:[2,79],49:[2,79],54:[2,79],57:[2,79],66:[2,79],67:[2,79],68:[2,79],70:[2,79],72:[2,79],73:[2,79],77:[2,79],83:[2,79],84:[2,79],85:[2,79],90:[2,79],92:[2,79],101:[2,79],103:[2,79],104:[2,79],105:[2,79],109:[2,79],117:[2,79],125:[2,79],127:[2,79],128:[2,79],131:[2,79],132:[2,79],133:[2,79],134:[2,79],135:[2,79],136:[2,79]},{1:[2,105],6:[2,105],25:[2,105],26:[2,105],49:[2,105],54:[2,105],57:[2,105],66:[2,105],67:[2,105],68:[2,105],70:[2,105],72:[2,105],73:[2,105],77:[2,105],81:104,83:[2,105],84:[1,105],85:[2,105],90:[2,105],92:[2,105],101:[2,105],103:[2,105],104:[2,105],105:[2,105],109:[2,105],117:[2,105],125:[2,105],127:[2,105],128:[2,105],131:[2,105],132:[2,105],133:[2,105],134:[2,105],135:[2,105],136:[2,105]},{6:[2,55],25:[2,55],27:109,28:[1,73],44:110,48:106,49:[2,55],54:[2,55],55:107,56:108,58:111,59:112,75:[1,70],88:[1,113],89:[1,114]},{5:115,25:[1,5]},{8:116,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:118,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:119,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{13:121,14:122,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:123,44:63,58:47,59:48,61:120,63:25,64:26,65:27,75:[1,70],82:[1,28],87:[1,58],88:[1,59],89:[1,57],100:[1,56]},{13:121,14:122,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:123,44:63,58:47,59:48,61:124,63:25,64:26,65:27,75:[1,70],82:[1,28],87:[1,58],88:[1,59],89:[1,57],100:[1,56]},{1:[2,72],6:[2,72],25:[2,72],26:[2,72],40:[2,72],49:[2,72],54:[2,72],57:[2,72],66:[2,72],67:[2,72],68:[2,72],70:[2,72],72:[2,72],73:[2,72],77:[2,72],79:[1,128],83:[2,72],84:[2,72],85:[2,72],90:[2,72],92:[2,72],101:[2,72],103:[2,72],104:[2,72],105:[2,72],109:[2,72],117:[2,72],125:[2,72],127:[2,72],128:[2,72],129:[1,125],130:[1,126],131:[2,72],132:[2,72],133:[2,72],134:[2,72],135:[2,72],136:[2,72],137:[1,127]},{1:[2,180],6:[2,180],25:[2,180],26:[2,180],49:[2,180],54:[2,180],57:[2,180],72:[2,180],77:[2,180],85:[2,180],90:[2,180],92:[2,180],101:[2,180],103:[2,180],104:[2,180],105:[2,180],109:[2,180],117:[2,180],120:[1,129],125:[2,180],127:[2,180],128:[2,180],131:[2,180],132:[2,180],133:[2,180],134:[2,180],135:[2,180],136:[2,180]},{5:130,25:[1,5]},{5:131,25:[1,5]},{1:[2,147],6:[2,147],25:[2,147],26:[2,147],49:[2,147],54:[2,147],57:[2,147],72:[2,147],77:[2,147],85:[2,147],90:[2,147],92:[2,147],101:[2,147],103:[2,147],104:[2,147],105:[2,147],109:[2,147],117:[2,147],125:[2,147],127:[2,147],128:[2,147],131:[2,147],132:[2,147],133:[2,147],134:[2,147],135:[2,147],136:[2,147]},{5:132,25:[1,5]},{8:133,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,25:[1,134],27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,95],5:135,6:[2,95],13:121,14:122,25:[1,5],26:[2,95],27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:123,44:63,49:[2,95],54:[2,95],57:[2,95],58:47,59:48,61:137,63:25,64:26,65:27,72:[2,95],75:[1,70],77:[2,95],79:[1,136],82:[1,28],85:[2,95],87:[1,58],88:[1,59],89:[1,57],90:[2,95],92:[2,95],100:[1,56],101:[2,95],103:[2,95],104:[2,95],105:[2,95],109:[2,95],117:[2,95],125:[2,95],127:[2,95],128:[2,95],131:[2,95],132:[2,95],133:[2,95],134:[2,95],135:[2,95],136:[2,95]},{8:138,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,47],6:[2,47],8:139,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,26:[2,47],27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],101:[2,47],102:39,103:[2,47],105:[2,47],106:40,107:[1,67],108:41,109:[2,47],110:69,118:[1,42],123:37,124:[1,64],125:[2,47],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,48],6:[2,48],25:[2,48],26:[2,48],54:[2,48],77:[2,48],101:[2,48],103:[2,48],105:[2,48],109:[2,48],125:[2,48]},{1:[2,73],6:[2,73],25:[2,73],26:[2,73],40:[2,73],49:[2,73],54:[2,73],57:[2,73],66:[2,73],67:[2,73],68:[2,73],70:[2,73],72:[2,73],73:[2,73],77:[2,73],83:[2,73],84:[2,73],85:[2,73],90:[2,73],92:[2,73],101:[2,73],103:[2,73],104:[2,73],105:[2,73],109:[2,73],117:[2,73],125:[2,73],127:[2,73],128:[2,73],131:[2,73],132:[2,73],133:[2,73],134:[2,73],135:[2,73],136:[2,73]},{1:[2,74],6:[2,74],25:[2,74],26:[2,74],40:[2,74],49:[2,74],54:[2,74],57:[2,74],66:[2,74],67:[2,74],68:[2,74],70:[2,74],72:[2,74],73:[2,74],77:[2,74],83:[2,74],84:[2,74],85:[2,74],90:[2,74],92:[2,74],101:[2,74],103:[2,74],104:[2,74],105:[2,74],109:[2,74],117:[2,74],125:[2,74],127:[2,74],128:[2,74],131:[2,74],132:[2,74],133:[2,74],134:[2,74],135:[2,74],136:[2,74]},{1:[2,29],6:[2,29],25:[2,29],26:[2,29],49:[2,29],54:[2,29],57:[2,29],66:[2,29],67:[2,29],68:[2,29],70:[2,29],72:[2,29],73:[2,29],77:[2,29],83:[2,29],84:[2,29],85:[2,29],90:[2,29],92:[2,29],101:[2,29],103:[2,29],104:[2,29],105:[2,29],109:[2,29],117:[2,29],125:[2,29],127:[2,29],128:[2,29],131:[2,29],132:[2,29],133:[2,29],134:[2,29],135:[2,29],136:[2,29]},{1:[2,30],6:[2,30],25:[2,30],26:[2,30],49:[2,30],54:[2,30],57:[2,30],66:[2,30],67:[2,30],68:[2,30],70:[2,30],72:[2,30],73:[2,30],77:[2,30],83:[2,30],84:[2,30],85:[2,30],90:[2,30],92:[2,30],101:[2,30],103:[2,30],104:[2,30],105:[2,30],109:[2,30],117:[2,30],125:[2,30],127:[2,30],128:[2,30],131:[2,30],132:[2,30],133:[2,30],134:[2,30],135:[2,30],136:[2,30]},{1:[2,31],6:[2,31],25:[2,31],26:[2,31],49:[2,31],54:[2,31],57:[2,31],66:[2,31],67:[2,31],68:[2,31],70:[2,31],72:[2,31],73:[2,31],77:[2,31],83:[2,31],84:[2,31],85:[2,31],90:[2,31],92:[2,31],101:[2,31],103:[2,31],104:[2,31],105:[2,31],109:[2,31],117:[2,31],125:[2,31],127:[2,31],128:[2,31],131:[2,31],132:[2,31],133:[2,31],134:[2,31],135:[2,31],136:[2,31]},{1:[2,32],6:[2,32],25:[2,32],26:[2,32],49:[2,32],54:[2,32],57:[2,32],66:[2,32],67:[2,32],68:[2,32],70:[2,32],72:[2,32],73:[2,32],77:[2,32],83:[2,32],84:[2,32],85:[2,32],90:[2,32],92:[2,32],101:[2,32],103:[2,32],104:[2,32],105:[2,32],109:[2,32],117:[2,32],125:[2,32],127:[2,32],128:[2,32],131:[2,32],132:[2,32],133:[2,32],134:[2,32],135:[2,32],136:[2,32]},{1:[2,33],6:[2,33],25:[2,33],26:[2,33],49:[2,33],54:[2,33],57:[2,33],66:[2,33],67:[2,33],68:[2,33],70:[2,33],72:[2,33],73:[2,33],77:[2,33],83:[2,33],84:[2,33],85:[2,33],90:[2,33],92:[2,33],101:[2,33],103:[2,33],104:[2,33],105:[2,33],109:[2,33],117:[2,33],125:[2,33],127:[2,33],128:[2,33],131:[2,33],132:[2,33],133:[2,33],134:[2,33],135:[2,33],136:[2,33]},{1:[2,34],6:[2,34],25:[2,34],26:[2,34],49:[2,34],54:[2,34],57:[2,34],66:[2,34],67:[2,34],68:[2,34],70:[2,34],72:[2,34],73:[2,34],77:[2,34],83:[2,34],84:[2,34],85:[2,34],90:[2,34],92:[2,34],101:[2,34],103:[2,34],104:[2,34],105:[2,34],109:[2,34],117:[2,34],125:[2,34],127:[2,34],128:[2,34],131:[2,34],132:[2,34],133:[2,34],134:[2,34],135:[2,34],136:[2,34]},{1:[2,35],6:[2,35],25:[2,35],26:[2,35],49:[2,35],54:[2,35],57:[2,35],66:[2,35],67:[2,35],68:[2,35],70:[2,35],72:[2,35],73:[2,35],77:[2,35],83:[2,35],84:[2,35],85:[2,35],90:[2,35],92:[2,35],101:[2,35],103:[2,35],104:[2,35],105:[2,35],109:[2,35],117:[2,35],125:[2,35],127:[2,35],128:[2,35],131:[2,35],132:[2,35],133:[2,35],134:[2,35],135:[2,35],136:[2,35]},{4:140,7:4,8:6,9:7,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,25:[1,141],27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:142,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,25:[1,146],27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,60:147,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],86:144,87:[1,58],88:[1,59],89:[1,57],90:[1,143],93:145,95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,111],6:[2,111],25:[2,111],26:[2,111],49:[2,111],54:[2,111],57:[2,111],66:[2,111],67:[2,111],68:[2,111],70:[2,111],72:[2,111],73:[2,111],77:[2,111],83:[2,111],84:[2,111],85:[2,111],90:[2,111],92:[2,111],101:[2,111],103:[2,111],104:[2,111],105:[2,111],109:[2,111],117:[2,111],125:[2,111],127:[2,111],128:[2,111],131:[2,111],132:[2,111],133:[2,111],134:[2,111],135:[2,111],136:[2,111]},{1:[2,112],6:[2,112],25:[2,112],26:[2,112],27:148,28:[1,73],49:[2,112],54:[2,112],57:[2,112],66:[2,112],67:[2,112],68:[2,112],70:[2,112],72:[2,112],73:[2,112],77:[2,112],83:[2,112],84:[2,112],85:[2,112],90:[2,112],92:[2,112],101:[2,112],103:[2,112],104:[2,112],105:[2,112],109:[2,112],117:[2,112],125:[2,112],127:[2,112],128:[2,112],131:[2,112],132:[2,112],133:[2,112],134:[2,112],135:[2,112],136:[2,112]},{25:[2,51]},{25:[2,52]},{1:[2,68],6:[2,68],25:[2,68],26:[2,68],40:[2,68],49:[2,68],54:[2,68],57:[2,68],66:[2,68],67:[2,68],68:[2,68],70:[2,68],72:[2,68],73:[2,68],77:[2,68],79:[2,68],83:[2,68],84:[2,68],85:[2,68],90:[2,68],92:[2,68],101:[2,68],103:[2,68],104:[2,68],105:[2,68],109:[2,68],117:[2,68],125:[2,68],127:[2,68],128:[2,68],129:[2,68],130:[2,68],131:[2,68],132:[2,68],133:[2,68],134:[2,68],135:[2,68],136:[2,68],137:[2,68]},{1:[2,71],6:[2,71],25:[2,71],26:[2,71],40:[2,71],49:[2,71],54:[2,71],57:[2,71],66:[2,71],67:[2,71],68:[2,71],70:[2,71],72:[2,71],73:[2,71],77:[2,71],79:[2,71],83:[2,71],84:[2,71],85:[2,71],90:[2,71],92:[2,71],101:[2,71],103:[2,71],104:[2,71],105:[2,71],109:[2,71],117:[2,71],125:[2,71],127:[2,71],128:[2,71],129:[2,71],130:[2,71],131:[2,71],132:[2,71],133:[2,71],134:[2,71],135:[2,71],136:[2,71],137:[2,71]},{8:149,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:150,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:151,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{5:152,8:153,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,25:[1,5],27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{27:158,28:[1,73],44:159,58:160,59:161,64:154,75:[1,70],88:[1,113],89:[1,57],112:155,113:[1,156],114:157},{111:162,115:[1,163],116:[1,164]},{6:[2,90],11:168,25:[2,90],27:169,28:[1,73],29:170,30:[1,71],31:[1,72],41:166,42:167,44:171,46:[1,46],54:[2,90],76:165,77:[2,90],88:[1,113]},{1:[2,27],6:[2,27],25:[2,27],26:[2,27],43:[2,27],49:[2,27],54:[2,27],57:[2,27],66:[2,27],67:[2,27],68:[2,27],70:[2,27],72:[2,27],73:[2,27],77:[2,27],83:[2,27],84:[2,27],85:[2,27],90:[2,27],92:[2,27],101:[2,27],103:[2,27],104:[2,27],105:[2,27],109:[2,27],117:[2,27],125:[2,27],127:[2,27],128:[2,27],131:[2,27],132:[2,27],133:[2,27],134:[2,27],135:[2,27],136:[2,27]},{1:[2,28],6:[2,28],25:[2,28],26:[2,28],43:[2,28],49:[2,28],54:[2,28],57:[2,28],66:[2,28],67:[2,28],68:[2,28],70:[2,28],72:[2,28],73:[2,28],77:[2,28],83:[2,28],84:[2,28],85:[2,28],90:[2,28],92:[2,28],101:[2,28],103:[2,28],104:[2,28],105:[2,28],109:[2,28],117:[2,28],125:[2,28],127:[2,28],128:[2,28],131:[2,28],132:[2,28],133:[2,28],134:[2,28],135:[2,28],136:[2,28]},{1:[2,26],6:[2,26],25:[2,26],26:[2,26],40:[2,26],43:[2,26],49:[2,26],54:[2,26],57:[2,26],66:[2,26],67:[2,26],68:[2,26],70:[2,26],72:[2,26],73:[2,26],77:[2,26],79:[2,26],83:[2,26],84:[2,26],85:[2,26],90:[2,26],92:[2,26],101:[2,26],103:[2,26],104:[2,26],105:[2,26],109:[2,26],115:[2,26],116:[2,26],117:[2,26],125:[2,26],127:[2,26],128:[2,26],129:[2,26],130:[2,26],131:[2,26],132:[2,26],133:[2,26],134:[2,26],135:[2,26],136:[2,26],137:[2,26]},{1:[2,6],6:[2,6],7:172,8:6,9:7,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,26:[2,6],27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],101:[2,6],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,3]},{1:[2,24],6:[2,24],25:[2,24],26:[2,24],49:[2,24],54:[2,24],57:[2,24],72:[2,24],77:[2,24],85:[2,24],90:[2,24],92:[2,24],97:[2,24],98:[2,24],101:[2,24],103:[2,24],104:[2,24],105:[2,24],109:[2,24],117:[2,24],120:[2,24],122:[2,24],125:[2,24],127:[2,24],128:[2,24],131:[2,24],132:[2,24],133:[2,24],134:[2,24],135:[2,24],136:[2,24]},{6:[1,74],26:[1,173]},{1:[2,191],6:[2,191],25:[2,191],26:[2,191],49:[2,191],54:[2,191],57:[2,191],72:[2,191],77:[2,191],85:[2,191],90:[2,191],92:[2,191],101:[2,191],103:[2,191],104:[2,191],105:[2,191],109:[2,191],117:[2,191],125:[2,191],127:[2,191],128:[2,191],131:[2,191],132:[2,191],133:[2,191],134:[2,191],135:[2,191],136:[2,191]},{8:174,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:175,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:176,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:177,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:178,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:179,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:180,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:181,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,146],6:[2,146],25:[2,146],26:[2,146],49:[2,146],54:[2,146],57:[2,146],72:[2,146],77:[2,146],85:[2,146],90:[2,146],92:[2,146],101:[2,146],103:[2,146],104:[2,146],105:[2,146],109:[2,146],117:[2,146],125:[2,146],127:[2,146],128:[2,146],131:[2,146],132:[2,146],133:[2,146],134:[2,146],135:[2,146],136:[2,146]},{1:[2,151],6:[2,151],25:[2,151],26:[2,151],49:[2,151],54:[2,151],57:[2,151],72:[2,151],77:[2,151],85:[2,151],90:[2,151],92:[2,151],101:[2,151],103:[2,151],104:[2,151],105:[2,151],109:[2,151],117:[2,151],125:[2,151],127:[2,151],128:[2,151],131:[2,151],132:[2,151],133:[2,151],134:[2,151],135:[2,151],136:[2,151]},{8:182,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,145],6:[2,145],25:[2,145],26:[2,145],49:[2,145],54:[2,145],57:[2,145],72:[2,145],77:[2,145],85:[2,145],90:[2,145],92:[2,145],101:[2,145],103:[2,145],104:[2,145],105:[2,145],109:[2,145],117:[2,145],125:[2,145],127:[2,145],128:[2,145],131:[2,145],132:[2,145],133:[2,145],134:[2,145],135:[2,145],136:[2,145]},{1:[2,150],6:[2,150],25:[2,150],26:[2,150],49:[2,150],54:[2,150],57:[2,150],72:[2,150],77:[2,150],85:[2,150],90:[2,150],92:[2,150],101:[2,150],103:[2,150],104:[2,150],105:[2,150],109:[2,150],117:[2,150],125:[2,150],127:[2,150],128:[2,150],131:[2,150],132:[2,150],133:[2,150],134:[2,150],135:[2,150],136:[2,150]},{81:183,84:[1,105]},{1:[2,69],6:[2,69],25:[2,69],26:[2,69],40:[2,69],49:[2,69],54:[2,69],57:[2,69],66:[2,69],67:[2,69],68:[2,69],70:[2,69],72:[2,69],73:[2,69],77:[2,69],79:[2,69],83:[2,69],84:[2,69],85:[2,69],90:[2,69],92:[2,69],101:[2,69],103:[2,69],104:[2,69],105:[2,69],109:[2,69],117:[2,69],125:[2,69],127:[2,69],128:[2,69],129:[2,69],130:[2,69],131:[2,69],132:[2,69],133:[2,69],134:[2,69],135:[2,69],136:[2,69],137:[2,69]},{84:[2,108]},{27:184,28:[1,73]},{27:185,28:[1,73]},{1:[2,83],6:[2,83],25:[2,83],26:[2,83],27:186,28:[1,73],40:[2,83],49:[2,83],54:[2,83],57:[2,83],66:[2,83],67:[2,83],68:[2,83],70:[2,83],72:[2,83],73:[2,83],77:[2,83],79:[2,83],83:[2,83],84:[2,83],85:[2,83],90:[2,83],92:[2,83],101:[2,83],103:[2,83],104:[2,83],105:[2,83],109:[2,83],117:[2,83],125:[2,83],127:[2,83],128:[2,83],129:[2,83],130:[2,83],131:[2,83],132:[2,83],133:[2,83],134:[2,83],135:[2,83],136:[2,83],137:[2,83]},{1:[2,84],6:[2,84],25:[2,84],26:[2,84],40:[2,84],49:[2,84],54:[2,84],57:[2,84],66:[2,84],67:[2,84],68:[2,84],70:[2,84],72:[2,84],73:[2,84],77:[2,84],79:[2,84],83:[2,84],84:[2,84],85:[2,84],90:[2,84],92:[2,84],101:[2,84],103:[2,84],104:[2,84],105:[2,84],109:[2,84],117:[2,84],125:[2,84],127:[2,84],128:[2,84],129:[2,84],130:[2,84],131:[2,84],132:[2,84],133:[2,84],134:[2,84],135:[2,84],136:[2,84],137:[2,84]},{8:188,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],57:[1,192],58:47,59:48,61:36,63:25,64:26,65:27,71:187,74:189,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],91:190,92:[1,191],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{69:193,70:[1,99],73:[1,100]},{81:194,84:[1,105]},{1:[2,70],6:[2,70],25:[2,70],26:[2,70],40:[2,70],49:[2,70],54:[2,70],57:[2,70],66:[2,70],67:[2,70],68:[2,70],70:[2,70],72:[2,70],73:[2,70],77:[2,70],79:[2,70],83:[2,70],84:[2,70],85:[2,70],90:[2,70],92:[2,70],101:[2,70],103:[2,70],104:[2,70],105:[2,70],109:[2,70],117:[2,70],125:[2,70],127:[2,70],128:[2,70],129:[2,70],130:[2,70],131:[2,70],132:[2,70],133:[2,70],134:[2,70],135:[2,70],136:[2,70],137:[2,70]},{6:[1,196],8:195,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,25:[1,197],27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,106],6:[2,106],25:[2,106],26:[2,106],49:[2,106],54:[2,106],57:[2,106],66:[2,106],67:[2,106],68:[2,106],70:[2,106],72:[2,106],73:[2,106],77:[2,106],83:[2,106],84:[2,106],85:[2,106],90:[2,106],92:[2,106],101:[2,106],103:[2,106],104:[2,106],105:[2,106],109:[2,106],117:[2,106],125:[2,106],127:[2,106],128:[2,106],131:[2,106],132:[2,106],133:[2,106],134:[2,106],135:[2,106],136:[2,106]},{8:200,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,25:[1,146],27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,60:147,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],85:[1,198],86:199,87:[1,58],88:[1,59],89:[1,57],93:145,95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{6:[2,53],25:[2,53],49:[1,201],53:203,54:[1,202]},{6:[2,56],25:[2,56],26:[2,56],49:[2,56],54:[2,56]},{6:[2,60],25:[2,60],26:[2,60],40:[1,205],49:[2,60],54:[2,60],57:[1,204]},{6:[2,63],25:[2,63],26:[2,63],40:[2,63],49:[2,63],54:[2,63],57:[2,63]},{6:[2,64],25:[2,64],26:[2,64],40:[2,64],49:[2,64],54:[2,64],57:[2,64]},{6:[2,65],25:[2,65],26:[2,65],40:[2,65],49:[2,65],54:[2,65],57:[2,65]},{6:[2,66],25:[2,66],26:[2,66],40:[2,66],49:[2,66],54:[2,66],57:[2,66]},{27:148,28:[1,73]},{8:200,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,25:[1,146],27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,60:147,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],86:144,87:[1,58],88:[1,59],89:[1,57],90:[1,143],93:145,95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,50],6:[2,50],25:[2,50],26:[2,50],49:[2,50],54:[2,50],57:[2,50],72:[2,50],77:[2,50],85:[2,50],90:[2,50],92:[2,50],101:[2,50],103:[2,50],104:[2,50],105:[2,50],109:[2,50],117:[2,50],125:[2,50],127:[2,50],128:[2,50],131:[2,50],132:[2,50],133:[2,50],134:[2,50],135:[2,50],136:[2,50]},{1:[2,184],6:[2,184],25:[2,184],26:[2,184],49:[2,184],54:[2,184],57:[2,184],72:[2,184],77:[2,184],85:[2,184],90:[2,184],92:[2,184],101:[2,184],102:87,103:[2,184],104:[2,184],105:[2,184],108:88,109:[2,184],110:69,117:[2,184],125:[2,184],127:[2,184],128:[2,184],131:[1,78],132:[2,184],133:[2,184],134:[2,184],135:[2,184],136:[2,184]},{102:90,103:[1,65],105:[1,66],108:91,109:[1,68],110:69,125:[1,89]},{1:[2,185],6:[2,185],25:[2,185],26:[2,185],49:[2,185],54:[2,185],57:[2,185],72:[2,185],77:[2,185],85:[2,185],90:[2,185],92:[2,185],101:[2,185],102:87,103:[2,185],104:[2,185],105:[2,185],108:88,109:[2,185],110:69,117:[2,185],125:[2,185],127:[2,185],128:[2,185],131:[1,78],132:[2,185],133:[2,185],134:[2,185],135:[2,185],136:[2,185]},{1:[2,186],6:[2,186],25:[2,186],26:[2,186],49:[2,186],54:[2,186],57:[2,186],72:[2,186],77:[2,186],85:[2,186],90:[2,186],92:[2,186],101:[2,186],102:87,103:[2,186],104:[2,186],105:[2,186],108:88,109:[2,186],110:69,117:[2,186],125:[2,186],127:[2,186],128:[2,186],131:[1,78],132:[2,186],133:[2,186],134:[2,186],135:[2,186],136:[2,186]},{1:[2,187],6:[2,187],25:[2,187],26:[2,187],49:[2,187],54:[2,187],57:[2,187],66:[2,72],67:[2,72],68:[2,72],70:[2,72],72:[2,187],73:[2,72],77:[2,187],83:[2,72],84:[2,72],85:[2,187],90:[2,187],92:[2,187],101:[2,187],103:[2,187],104:[2,187],105:[2,187],109:[2,187],117:[2,187],125:[2,187],127:[2,187],128:[2,187],131:[2,187],132:[2,187],133:[2,187],134:[2,187],135:[2,187],136:[2,187]},{62:93,66:[1,95],67:[1,96],68:[1,97],69:98,70:[1,99],73:[1,100],80:92,83:[1,94],84:[2,107]},{62:102,66:[1,95],67:[1,96],68:[1,97],69:98,70:[1,99],73:[1,100],80:101,83:[1,94],84:[2,107]},{66:[2,75],67:[2,75],68:[2,75],70:[2,75],73:[2,75],83:[2,75],84:[2,75]},{1:[2,188],6:[2,188],25:[2,188],26:[2,188],49:[2,188],54:[2,188],57:[2,188],66:[2,72],67:[2,72],68:[2,72],70:[2,72],72:[2,188],73:[2,72],77:[2,188],83:[2,72],84:[2,72],85:[2,188],90:[2,188],92:[2,188],101:[2,188],103:[2,188],104:[2,188],105:[2,188],109:[2,188],117:[2,188],125:[2,188],127:[2,188],128:[2,188],131:[2,188],132:[2,188],133:[2,188],134:[2,188],135:[2,188],136:[2,188]},{1:[2,189],6:[2,189],25:[2,189],26:[2,189],49:[2,189],54:[2,189],57:[2,189],72:[2,189],77:[2,189],85:[2,189],90:[2,189],92:[2,189],101:[2,189],103:[2,189],104:[2,189],105:[2,189],109:[2,189],117:[2,189],125:[2,189],127:[2,189],128:[2,189],131:[2,189],132:[2,189],133:[2,189],134:[2,189],135:[2,189],136:[2,189]},{1:[2,190],6:[2,190],25:[2,190],26:[2,190],49:[2,190],54:[2,190],57:[2,190],72:[2,190],77:[2,190],85:[2,190],90:[2,190],92:[2,190],101:[2,190],103:[2,190],104:[2,190],105:[2,190],109:[2,190],117:[2,190],125:[2,190],127:[2,190],128:[2,190],131:[2,190],132:[2,190],133:[2,190],134:[2,190],135:[2,190],136:[2,190]},{8:206,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,25:[1,207],27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:208,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{5:209,25:[1,5],124:[1,210]},{1:[2,132],6:[2,132],25:[2,132],26:[2,132],49:[2,132],54:[2,132],57:[2,132],72:[2,132],77:[2,132],85:[2,132],90:[2,132],92:[2,132],96:211,97:[1,212],98:[1,213],101:[2,132],103:[2,132],104:[2,132],105:[2,132],109:[2,132],117:[2,132],125:[2,132],127:[2,132],128:[2,132],131:[2,132],132:[2,132],133:[2,132],134:[2,132],135:[2,132],136:[2,132]},{1:[2,144],6:[2,144],25:[2,144],26:[2,144],49:[2,144],54:[2,144],57:[2,144],72:[2,144],77:[2,144],85:[2,144],90:[2,144],92:[2,144],101:[2,144],103:[2,144],104:[2,144],105:[2,144],109:[2,144],117:[2,144],125:[2,144],127:[2,144],128:[2,144],131:[2,144],132:[2,144],133:[2,144],134:[2,144],135:[2,144],136:[2,144]},{1:[2,152],6:[2,152],25:[2,152],26:[2,152],49:[2,152],54:[2,152],57:[2,152],72:[2,152],77:[2,152],85:[2,152],90:[2,152],92:[2,152],101:[2,152],103:[2,152],104:[2,152],105:[2,152],109:[2,152],117:[2,152],125:[2,152],127:[2,152],128:[2,152],131:[2,152],132:[2,152],133:[2,152],134:[2,152],135:[2,152],136:[2,152]},{25:[1,214],102:87,103:[1,65],105:[1,66],108:88,109:[1,68],110:69,125:[1,86],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{119:215,121:216,122:[1,217]},{1:[2,96],6:[2,96],25:[2,96],26:[2,96],49:[2,96],54:[2,96],57:[2,96],72:[2,96],77:[2,96],85:[2,96],90:[2,96],92:[2,96],101:[2,96],103:[2,96],104:[2,96],105:[2,96],109:[2,96],117:[2,96],125:[2,96],127:[2,96],128:[2,96],131:[2,96],132:[2,96],133:[2,96],134:[2,96],135:[2,96],136:[2,96]},{8:218,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,99],5:219,6:[2,99],25:[1,5],26:[2,99],49:[2,99],54:[2,99],57:[2,99],66:[2,72],67:[2,72],68:[2,72],70:[2,72],72:[2,99],73:[2,72],77:[2,99],79:[1,220],83:[2,72],84:[2,72],85:[2,99],90:[2,99],92:[2,99],101:[2,99],103:[2,99],104:[2,99],105:[2,99],109:[2,99],117:[2,99],125:[2,99],127:[2,99],128:[2,99],131:[2,99],132:[2,99],133:[2,99],134:[2,99],135:[2,99],136:[2,99]},{1:[2,137],6:[2,137],25:[2,137],26:[2,137],49:[2,137],54:[2,137],57:[2,137],72:[2,137],77:[2,137],85:[2,137],90:[2,137],92:[2,137],101:[2,137],102:87,103:[2,137],104:[2,137],105:[2,137],108:88,109:[2,137],110:69,117:[2,137],125:[2,137],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,46],6:[2,46],26:[2,46],101:[2,46],102:87,103:[2,46],105:[2,46],108:88,109:[2,46],110:69,125:[2,46],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{6:[1,74],101:[1,221]},{4:222,7:4,8:6,9:7,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{6:[2,128],25:[2,128],54:[2,128],57:[1,224],90:[2,128],91:223,92:[1,191],102:87,103:[1,65],105:[1,66],108:88,109:[1,68],110:69,125:[1,86],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,114],6:[2,114],25:[2,114],26:[2,114],40:[2,114],49:[2,114],54:[2,114],57:[2,114],66:[2,114],67:[2,114],68:[2,114],70:[2,114],72:[2,114],73:[2,114],77:[2,114],83:[2,114],84:[2,114],85:[2,114],90:[2,114],92:[2,114],101:[2,114],103:[2,114],104:[2,114],105:[2,114],109:[2,114],115:[2,114],116:[2,114],117:[2,114],125:[2,114],127:[2,114],128:[2,114],131:[2,114],132:[2,114],133:[2,114],134:[2,114],135:[2,114],136:[2,114]},{6:[2,53],25:[2,53],53:225,54:[1,226],90:[2,53]},{6:[2,123],25:[2,123],26:[2,123],54:[2,123],85:[2,123],90:[2,123]},{8:200,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,25:[1,146],27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,60:147,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],86:227,87:[1,58],88:[1,59],89:[1,57],93:145,95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{6:[2,129],25:[2,129],26:[2,129],54:[2,129],85:[2,129],90:[2,129]},{1:[2,113],6:[2,113],25:[2,113],26:[2,113],40:[2,113],43:[2,113],49:[2,113],54:[2,113],57:[2,113],66:[2,113],67:[2,113],68:[2,113],70:[2,113],72:[2,113],73:[2,113],77:[2,113],79:[2,113],83:[2,113],84:[2,113],85:[2,113],90:[2,113],92:[2,113],101:[2,113],103:[2,113],104:[2,113],105:[2,113],109:[2,113],115:[2,113],116:[2,113],117:[2,113],125:[2,113],127:[2,113],128:[2,113],129:[2,113],130:[2,113],131:[2,113],132:[2,113],133:[2,113],134:[2,113],135:[2,113],136:[2,113],137:[2,113]},{5:228,25:[1,5],102:87,103:[1,65],105:[1,66],108:88,109:[1,68],110:69,125:[1,86],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,140],6:[2,140],25:[2,140],26:[2,140],49:[2,140],54:[2,140],57:[2,140],72:[2,140],77:[2,140],85:[2,140],90:[2,140],92:[2,140],101:[2,140],102:87,103:[1,65],104:[1,229],105:[1,66],108:88,109:[1,68],110:69,117:[2,140],125:[2,140],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,142],6:[2,142],25:[2,142],26:[2,142],49:[2,142],54:[2,142],57:[2,142],72:[2,142],77:[2,142],85:[2,142],90:[2,142],92:[2,142],101:[2,142],102:87,103:[1,65],104:[1,230],105:[1,66],108:88,109:[1,68],110:69,117:[2,142],125:[2,142],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,148],6:[2,148],25:[2,148],26:[2,148],49:[2,148],54:[2,148],57:[2,148],72:[2,148],77:[2,148],85:[2,148],90:[2,148],92:[2,148],101:[2,148],103:[2,148],104:[2,148],105:[2,148],109:[2,148],117:[2,148],125:[2,148],127:[2,148],128:[2,148],131:[2,148],132:[2,148],133:[2,148],134:[2,148],135:[2,148],136:[2,148]},{1:[2,149],6:[2,149],25:[2,149],26:[2,149],49:[2,149],54:[2,149],57:[2,149],72:[2,149],77:[2,149],85:[2,149],90:[2,149],92:[2,149],101:[2,149],102:87,103:[1,65],104:[2,149],105:[1,66],108:88,109:[1,68],110:69,117:[2,149],125:[2,149],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,153],6:[2,153],25:[2,153],26:[2,153],49:[2,153],54:[2,153],57:[2,153],72:[2,153],77:[2,153],85:[2,153],90:[2,153],92:[2,153],101:[2,153],103:[2,153],104:[2,153],105:[2,153],109:[2,153],117:[2,153],125:[2,153],127:[2,153],128:[2,153],131:[2,153],132:[2,153],133:[2,153],134:[2,153],135:[2,153],136:[2,153]},{115:[2,155],116:[2,155]},{27:158,28:[1,73],44:159,58:160,59:161,75:[1,70],88:[1,113],89:[1,114],112:231,114:157},{54:[1,232],115:[2,161],116:[2,161]},{54:[2,157],115:[2,157],116:[2,157]},{54:[2,158],115:[2,158],116:[2,158]},{54:[2,159],115:[2,159],116:[2,159]},{54:[2,160],115:[2,160],116:[2,160]},{1:[2,154],6:[2,154],25:[2,154],26:[2,154],49:[2,154],54:[2,154],57:[2,154],72:[2,154],77:[2,154],85:[2,154],90:[2,154],92:[2,154],101:[2,154],103:[2,154],104:[2,154],105:[2,154],109:[2,154],117:[2,154],125:[2,154],127:[2,154],128:[2,154],131:[2,154],132:[2,154],133:[2,154],134:[2,154],135:[2,154],136:[2,154]},{8:233,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:234,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{6:[2,53],25:[2,53],53:235,54:[1,236],77:[2,53]},{6:[2,91],25:[2,91],26:[2,91],54:[2,91],77:[2,91]},{6:[2,39],25:[2,39],26:[2,39],43:[1,237],54:[2,39],77:[2,39]},{6:[2,42],25:[2,42],26:[2,42],54:[2,42],77:[2,42]},{6:[2,43],25:[2,43],26:[2,43],43:[2,43],54:[2,43],77:[2,43]},{6:[2,44],25:[2,44],26:[2,44],43:[2,44],54:[2,44],77:[2,44]},{6:[2,45],25:[2,45],26:[2,45],43:[2,45],54:[2,45],77:[2,45]},{1:[2,5],6:[2,5],26:[2,5],101:[2,5]},{1:[2,25],6:[2,25],25:[2,25],26:[2,25],49:[2,25],54:[2,25],57:[2,25],72:[2,25],77:[2,25],85:[2,25],90:[2,25],92:[2,25],97:[2,25],98:[2,25],101:[2,25],103:[2,25],104:[2,25],105:[2,25],109:[2,25],117:[2,25],120:[2,25],122:[2,25],125:[2,25],127:[2,25],128:[2,25],131:[2,25],132:[2,25],133:[2,25],134:[2,25],135:[2,25],136:[2,25]},{1:[2,192],6:[2,192],25:[2,192],26:[2,192],49:[2,192],54:[2,192],57:[2,192],72:[2,192],77:[2,192],85:[2,192],90:[2,192],92:[2,192],101:[2,192],102:87,103:[2,192],104:[2,192],105:[2,192],108:88,109:[2,192],110:69,117:[2,192],125:[2,192],127:[2,192],128:[2,192],131:[1,78],132:[1,81],133:[2,192],134:[2,192],135:[2,192],136:[2,192]},{1:[2,193],6:[2,193],25:[2,193],26:[2,193],49:[2,193],54:[2,193],57:[2,193],72:[2,193],77:[2,193],85:[2,193],90:[2,193],92:[2,193],101:[2,193],102:87,103:[2,193],104:[2,193],105:[2,193],108:88,109:[2,193],110:69,117:[2,193],125:[2,193],127:[2,193],128:[2,193],131:[1,78],132:[1,81],133:[2,193],134:[2,193],135:[2,193],136:[2,193]},{1:[2,194],6:[2,194],25:[2,194],26:[2,194],49:[2,194],54:[2,194],57:[2,194],72:[2,194],77:[2,194],85:[2,194],90:[2,194],92:[2,194],101:[2,194],102:87,103:[2,194],104:[2,194],105:[2,194],108:88,109:[2,194],110:69,117:[2,194],125:[2,194],127:[2,194],128:[2,194],131:[1,78],132:[2,194],133:[2,194],134:[2,194],135:[2,194],136:[2,194]},{1:[2,195],6:[2,195],25:[2,195],26:[2,195],49:[2,195],54:[2,195],57:[2,195],72:[2,195],77:[2,195],85:[2,195],90:[2,195],92:[2,195],101:[2,195],102:87,103:[2,195],104:[2,195],105:[2,195],108:88,109:[2,195],110:69,117:[2,195],125:[2,195],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[2,195],134:[2,195],135:[2,195],136:[2,195]},{1:[2,196],6:[2,196],25:[2,196],26:[2,196],49:[2,196],54:[2,196],57:[2,196],72:[2,196],77:[2,196],85:[2,196],90:[2,196],92:[2,196],101:[2,196],102:87,103:[2,196],104:[2,196],105:[2,196],108:88,109:[2,196],110:69,117:[2,196],125:[2,196],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[2,196],135:[2,196],136:[1,85]},{1:[2,197],6:[2,197],25:[2,197],26:[2,197],49:[2,197],54:[2,197],57:[2,197],72:[2,197],77:[2,197],85:[2,197],90:[2,197],92:[2,197],101:[2,197],102:87,103:[2,197],104:[2,197],105:[2,197],108:88,109:[2,197],110:69,117:[2,197],125:[2,197],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[2,197],136:[1,85]},{1:[2,198],6:[2,198],25:[2,198],26:[2,198],49:[2,198],54:[2,198],57:[2,198],72:[2,198],77:[2,198],85:[2,198],90:[2,198],92:[2,198],101:[2,198],102:87,103:[2,198],104:[2,198],105:[2,198],108:88,109:[2,198],110:69,117:[2,198],125:[2,198],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[2,198],135:[2,198],136:[2,198]},{1:[2,183],6:[2,183],25:[2,183],26:[2,183],49:[2,183],54:[2,183],57:[2,183],72:[2,183],77:[2,183],85:[2,183],90:[2,183],92:[2,183],101:[2,183],102:87,103:[1,65],104:[2,183],105:[1,66],108:88,109:[1,68],110:69,117:[2,183],125:[1,86],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,182],6:[2,182],25:[2,182],26:[2,182],49:[2,182],54:[2,182],57:[2,182],72:[2,182],77:[2,182],85:[2,182],90:[2,182],92:[2,182],101:[2,182],102:87,103:[1,65],104:[2,182],105:[1,66],108:88,109:[1,68],110:69,117:[2,182],125:[1,86],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,103],6:[2,103],25:[2,103],26:[2,103],49:[2,103],54:[2,103],57:[2,103],66:[2,103],67:[2,103],68:[2,103],70:[2,103],72:[2,103],73:[2,103],77:[2,103],83:[2,103],84:[2,103],85:[2,103],90:[2,103],92:[2,103],101:[2,103],103:[2,103],104:[2,103],105:[2,103],109:[2,103],117:[2,103],125:[2,103],127:[2,103],128:[2,103],131:[2,103],132:[2,103],133:[2,103],134:[2,103],135:[2,103],136:[2,103]},{1:[2,80],6:[2,80],25:[2,80],26:[2,80],40:[2,80],49:[2,80],54:[2,80],57:[2,80],66:[2,80],67:[2,80],68:[2,80],70:[2,80],72:[2,80],73:[2,80],77:[2,80],79:[2,80],83:[2,80],84:[2,80],85:[2,80],90:[2,80],92:[2,80],101:[2,80],103:[2,80],104:[2,80],105:[2,80],109:[2,80],117:[2,80],125:[2,80],127:[2,80],128:[2,80],129:[2,80],130:[2,80],131:[2,80],132:[2,80],133:[2,80],134:[2,80],135:[2,80],136:[2,80],137:[2,80]},{1:[2,81],6:[2,81],25:[2,81],26:[2,81],40:[2,81],49:[2,81],54:[2,81],57:[2,81],66:[2,81],67:[2,81],68:[2,81],70:[2,81],72:[2,81],73:[2,81],77:[2,81],79:[2,81],83:[2,81],84:[2,81],85:[2,81],90:[2,81],92:[2,81],101:[2,81],103:[2,81],104:[2,81],105:[2,81],109:[2,81],117:[2,81],125:[2,81],127:[2,81],128:[2,81],129:[2,81],130:[2,81],131:[2,81],132:[2,81],133:[2,81],134:[2,81],135:[2,81],136:[2,81],137:[2,81]},{1:[2,82],6:[2,82],25:[2,82],26:[2,82],40:[2,82],49:[2,82],54:[2,82],57:[2,82],66:[2,82],67:[2,82],68:[2,82],70:[2,82],72:[2,82],73:[2,82],77:[2,82],79:[2,82],83:[2,82],84:[2,82],85:[2,82],90:[2,82],92:[2,82],101:[2,82],103:[2,82],104:[2,82],105:[2,82],109:[2,82],117:[2,82],125:[2,82],127:[2,82],128:[2,82],129:[2,82],130:[2,82],131:[2,82],132:[2,82],133:[2,82],134:[2,82],135:[2,82],136:[2,82],137:[2,82]},{72:[1,238]},{57:[1,192],72:[2,87],91:239,92:[1,191],102:87,103:[1,65],105:[1,66],108:88,109:[1,68],110:69,125:[1,86],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{72:[2,88]},{8:240,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,72:[2,122],75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{12:[2,116],28:[2,116],30:[2,116],31:[2,116],33:[2,116],34:[2,116],35:[2,116],36:[2,116],37:[2,116],38:[2,116],45:[2,116],46:[2,116],47:[2,116],51:[2,116],52:[2,116],72:[2,116],75:[2,116],78:[2,116],82:[2,116],87:[2,116],88:[2,116],89:[2,116],95:[2,116],99:[2,116],100:[2,116],103:[2,116],105:[2,116],107:[2,116],109:[2,116],118:[2,116],124:[2,116],126:[2,116],127:[2,116],128:[2,116],129:[2,116],130:[2,116]},{12:[2,117],28:[2,117],30:[2,117],31:[2,117],33:[2,117],34:[2,117],35:[2,117],36:[2,117],37:[2,117],38:[2,117],45:[2,117],46:[2,117],47:[2,117],51:[2,117],52:[2,117],72:[2,117],75:[2,117],78:[2,117],82:[2,117],87:[2,117],88:[2,117],89:[2,117],95:[2,117],99:[2,117],100:[2,117],103:[2,117],105:[2,117],107:[2,117],109:[2,117],118:[2,117],124:[2,117],126:[2,117],127:[2,117],128:[2,117],129:[2,117],130:[2,117]},{1:[2,86],6:[2,86],25:[2,86],26:[2,86],40:[2,86],49:[2,86],54:[2,86],57:[2,86],66:[2,86],67:[2,86],68:[2,86],70:[2,86],72:[2,86],73:[2,86],77:[2,86],79:[2,86],83:[2,86],84:[2,86],85:[2,86],90:[2,86],92:[2,86],101:[2,86],103:[2,86],104:[2,86],105:[2,86],109:[2,86],117:[2,86],125:[2,86],127:[2,86],128:[2,86],129:[2,86],130:[2,86],131:[2,86],132:[2,86],133:[2,86],134:[2,86],135:[2,86],136:[2,86],137:[2,86]},{1:[2,104],6:[2,104],25:[2,104],26:[2,104],49:[2,104],54:[2,104],57:[2,104],66:[2,104],67:[2,104],68:[2,104],70:[2,104],72:[2,104],73:[2,104],77:[2,104],83:[2,104],84:[2,104],85:[2,104],90:[2,104],92:[2,104],101:[2,104],103:[2,104],104:[2,104],105:[2,104],109:[2,104],117:[2,104],125:[2,104],127:[2,104],128:[2,104],131:[2,104],132:[2,104],133:[2,104],134:[2,104],135:[2,104],136:[2,104]},{1:[2,36],6:[2,36],25:[2,36],26:[2,36],49:[2,36],54:[2,36],57:[2,36],72:[2,36],77:[2,36],85:[2,36],90:[2,36],92:[2,36],101:[2,36],102:87,103:[2,36],104:[2,36],105:[2,36],108:88,109:[2,36],110:69,117:[2,36],125:[2,36],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{8:241,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:242,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,109],6:[2,109],25:[2,109],26:[2,109],49:[2,109],54:[2,109],57:[2,109],66:[2,109],67:[2,109],68:[2,109],70:[2,109],72:[2,109],73:[2,109],77:[2,109],83:[2,109],84:[2,109],85:[2,109],90:[2,109],92:[2,109],101:[2,109],103:[2,109],104:[2,109],105:[2,109],109:[2,109],117:[2,109],125:[2,109],127:[2,109],128:[2,109],131:[2,109],132:[2,109],133:[2,109],134:[2,109],135:[2,109],136:[2,109]},{6:[2,53],25:[2,53],53:243,54:[1,226],85:[2,53]},{6:[2,128],25:[2,128],26:[2,128],54:[2,128],57:[1,244],85:[2,128],90:[2,128],102:87,103:[1,65],105:[1,66],108:88,109:[1,68],110:69,125:[1,86],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{50:245,51:[1,60],52:[1,61]},{6:[2,54],25:[2,54],26:[2,54],27:109,28:[1,73],44:110,55:246,56:108,58:111,59:112,75:[1,70],88:[1,113],89:[1,114]},{6:[1,247],25:[1,248]},{6:[2,61],25:[2,61],26:[2,61],49:[2,61],54:[2,61]},{8:249,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,199],6:[2,199],25:[2,199],26:[2,199],49:[2,199],54:[2,199],57:[2,199],72:[2,199],77:[2,199],85:[2,199],90:[2,199],92:[2,199],101:[2,199],102:87,103:[2,199],104:[2,199],105:[2,199],108:88,109:[2,199],110:69,117:[2,199],125:[2,199],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{8:250,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,201],6:[2,201],25:[2,201],26:[2,201],49:[2,201],54:[2,201],57:[2,201],72:[2,201],77:[2,201],85:[2,201],90:[2,201],92:[2,201],101:[2,201],102:87,103:[2,201],104:[2,201],105:[2,201],108:88,109:[2,201],110:69,117:[2,201],125:[2,201],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,181],6:[2,181],25:[2,181],26:[2,181],49:[2,181],54:[2,181],57:[2,181],72:[2,181],77:[2,181],85:[2,181],90:[2,181],92:[2,181],101:[2,181],103:[2,181],104:[2,181],105:[2,181],109:[2,181],117:[2,181],125:[2,181],127:[2,181],128:[2,181],131:[2,181],132:[2,181],133:[2,181],134:[2,181],135:[2,181],136:[2,181]},{8:251,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,133],6:[2,133],25:[2,133],26:[2,133],49:[2,133],54:[2,133],57:[2,133],72:[2,133],77:[2,133],85:[2,133],90:[2,133],92:[2,133],97:[1,252],101:[2,133],103:[2,133],104:[2,133],105:[2,133],109:[2,133],117:[2,133],125:[2,133],127:[2,133],128:[2,133],131:[2,133],132:[2,133],133:[2,133],134:[2,133],135:[2,133],136:[2,133]},{5:253,25:[1,5]},{27:254,28:[1,73]},{119:255,121:216,122:[1,217]},{26:[1,256],120:[1,257],121:258,122:[1,217]},{26:[2,174],120:[2,174],122:[2,174]},{8:260,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],94:259,95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,97],5:261,6:[2,97],25:[1,5],26:[2,97],49:[2,97],54:[2,97],57:[2,97],72:[2,97],77:[2,97],85:[2,97],90:[2,97],92:[2,97],101:[2,97],102:87,103:[1,65],104:[2,97],105:[1,66],108:88,109:[1,68],110:69,117:[2,97],125:[2,97],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,100],6:[2,100],25:[2,100],26:[2,100],49:[2,100],54:[2,100],57:[2,100],72:[2,100],77:[2,100],85:[2,100],90:[2,100],92:[2,100],101:[2,100],103:[2,100],104:[2,100],105:[2,100],109:[2,100],117:[2,100],125:[2,100],127:[2,100],128:[2,100],131:[2,100],132:[2,100],133:[2,100],134:[2,100],135:[2,100],136:[2,100]},{8:262,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,138],6:[2,138],25:[2,138],26:[2,138],49:[2,138],54:[2,138],57:[2,138],66:[2,138],67:[2,138],68:[2,138],70:[2,138],72:[2,138],73:[2,138],77:[2,138],83:[2,138],84:[2,138],85:[2,138],90:[2,138],92:[2,138],101:[2,138],103:[2,138],104:[2,138],105:[2,138],109:[2,138],117:[2,138],125:[2,138],127:[2,138],128:[2,138],131:[2,138],132:[2,138],133:[2,138],134:[2,138],135:[2,138],136:[2,138]},{6:[1,74],26:[1,263]},{8:264,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{6:[2,67],12:[2,117],25:[2,67],28:[2,117],30:[2,117],31:[2,117],33:[2,117],34:[2,117],35:[2,117],36:[2,117],37:[2,117],38:[2,117],45:[2,117],46:[2,117],47:[2,117],51:[2,117],52:[2,117],54:[2,67],75:[2,117],78:[2,117],82:[2,117],87:[2,117],88:[2,117],89:[2,117],90:[2,67],95:[2,117],99:[2,117],100:[2,117],103:[2,117],105:[2,117],107:[2,117],109:[2,117],118:[2,117],124:[2,117],126:[2,117],127:[2,117],128:[2,117],129:[2,117],130:[2,117]},{6:[1,266],25:[1,267],90:[1,265]},{6:[2,54],8:200,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,25:[2,54],26:[2,54],27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,60:147,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],85:[2,54],87:[1,58],88:[1,59],89:[1,57],90:[2,54],93:268,95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{6:[2,53],25:[2,53],26:[2,53],53:269,54:[1,226]},{1:[2,178],6:[2,178],25:[2,178],26:[2,178],49:[2,178],54:[2,178],57:[2,178],72:[2,178],77:[2,178],85:[2,178],90:[2,178],92:[2,178],101:[2,178],103:[2,178],104:[2,178],105:[2,178],109:[2,178],117:[2,178],120:[2,178],125:[2,178],127:[2,178],128:[2,178],131:[2,178],132:[2,178],133:[2,178],134:[2,178],135:[2,178],136:[2,178]},{8:270,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:271,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{115:[2,156],116:[2,156]},{27:158,28:[1,73],44:159,58:160,59:161,75:[1,70],88:[1,113],89:[1,114],114:272},{1:[2,163],6:[2,163],25:[2,163],26:[2,163],49:[2,163],54:[2,163],57:[2,163],72:[2,163],77:[2,163],85:[2,163],90:[2,163],92:[2,163],101:[2,163],102:87,103:[2,163],104:[1,273],105:[2,163],108:88,109:[2,163],110:69,117:[1,274],125:[2,163],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,164],6:[2,164],25:[2,164],26:[2,164],49:[2,164],54:[2,164],57:[2,164],72:[2,164],77:[2,164],85:[2,164],90:[2,164],92:[2,164],101:[2,164],102:87,103:[2,164],104:[1,275],105:[2,164],108:88,109:[2,164],110:69,117:[2,164],125:[2,164],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{6:[1,277],25:[1,278],77:[1,276]},{6:[2,54],11:168,25:[2,54],26:[2,54],27:169,28:[1,73],29:170,30:[1,71],31:[1,72],41:279,42:167,44:171,46:[1,46],77:[2,54],88:[1,113]},{8:280,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,25:[1,281],27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,85],6:[2,85],25:[2,85],26:[2,85],40:[2,85],49:[2,85],54:[2,85],57:[2,85],66:[2,85],67:[2,85],68:[2,85],70:[2,85],72:[2,85],73:[2,85],77:[2,85],79:[2,85],83:[2,85],84:[2,85],85:[2,85],90:[2,85],92:[2,85],101:[2,85],103:[2,85],104:[2,85],105:[2,85],109:[2,85],117:[2,85],125:[2,85],127:[2,85],128:[2,85],129:[2,85],130:[2,85],131:[2,85],132:[2,85],133:[2,85],134:[2,85],135:[2,85],136:[2,85],137:[2,85]},{8:282,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,72:[2,120],75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{72:[2,121],102:87,103:[1,65],105:[1,66],108:88,109:[1,68],110:69,125:[1,86],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,37],6:[2,37],25:[2,37],26:[2,37],49:[2,37],54:[2,37],57:[2,37],72:[2,37],77:[2,37],85:[2,37],90:[2,37],92:[2,37],101:[2,37],102:87,103:[2,37],104:[2,37],105:[2,37],108:88,109:[2,37],110:69,117:[2,37],125:[2,37],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{26:[1,283],102:87,103:[1,65],105:[1,66],108:88,109:[1,68],110:69,125:[1,86],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{6:[1,266],25:[1,267],85:[1,284]},{6:[2,67],25:[2,67],26:[2,67],54:[2,67],85:[2,67],90:[2,67]},{5:285,25:[1,5]},{6:[2,57],25:[2,57],26:[2,57],49:[2,57],54:[2,57]},{27:109,28:[1,73],44:110,55:286,56:108,58:111,59:112,75:[1,70],88:[1,113],89:[1,114]},{6:[2,55],25:[2,55],26:[2,55],27:109,28:[1,73],44:110,48:287,54:[2,55],55:107,56:108,58:111,59:112,75:[1,70],88:[1,113],89:[1,114]},{6:[2,62],25:[2,62],26:[2,62],49:[2,62],54:[2,62],102:87,103:[1,65],105:[1,66],108:88,109:[1,68],110:69,125:[1,86],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{26:[1,288],102:87,103:[1,65],105:[1,66],108:88,109:[1,68],110:69,125:[1,86],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{5:289,25:[1,5],102:87,103:[1,65],105:[1,66],108:88,109:[1,68],110:69,125:[1,86],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{5:290,25:[1,5]},{1:[2,134],6:[2,134],25:[2,134],26:[2,134],49:[2,134],54:[2,134],57:[2,134],72:[2,134],77:[2,134],85:[2,134],90:[2,134],92:[2,134],101:[2,134],103:[2,134],104:[2,134],105:[2,134],109:[2,134],117:[2,134],125:[2,134],127:[2,134],128:[2,134],131:[2,134],132:[2,134],133:[2,134],134:[2,134],135:[2,134],136:[2,134]},{5:291,25:[1,5]},{26:[1,292],120:[1,293],121:258,122:[1,217]},{1:[2,172],6:[2,172],25:[2,172],26:[2,172],49:[2,172],54:[2,172],57:[2,172],72:[2,172],77:[2,172],85:[2,172],90:[2,172],92:[2,172],101:[2,172],103:[2,172],104:[2,172],105:[2,172],109:[2,172],117:[2,172],125:[2,172],127:[2,172],128:[2,172],131:[2,172],132:[2,172],133:[2,172],134:[2,172],135:[2,172],136:[2,172]},{5:294,25:[1,5]},{26:[2,175],120:[2,175],122:[2,175]},{5:295,25:[1,5],54:[1,296]},{25:[2,130],54:[2,130],102:87,103:[1,65],105:[1,66],108:88,109:[1,68],110:69,125:[1,86],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,98],6:[2,98],25:[2,98],26:[2,98],49:[2,98],54:[2,98],57:[2,98],72:[2,98],77:[2,98],85:[2,98],90:[2,98],92:[2,98],101:[2,98],103:[2,98],104:[2,98],105:[2,98],109:[2,98],117:[2,98],125:[2,98],127:[2,98],128:[2,98],131:[2,98],132:[2,98],133:[2,98],134:[2,98],135:[2,98],136:[2,98]},{1:[2,101],5:297,6:[2,101],25:[1,5],26:[2,101],49:[2,101],54:[2,101],57:[2,101],72:[2,101],77:[2,101],85:[2,101],90:[2,101],92:[2,101],101:[2,101],102:87,103:[1,65],104:[2,101],105:[1,66],108:88,109:[1,68],110:69,117:[2,101],125:[2,101],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{101:[1,298]},{90:[1,299],102:87,103:[1,65],105:[1,66],108:88,109:[1,68],110:69,125:[1,86],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,115],6:[2,115],25:[2,115],26:[2,115],40:[2,115],49:[2,115],54:[2,115],57:[2,115],66:[2,115],67:[2,115],68:[2,115],70:[2,115],72:[2,115],73:[2,115],77:[2,115],83:[2,115],84:[2,115],85:[2,115],90:[2,115],92:[2,115],101:[2,115],103:[2,115],104:[2,115],105:[2,115],109:[2,115],115:[2,115],116:[2,115],117:[2,115],125:[2,115],127:[2,115],128:[2,115],131:[2,115],132:[2,115],133:[2,115],134:[2,115],135:[2,115],136:[2,115]},{8:200,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,60:147,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],93:300,95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:200,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,25:[1,146],27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,60:147,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],86:301,87:[1,58],88:[1,59],89:[1,57],93:145,95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{6:[2,124],25:[2,124],26:[2,124],54:[2,124],85:[2,124],90:[2,124]},{6:[1,266],25:[1,267],26:[1,302]},{1:[2,141],6:[2,141],25:[2,141],26:[2,141],49:[2,141],54:[2,141],57:[2,141],72:[2,141],77:[2,141],85:[2,141],90:[2,141],92:[2,141],101:[2,141],102:87,103:[1,65],104:[2,141],105:[1,66],108:88,109:[1,68],110:69,117:[2,141],125:[2,141],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,143],6:[2,143],25:[2,143],26:[2,143],49:[2,143],54:[2,143],57:[2,143],72:[2,143],77:[2,143],85:[2,143],90:[2,143],92:[2,143],101:[2,143],102:87,103:[1,65],104:[2,143],105:[1,66],108:88,109:[1,68],110:69,117:[2,143],125:[2,143],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{115:[2,162],116:[2,162]},{8:303,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:304,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:305,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,89],6:[2,89],25:[2,89],26:[2,89],40:[2,89],49:[2,89],54:[2,89],57:[2,89],66:[2,89],67:[2,89],68:[2,89],70:[2,89],72:[2,89],73:[2,89],77:[2,89],83:[2,89],84:[2,89],85:[2,89],90:[2,89],92:[2,89],101:[2,89],103:[2,89],104:[2,89],105:[2,89],109:[2,89],115:[2,89],116:[2,89],117:[2,89],125:[2,89],127:[2,89],128:[2,89],131:[2,89],132:[2,89],133:[2,89],134:[2,89],135:[2,89],136:[2,89]},{11:168,27:169,28:[1,73],29:170,30:[1,71],31:[1,72],41:306,42:167,44:171,46:[1,46],88:[1,113]},{6:[2,90],11:168,25:[2,90],26:[2,90],27:169,28:[1,73],29:170,30:[1,71],31:[1,72],41:166,42:167,44:171,46:[1,46],54:[2,90],76:307,88:[1,113]},{6:[2,92],25:[2,92],26:[2,92],54:[2,92],77:[2,92]},{6:[2,40],25:[2,40],26:[2,40],54:[2,40],77:[2,40],102:87,103:[1,65],105:[1,66],108:88,109:[1,68],110:69,125:[1,86],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{8:308,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{72:[2,119],102:87,103:[1,65],105:[1,66],108:88,109:[1,68],110:69,125:[1,86],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,38],6:[2,38],25:[2,38],26:[2,38],49:[2,38],54:[2,38],57:[2,38],72:[2,38],77:[2,38],85:[2,38],90:[2,38],92:[2,38],101:[2,38],103:[2,38],104:[2,38],105:[2,38],109:[2,38],117:[2,38],125:[2,38],127:[2,38],128:[2,38],131:[2,38],132:[2,38],133:[2,38],134:[2,38],135:[2,38],136:[2,38]},{1:[2,110],6:[2,110],25:[2,110],26:[2,110],49:[2,110],54:[2,110],57:[2,110],66:[2,110],67:[2,110],68:[2,110],70:[2,110],72:[2,110],73:[2,110],77:[2,110],83:[2,110],84:[2,110],85:[2,110],90:[2,110],92:[2,110],101:[2,110],103:[2,110],104:[2,110],105:[2,110],109:[2,110],117:[2,110],125:[2,110],127:[2,110],128:[2,110],131:[2,110],132:[2,110],133:[2,110],134:[2,110],135:[2,110],136:[2,110]},{1:[2,49],6:[2,49],25:[2,49],26:[2,49],49:[2,49],54:[2,49],57:[2,49],72:[2,49],77:[2,49],85:[2,49],90:[2,49],92:[2,49],101:[2,49],103:[2,49],104:[2,49],105:[2,49],109:[2,49],117:[2,49],125:[2,49],127:[2,49],128:[2,49],131:[2,49],132:[2,49],133:[2,49],134:[2,49],135:[2,49],136:[2,49]},{6:[2,58],25:[2,58],26:[2,58],49:[2,58],54:[2,58]},{6:[2,53],25:[2,53],26:[2,53],53:309,54:[1,202]},{1:[2,200],6:[2,200],25:[2,200],26:[2,200],49:[2,200],54:[2,200],57:[2,200],72:[2,200],77:[2,200],85:[2,200],90:[2,200],92:[2,200],101:[2,200],103:[2,200],104:[2,200],105:[2,200],109:[2,200],117:[2,200],125:[2,200],127:[2,200],128:[2,200],131:[2,200],132:[2,200],133:[2,200],134:[2,200],135:[2,200],136:[2,200]},{1:[2,179],6:[2,179],25:[2,179],26:[2,179],49:[2,179],54:[2,179],57:[2,179],72:[2,179],77:[2,179],85:[2,179],90:[2,179],92:[2,179],101:[2,179],103:[2,179],104:[2,179],105:[2,179],109:[2,179],117:[2,179],120:[2,179],125:[2,179],127:[2,179],128:[2,179],131:[2,179],132:[2,179],133:[2,179],134:[2,179],135:[2,179],136:[2,179]},{1:[2,135],6:[2,135],25:[2,135],26:[2,135],49:[2,135],54:[2,135],57:[2,135],72:[2,135],77:[2,135],85:[2,135],90:[2,135],92:[2,135],101:[2,135],103:[2,135],104:[2,135],105:[2,135],109:[2,135],117:[2,135],125:[2,135],127:[2,135],128:[2,135],131:[2,135],132:[2,135],133:[2,135],134:[2,135],135:[2,135],136:[2,135]},{1:[2,136],6:[2,136],25:[2,136],26:[2,136],49:[2,136],54:[2,136],57:[2,136],72:[2,136],77:[2,136],85:[2,136],90:[2,136],92:[2,136],97:[2,136],101:[2,136],103:[2,136],104:[2,136],105:[2,136],109:[2,136],117:[2,136],125:[2,136],127:[2,136],128:[2,136],131:[2,136],132:[2,136],133:[2,136],134:[2,136],135:[2,136],136:[2,136]},{1:[2,170],6:[2,170],25:[2,170],26:[2,170],49:[2,170],54:[2,170],57:[2,170],72:[2,170],77:[2,170],85:[2,170],90:[2,170],92:[2,170],101:[2,170],103:[2,170],104:[2,170],105:[2,170],109:[2,170],117:[2,170],125:[2,170],127:[2,170],128:[2,170],131:[2,170],132:[2,170],133:[2,170],134:[2,170],135:[2,170],136:[2,170]},{5:310,25:[1,5]},{26:[1,311]},{6:[1,312],26:[2,176],120:[2,176],122:[2,176]},{8:313,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{1:[2,102],6:[2,102],25:[2,102],26:[2,102],49:[2,102],54:[2,102],57:[2,102],72:[2,102],77:[2,102],85:[2,102],90:[2,102],92:[2,102],101:[2,102],103:[2,102],104:[2,102],105:[2,102],109:[2,102],117:[2,102],125:[2,102],127:[2,102],128:[2,102],131:[2,102],132:[2,102],133:[2,102],134:[2,102],135:[2,102],136:[2,102]},{1:[2,139],6:[2,139],25:[2,139],26:[2,139],49:[2,139],54:[2,139],57:[2,139],66:[2,139],67:[2,139],68:[2,139],70:[2,139],72:[2,139],73:[2,139],77:[2,139],83:[2,139],84:[2,139],85:[2,139],90:[2,139],92:[2,139],101:[2,139],103:[2,139],104:[2,139],105:[2,139],109:[2,139],117:[2,139],125:[2,139],127:[2,139],128:[2,139],131:[2,139],132:[2,139],133:[2,139],134:[2,139],135:[2,139],136:[2,139]},{1:[2,118],6:[2,118],25:[2,118],26:[2,118],49:[2,118],54:[2,118],57:[2,118],66:[2,118],67:[2,118],68:[2,118],70:[2,118],72:[2,118],73:[2,118],77:[2,118],83:[2,118],84:[2,118],85:[2,118],90:[2,118],92:[2,118],101:[2,118],103:[2,118],104:[2,118],105:[2,118],109:[2,118],117:[2,118],125:[2,118],127:[2,118],128:[2,118],131:[2,118],132:[2,118],133:[2,118],134:[2,118],135:[2,118],136:[2,118]},{6:[2,125],25:[2,125],26:[2,125],54:[2,125],85:[2,125],90:[2,125]},{6:[2,53],25:[2,53],26:[2,53],53:314,54:[1,226]},{6:[2,126],25:[2,126],26:[2,126],54:[2,126],85:[2,126],90:[2,126]},{1:[2,165],6:[2,165],25:[2,165],26:[2,165],49:[2,165],54:[2,165],57:[2,165],72:[2,165],77:[2,165],85:[2,165],90:[2,165],92:[2,165],101:[2,165],102:87,103:[2,165],104:[2,165],105:[2,165],108:88,109:[2,165],110:69,117:[1,315],125:[2,165],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,167],6:[2,167],25:[2,167],26:[2,167],49:[2,167],54:[2,167],57:[2,167],72:[2,167],77:[2,167],85:[2,167],90:[2,167],92:[2,167],101:[2,167],102:87,103:[2,167],104:[1,316],105:[2,167],108:88,109:[2,167],110:69,117:[2,167],125:[2,167],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,166],6:[2,166],25:[2,166],26:[2,166],49:[2,166],54:[2,166],57:[2,166],72:[2,166],77:[2,166],85:[2,166],90:[2,166],92:[2,166],101:[2,166],102:87,103:[2,166],104:[2,166],105:[2,166],108:88,109:[2,166],110:69,117:[2,166],125:[2,166],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{6:[2,93],25:[2,93],26:[2,93],54:[2,93],77:[2,93]},{6:[2,53],25:[2,53],26:[2,53],53:317,54:[1,236]},{26:[1,318],102:87,103:[1,65],105:[1,66],108:88,109:[1,68],110:69,125:[1,86],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{6:[1,247],25:[1,248],26:[1,319]},{26:[1,320]},{1:[2,173],6:[2,173],25:[2,173],26:[2,173],49:[2,173],54:[2,173],57:[2,173],72:[2,173],77:[2,173],85:[2,173],90:[2,173],92:[2,173],101:[2,173],103:[2,173],104:[2,173],105:[2,173],109:[2,173],117:[2,173],125:[2,173],127:[2,173],128:[2,173],131:[2,173],132:[2,173],133:[2,173],134:[2,173],135:[2,173],136:[2,173]},{26:[2,177],120:[2,177],122:[2,177]},{25:[2,131],54:[2,131],102:87,103:[1,65],105:[1,66],108:88,109:[1,68],110:69,125:[1,86],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{6:[1,266],25:[1,267],26:[1,321]},{8:322,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{8:323,9:117,10:20,11:21,12:[1,22],13:8,14:9,15:10,16:11,17:12,18:13,19:14,20:15,21:16,22:17,23:18,24:19,27:62,28:[1,73],29:49,30:[1,71],31:[1,72],32:24,33:[1,50],34:[1,51],35:[1,52],36:[1,53],37:[1,54],38:[1,55],39:23,44:63,45:[1,45],46:[1,46],47:[1,29],50:30,51:[1,60],52:[1,61],58:47,59:48,61:36,63:25,64:26,65:27,75:[1,70],78:[1,43],82:[1,28],87:[1,58],88:[1,59],89:[1,57],95:[1,38],99:[1,44],100:[1,56],102:39,103:[1,65],105:[1,66],106:40,107:[1,67],108:41,109:[1,68],110:69,118:[1,42],123:37,124:[1,64],126:[1,31],127:[1,32],128:[1,33],129:[1,34],130:[1,35]},{6:[1,277],25:[1,278],26:[1,324]},{6:[2,41],25:[2,41],26:[2,41],54:[2,41],77:[2,41]},{6:[2,59],25:[2,59],26:[2,59],49:[2,59],54:[2,59]},{1:[2,171],6:[2,171],25:[2,171],26:[2,171],49:[2,171],54:[2,171],57:[2,171],72:[2,171],77:[2,171],85:[2,171],90:[2,171],92:[2,171],101:[2,171],103:[2,171],104:[2,171],105:[2,171],109:[2,171],117:[2,171],125:[2,171],127:[2,171],128:[2,171],131:[2,171],132:[2,171],133:[2,171],134:[2,171],135:[2,171],136:[2,171]},{6:[2,127],25:[2,127],26:[2,127],54:[2,127],85:[2,127],90:[2,127]},{1:[2,168],6:[2,168],25:[2,168],26:[2,168],49:[2,168],54:[2,168],57:[2,168],72:[2,168],77:[2,168],85:[2,168],90:[2,168],92:[2,168],101:[2,168],102:87,103:[2,168],104:[2,168],105:[2,168],108:88,109:[2,168],110:69,117:[2,168],125:[2,168],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{1:[2,169],6:[2,169],25:[2,169],26:[2,169],49:[2,169],54:[2,169],57:[2,169],72:[2,169],77:[2,169],85:[2,169],90:[2,169],92:[2,169],101:[2,169],102:87,103:[2,169],104:[2,169],105:[2,169],108:88,109:[2,169],110:69,117:[2,169],125:[2,169],127:[1,80],128:[1,79],131:[1,78],132:[1,81],133:[1,82],134:[1,83],135:[1,84],136:[1,85]},{6:[2,94],25:[2,94],26:[2,94],54:[2,94],77:[2,94]}],defaultActions:{60:[2,51],61:[2,52],75:[2,3],94:[2,108],189:[2,88]},parseError:function(a,b){throw new Error(a)},parse:function(a){function o(){var a;a=b.lexer.lex()||1,typeof a!="number"&&(a=b.symbols_[a]||a);return a}function n(a){c.length=c.length-2*a,d.length=d.length-a,e.length=e.length-a}var b=this,c=[0],d=[null],e=[],f=this.table,g="",h=0,i=0,j=0,k=2,l=1;this.lexer.setInput(a),this.lexer.yy=this.yy,this.yy.lexer=this.lexer,typeof this.lexer.yylloc=="undefined"&&(this.lexer.yylloc={});var m=this.lexer.yylloc;e.push(m),typeof this.yy.parseError=="function"&&(this.parseError=this.yy.parseError);var p,q,r,s,t,u,v={},w,x,y,z;for(;;){r=c[c.length-1],this.defaultActions[r]?s=this.defaultActions[r]:(p==null&&(p=o()),s=f[r]&&f[r][p]);_handle_error:if(typeof s=="undefined"||!s.length||!s[0]){if(!j){z=[];for(w in f[r])this.terminals_[w]&&w>2&&z.push("'"+this.terminals_[w]+"'");var A="";this.lexer.showPosition?A="Parse error on line "+(h+1)+":\n"+this.lexer.showPosition()+"\nExpecting "+z.join(", ")+", got '"+this.terminals_[p]+"'":A="Parse error on line "+(h+1)+": Unexpected "+(p==1?"end of input":"'"+(this.terminals_[p]||p)+"'"),this.parseError(A,{text:this.lexer.match,token:this.terminals_[p]||p,line:this.lexer.yylineno,loc:m,expected:z})}if(j==3){if(p==l)throw new Error(A||"Parsing halted.");i=this.lexer.yyleng,g=this.lexer.yytext,h=this.lexer.yylineno,m=this.lexer.yylloc,p=o()}for(;;){if(k.toString()in f[r])break;if(r==0)throw new Error(A||"Parsing halted.");n(1),r=c[c.length-1]}q=p,p=k,r=c[c.length-1],s=f[r]&&f[r][k],j=3}if(s[0]instanceof Array&&s.length>1)throw new Error("Parse Error: multiple actions possible at state: "+r+", token: "+p);switch(s[0]){case 1:c.push(p),d.push(this.lexer.yytext),e.push(this.lexer.yylloc),c.push(s[1]),p=null,q?(p=q,q=null):(i=this.lexer.yyleng,g=this.lexer.yytext,h=this.lexer.yylineno,m=this.lexer.yylloc,j>0&&j--);break;case 2:x=this.productions_[s[1]][1],v.$=d[d.length-x],v._$={first_line:e[e.length-(x||1)].first_line,last_line:e[e.length-1].last_line,first_column:e[e.length-(x||1)].first_column,last_column:e[e.length-1].last_column},u=this.performAction.call(v,g,i,h,this.yy,s[1],d,e);if(typeof u!="undefined")return u;x&&(c=c.slice(0,-1*x*2),d=d.slice(0,-1*x),e=e.slice(0,-1*x)),c.push(this.productions_[s[1]][0]),d.push(v.$),e.push(v._$),y=f[c[c.length-2]][c[c.length-1]],c.push(y);break;case 3:return!0}}return!0}};undefined;return a}();typeof require!="undefined"&&typeof a!="undefined"&&(a.parser=b,a.parse=function(){return b.parse.apply(b,arguments)},a.main=function(b){if(!b[1])throw new Error("Usage: "+b[0]+" FILE");if(typeof process!="undefined")var c=require("fs").readFileSync(require("path").join(process.cwd(),b[1]),"utf8");else var d=require("file").path(require("file").cwd()),c=d.join(b[1]).read({charset:"utf-8"});return a.parser.parse(c)},typeof module!="undefined"&&require.main===module&&a.main(typeof process!="undefined"?process.argv.slice(1):require("system").args))},require["./scope"]=new function(){var a=this;(function(){var b,c,d,e;e=require("./helpers"),c=e.extend,d=e.last,a.Scope=b=function(){function a(b,c,d){this.parent=b,this.expressions=c,this.method=d,this.variables=[{name:"arguments",type:"arguments"}],this.positions={},this.parent||(a.root=this)}a.root=null,a.prototype.add=function(a,b,c){if(this.shared&&!c)return this.parent.add(a,b,c);return Object.prototype.hasOwnProperty.call(this.positions,a)?this.variables[this.positions[a]].type=b:this.positions[a]=this.variables.push({name:a,type:b})-1},a.prototype.namedMethod=function(){if(this.method.name||!this.parent)return this.method;return this.parent.namedMethod()},a.prototype.find=function(a){if(this.check(a))return!0;this.add(a,"var");return!1},a.prototype.parameter=function(a){if(!this.shared||!this.parent.check(a,!0))return this.add(a,"param")},a.prototype.check=function(a){var b;return!!(this.type(a)||((b=this.parent)!=null?b.check(a):void 0))},a.prototype.temporary=function(a,b){return a.length>1?"_"+a+(b>1?b-1:""):"_"+(b+parseInt(a,36)).toString(36).replace(/\d/g,"a")},a.prototype.type=function(a){var b,c,d,e;e=this.variables;for(c=0,d=e.length;c<d;c++){b=e[c];if(b.name===a)return b.type}return null},a.prototype.freeVariable=function(a,b){var c,d;b==null&&(b=!0),c=0;while(this.check(d=this.temporary(a,c)))c++;b&&this.add(d,"var",!0);return d},a.prototype.assign=function(a,b){this.add(a,{value:b,assigned:!0},!0);return this.hasAssignments=!0},a.prototype.hasDeclarations=function(){return!!this.declaredVariables().length},a.prototype.declaredVariables=function(){var a,b,c,d,e,f;a=[],b=[],f=this.variables;for(d=0,e=f.length;d<e;d++)c=f[d],c.type==="var"&&(c.name.charAt(0)==="_"?b:a).push(c.name);return a.sort().concat(b.sort())},a.prototype.assignedVariables=function(){var a,b,c,d,e;d=this.variables,e=[];for(b=0,c=d.length;b<c;b++)a=d[b],a.type.assigned&&e.push(""+a.name+" = "+a.type.value);return e};return a}()}).call(this)},require["./nodes"]=new function(){var a=this;(function(){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,$,_,ba,bb,bc,bd,be,bf,bg,bh,bi,bj,bk=({}).hasOwnProperty,bl=function(a,b){function d(){this.constructor=a}for(var c in b)bk.call(b,c)&&(a[c]=b[c]);d.prototype=b.prototype,a.prototype=new d,a.__super__=b.prototype;return a},bm=[].indexOf||function(a){for(var b=0,c=this.length;b<c;b++)if(b in this&&this[b]===a)return b;return-1};N=require("./scope").Scope,bi=require("./lexer"),I=bi.RESERVED,M=bi.STRICT_PROSCRIBED,bj=require("./helpers"),Z=bj.compact,bb=bj.flatten,ba=bj.extend,bd=bj.merge,$=bj.del,bf=bj.starts,_=bj.ends,bc=bj.last,a.extend=ba,Y=function(){return!0},D=function(){return!1},S=function(){return this},C=function(){this.negated=!this.negated;return this},a.Base=e=function(){function a(){}a.prototype.compile=function(a,b){var c;a=ba({},a),b&&(a.level=b),c=this.unfoldSoak(a)||this,c.tab=a.indent;return a.level===z||!c.isStatement(a)?c.compileNode(a):c.compileClosure(a)},a.prototype.compileClosure=function(a){if(this.jumps())throw SyntaxError("cannot use a pure statement in an expression.");a.sharedScope=!0;return i.wrap(this).compileNode(a)},a.prototype.cache=function(a,b,c){var e,f;if(!this.isComplex()){e=b?this.compile(a,b):this;return[e,e]}e=new A(c||a.scope.freeVariable("ref")),f=new d(e,this);return b?[f.compile(a,b),e.value]:[f,e]},a.prototype.compileLoopReference=function(a,b){var c,d;c=d=this.compile(a,w),-Infinity<+c&&+c<Infinity||o.test(c)&&a.scope.check(c,!0)||(c=""+(d=a.scope.freeVariable(b))+" = "+c);return[c,d]},a.prototype.makeReturn=function(a){var b;b=this.unwrapAll();return a?new g(new A(""+a+".push"),[b]):new K(b)},a.prototype.contains=function(a){var b;b=!1,this.traverseChildren(!1,function(c){if(a(c)){b=!0;return!1}});return b},a.prototype.containsType=function(a){return this instanceof a||this.contains(function(b){return b instanceof a})},a.prototype.lastNonComment=function(a){var b;b=a.length;while(b--)if(!(a[b]instanceof k))return a[b];return null},a.prototype.toString=function(a,b){var c;a==null&&(a=""),b==null&&(b=this.constructor.name),c="\n"+a+b,this.soak&&(c+="?"),this.eachChild(function(b){return c+=b.toString(a+R)});return c},a.prototype.eachChild=function(a){var b,c,d,e,f,g,h,i;if(!this.children)return this;h=this.children;for(d=0,f=h.length;d<f;d++){b=h[d];if(this[b]){i=bb([this[b]]);for(e=0,g=i.length;e<g;e++){c=i[e];if(a(c)===!1)return this}}}return this},a.prototype.traverseChildren=function(a,b){return this.eachChild(function(c){if(b(c)===!1)return!1;return c.traverseChildren(a,b)})},a.prototype.invert=function(){return new F("!",this)},a.prototype.unwrapAll=function(){var a;a=this;while(a!==(a=a.unwrap()))continue;return a},a.prototype.children=[],a.prototype.isStatement=D,a.prototype.jumps=D,a.prototype.isComplex=Y,a.prototype.isChainable=D,a.prototype.isAssignable=D,a.prototype.unwrap=S,a.prototype.unfoldSoak=D,a.prototype.assigns=D;return a}(),a.Block=f=function(a){function b(a){this.expressions=Z(bb(a||[]))}bl(b,a),b.prototype.children=["expressions"],b.prototype.push=function(a){this.expressions.push(a);return this},b.prototype.pop=function(){return this.expressions.pop()},b.prototype.unshift=function(a){this.expressions.unshift(a);return this},b.prototype.unwrap=function(){return this.expressions.length===1?this.expressions[0]:this},b.prototype.isEmpty=function(){return!this.expressions.length},b.prototype.isStatement=function(a){var b,c,d,e;e=this.expressions;for(c=0,d=e.length;c<d;c++){b=e[c];if(b.isStatement(a))return!0}return!1},b.prototype.jumps=function(a){var b,c,d,e;e=this.expressions;for(c=0,d=e.length;c<d;c++){b=e[c];if(b.jumps(a))return b}},b.prototype.makeReturn=function(a){var b,c;c=this.expressions.length;while(c--){b=this.expressions[c];if(!(b instanceof k)){this.expressions[c]=b.makeReturn(a),b instanceof K&&!b.expression&&this.expressions.splice(c,1);break}}return this},b.prototype.compile=function(a,c){a==null&&(a={});return a.scope?b.__super__.compile.call(this,a,c):this.compileRoot(a)},b.prototype.compileNode=function(a){var c,d,e,f,g,h,i;this.tab=a.indent,f=a.level===z,d=[],i=this.expressions;for(g=0,h=i.length;g<h;g++)e=i[g],e=e.unwrapAll(),e=e.unfoldSoak(a)||e,e instanceof b?d.push(e.compileNode(a)):f?(e.front=!0,c=e.compile(a),e.isStatement(a)||(c=""+this.tab+c+";",e instanceof A&&(c=""+c+"\n")),d.push(c)):d.push(e.compile(a,w));if(f)return this.spaced?"\n"+d.join("\n\n")+"\n":d.join("\n");c=d.join(", ")||"void 0";return d.length>1&&a.level>=w?"("+c+")":c},b.prototype.compileRoot=function(a){var b,c,d,e,f,g;a.indent=a.bare?"":R,a.scope=new N(null,this,null),a.level=z,this.spaced=!0,e="",a.bare||(f=function(){var a,b,e,f;e=this.expressions,f=[];for(d=a=0,b=e.length;a<b;d=++a){c=e[d];if(!(c.unwrap()instanceof k))break;f.push(c)}return f}.call(this),g=this.expressions.slice(f.length),this.expressions=f,f.length&&(e=""+this.compileNode(bd(a,{indent:""}))+"\n"),this.expressions=g),b=this.compileWithDeclarations(a);if(a.bare)return b;return""+e+"(function() {\n"+b+"\n}).call(this);\n"},b.prototype.compileWithDeclarations=function(a){var b,c,d,e,f,g,h,i,j,l,m,n,o,p;c=g="",n=this.expressions;for(f=l=0,m=n.length;l<m;f=++l){e=n[f],e=e.unwrap();if(!(e instanceof k||e instanceof A))break}a=bd(a,{level:z}),f&&(h=this.expressions.splice(f,9e9),o=[this.spaced,!1],j=o[0],this.spaced=o[1],p=[this.compileNode(a),j],c=p[0],this.spaced=p[1],this.expressions=h),g=this.compileNode(a),i=a.scope;if(i.expressions===this){d=a.scope.hasDeclarations(),b=i.hasAssignments;if(d||b)f&&(c+="\n"),c+=""+this.tab+"var ",d&&(c+=i.declaredVariables().join(", ")),b&&(d&&(c+=",\n"+(this.tab+R)),c+=i.assignedVariables().join(",\n"+(this.tab+R))),c+=";\n"}return c+g},b.wrap=function(a){if(a.length===1&&a[0]instanceof b)return a[0];return new b(a)};return b}(e),a.Literal=A=function(a){function b(a){this.value=a}bl(b,a),b.prototype.makeReturn=function(){return this.isStatement()?this:b.__super__.makeReturn.apply(this,arguments)},b.prototype.isAssignable=function(){return o.test(this.value)},b.prototype.isStatement=function(){var a;return(a=this.value)==="break"||a==="continue"||a==="debugger"},b.prototype.isComplex=D,b.prototype.assigns=function(a){return a===this.value},b.prototype.jumps=function(a){if(this.value==="break"&&!((a!=null?a.loop:void 0)||(a!=null?a.block:void 0)))return this;if(this.value==="continue"&&(a!=null?!a.loop:!void 0))return this},b.prototype.compileNode=function(a){var b,c;b=this.value==="this"?((c=a.scope.method)!=null?c.bound:void 0)?a.scope.method.context:this.value:this.value.reserved?'"'+this.value+'"':this.value;return this.isStatement()?""+this.tab+b+";":b},b.prototype.toString=function(){return' "'+this.value+'"'};return b}(e),a.Undefined=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}bl(b,a),b.prototype.isAssignable=D,b.prototype.isComplex=D,b.prototype.compileNode=function(a){return a.level>=u?"(void 0)":"void 0"};return b}(e),a.Null=function(a){function b(){return b.__super__.constructor.apply(this,arguments)}bl(b,a),b.prototype.isAssignable=D,b.prototype.isComplex=D,b.prototype.compileNode=function(){return"null"};return b}(e),a.Bool=function(a){function b(a){this.val=a}bl(b,a),b.prototype.isAssignable=D,b.prototype.isComplex=D,b.prototype.compileNode=function(){return this.val};return b}(e),a.Return=K=function(a){function b(a){a&&!a.unwrap().isUndefined&&(this.expression=a)}bl(b,a),b.prototype.children=["expression"],b.prototype.isStatement=Y,b.prototype.makeReturn=S,b.prototype.jumps=S,b.prototype.compile=function(a,c){var d,e;d=(e=this.expression)!=null?e.makeReturn():void 0;return!d||d instanceof b?b.__super__.compile.call(this,a,c):d.compile(a,c)},b.prototype.compileNode=function(a){return this.tab+("return"+[this.expression?" "+this.expression.compile(a,y):void 0]+";")};return b}(e),a.Value=W=function(a){function b(a,c,d){if(!c&&a instanceof b)return a;this.base=a,this.properties=c||[],d&&(this[d]=!0);return this}bl(b,a),b.prototype.children=["base","properties"],b.prototype.add=function(a){this.properties=this.properties.concat(a);return this},b.prototype.hasProperties=function(){return!!this.properties.length},b.prototype.isArray=function(){return!this.properties.length&&this.base instanceof c},b.prototype.isComplex=function(){return this.hasProperties()||this.base.isComplex()},b.prototype.isAssignable=function(){return this.hasProperties()||this.base.isAssignable()},b.prototype.isSimpleNumber=function(){return this.base instanceof A&&L.test(this.base.value)},b.prototype.isString=function(){return this.base instanceof A&&q.test(this.base.value)},b.prototype.isAtomic=function(){var a,b,c,d;d=this.properties.concat(this.base);for(b=0,c=d.length;b<c;b++){a=d[b];if(a.soak||a instanceof g)return!1}return!0},b.prototype.isStatement=function(a){return!this.properties.length&&this.base.isStatement(a)},b.prototype.assigns=function(a){return!this.properties.length&&this.base.assigns(a)},b.prototype.jumps=function(a){return!this.properties.length&&this.base.jumps(a)},b.prototype.isObject=function(a){if(this.properties.length)return!1;return this.base instanceof E&&(!a||this.base.generated)},b.prototype.isSplice=function(){return bc(this.properties)instanceof O},b.prototype.unwrap=function(){return this.properties.length?this:this.base},b.prototype.cacheReference=function(a){var c,e,f,g;f=bc(this.properties);if(this.properties.length<2&&!this.base.isComplex()&&(f!=null?!f.isComplex():!void 0))return[this,this];c=new b(this.base,this.properties.slice(0,-1)),c.isComplex()&&(e=new A(a.scope.freeVariable("base")),c=new b(new H(new d(e,c))));if(!f)return[c,e];f.isComplex()&&(g=new A(a.scope.freeVariable("name")),f=new t(new d(g,f.index)),g=new t(g));return[c.add(f),new b(e||c.base,[g||f])]},b.prototype.compileNode=function(a){var b,c,d,e,f;this.base.front=this.front,d=this.properties,b=this.base.compile(a,d.length?u:null),(this.base instanceof H||d.length)&&L.test(b)&&(b=""+b+".");for(e=0,f=d.length;e<f;e++)c=d[e],b+=c.compile(a);return b},b.prototype.unfoldSoak=function(a){var c,e=this;if(this.unfoldedSoak!=null)return this.unfoldedSoak;c=function(){var c,f,g,h,i,j,k,m,n;if(g=e.base.unfoldSoak(a)){Array.prototype.push.apply(g.body.properties,e.properties);return g}n=e.properties;for(f=k=0,m=n.length;k<m;f=++k){h=n[f];if(!h.soak)continue;h.soak=!1,c=new b(e.base,e.properties.slice(0,f)),j=new b(e.base,e.properties.slice(f)),c.isComplex()&&(i=new A(a.scope.freeVariable("ref")),c=new H(new d(i,c)),j.base=i);return new r(new l(c),j,{soak:!0})}return null}();return this.unfoldedSoak=c||!1};return b}(e),a.Comment=k=function(a){function b(a){this.comment=a}bl(b,a),b.prototype.isStatement=Y,b.prototype.makeReturn=S,b.prototype.compileNode=function(a,b){var c;c="/*"+be(this.comment,this.tab)+("\n"+this.tab+"*/\n"),(b||a.level)===z&&(c=a.indent+c);return c};return b}(e),a.Call=g=function(a){function c(a,b,c){this.args=b!=null?b:[],this.soak=c,this.isNew=!1,this.isSuper=a==="super",this.variable=this.isSuper?null:a}bl(c,a),c.prototype.children=["variable","args"],c.prototype.newInstance=function(){var a,b;a=((b=this.variable)!=null?b.base:void 0)||this.variable,a instanceof c&&!a.isNew?a.newInstance():this.isNew=!0;return this},c.prototype.superReference=function(a){var c,d,e;d=a.scope.namedMethod();if(!d)throw SyntaxError("cannot call super outside of a function.");e=d.name;if(e==null)throw SyntaxError("cannot call super on an anonymous function.");if(d.klass){c=[new b(new A("__super__"))],d["static"]&&c.push(new b(new A("constructor"))),c.push(new b(new A(e)));return(new W(new A(d.klass),c)).compile(a)}return""+e+".__super__.constructor"},c.prototype.superThis=function(a){var b;b=a.scope.method;return b&&!b.klass&&b.context||"this"},c.prototype.unfoldSoak=function(a){var b,d,e,f,g,h,i,j,k;if(this.soak){if(this.variable){if(d=bg(a,this,"variable"))return d;j=(new W(this.variable)).cacheReference(a),e=j[0],g=j[1]}else e=new A(this.superReference(a)),g=new W(e);g=new c(g,this.args),g.isNew=this.isNew,e=new A("typeof "+e.compile(a)+' === "function"');return new r(e,new W(g),{soak:!0})}b=this,f=[];for(;;){if(b.variable instanceof c){f.push(b),b=b.variable;continue}if(!(b.variable instanceof W))break;f.push(b);if(!((b=b.variable.base)instanceof c))break}k=f.reverse();for(h=0,i=k.length;h<i;h++)b=k[h],d&&(b.variable instanceof c?b.variable=d:b.variable.base=d),d=bg(a,b,"variable");return d},c.prototype.filterImplicitObjects=function(a){var b,c,e,f,g,h,i,j,l,m;c=[];for(h=0,j=a.length;h<j;h++){b=a[h];if(!((typeof b.isObject=="function"?b.isObject():void 0)&&b.base.generated)){c.push(b);continue}e=null,m=b.base.properties;for(i=0,l=m.length;i<l;i++)f=m[i],f instanceof d||f instanceof k?(e||c.push(e=new E(g=[],!0)),g.push(f)):(c.push(f),e=null)}return c},c.prototype.compileNode=function(a){var b,c,d,e;(e=this.variable)!=null&&(e.front=this.front);if(d=P.compileSplattedArray(a,this.args,!0))return this.compileSplat(a,d);c=this.filterImplicitObjects(this.args),c=function(){var d,e,f;f=[];for(d=0,e=c.length;d<e;d++)b=c[d],f.push(b.compile(a,w));return f}().join(", ");return this.isSuper?this.superReference(a)+(".call("+this.superThis(a)+(c&&", "+c)+")"):(this.isNew?"new ":"")+this.variable.compile(a,u)+("("+c+")")},c.prototype.compileSuper=function(a,b){return""+this.superReference(b)+".call("+this.superThis(b)+(a.length?", ":"")+a+")"},c.prototype.compileSplat=function(a,b){var c,d,e,f,g;if(this.isSuper)return""+this.superReference(a)+".apply("+this.superThis(a)+", "+b+")";if(this.isNew){e=this.tab+R;return"(function(func, args, ctor) {\n"+e+"ctor.prototype = func.prototype;\n"+e+"var child = new ctor, result = func.apply(child, args), t = typeof result;\n"+e+'return t == "object" || t == "function" ? result || child : child;\n'+this.tab+"})("+this.variable.compile(a,w)+", "+b+", function(){})"}c=new W(this.variable),(f=c.properties.pop())&&c.isComplex()?(g=a.scope.freeVariable("ref"),d="("+g+" = "+c.compile(a,w)+")"+f.compile(a)):(d=c.compile(a,u),L.test(d)&&(d="("+d+")"),f?(g=d,d+=f.compile(a)):g="null");return""+d+".apply("+g+", "+b+")"};return c}(e),a.Extends=m=function(a){function b(a,b){this.child=a,this.parent=b}bl(b,a),b.prototype.children=["child","parent"],b.prototype.compile=function(a){return(new g(new W(new A(bh("extends"))),[this.child,this.parent])).compile(a)};return b}(e),a.Access=b=function(a){function b(a,b){this.name=a,this.name.asKey=!0,this.soak=b==="soak"}bl(b,a),b.prototype.children=["name"],b.prototype.compile=function(a){var b;b=this.name.compile(a);return o.test(b)?"."+b:"["+b+"]"},b.prototype.isComplex=D;return b}(e),a.Index=t=function(a){function b(a){this.index=a}bl(b,a),b.prototype.children=["index"],b.prototype.compile=function(a){return"["+this.index.compile(a,y)+"]"},b.prototype.isComplex=function(){return this.index.isComplex()};return b}(e),a.Range=J=function(a){function b(a,b,c){this.from=a,this.to=b,this.exclusive=c==="exclusive",this.equals=this.exclusive?"":"="}bl(b,a),b.prototype.children=["from","to"],b.prototype.compileVariables=function(a){var b,c,d,e,f;a=bd(a,{top:!0}),c=this.from.cache(a,w),this.fromC=c[0],this.fromVar=c[1],d=this.to.cache(a,w),this.toC=d[0],this.toVar=d[1];if(b=$(a,"step"))e=b.cache(a,w),this.step=e[0],this.stepVar=e[1];f=[this.fromVar.match(L),this.toVar.match(L)],this.fromNum=f[0],this.toNum=f[1];if(this.stepVar)return this.stepNum=this.stepVar.match(L)},b.prototype.compileNode=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o;this.fromVar||this.compileVariables(a);if(!a.index)return this.compileArray(a);h=this.fromNum&&this.toNum,f=$(a,"index"),g=$(a,"name"),j=g&&g!==f,m=""+f+" = "+this.fromC,this.toC!==this.toVar&&(m+=", "+this.toC),this.step!==this.stepVar&&(m+=", "+this.step),n=[""+f+" <"+this.equals,""+f+" >"+this.equals],i=n[0],e=n[1],c=this.stepNum?+this.stepNum>0?""+i+" "+this.toVar:""+e+" "+this.toVar:h?(o=[+this.fromNum,+this.toNum],d=o[0],l=o[1],o,d<=l?""+i+" "+l:""+e+" "+l):(b=""+this.fromVar+" <= "+this.toVar,""+b+" ? "+i+" "+this.toVar+" : "+e+" "+this.toVar),k=this.stepVar?""+f+" += "+this.stepVar:h?j?d<=l?"++"+f:"--"+f:d<=l?""+f+"++":""+f+"--":j?""+b+" ? ++"+f+" : --"+f:""+b+" ? "+f+"++ : "+f+"--",j&&(m=""+g+" = "+m),j&&(k=""+g+" = "+k);return""+m+"; "+c+"; "+k},b.prototype.compileArray=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p;if(this.fromNum&&this.toNum&&Math.abs(this.fromNum-this.toNum)<=20){j=function(){p=[];for(var a=n=+this.fromNum,b=+this.toNum;n<=b?a<=b:a>=b;n<=b?a++:a--)p.push(a);return p}.apply(this),this.exclusive&&j.pop();return"["+j.join(", ")+"]"}g=this.tab+R,f=a.scope.freeVariable("i"),k=a.scope.freeVariable("results"),i="\n"+g+k+" = [];",this.fromNum&&this.toNum?(a.index=f,c=this.compileNode(a)):(l=""+f+" = "+this.fromC+(this.toC!==this.toVar?", "+this.toC:""),d=""+this.fromVar+" <= "+this.toVar,c="var "+l+"; "+d+" ? "+f+" <"+this.equals+" "+this.toVar+" : "+f+" >"+this.equals+" "+this.toVar+"; "+d+" ? "+f+"++ : "+f+"--"),h="{ "+k+".push("+f+"); }\n"+g+"return "+k+";\n"+a.indent,e=function(a){return a!=null?a.contains(function(a){return a instanceof A&&a.value==="arguments"&&!a.asKey}):void 0};if(e(this.from)||e(this.to))b=", arguments";return"(function() {"+i+"\n"+g+"for ("+c+")"+h+"}).apply(this"+(b!=null?b:"")+")"};return b}(e),a.Slice=O=function(a){function b(a){this.range=a,b.__super__.constructor.call(this)}bl(b,a),b.prototype.children=["range"],b.prototype.compileNode=function(a){var b,c,d,e,f,g;g=this.range,e=g.to,c=g.from,d=c&&c.compile(a,y)||"0",b=e&&e.compile(a,y),e&&(!!this.range.exclusive||+b!==-1)&&(f=", "+(this.range.exclusive?b:L.test(b)?""+(+b+1):(b=e.compile(a,u),""+b+" + 1 || 9e9")));return".slice("+d+(f||"")+")"};return b}(e),a.Obj=E=function(a){function b(a,b){this.generated=b!=null?b:!1,this.objects=this.properties=a||[]}bl(b,a),b.prototype.children=["properties"],b.prototype.compileNode=function(a){var b,c,e,f,g,h,i,j,l,m,n,o,p,q,r,s;n=this.properties,m=[],s=this.properties;for(o=0,q=s.length;o<q;o++){j=s[o],j.isComplex()&&(j=j.variable);if(j!=null){l=j.unwrapAll().value.toString();if(bm.call(m,l)>=0)throw SyntaxError('multiple object literal properties named "'+l+'"');m.push(l)}}if(!n.length)return this.front?"({})":"{}";if(this.generated)for(p=0,r=n.length;p<r;p++){h=n[p];if(h instanceof W)throw new Error("cannot have an implicit value in an implicit object")}c=a.indent+=R,g=this.lastNonComment(this.properties),n=function(){var h,i,l;l=[];for(b=h=0,i=n.length;h<i;b=++h)j=n[b],f=b===n.length-1?"":j===g||j instanceof k?"\n":",\n",e=j instanceof k?"":c,j instanceof W&&j["this"]&&(j=new d(j.properties[0].name,j,"object")),j instanceof k||(j instanceof d||(j=new d(j,j,"object")),(j.variable.base||j.variable).asKey=!0),l.push(e+j.compile(a,z)+f);return l}(),n=n.join(""),i="{"+(n&&"\n"+n+"\n"+this.tab)+"}";return this.front?"("+i+")":i},b.prototype.assigns=function(a){var b,c,d,e;e=this.properties;for(c=0,d=e.length;c<d;c++){b=e[c];if(b.assigns(a))return!0}return!1};return b}(e),a.Arr=c=function(a){function b(a){this.objects=a||[]}bl(b,a),b.prototype.children=["objects"],b.prototype.filterImplicitObjects=g.prototype.filterImplicitObjects,b.prototype.compileNode=function(a){var b,c,d;if(!this.objects.length)return"[]";a.indent+=R,d=this.filterImplicitObjects(this.objects);if(b=P.compileSplattedArray(a,d))return b;b=function(){var b,e,f;f=[];for(b=0,e=d.length;b<e;b++)c=d[b],f.push(c.compile(a,w));return f}().join(", ");return b.indexOf("\n")>=0?"[\n"+a.indent+b+"\n"+this.tab+"]":"["+b+"]"},b.prototype.assigns=function(a){var b,c,d,e;e=this.objects;for(c=0,d=e.length;c<d;c++){b=e[c];if(b.assigns(a))return!0}return!1};return b}(e),a.Class=h=function(a){function c(a,b,c){this.variable=a,this.parent=b,this.body=c!=null?c:new f,this.boundFuncs=[],this.body.classBody=!0}bl(c,a),c.prototype.children=["variable","parent","body"],c.prototype.determineName=function(){var a,c;if(!this.variable)return null;a=(c=bc(this.variable.properties))?c instanceof b&&c.name.value:this.variable.base.value;if(bm.call(M,a)>=0)throw SyntaxError("variable name may not be "+a);return a&&(a=o.test(a)&&a)},c.prototype.setContext=function(a){return this.body.traverseChildren(!1,function(b){if(b.classBody)return!1;if(b instanceof A&&b.value==="this")return b.value=a;if(b instanceof j){b.klass=a;if(b.bound)return b.context=a}})},c.prototype.addBoundFunctions=function(a){var c,d,e,f,g,h;if(this.boundFuncs.length){g=this.boundFuncs,h=[];for(e=0,f=g.length;e<f;e++)c=g[e],d=(new W(new A("this"),[new b(c)])).compile(a),h.push(this.ctor.body.unshift(new A(""+d+" = "+bh("bind")+"("+d+", this)")));return h}},c.prototype.addProperties=function(a,c,e){var f,g,h,i,k;k=a.base.properties.slice(0),h=function(){var a;a=[];while(f=k.shift()){if(f instanceof d){g=f.variable.base,delete f.context,i=f.value;if(g.value==="constructor"){if(this.ctor)throw new Error("cannot define more than one constructor in a class");if(i.bound)throw new Error("cannot define a constructor as a bound function");i instanceof j?f=this.ctor=i:(this.externalCtor=e.scope.freeVariable("class"),f=new d(new A(this.externalCtor),i))}else f.variable["this"]?(i["static"]=!0,i.bound&&(i.context=c)):(f.variable=new W(new A(c),[new b(new A("prototype")),new b(g)]),i instanceof j&&i.bound&&(this.boundFuncs.push(g),i.bound=!1))}a.push(f)}return a}.call(this);return Z(h)},c.prototype.walkBody=function(a,b){var d=this;return this.traverseChildren(!1,function(e){var g,h,i,j,k,l;if(e instanceof c)return!1;if(e instanceof f){l=g=e.expressions;for(h=j=0,k=l.length;j<k;h=++j)i=l[h],i instanceof W&&i.isObject(!0)&&(g[h]=d.addProperties(i,a,b));return e.expressions=g=bb(g)}})},c.prototype.hoistDirectivePrologue=function(){var a,b,c;b=0,a=this.body.expressions;while((c=a[b])&&c instanceof k||c instanceof W&&c.isString())++b;return this.directives=a.splice(0,b)},c.prototype.ensureConstructor=function(a){this.ctor||(this.ctor=new j,this.parent&&this.ctor.body.push(new A(""+a+".__super__.constructor.apply(this, arguments)")),this.externalCtor&&this.ctor.body.push(new A(""+this.externalCtor+".apply(this, arguments)")),this.ctor.body.makeReturn(),this.body.expressions.unshift(this.ctor)),this.ctor.ctor=this.ctor.name=a,this.ctor.klass=null;return this.ctor.noReturn=!0},c.prototype.compileNode=function(a){var b,c,e,f,g,h,k;c=this.determineName(),g=c||"_Class",g.reserved&&(g="_"+g),f=new A(g),this.hoistDirectivePrologue(),this.setContext(g),this.walkBody(g,a),this.ensureConstructor(g),this.body.spaced=!0,this.ctor instanceof j||this.body.expressions.unshift(this.ctor),this.body.expressions.push(f),(k=this.body.expressions).unshift.apply(k,this.directives),this.addBoundFunctions(a),b=i.wrap(this.body),this.parent&&(this.superClass=new A(a.scope.freeVariable("super",!1)),this.body.expressions.unshift(new m(f,this.superClass)),b.args.push(this.parent),h=b.variable.params||b.variable.base.params,h.push(new G(this.superClass))),e=new H(b,!0),this.variable&&(e=new d(this.variable,e));return e.compile(a)};return c}(e),a.Assign=d=function(a){function c(a,b,c,d){var e,f,g;this.variable=a,this.value=b,this.context=c,this.param=d&&d.param,this.subpattern=d&&d.subpattern,e=(g=f=this.variable.unwrapAll().value,bm.call(M,g)>=0);if(e&&this.context!=="object")throw SyntaxError('variable name may not be "'+f+'"')}bl(c,a),c.prototype.children=["variable","value"],c.prototype.isStatement=function(a){return(a!=null?a.level:void 0)===z&&this.context!=null&&bm.call(this.context,"?")>=0},c.prototype.assigns=function(a){return this[this.context==="object"?"value":"variable"].assigns(a)},c.prototype.unfoldSoak=function(a){return bg(a,this,"variable")},c.prototype.compileNode=function(a){var b,c,d,e,f,g,h,i,k;if(b=this.variable instanceof W){if(this.variable.isArray()||this.variable.isObject())return this.compilePatternMatch(a);if(this.variable.isSplice())return this.compileSplice(a);if((g=this.context)==="||="||g==="&&="||g==="?=")return this.compileConditional(a)}d=this.variable.compile(a,w);if(!this.context){if(!(f=this.variable.unwrapAll()).isAssignable())throw SyntaxError('"'+this.variable.compile(a)+'" cannot be assigned.');if(typeof f.hasProperties=="function"?!f.hasProperties():!void 0)this.param?a.scope.add(d,"var"):a.scope.find(d)}this.value instanceof j&&(c=B.exec(d))&&(c[1]&&(this.value.klass=c[1]),this.value.name=(h=(i=(k=c[2])!=null?k:c[3])!=null?i:c[4])!=null?h:c[5]),e=this.value.compile(a,w);if(this.context==="object")return""+d+": "+e;e=d+(" "+(this.context||"=")+" ")+e;return a.level<=w?e:"("+e+")"},c.prototype.compilePatternMatch=function(a){var d,e,f,g,h,i,j,k,l,m,n,p,q,r,s,u,v,y,B,C,D,E,F,G,J,K,L;s=a.level===z,v=this.value,m=this.variable.base.objects;if(!(n=m.length)){f=v.compile(a);return a.level>=x?"("+f+")":f}i=this.variable.isObject();if(s&&n===1&&!((l=m[0])instanceof P)){l instanceof c?(D=l,E=D.variable,h=E.base,l=D.value):l.base instanceof H?(F=(new W(l.unwrapAll())).cacheReference(a),l=F[0],h=F[1]):h=i?l["this"]?l.properties[0].name:l:new A(0),d=o.test(h.unwrap().value||0),v=new W(v),v.properties.push(new(d?b:t)(h));if(G=l.unwrap().value,bm.call(I,G)>=0)throw new SyntaxError("assignment to a reserved word: "+l.compile(a)+" = "+v.compile(a));return(new c(l,v,null,{param:this.param})).compile(a,z)}y=v.compile(a,w),e=[],r=!1;if(!o.test(y)||this.variable.assigns(y))e.push(""+(p=a.scope.freeVariable("ref"))+" = "+y),y=p;for(g=B=0,C=m.length;B<C;g=++B){l=m[g],h=g,i&&(l instanceof c?(J=l,K=J.variable,h=K.base,l=J.value):l.base instanceof H?(L=(new W(l.unwrapAll())).cacheReference(a),l=L[0],h=L[1]):h=l["this"]?l.properties[0].name:l);if(!r&&l instanceof P)k=l.name.unwrap().value,l=l.unwrap(),u=""+n+" <= "+y+".length ? "+bh("slice")+".call("+y+", "+g,(q=n-g-1)?(j=a.scope.freeVariable("i"),u+=", "+j+" = "+y+".length - "+q+") : ("+j+" = "+g+", [])"):u+=") : []",u=new A(u),r=""+j+"++";else{k=l.unwrap().value;if(l instanceof P){l=l.name.compile(a);throw new SyntaxError("multiple splats are disallowed in an assignment: "+l+"...")}typeof h=="number"?(h=new A(r||h),d=!1):d=i&&o.test(h.unwrap().value||0),u=new W(new A(y),[new(d?b:t)(h)])}if(k!=null&&bm.call(I,k)>=0)throw new SyntaxError("assignment to a reserved word: "+l.compile(a)+" = "+u.compile(a));e.push((new c(l,u,null,{param:this.param,subpattern:!0})).compile(a,w))}!s&&!this.subpattern&&e.push(y),f=e.join(", ");return a.level<w?f:"("+f+")"},c.prototype.compileConditional=function(a){var b,d,e;e=this.variable.cacheReference(a),b=e[0],d=e[1];if(!b.properties.length&&b.base instanceof A&&b.base.value!=="this"&&!a.scope.check(b.base.value))throw new Error('the variable "'+b.base.value+"\" can't be assigned with "+this.context+" because it has not been defined.");bm.call(this.context,"?")>=0&&(a.isExistentialEquals=!0);return(new F(this.context.slice(0,-1),b,new c(d,this.value,"="))).compile(a)},c.prototype.compileSplice=function(a){var b,c,d,e,f,g,h,i,j,k,l,m;k=this.variable.properties.pop().range,d=k.from,h=k.to,c=k.exclusive,g=this.variable.compile(a),l=(d!=null?d.cache(a,x):void 0)||["0","0"],e=l[0],f=l[1],h?(d!=null?d.isSimpleNumber():void 0)&&h.isSimpleNumber()?(h=+h.compile(a)- +f,c||(h+=1)):(h=h.compile(a,u)+" - "+f,c||(h+=" + 1")):h="9e9",m=this.value.cache(a,w),i=m[0],j=m[1],b="[].splice.apply("+g+", ["+e+", "+h+"].concat("+i+")), "+j;return a.level>z?"("+b+")":b};return c}(e),a.Code=j=function(a){function b(a,b,c){this.params=a||[],this.body=b||new f,this.bound=c==="boundfunc",this.bound&&(this.context="_this")}bl(b,a),b.prototype.children=["params","body"],b.prototype.isStatement=function(){return!!this.ctor},b.prototype.jumps=D,b.prototype.compileNode=function(a){var b,e,f,g,h,i,j,k,l,m,n,o,p,q,s,t,v,w,x,y,z,B,C,D,E,G,H,I,J,K,L,M,O;a.scope=new N(a.scope,this.body,this),a.scope.shared=$(a,"sharedScope"),a.indent+=R,delete a.bare,delete a.isExistentialEquals,l=[],e=[],H=this.paramNames();for(s=0,x=H.length;s<x;s++)i=H[s],a.scope.check(i)||a.scope.parameter(i);I=this.params;for(t=0,y=I.length;t<y;t++){k=I[t];if(!k.splat)continue;J=this.params;for(v=0,z=J.length;v<z;v++)j=J[v].name,j["this"]&&(j=j.properties[0].name),j.value&&a.scope.add(j.value,"var",!0);n=new d(new W(new c(function(){var b,c,d,e;d=this.params,e=[];for(b=0,c=d.length;b<c;b++)j=d[b],e.push(j.asReference(a));return e}.call(this))),new W(new A("arguments")));break}K=this.params;for(w=0,B=K.length;w<B;w++)k=K[w],k.isComplex()?(p=m=k.asReference(a),k.value&&(p=new F("?",m,k.value)),e.push(new d(new W(k.name),p,"=",{param:!0}))):(m=k,k.value&&(h=new A(m.name.value+" == null"),p=new d(new W(k.name),k.value,"="),e.push(new r(h,p)))),n||l.push(m);q=this.body.isEmpty(),n&&e.unshift(n),e.length&&(L=this.body.expressions).unshift.apply(L,e);for(f=E=0,C=l.length;E<C;f=++E)j=l[f],a.scope.parameter(l[f]=j.compile(a));o=[],M=this.paramNames();for(G=0,D=M.length;G<D;G++){i=M[G];if(bm.call(o,i)>=0)throw SyntaxError("multiple parameters named '"+i+"'");o.push(i)}!q&&!this.noReturn&&this.body.makeReturn(),this.bound&&(((O=a.scope.parent.method)!=null?O.bound:void 0)?this.bound=this.context=a.scope.parent.method.context:this["static"]||a.scope.parent.assign("_this","this")),g=a.indent,b="function",this.ctor&&(b+=" "+this.name),b+="("+l.join(", ")+") {",this.body.isEmpty()||(b+="\n"+this.body.compileWithDeclarations(a)+"\n"+this.tab),b+="}";if(this.ctor)return this.tab+b;return this.front||a.level>=u?"("+b+")":b},b.prototype.paramNames=function(){var a,b,c,d,e;a=[],e=this.params;for(c=0,d=e.length;c<d;c++)b=e[c],a.push.apply(a,b.names());return a},b.prototype.traverseChildren=function(a,c){if(a)return b.__super__.traverseChildren.call(this,a,c)};return b}(e),a.Param=G=function(a){function b(a,b,c){var d;this.name=a,this.value=b,this.splat=c;if(d=a=this.name.unwrapAll().value,bm.call(M,d)>=0)throw SyntaxError('parameter name "'+a+'" is not allowed')}bl(b,a),b.prototype.children=["name","value"],b.prototype.compile=function(a){return this.name.compile(a,w)},b.prototype.asReference=function(a){var b;if(this.reference)return this.reference;b=this.name,b["this"]?(b=b.properties[0].name,b.value.reserved&&(b=new A(a.scope.freeVariable(b.value)))):b.isComplex()&&(b=new A(a.scope.freeVariable("arg"))),b=new W(b),this.splat&&(b=new P(b));return this.reference=b},b.prototype.isComplex=function(){return this.name.isComplex()},b.prototype.names=function(a){var b,c,e,f,g,h;a==null&&(a=this.name),b=function(a){var b;b=a.properties[0].name.value;return b.reserved?[]:[b]};if(a instanceof A)return[a.value];if(a instanceof W)return b(a);c=[],h=a.objects;for(f=0,g=h.length;f<g;f++){e=h[f];if(e instanceof d)c.push(e.value.unwrap().value);else if(e instanceof P)c.push(e.name.unwrap().value);else if(e instanceof W)e.isArray()||e.isObject()?c.push.apply(c,this.names(e.base)):e["this"]?c.push.apply(c,b(e)):c.push(e.base.value);else throw SyntaxError("illegal parameter "+e.compile())}return c};return b}(e),a.Splat=P=function(a){function b(a){this.name=a.compile?a:new A(a)}bl(b,a),b.prototype.children=["name"],b.prototype.isAssignable=Y,b.prototype.assigns=function(a){return this.name.assigns(a)},b.prototype.compile=function(a){return this.index!=null?this.compileParam(a):this.name.compile(a)},b.prototype.unwrap=function(){return this.name},b.compileSplattedArray=function(a,c,d){var e,f,g,h,i,j,k,l;i=-1;while((j=c[++i])&&!(j instanceof b))continue;if(i>=c.length)return"";if(c.length===1){g=c[0].compile(a,w);if(d)return g;return""+bh("slice")+".call("+g+")"}e=c.slice(i);for(h=k=0,l=e.length;k<l;h=++k)j=e[h],g=j.compile(a,w),e[h]=j instanceof b?""+bh("slice")+".call("+g+")":"["+g+"]";if(i===0)return e[0]+(".concat("+e.slice(1).join(", ")+")");f=function(){var b,d,e,f;e=c.slice(0,i),f=[];for(b=0,d=e.length;b<d;b++)j=e[b],f.push(j.compile(a,w));return f}();return"["+f.join(", ")+"].concat("+e.join(", ")+")"};return b}(e),a.While=X=function(a){function b(a,b){this.condition=(b!=null?b.invert:void 0)?a.invert():a,this.guard=b!=null?b.guard:void 0}bl(b,a),b.prototype.children=["condition","guard","body"],b.prototype.isStatement=Y,b.prototype.makeReturn=function(a){if(a)return b.__super__.makeReturn.apply(this,arguments);this.returns=!this.jumps({loop:!0});return this},b.prototype.addBody=function(a){this.body=a;return this},b.prototype.jumps=function(){var a,b,c,d;a=this.body.expressions;if(!a.length)return!1;for(c=0,d=a.length;c<d;c++){b=a[c];if(b.jumps({loop:!0}))return b}return!1},b.prototype.compileNode=function(a){var b,c,d,e;a.indent+=R,e="",b=this.body,b.isEmpty()?b="":(this.returns&&(b.makeReturn(d=a.scope.freeVariable("results")),e=""+this.tab+d+" = [];\n"),this.guard&&(b.expressions.length>1?b.expressions.unshift(new r((new H(this.guard)).invert(),new A("continue"))):this.guard&&(b=f.wrap([new r(this.guard,b)]))),b="\n"+b.compile(a,z)+"\n"+this.tab),c=e+this.tab+("while ("+this.condition.compile(a,y)+") {"+b+"}"),this.returns&&(c+="\n"+this.tab+"return "+d+";");return c};return b}(e),a.Op=F=function(a){function e(a,c,d,e){if(a==="in")return new s(c,d);if(a==="do")return this.generateDo(c);if(a==="new"){if(c instanceof g&&!c["do"]&&!c.isNew)return c.newInstance();if(c instanceof j&&c.bound||c["do"])c=new H(c)}this.operator=b[a]||a,this.first=c,this.second=d,this.flip=!!e;return this}var b,c;bl(e,a),b={"==":"===","!=":"!==",of:"in"},c={"!==":"===","===":"!=="},e.prototype.children=["first","second"],e.prototype.isSimpleNumber=D,e.prototype.isUnary=function(){return!this.second},e.prototype.isComplex=function(){var a;return!this.isUnary()||(a=this.operator)!=="+"&&a!=="-"||this.first.isComplex()},e.prototype.isChainable=function(){var a;return(a=this.operator)==="<"||a===">"||a===">="||a==="<="||a==="==="||a==="!=="},e.prototype.invert=function(){var a,b,d,f,g;if(this.isChainable()&&this.first.isChainable()){a=!0,b=this;while(b&&b.operator)a&&(a=b.operator in c),b=b.first;if(!a)return(new H(this)).invert();b=this;while(b&&b.operator)b.invert=!b.invert,b.operator=c[b.operator],b=b.first;return this}if(f=c[this.operator]){this.operator=f,this.first.unwrap()instanceof e&&this.first.invert();return this}return this.second?(new H(this)).invert():this.operator==="!"&&(d=this.first.unwrap())instanceof e&&((g=d.operator)==="!"||g==="in"||g==="instanceof")?d:new e("!",this)},e.prototype.unfoldSoak=function(a){var b;return((b=this.operator)==="++"||b==="--"||b==="delete")&&bg(a,this,"first")},e.prototype.generateDo=function(a){var b,c,e,f,h,i,k,l;f=[],c=a instanceof d&&(h=a.value.unwrap())instanceof j?h:a,l=c.params||[];for(i=0,k=l.length;i<k;i++)e=l[i],e.value?(f.push(e.value),delete e.value):f.push(e);b=new g(a,f),b["do"]=!0;return b},e.prototype.compileNode=function(a){var b,c,d,e;c=this.isChainable()&&this.first.isChainable(),c||(this.first.front=this.front);if(this.operator==="delete"&&a.scope.check(this.first.unwrapAll().value))throw SyntaxError("delete operand may not be argument or var");if(((d=this.operator)==="--"||d==="++")&&(e=this.first.unwrapAll().value,bm.call(M,e)>=0))throw SyntaxError("prefix increment/decrement may not have eval or arguments operand");if(this.isUnary())return this.compileUnary(a);if(c)return this.compileChain(a);if(this.operator==="?")return this.compileExistence(a);b=this.first.compile(a,x)+" "+this.operator+" "+this.second.compile(a,x);return a.level<=x?b:"("+b+")"},e.prototype.compileChain=function(a){var b,c,d,e;e=this.first.second.cache(a),this.first.second=e[0],d=e[1],c=this.first.compile(a,x),b=""+c+" "+(this.invert?"&&":"||")+" "+d.compile(a)+" "+this.operator+" "+this.second.compile(a,x);return"("+b+")"},e.prototype.compileExistence=function(a){var b,c;this.first.isComplex()?(c=new A(a.scope.freeVariable("ref")),b=new H(new d(c,this.first))):(b=this.first,c=b);return(new r(new l(b),c,{type:"if"})).addElse(this.second).compile(a)},e.prototype.compileUnary=function(a){var b,c,d;if(a.level>=u)return(new H(this)).compile(a);c=[b=this.operator],d=b==="+"||b==="-",(b==="new"||b==="typeof"||b==="delete"||d&&this.first instanceof e&&this.first.operator===b)&&c.push(" ");if(d&&this.first instanceof e||b==="new"&&this.first.isStatement(a))this.first=new H(this.first);c.push(this.first.compile(a,x)),this.flip&&c.reverse();return c.join("")},e.prototype.toString=function(a){return e.__super__.toString.call(this,a,this.constructor.name+" "+this.operator)};return e}(e),a.In=s=function(a){function b(a,b){this.object=a,this.array=b}bl(b,a),b.prototype.children=["object","array"],b.prototype.invert=C,b.prototype.compileNode=function(a){var b,c,d,e,f;if(this.array instanceof W&&this.array.isArray()){f=this.array.base.objects;for(d=0,e=f.length;d<e;d++){c=f[d];if(!(c instanceof P))continue;b=!0;break}if(!b)return this.compileOrTest(a)}return this.compileLoopTest(a)},b.prototype.compileOrTest=function(a){var b,c,d,e,f,g,h,i,j;if(this.array.base.objects.length===0)return""+!!this.negated;i=this.object.cache(a,x),g=i[0],f=i[1],j=this.negated?[" !== "," && "]:[" === "," || "],b=j[0],c=j[1],h=function(){var c,h,i,j;i=this.array.base.objects,j=[];for(d=c=0,h=i.length;c<h;d=++c)e=i[d],j.push((d?f:g)+b+e.compile(a,u));return j}.call(this),h=h.join(c);return a.level<x?h:"("+h+")"},b.prototype.compileLoopTest=function(a){var b,c,d,e;e=this.object.cache(a,w),d=e[0],c=e[1],b=bh("indexOf")+(".call("+this.array.compile(a,w)+", "+c+") ")+(this.negated?"< 0":">= 0");if(d===c)return b;b=d+", "+b;return a.level<w?b:"("+b+")"},b.prototype.toString=function(a){return b.__super__.toString.call(this,a,this.constructor.name+(this.negated?"!":""))};return b}(e),a.Try=U=function(a){function b(a,b,c,d){this.attempt=a,this.error=b,this.recovery=c,this.ensure=d}bl(b,a),b.prototype.children=["attempt","recovery","ensure"],b.prototype.isStatement=Y,b.prototype.jumps=function(a){var b;return this.attempt.jumps(a)||((b=this.recovery)!=null?b.jumps(a):void 0)},b.prototype.makeReturn=function(a){this.attempt&&(this.attempt=this.attempt.makeReturn(a)),this.recovery&&(this.recovery=this.recovery.makeReturn(a));return this},b.prototype.compileNode=function(a){var b,c,d,e;a.indent+=R,d=this.error?" ("+this.error.compile(a)+") ":" ",e=this.attempt.compile(a,z),b=function(){var b;if(this.recovery){if(b=this.error.value,bm.call(M,b)>=0)throw SyntaxError('catch variable may not be "'+this.error.value+'"');a.scope.check(this.error.value)||a.scope.add(this.error.value,"param");return" catch"+d+"{\n"+this.recovery.compile(a,z)+"\n"+this.tab+"}"}if(!this.ensure&&!this.recovery)return" catch (_error) {}"}.call(this),c=this.ensure?" finally {\n"+this.ensure.compile(a,z)+"\n"+this.tab+"}":"";return""+this.tab+"try {\n"+e+"\n"+this.tab+"}"+(b||"")+c};return b}(e),a.Throw=T=function(a){function b(a){this.expression=a}bl(b,a),b.prototype.children=["expression"],b.prototype.isStatement=Y,b.prototype.jumps=D,b.prototype.makeReturn=S,b.prototype.compileNode=function(a){return this.tab+("throw "+this.expression.compile(a)+";")};return b}(e),a.Existence=l=function(a){function b(a){this.expression=a}bl(b,a),b.prototype.children=["expression"],b.prototype.invert=C,b.prototype.compileNode=function(a){var b,c,d,e;this.expression.front=this.front,d=this.expression.compile(a,x),o.test(d)&&!a.scope.check(d)?(e=this.negated?["===","||"]:["!==","&&"],b=e[0],c=e[1],d="typeof "+d+" "+b+' "undefined" '+c+" "+d+" "+b+" null"):d=""+d+" "+(this.negated?"==":"!=")+" null";return a.level<=v?d:"("+d+")"};return b}(e),a.Parens=H=function(a){function b(a){this.body=a}bl(b,a),b.prototype.children=["body"],b.prototype.unwrap=function(){return this.body},b.prototype.isComplex=function(){return this.body.isComplex()},b.prototype.compileNode=function(a){var b,c,d;d=this.body.unwrap();if(d instanceof W&&d.isAtomic()){d.front=this.front;return d.compile(a)}c=d.compile(a,y),b=a.level<x&&(d instanceof F||d instanceof g||d instanceof n&&d.returns);return b?c:"("+c+")"};return b}(e),a.For=n=function(a){function b(a,b){var c;this.source=b.source,this.guard=b.guard,this.step=b.step,this.name=b.name,this.index=b.index,this.body=f.wrap([a]),this.own=!!b.own,this.object=!!b.object,this.object&&(c=[this.index,this.name],this.name=c[0],this.index=c[1]);if(this.index instanceof W)throw SyntaxError("index cannot be a pattern matching expression");this.range=this.source instanceof W&&this.source.base instanceof J&&!this.source.properties.length,this.pattern=this.name instanceof W;if(this.range&&this.index)throw SyntaxError("indexes do not apply to range loops");if(this.range&&this.pattern)throw SyntaxError("cannot pattern match over range loops");this.returns=!1}bl(b,a),b.prototype.children=["body","source","guard","step"],b.prototype.compileNode=function(a){var b,c,e,g,h,i,j,k,l,m,n,p,q,s,t,u,v,y,B,C,D,E,F,G,I;b=f.wrap([this.body]),n=(I=bc(b.expressions))!=null?I.jumps():void 0,n&&n instanceof K&&(this.returns=!1),C=this.range?this.source.base:this.source,B=a.scope,q=this.name&&this.name.compile(a,w),j=this.index&&this.index.compile(a,w),q&&!this.pattern&&B.find(q),j&&B.find(j),this.returns&&(y=B.freeVariable("results")),k=this.object&&j||B.freeVariable("i"),l=this.range&&q||j||k,m=l!==k?""+l+" = ":"",this.step&&!this.range&&(E=B.freeVariable("step")),this.pattern&&(q=k),G="",h="",c="",i=this.tab+R,this.range?e=C.compile(bd(a,{index:k,name:q,step:this.step})):(F=this.source.compile(a,w),(q||this.own)&&!o.test(F)&&(c=""+this.tab+(t=B.freeVariable("ref"))+" = "+F+";\n",F=t),q&&!this.pattern&&(s=""+q+" = "+F+"["+l+"]"),this.object||(p=B.freeVariable("len"),g=""+m+k+" = 0, "+p+" = "+F+".length",this.step&&(g+=", "+E+" = "+this.step.compile(a,x)),D=""+m+(this.step?""+k+" += "+E:l!==k?"++"+k:""+k+"++"),e=""+g+"; "+k+" < "+p+"; "+D)),this.returns&&(u=""+this.tab+y+" = [];\n",v="\n"+this.tab+"return "+y+";",b.makeReturn(y)),this.guard&&(b.expressions.length>1?b.expressions.unshift(new r((new H(this.guard)).invert(),new A("continue"))):this.guard&&(b=f.wrap([new r(this.guard,b)]))),this.pattern&&b.expressions.unshift(new d(this.name,new A(""+F+"["+l+"]"))),c+=this.pluckDirectCall(a,b),s&&(G="\n"+i+s+";"),this.object&&(e=""+l+" in "+F,this.own&&(h="\n"+i+"if (!"+bh("hasProp")+".call("+F+", "+l+")) continue;")),b=b.compile(bd(a,{indent:i}),z),b&&(b="\n"+b+"\n");return""+c+(u||"")+this.tab+"for ("+e+") {"+h+G+b+this.tab+"}"+(v||"")},b.prototype.pluckDirectCall=function(a,b){var c,e,f,h,i,k,l,m,n,o,p,q,r,s,t;e="",o=b.expressions;for(i=m=0,n=o.length;m<n;i=++m){f=o[i],f=f.unwrapAll();if(!(f instanceof g))continue;l=f.variable.unwrapAll();if(!(l instanceof j||l instanceof W&&((p=l.base)!=null?p.unwrapAll():void 0)instanceof j&&l.properties.length===1&&((q=(r=l.properties[0].name)!=null?r.value:void 0)==="call"||q==="apply")))continue;h=((s=l.base)!=null?s.unwrapAll():void 0)||l,k=new A(a.scope.freeVariable("fn")),c=new W(k),l.base&&(t=[c,l],l.base=t[0],c=t[1]),b.expressions[i]=new g(c,f.args),e+=this.tab+(new d(k,h)).compile(a,z)+";\n"}return e};return b}(X),a.Switch=Q=function(a){function b(a,b,c){this.subject=a,this.cases=b,this.otherwise=c}bl(b,a),b.prototype.children=["subject","cases","otherwise"],b.prototype.isStatement=Y,b.prototype.jumps=function(a){var b,c,d,e,f,g,h;a==null&&(a={block:!0}),f=this.cases;for(d=0,e=f.length;d<e;d++){g=f[d],c=g[0],b=g[1];if(b.jumps(a))return b}return(h=this.otherwise)!=null?h.jumps(a):void 0},b.prototype.makeReturn=function(a){var b,c,d,e,g;e=this.cases;for(c=0,d=e.length;c<d;c++)b=e[c],b[1].makeReturn(a);a&&(this.otherwise||(this.otherwise=new f([new A("void 0")]))),(g=this.otherwise)!=null&&g.makeReturn(a);return this},b.prototype.compileNode=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r;i=a.indent+R,j=a.indent=i+R,d=this.tab+("switch ("+(((o=this.subject)!=null?o.compile(a,y):void 0)||!1)+") {\n"),p=this.cases;for(h=k=0,m=p.length;k<m;h=++k){q=p[h],f=q[0],b=q[1],r=bb([f]);for(l=0,n=r.length;l<n;l++)e=r[l],this.subject||(e=e.invert()),d+=i+("case "+e.compile(a,y)+":\n");if(c=b.compile(a,z))d+=c+"\n";if(h===this.cases.length-1&&!this.otherwise)break;g=this.lastNonComment(b.expressions);if(g instanceof K||g instanceof A&&g.jumps()&&g.value!=="debugger")continue;d+=j+"break;\n"}this.otherwise&&this.otherwise.expressions.length&&(d+=i+("default:\n"+this.otherwise.compile(a,z)+"\n"));return d+this.tab+"}"};return b}(e),a.If=r=function(a){function b(a,b,c){this.body=b,c==null&&(c={}),this.condition=c.type==="unless"?a.invert():a,this.elseBody=null,this.isChain=!1,this.soak=c.soak}bl(b,a),b.prototype.children=["condition","body","elseBody"],b.prototype.bodyNode=function(){var a;return(a=this.body)!=null?a.unwrap():void 0},b.prototype.elseBodyNode=function(){var a;return(a=this.elseBody)!=null?a.unwrap():void 0},b.prototype.addElse=function(a){this.isChain?this.elseBodyNode().addElse(a):(this.isChain=a instanceof b,this.elseBody=this.ensureBlock(a));return this},b.prototype.isStatement=function(a){var b;return(a!=null?a.level:void 0)===z||this.bodyNode().isStatement(a)||((b=this.elseBodyNode())!=null?b.isStatement(a):void 0)},b.prototype.jumps=function(a){var b;return this.body.jumps(a)||((b=this.elseBody)!=null?b.jumps(a):void 0)},b.prototype.compileNode=function(a){return this.isStatement(a)?this.compileStatement(a):this.compileExpression(a)},b.prototype.makeReturn=function(a){a&&(this.elseBody||(this.elseBody=new f([new A("void 0")]))),this.body&&(this.body=new f([this.body.makeReturn(a)])),this.elseBody&&(this.elseBody=new f([this.elseBody.makeReturn(a)]));return this},b.prototype.ensureBlock=function(a){return a instanceof f?a:new f([a])},b.prototype.compileStatement=function(a){var c,d,e,f,g;d=$(a,"chainChild"),f=$(a,"isExistentialEquals");if(f)return(new b(this.condition.invert(),this.elseBodyNode(),{type:"if"})).compile(a);e=this.condition.compile(a,y),a.indent+=R,c=this.ensureBlock(this.body),g="if ("+e+") {\n"+c.compile(a)+"\n"+this.tab+"}",d||(g=this.tab+g);if(!this.elseBody)return g;return g+" else "+(this.isChain?(a.indent=this.tab,a.chainChild=!0,this.elseBody.unwrap().compile(a,z)):"{\n"+this.elseBody.compile(a,z)+"\n"+this.tab+"}")},b.prototype.compileExpression=function(a){var b,c,d,e;e=this.condition.compile(a,v),c=this.bodyNode().compile(a,w),b=this.elseBodyNode()?this.elseBodyNode().compile(a,w):"void 0",d=""+e+" ? "+c+" : "+b;return a.level>=v?"("+d+")":d},b.prototype.unfoldSoak=function(){return this.soak&&this};return b}(e),i={wrap:function(a,c,d){var e,h,i,k,l;if(a.jumps())return a;i=new j([],f.wrap([a])),e=[];if((k=a.contains(this.literalArgs))||a.contains(this.literalThis))l=new A(k?"apply":"call"),e=[new A("this")],k&&e.push(new A("arguments")),i=new W(i,[new b(l)]);i.noReturn=d,h=new g(i,e);return c?f.wrap([h]):h},literalArgs:function(a){return a instanceof A&&a.value==="arguments"&&!a.asKey},literalThis:function(a){return a instanceof A&&a.value==="this"&&!a.asKey||a instanceof j&&a.bound||a instanceof g&&a.isSuper}},bg=function(a,b,c){var d;if(!!(d=b[c].unfoldSoak(a))){b[c]=d.body,d.body=new W(b);return d}},V={"extends":function(){return"function(child, parent) { for (var key in parent) { if ("+bh("hasProp")+".call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }"},bind:function(){return"function(fn, me){ return function(){ return fn.apply(me, arguments); }; }"},indexOf:function(){return"[].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; }"},hasProp:function(){return"{}.hasOwnProperty"},slice:function(){return"[].slice"}},z=1,y=2,w=3,v=4,x=5,u=6,R="  ",p="[$A-Za-z_\\x7f-\\uffff][$\\w\\x7f-\\uffff]*",o=RegExp("^"+p+"$"),L=/^[+-]?\d+$/,B=RegExp("^(?:("+p+")\\.prototype(?:\\.("+p+")|\\[(\"(?:[^\\\\\"\\r\\n]|\\\\.)*\"|'(?:[^\\\\'\\r\\n]|\\\\.)*')\\]|\\[(0x[\\da-fA-F]+|\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\]))|("+p+")$"),q=/^['"]/,bh=function(a){var b;b="__"+a,N.root.assign(b,V[a]());return b},be=function(a,b){a=a.replace(/\n/g,"$&"+b);return a.replace(/\s+$/,"")}}).call(this)},require["./coffee-script"]=new function(){var a=this;(function(){var b,c,d,e,f,g,h,i,j,k=({}).hasOwnProperty;e=require("fs"),h=require("path"),j=require("./lexer"),b=j.Lexer,c=j.RESERVED,g=require("./parser").parser,i=require("vm"),require.extensions?require.extensions[".coffee"]=function(a,b){var c;c=d(e.readFileSync(b,"utf8"),{filename:b});return a._compile(c,b)}:require.registerExtension&&require.registerExtension(".coffee",function(a){return d(a)}),a.VERSION="1.3.3",a.RESERVED=c,a.helpers=require("./helpers"),a.compile=d=function(b,c){var d,e,h;c==null&&(c={}),h=a.helpers.merge;try{e=g.parse(f.tokenize(b)).compile(c);if(!c.header)return e}catch(i){c.filename&&(i.message="In "+c.filename+", "+i.message);throw i}d="Generated by CoffeeScript "+this.VERSION;return"// "+d+"\n"+e},a.tokens=function(a,b){return f.tokenize(a,b)},a.nodes=function(a,b){return typeof a=="string"?g.parse(f.tokenize(a,b)):g.parse(a)},a.run=function(a,b){var c;b==null&&(b={}),c=require.main,c.filename=process.argv[1]=b.filename?e.realpathSync(b.filename):".",c.moduleCache&&(c.moduleCache={}),c.paths=require("module")._nodeModulePaths(h.dirname(e.realpathSync(b.filename)));return h.extname(c.filename)!==".coffee"||require.extensions?c._compile(d(a,b),c.filename):c._compile(a,c.filename)},a.eval=function(a,b){var c,e,f,g,j,l,m,n,o,p,q,r,s,t;b==null&&(b={});if(!!(a=a.trim())){e=i.Script;if(e){if(b.sandbox!=null){if(b.sandbox instanceof e.createContext().constructor)m=b.sandbox;else{m=e.createContext(),r=b.sandbox;for(g in r){if(!k.call(r,g))continue;n=r[g],m[g]=n}}m.global=m.root=m.GLOBAL=m}else m=global;m.__filename=b.filename||"eval",m.__dirname=h.dirname(m.__filename);if(m===global&&!m.module&&!m.require){c=require("module"),m.module=q=new c(b.modulename||"eval"),m.require=t=function(a){return c._load(a,q,!0)},q.filename=m.__filename,s=Object.getOwnPropertyNames(require);for(o=0,p=s.length;o<p;o++)l=s[o],l!=="paths"&&(t[l]=require[l]);t.paths=q.paths=c._nodeModulePaths(process.cwd()),t.resolve=function(a){return c._resolveFilename(a,q)}}}j={};for(g in b){if(!k.call(b,g))continue;n=b[g],j[g]=n}j.bare=!0,f=d(a,j);return m===global?i.runInThisContext(f):i.runInContext(f,m)}},f=new b,g.lexer={lex:function(){var a,b;b=this.tokens[this.pos++]||[""],a=b[0],this.yytext=b[1],this.yylineno=b[2];return a},setInput:function(a){this.tokens=a;return this.pos=0},upcomingInput:function(){return""}},g.yy=require("./nodes")}).call(this)},require["./browser"]=new function(){var exports=this;(function(){var CoffeeScript,runScripts;CoffeeScript=require("./coffee-script"),CoffeeScript.require=require,CoffeeScript.eval=function(code,options){var _ref;options==null&&(options={}),(_ref=options.bare)==null&&(options.bare=!0);return eval(CoffeeScript.compile(code,options))},CoffeeScript.run=function(a,b){b==null&&(b={}),b.bare=!0;return Function(CoffeeScript.compile(a,b))()};typeof window!="undefined"&&window!==null&&(CoffeeScript.load=function(a,b){var c;c=new(window.ActiveXObject||XMLHttpRequest)("Microsoft.XMLHTTP"),c.open("GET",a,!0),"overrideMimeType"in c&&c.overrideMimeType("text/plain"),c.onreadystatechange=function(){var d;if(c.readyState===4){if((d=c.status)===0||d===200)CoffeeScript.run(c.responseText);else throw new Error("Could not load "+a);if(b)return b()}};return c.send(null)},runScripts=function(){var a,b,c,d,e,f;f=document.getElementsByTagName("script"),a=function(){var a,b,c;c=[];for(a=0,b=f.length;a<b;a++)e=f[a],e.type==="text/coffeescript"&&c.push(e);return c}(),c=0,d=a.length,(b=function(){var d;d=a[c++];if((d!=null?d.type:void 0)==="text/coffeescript"){if(d.src)return CoffeeScript.load(d.src,b);CoffeeScript.run(d.innerHTML);return b()}})();return null},window.addEventListener?addEventListener("DOMContentLoaded",runScripts,!1):attachEvent("onload",runScripts))}).call(this)};return require["./coffee-script"]}();typeof define=="function"&&define.amd?define('coffee-script',[],function(){return CoffeeScript}):root.CoffeeScript=CoffeeScript})(this);
/**
 * @license cs 0.4.2 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/require-cs for details
 */

/*jslint */
/*global define, window, XMLHttpRequest, importScripts, Packages, java,
  ActiveXObject, process, require */

define('cs',['coffee-script'], function (CoffeeScript) {
    'use strict';
    var fs, getXhr,
        progIds = ['Msxml2.XMLHTTP', 'Microsoft.XMLHTTP', 'Msxml2.XMLHTTP.4.0'],
        fetchText = function () {
            throw new Error('Environment unsupported.');
        },
        buildMap = {};

    if (typeof process !== "undefined" &&
               process.versions &&
               !!process.versions.node) {
        //Using special require.nodeRequire, something added by r.js.
        fs = require.nodeRequire('fs');
        fetchText = function (path, callback) {
            callback(fs.readFileSync(path, 'utf8'));
        };
    } else if ((typeof window !== "undefined" && window.navigator && window.document) || typeof importScripts !== "undefined") {
        // Browser action
        getXhr = function () {
            //Would love to dump the ActiveX crap in here. Need IE 6 to die first.
            var xhr, i, progId;
            if (typeof XMLHttpRequest !== "undefined") {
                return new XMLHttpRequest();
            } else {
                for (i = 0; i < 3; i++) {
                    progId = progIds[i];
                    try {
                        xhr = new ActiveXObject(progId);
                    } catch (e) {}

                    if (xhr) {
                        progIds = [progId];  // so faster next time
                        break;
                    }
                }
            }

            if (!xhr) {
                throw new Error("getXhr(): XMLHttpRequest not available");
            }

            return xhr;
        };

        fetchText = function (url, callback) {
            var xhr = getXhr();
            xhr.open('GET', url, true);
            xhr.onreadystatechange = function (evt) {
                //Do not explicitly handle errors, those should be
                //visible via console output in the browser.
                if (xhr.readyState === 4) {
                    callback(xhr.responseText);
                }
            };
            xhr.send(null);
        };
        // end browser.js adapters
    } else if (typeof Packages !== 'undefined') {
        //Why Java, why is this so awkward?
        fetchText = function (path, callback) {
            var encoding = "utf-8",
                file = new java.io.File(path),
                lineSeparator = java.lang.System.getProperty("line.separator"),
                input = new java.io.BufferedReader(new java.io.InputStreamReader(new java.io.FileInputStream(file), encoding)),
                stringBuffer, line,
                content = '';
            try {
                stringBuffer = new java.lang.StringBuffer();
                line = input.readLine();

                // Byte Order Mark (BOM) - The Unicode Standard, version 3.0, page 324
                // http://www.unicode.org/faq/utf_bom.html

                // Note that when we use utf-8, the BOM should appear as "EF BB BF", but it doesn't due to this bug in the JDK:
                // http://bugs.sun.com/bugdatabase/view_bug.do?bug_id=4508058
                if (line && line.length() && line.charAt(0) === 0xfeff) {
                    // Eat the BOM, since we've already found the encoding on this file,
                    // and we plan to concatenating this buffer with others; the BOM should
                    // only appear at the top of a file.
                    line = line.substring(1);
                }

                stringBuffer.append(line);

                while ((line = input.readLine()) !== null) {
                    stringBuffer.append(lineSeparator);
                    stringBuffer.append(line);
                }
                //Make sure we return a JavaScript string and not a Java string.
                content = String(stringBuffer.toString()); //String
            } finally {
                input.close();
            }
            callback(content);
        };
    }

    return {
        get: function () {
            return CoffeeScript;
        },

        write: function (pluginName, name, write) {
            if (buildMap.hasOwnProperty(name)) {
                var text = buildMap[name];
                write.asModule(pluginName + "!" + name, text);
            }
        },

        version: '0.4.2',

        load: function (name, parentRequire, load, config) {
            var path = parentRequire.toUrl(name + '.coffee');
            fetchText(path, function (text) {

                //Do CoffeeScript transform.
                try {
                  text = CoffeeScript.compile(text, config.CoffeeScript);
                }
                catch (err) {
                  err.message = "In " + path + ", " + err.message;
                  throw(err);
                }

                //Hold on to the transformed text if a build.
                if (config.isBuild) {
                    buildMap[name] = text;
                }

                //IE with conditional comments on cannot handle the
                //sourceURL trick, so skip it if enabled.
                /*@if (@_jscript) @else @*/
                if (!config.isBuild) {
                    text += "\r\n//@ sourceURL=" + path;
                }
                /*@end@*/

                load.fromText(name, text);

                //Give result to load. Need to wait until the module
                //is fully parse, which will happen after this
                //execution.
                parentRequire([name], function (value) {
                    load(value);
                });
            });
        }
    };
});

/*global define: false */
define('md2d/models/aminoacids-props',[],function() {
  return [
    {
      "fullName": "Alanine",
      "abbreviation": "Ala",
      "symbol": "A",
      "molWeight": 89.09,
      "charge": 0,
      "hydrophobicityRB": 2.15,
      "pK": 0,
      "surface": 115,
      "volume": 88.6,
      "solubility": 16.65,
      "hydrophobicity": 1,
      "property": "Total aliphatic; hydrophobic"
    },
    {
      "fullName": "Arginine",
      "abbreviation": "Arg",
      "symbol": "R",
      "molWeight": 174.2,
      "charge": 1,
      "hydrophobicityRB": 2.23,
      "pK": 12,
      "surface": 225,
      "volume": 173.4,
      "solubility": 15,
      "hydrophobicity": -2,
      "property": "Acidic side chains; strongly polar; cationic"
    },
    {
      "fullName": "Asparagine",
      "abbreviation": "Asn",
      "symbol": "N",
      "molWeight": 132.12,
      "charge": 0,
      "hydrophobicityRB": 1.05,
      "pK": 0,
      "surface": 160,
      "volume": 114.1,
      "solubility": 3.53,
      "hydrophobicity": -1,
      "property": "Strongly polar"
    },
    {
      "fullName": "Asparticacid",
      "abbreviation": "Asp",
      "symbol": "D",
      "molWeight": 133.1,
      "charge": -1,
      "hydrophobicityRB": 1.13,
      "pK": 4.4,
      "surface": 150,
      "volume": 111.1,
      "solubility": 0.778,
      "hydrophobicity": -2,
      "property": "Acidic side chains; strongly polar; anionic"
    },
    {
      "fullName": "Cysteine",
      "abbreviation": "Cys",
      "symbol": "C",
      "molWeight": 121.15,
      "charge": 0,
      "hydrophobicityRB": 1.2,
      "pK": 8.5,
      "surface": 135,
      "volume": 108.5,
      "solubility": 1000,
      "hydrophobicity": 1,
      "property": "Polar side chains; semipolar"
    },
    {
      "fullName": "Glutamine",
      "abbreviation": "Gln",
      "symbol": "Q",
      "molWeight": 146.15,
      "charge": 0,
      "hydrophobicityRB": 1.65,
      "pK": 0,
      "surface": 180,
      "volume": 143.8,
      "solubility": 2.5,
      "hydrophobicity": -1,
      "property": "Strongly polar"
    },
    {
      "fullName": "Glutamicacid",
      "abbreviation": "Glu",
      "symbol": "E",
      "molWeight": 147.13,
      "charge": -1,
      "hydrophobicityRB": 1.73,
      "pK": 4.4,
      "surface": 190,
      "volume": 138.4,
      "solubility": 0.864,
      "hydrophobicity": -2,
      "property": "Acidic side chains; strongly polar; anionic"
    },
    {
      "fullName": "Glycine",
      "abbreviation": "Gly",
      "symbol": "G",
      "molWeight": 75.07,
      "charge": 0,
      "hydrophobicityRB": 1.18,
      "pK": 0,
      "surface": 75,
      "volume": 60.1,
      "solubility": 24.99,
      "hydrophobicity": 1,
      "property": "Semipolar"
    },
    {
      "fullName": "Histidine",
      "abbreviation": "His",
      "symbol": "H",
      "molWeight": 155.16,
      "charge": 1,
      "hydrophobicityRB": 2.45,
      "pK": 6.5,
      "surface": 195,
      "volume": 153.2,
      "solubility": 4.19,
      "hydrophobicity": -2,
      "property": "Basic side chains; strongly polar; cationic"
    },
    {
      "fullName": "Isoleucine",
      "abbreviation": "Ile",
      "symbol": "I",
      "molWeight": 131.17,
      "charge": 0,
      "hydrophobicityRB": 3.88,
      "pK": 0,
      "surface": 175,
      "volume": 166.7,
      "solubility": 4.117,
      "hydrophobicity": 1,
      "property": "Branched chain aliphatic; hydrophobic"
    },
    {
      "fullName": "Leucine",
      "abbreviation": "Leu",
      "symbol": "L",
      "molWeight": 131.17,
      "charge": 0,
      "hydrophobicityRB": 4.1,
      "pK": 10,
      "surface": 170,
      "volume": 166.7,
      "solubility": 2.426,
      "hydrophobicity": 1,
      "property": "Branched chain aliphatic; hydrophobic"
    },
    {
      "fullName": "Lysine",
      "abbreviation": "Lys",
      "symbol": "K",
      "molWeight": 146.19,
      "charge": 1,
      "hydrophobicityRB": 3.05,
      "pK": 0,
      "surface": 200,
      "volume": 168.6,
      "solubility": 1000,
      "hydrophobicity": -2,
      "property": "Acidic side chains; strongly polar; cationic"
    },
    {
      "fullName": "Methionine",
      "abbreviation": "Met",
      "symbol": "M",
      "molWeight": 149.21,
      "charge": 0,
      "hydrophobicityRB": 3.43,
      "pK": 0,
      "surface": 185,
      "volume": 162.9,
      "solubility": 3.81,
      "hydrophobicity": 1,
      "property": "Totally alyphatic"
    },
    {
      "fullName": "Phenylalanine",
      "abbreviation": "Phe",
      "symbol": "F",
      "molWeight": 165.19,
      "charge": 0,
      "hydrophobicityRB": 3.46,
      "pK": 0,
      "surface": 210,
      "volume": 189.9,
      "solubility": 2.965,
      "hydrophobicity": 2,
      "property": "Totally aromatic"
    },
    {
      "fullName": "Proline",
      "abbreviation": "Pro",
      "symbol": "P",
      "molWeight": 115.13,
      "charge": 0,
      "hydrophobicityRB": 3.1,
      "pK": 0,
      "surface": 145,
      "volume": 112.7,
      "solubility": 162.3,
      "hydrophobicity": 1,
      "property": "Totally alyphatic"
    },
    {
      "fullName": "Serine",
      "abbreviation": "Ser",
      "symbol": "S",
      "molWeight": 105.09,
      "charge": 0,
      "hydrophobicityRB": 1.4,
      "pK": 0,
      "surface": 115,
      "volume": 89,
      "solubility": 5.023,
      "hydrophobicity": -1,
      "property": "Semipolar"
    },
    {
      "fullName": "Threonine",
      "abbreviation": "Thr",
      "symbol": "T",
      "molWeight": 119.12,
      "charge": 0,
      "hydrophobicityRB": 2.25,
      "pK": 0,
      "surface": 140,
      "volume": 116.1,
      "solubility": 1000,
      "hydrophobicity": -1,
      "property": "Semipolar"
    },
    {
      "fullName": "Tryptophan",
      "abbreviation": "Trp",
      "symbol": "W",
      "molWeight": 204.23,
      "charge": 0,
      "hydrophobicityRB": 4.11,
      "pK": 0,
      "surface": 255,
      "volume": 227.8,
      "solubility": 1.136,
      "hydrophobicity": 2,
      "property": "Totally aromatic"
    },
    {
      "fullName": "Tyrosine",
      "abbreviation": "Tyr",
      "symbol": "Y",
      "molWeight": 181.19,
      "charge": 0,
      "hydrophobicityRB": 2.81,
      "pK": 10,
      "surface": 230,
      "volume": 193.6,
      "solubility": 0.045,
      "hydrophobicity": 1,
      "property": "Hydrophobic; total aromatic"
    },
    {
      "fullName": "Valine",
      "abbreviation": "Val",
      "symbol": "V",
      "molWeight": 117.15,
      "charge": 0,
      "hydrophobicityRB": 3.38,
      "pK": 0,
      "surface": 155,
      "volume": 140,
      "solubility": 8.85,
      "hydrophobicity": 1,
      "property": "Branched chain aliphatic; hydrophobic"
    }
  ];
});


/*
Module which provides convenience functions related to amino acids.
*/


(function() {

  define('cs!md2d/models/aminoacids-helper',['require','md2d/models/aminoacids-props'],function(require) {
    var FIST_ELEMENT_ID, RNA_CODON_TABLE, aminoacidsProps;
    aminoacidsProps = require('md2d/models/aminoacids-props');
    FIST_ELEMENT_ID = 5;
    RNA_CODON_TABLE = {
      "UUU": "Phe",
      "UUC": "Phe",
      "UUA": "Leu",
      "UUG": "Leu",
      "CUU": "Leu",
      "CUC": "Leu",
      "CUA": "Leu",
      "CUG": "Leu",
      "AUU": "Ile",
      "AUC": "Ile",
      "AUA": "Ile",
      "AUG": "Met",
      "GUU": "Val",
      "GUC": "Val",
      "GUA": "Val",
      "GUG": "Val",
      "UCU": "Ser",
      "UCC": "Ser",
      "UCA": "Ser",
      "UCG": "Ser",
      "AGU": "Ser",
      "AGC": "Ser",
      "CCU": "Pro",
      "CCC": "Pro",
      "CCA": "Pro",
      "CCG": "Pro",
      "ACU": "Thr",
      "ACC": "Thr",
      "ACA": "Thr",
      "ACG": "Thr",
      "GCU": "Ala",
      "GCC": "Ala",
      "GCA": "Ala",
      "GCG": "Ala",
      "UAU": "Tyr",
      "UAC": "Tyr",
      "CAU": "His",
      "CAC": "His",
      "CAA": "Gln",
      "CAG": "Gln",
      "AAU": "Asn",
      "AAC": "Asn",
      "AAA": "Lys",
      "AAG": "Lys",
      "GAU": "Asp",
      "GAC": "Asp",
      "GAA": "Glu",
      "GAG": "Glu",
      "UGU": "Cys",
      "UGC": "Cys",
      "UGG": "Trp",
      "CGU": "Arg",
      "CGC": "Arg",
      "CGA": "Arg",
      "CGG": "Arg",
      "AGA": "Arg",
      "AGG": "Arg",
      "GGU": "Gly",
      "GGC": "Gly",
      "GGA": "Gly",
      "GGG": "Gly",
      "UAA": "STOP",
      "UAG": "STOP",
      "UGA": "STOP"
    };
    return {
      /*
        ID of an element representing the first amino acid in the elements collection.
      */

      firstElementID: FIST_ELEMENT_ID,
      /*
        ID of an element representing the last amino acid in the elements collection.
      */

      lastElementID: FIST_ELEMENT_ID + aminoacidsProps.length - 1,
      /*
        Element ID of the cysteine amino acid.
        Note that it should be stored in this class (instead of hard-coded in the engine),
        as it can be changed in the future.
      */

      cysteineElement: 9,
      /*
        Converts @abbreviation of amino acid to element ID.
      */

      abbrToElement: function(abbreviation) {
        var aminoacid, i, _i, _len;
        for (i = _i = 0, _len = aminoacidsProps.length; _i < _len; i = ++_i) {
          aminoacid = aminoacidsProps[i];
          if (aminoacid.abbreviation === abbreviation) {
            return i + this.firstElementID;
          }
        }
      },
      /*
        Returns properties (hash) of amino acid which is represented by a given @elementID.
      */

      getAminoAcidByElement: function(elementID) {
        return aminoacidsProps[elementID - this.firstElementID];
      },
      /*
        Checks if given @elementID represents amino acid.
      */

      isAminoAcid: function(elementID) {
        return elementID >= this.firstElementID && elementID <= this.lastElementID;
      },
      /*
        Returns polar amino acids (array of their element IDs).
      */

      getPolarAminoAcids: function() {
        var abbr, _i, _len, _ref, _results;
        _ref = ["Asn", "Gln", "Ser", "Thr"];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          abbr = _ref[_i];
          _results.push(this.abbrToElement(abbr));
        }
        return _results;
      },
      /*
        Converts RNA Codon to amino acid abbreviation
      */

      codonToAbbr: function(codon) {
        if (codon.length !== 3) {
          return "STOP";
        } else {
          return RNA_CODON_TABLE[codon];
        }
      }
    };
  });

}).call(this);

/*global define: true */
/*jslint eqnull: true */

// Simple (Box-Muller) univariate-normal random number generator.
//
// The 'science.js' library includes a Box-Muller implementation which is likely to be slower, especially in a
// modern Javascript engine, because it uses a rejection method to pick the random point in the unit circle.
// See discussion on pp. 1-3 of:
// http://www.math.nyu.edu/faculty/goodman/teaching/MonteCarlo2005/notes/GaussianSampling.pdf
//

// Module can be used both in Node.js environment and in Web browser
// using RequireJS. RequireJS Optimizer will strip out this if statement.


define('md2d/models/engine/math/distributions',['require','exports','module'],function (require, exports, module) {

  exports.normal = (function() {
    var next = null;

    return function(mean, sd) {
      if (mean == null) mean = 0;
      if (sd == null)   sd = 1;

      var r, ret, theta, u1, u2;

      if (next) {
        ret  = next;
        next = null;
        return ret;
      }

      u1    = Math.random();
      u2    = Math.random();
      theta = 2 * Math.PI * u1;
      r     = Math.sqrt(-2 * Math.log(u2));

      next = mean + sd * (r * Math.sin(theta));
      return mean + sd * (r * Math.cos(theta));
    };
  }());
});

/*global define: true */
/*jslint eqnull: true */
/**
  Returns a function which accepts a single numeric argument and returns:

   * the arithmetic mean of the windowSize most recent inputs, including the current input
   * NaN if there have not been windowSize inputs yet.

  The default windowSize is 1000.

*/

// Module can be used both in Node.js environment and in Web browser
// using RequireJS. RequireJS Optimizer will strip out this if statement.


define('md2d/models/engine/math/utils',['require','exports','module'],function (require, exports, module) {

  exports.getWindowedAverager = function(windowSize) {

    if (windowSize == null) windowSize = 1000;      // default window size

    var i = 0,
        vals = [],
        sum_vals = 0;

    return function(val) {
      sum_vals -= (vals[i] || 0);
      sum_vals += val;
      vals[i] = val;

      if (++i === windowSize) i = 0;

      if (vals.length === windowSize) {
        return sum_vals / windowSize;
      }
      else {
        // don't allow any numerical comparisons with result to be true
        return NaN;
      }
    };
  };
});

/*global define: true */
/*jshint eqnull:true */
/**
  Simple, good-enough minimization via gradient descent.
*/

// Module can be used both in Node.js environment and in Web browser
// using RequireJS. RequireJS Optimizer will strip out this if statement.


define('md2d/models/engine/math/minimizer',['require','exports','module','common/console'],function (require, exports, module) {
  // Dependencies.
  var console = require('common/console');

  exports.minimize = function(f, x0, opts) {
    opts = opts || {};

    if (opts.precision == null) opts.precision = 0.01;

    var // stop when the absolute difference between successive values of f is this much or less
        precision = opts.precision,

        // array of [min, max] boundaries for each component of x
        bounds    = opts.bounds,

        // maximum number of iterations
        maxiter   = opts.maxiter   || 1000,

        // optionally, stop when f is less than or equal to this value
        stopval   = opts.stopval   || -Infinity,

        // maximum distance to move x between steps
        maxstep   = opts.maxstep   || 0.01,

        // multiplied by the gradient
        eps       = opts.eps       || 0.01,
        dim       = x0.length,
        x,
        res,
        f_cur,
        f_prev,
        grad,
        maxstepsq,
        gradnormsq,
        iter,
        i,
        a;

    maxstepsq = maxstep*maxstep;

    // copy x0 into x (which we will mutate)
    x = [];
    for (i = 0; i < dim; i++) {
      x[i] = x0[i];
    }

    // evaluate f and get the gradient
    res = f.apply(null, x);
    f_cur = res[0];
    grad = res[1];

    iter = 0;
    do {
      if (f_cur <= stopval) {
        break;
      }

      if (iter > maxiter) {
        console.log("maxiter reached");
        // don't throw on error, but return some diagnostic information
        return { error: "maxiter reached", f: f_cur, iter: maxiter, x: x };
      }

      // Limit gradient descent step size to maxstep
      gradnormsq = 0;
      for (i = 0; i < dim; i++) {
        gradnormsq += grad[i]*grad[i];
      }
      if (eps*eps*gradnormsq > maxstepsq) {
        a = Math.sqrt(maxstepsq / gradnormsq) / eps;
        for (i = 0; i < dim; i++) {
          grad[i] = a * grad[i];
        }
      }

      // Take a step in the direction opposite the gradient
      for (i = 0; i < dim; i++) {
        x[i] -= eps * grad[i];

        // check bounds
        if (bounds && x[i] < bounds[i][0]) {
          x[i] = bounds[i][0];
        }
        if (bounds && x[i] > bounds[i][1]) {
          x[i] = bounds[i][1];
        }
      }

      f_prev = f_cur;

      res = f.apply(null, x);
      f_cur = res[0];
      grad = res[1];

      iter++;
    } while ( Math.abs(f_cur-f_prev) > precision );

    return [f_cur, x];
  };
});

/*global define: true */

// Module can be used both in Node.js environment and in Web browser
// using RequireJS. RequireJS Optimizer will strip out this if statement.


define('md2d/models/engine/math/index',['require','exports','module','./distributions','./utils','./minimizer'],function (require, exports, module) {
  exports.normal              = require('./distributions').normal;
  exports.getWindowedAverager = require('./utils').getWindowedAverager;
  exports.minimize            = require('./minimizer').minimize;
});

/*global define: true */

// Module can be used both in Node.js environment and in Web browser
// using RequireJS. RequireJS Optimizer will strip out this if statement.


define('md2d/models/engine/potentials/coulomb',['require','exports','module','../constants/index'],function (require, exports, module) {

  var
  constants = require('../constants/index'),
  unit      = constants.unit,

  // Classic MW uses a value for Coulomb's constant that is effectively 0.346 of the real value
  CLASSIC_MW_FUDGE_FACTOR = 0.346,

  COULOMB_CONSTANT_IN_METERS_PER_FARAD = constants.COULOMB_CONSTANT.as( constants.unit.METERS_PER_FARAD ),

  NANOMETERS_PER_METER = constants.ratio(unit.NANOMETER, { per: unit.METER }),
  COULOMBS_SQ_PER_ELEMENTARY_CHARGE_SQ = Math.pow( constants.ratio(unit.COULOMB, { per: unit.ELEMENTARY_CHARGE }), 2),

  EV_PER_JOULE = constants.ratio(unit.EV, { per: unit.JOULE }),
  MW_FORCE_UNITS_PER_NEWTON = constants.ratio(unit.MW_FORCE_UNIT, { per: unit.NEWTON }),

  // Coulomb constant for expressing potential in eV given elementary charges, nanometers
  k_ePotential = CLASSIC_MW_FUDGE_FACTOR *
                 COULOMB_CONSTANT_IN_METERS_PER_FARAD *
                 COULOMBS_SQ_PER_ELEMENTARY_CHARGE_SQ *
                 NANOMETERS_PER_METER *
                 EV_PER_JOULE,

  // Coulomb constant for expressing force in Dalton*nm/fs^2 given elementary charges, nanometers
  k_eForce = CLASSIC_MW_FUDGE_FACTOR *
             COULOMB_CONSTANT_IN_METERS_PER_FARAD *
             COULOMBS_SQ_PER_ELEMENTARY_CHARGE_SQ *
             NANOMETERS_PER_METER *
             NANOMETERS_PER_METER *
             MW_FORCE_UNITS_PER_NEWTON,

  // Exports

  /** Input:
       r: distance in nanometers,
       q1, q2: elementary charges,
       dC: dielectric constant, unitless,
       rDE: realistic dielectric effect switch, boolean.

      Output units: eV
  */
  potential = exports.potential = function(r, q1, q2, dC, rDE) {
    if (rDE && dC > 1 && r < 1.2) {
      // "Realistic Dielectric Effect" mode:
      // Diminish dielectric constant value using distance between particles.
      // Function based on: http://en.wikipedia.org/wiki/Generalized_logistic_curve
      // See plot for dC = 80: http://goo.gl/7zU6a
      // For optimization purposes it returns asymptotic value when r > 1.2.
      dC = 1 + (dC - 1)/(1 + Math.exp(-12 * r + 7));
    }
    return k_ePotential * ((q1 * q2) / r) / dC;
  },


  /** Input:
       rSq: squared distance in nanometers^2,
       q1, q2: elementary charges,
       dC: dielectric constant, unitless,
       rDE: realistic dielectric effect switch, boolean.

      Output units: "MW Force Units" (Dalton * nm / fs^2)
  */
  forceFromSquaredDistance = exports.forceFromSquaredDistance = function(rSq, q1, q2, dC, rDE) {
    var r = Math.sqrt(rSq);
    if (rDE && dC > 1 && r < 1.2) {
      // "Realistic Dielectric Effect" mode:
      // Diminish dielectric constant value using distance between particles.
      // Function based on: http://en.wikipedia.org/wiki/Generalized_logistic_curve
      // See plot for dC = 80: http://goo.gl/7zU6a
      // For optimization purposes it returns asymptotic value when r > 1.2.
      dC = 1 + (dC - 1)/(1 + Math.exp(-12 * r + 7));
    }
    return -k_eForce * ((q1 * q2) / rSq) / dC;
  },


  forceOverDistanceFromSquaredDistance = exports.forceOverDistanceFromSquaredDistance = function(rSq, q1, q2, dC, rDE) {
    return forceFromSquaredDistance(rSq, q1, q2, dC, rDE) / Math.sqrt(rSq);
  },

  /** Input:
       r: distance in nanometers,
       q1, q2: elementary charges,
       dC: dielectric constant, unitless,
       rDE: realistic dielectric effect switch, boolean.

      Output units: "MW Force Units" (Dalton * nm / fs^2)
  */
  force = exports.force = function(r, q1, q2, dC, rDE) {
    return forceFromSquaredDistance(r*r, q1, q2, dC, rDE);
  };
});

/*global define: true */
/*jshint eqnull:true boss:true */

// Module can be used both in Node.js environment and in Web browser
// using RequireJS. RequireJS Optimizer will strip out this if statement.


define('md2d/models/engine/potentials/lennard-jones',['require','exports','module','../constants/index'],function (require, exports, module) {

  var constants = require('../constants/index'),
      unit      = constants.unit,

      NANOMETERS_PER_METER = constants.ratio( unit.NANOMETER, { per: unit.METER }),
      MW_FORCE_UNITS_PER_NEWTON = constants.ratio( unit.MW_FORCE_UNIT, { per: unit.NEWTON });

  /**
    Helper function that returns the correct pairwise epsilon value to be used
    when elements each have epsilon values epsilon1, epsilon2
  */
  exports.pairwiseEpsilon = function(epsilon1, epsilon2) {
    return 0.5 * (epsilon1 + epsilon2);
  },

  /**
    Helper function that returns the correct pairwise sigma value to be used
    when elements each have sigma values sigma1, sigma2
  */
  exports.pairwiseSigma = function(sigma1, sigma2) {
    return Math.sqrt(sigma1 * sigma2);
  },

  /**
    Helper function that returns the correct rmin value for a given sigma
  */
  exports.rmin = function(sigma) {
    return Math.pow(2, 1/6) * sigma;
  };

  /**
    Helper function that returns the correct atomic radius for a given sigma
  */
  exports.radius = function(sigma) {
    // See line 637 of Atom.java (org.concord.mw2d.models.Atom)
    // This assumes the "VdW percentage" is 100%. In classic MW the VdW percentage is settable.
    return 0.5 * sigma;
  };

  /**
    Returns a new object with methods for calculating the force and potential for a Lennard-Jones
    potential with particular values of its parameters epsilon and sigma. These can be adjusted.

    To avoid the needing to take square roots during calculation of pairwise forces, there are
    also methods which calculate the inter-particle potential directly from a squared distance, and
    which calculate the quantity (force/distance) directly from a squared distance.

    This function also accepts a callback function which will be called with a hash representing
    the new coefficients, whenever the LJ coefficients are changed for the returned calculator.
  */
  exports.newLJCalculator = function(params, cb) {

    var epsilon,          // parameter; depth of the potential well, in eV
        sigma,            // parameter: characteristic distance from particle, in nm

        rmin,             // distance from particle at which the potential is at its minimum
        alpha_Potential,  // precalculated; units are eV * nm^12
        beta_Potential,   // precalculated; units are eV * nm^6
        alpha_Force,      // units are "MW Force Units" * nm^13
        beta_Force,       // units are "MW Force Units" * nm^7

        initialized = false, // skip callback during initialization

        setCoefficients = function(e, s) {
          // Input units:
          //  epsilon: eV
          //  sigma:   nm

          epsilon = e;
          sigma   = s;
          rmin    = exports.rmin(sigma);

          if (epsilon != null && sigma != null) {
            alpha_Potential = 4 * epsilon * Math.pow(sigma, 12);
            beta_Potential  = 4 * epsilon * Math.pow(sigma, 6);

            // (1 J * nm^12) = (1 N * m * nm^12)
            // (1 N * m * nm^12) * (b nm / m) * (c MWUnits / N) = (abc MWUnits nm^13)
            alpha_Force = 12 * constants.convert(alpha_Potential, { from: unit.EV, to: unit.JOULE }) * NANOMETERS_PER_METER * MW_FORCE_UNITS_PER_NEWTON;
            beta_Force =  6 * constants.convert(beta_Potential,  { from: unit.EV, to: unit.JOULE }) * NANOMETERS_PER_METER * MW_FORCE_UNITS_PER_NEWTON;
          }

          if (initialized && typeof cb === 'function') cb(getCoefficients(), this);
        },

        getCoefficients = function() {
          return {
            epsilon: epsilon,
            sigma  : sigma,
            rmin   : rmin
          };
        },

        validateEpsilon = function(e) {
          if (e == null || parseFloat(e) !== e) {
            throw new Error("lennardJones: epsilon value " + e + " is invalid");
          }
        },

        validateSigma = function(s) {
          if (s == null || parseFloat(s) !== s || s <= 0) {
            throw new Error("lennardJones: sigma value " + s + " is invalid");
          }
        },

        // this object
        calculator;

        // At creation time, there must be a valid epsilon and sigma ... we're not gonna check during
        // inner-loop force calculations!
        validateEpsilon(params.epsilon);
        validateSigma(params.sigma);

        // Initialize coefficients to passed-in values, skipping setCoefficients callback
        setCoefficients(params.epsilon, params.sigma);
        initialized = true;

    return calculator = {

      getCoefficients: getCoefficients,

      setEpsilon: function(e) {
        validateEpsilon(e);
        setCoefficients(e, sigma);
      },

      setSigma: function(s) {
        validateSigma(s);
        setCoefficients(epsilon, s);
      },

      /**
        Input units: r_sq: nm^2
        Output units: eV

        minimum is at r=rmin, V(rmin) = 0
      */
      potentialFromSquaredDistance: function(r_sq) {
        if (!r_sq) return -Infinity;
        return alpha_Potential*Math.pow(r_sq, -6) - beta_Potential*Math.pow(r_sq, -3);
      },

      /**
        Input units: r: nm
        Output units: eV
      */
      potential: function(r) {
        return calculator.potentialFromSquaredDistance(r*r);
      },

      /**
        Input units: r_sq: nm^2
        Output units: MW Force Units / nm (= Dalton / fs^2)
      */
      forceOverDistanceFromSquaredDistance: function(r_sq) {
        // optimizing divisions actually does appear to be *slightly* faster
        var r_minus2nd  = 1 / r_sq,
            r_minus6th  = r_minus2nd * r_minus2nd * r_minus2nd,
            r_minus8th  = r_minus6th * r_minus2nd,
            r_minus14th = r_minus8th * r_minus6th;

        return alpha_Force*r_minus14th - beta_Force*r_minus8th;
      },

      /**
        Input units: r: nm
        Output units: MW Force Units (= Dalton * nm / fs^2)
      */
      force: function(r) {
        return r * calculator.forceOverDistanceFromSquaredDistance(r*r);
      }
    };
  };
});

/*global define: true */

// Module can be used both in Node.js environment and in Web browser
// using RequireJS. RequireJS Optimizer will strip out this if statement.


define('md2d/models/engine/potentials/index',['require','exports','module','./coulomb','./lennard-jones'],function (require, exports, module) {
  exports.coulomb = require('./coulomb');
  exports.lennardJones = require('./lennard-jones');
});

/*global define: false */

define('md2d/models/metadata',[],function() {

  return {
    mainProperties: {
      type: {
        defaultValue: "md2d",
        immutable: true
      },
      imagePath: {
        defaultValue: "",
        immutable: true
      },
      minX: {
        serialize: false
      },
      maxX: {
        serialize: false
      },
      minY: {
        serialize: false
      },
      maxY: {
        serialize: false
      },
      width: {
        defaultValue: 10,
        unitType: "length",
        immutable: true
      },
      height: {
        defaultValue: 10,
        unitType: "length",
        immutable: true
      },
      unitsScheme: {
        defaultValue: "md2d"
      },
      lennardJonesForces: {
        defaultValue: true,
        storeInTickHistory: true
      },
      coulombForces: {
        defaultValue: true,
        storeInTickHistory: true
      },
      temperatureControl: {
        defaultValue: false,
        storeInTickHistory: true
      },
      targetTemperature: {
        defaultValue: 300,
        unitType: "temperature",
        storeInTickHistory: true
      },
      modelSampleRate: {
        defaultValue: "default"
      },
      gravitationalField: {
        defaultValue: false,
        unitType: "acceleration",
        storeInTickHistory: true
      },
      timeStep: {
        defaultValue: 1,
        unitType: "time",
        storeInTickHistory: true
      },
      dielectricConstant: {
        defaultValue: 1
      },
      realisticDielectricEffect: {
        defaultValue: true
      },
      solventForceFactor: {
        defaultValue: 1.25
      },
      solventForceType: {
        //  0 - vacuum.
        //  1 - water.
        // -1 - oil.
        defaultValue: 0
      },
      // Additional force applied to amino acids that depends on distance from the center of mass. It affects
      // only AAs which are pulled into the center of mass (to stabilize shape of the protein).
      // 'additionalSolventForceMult'      - maximum multiplier applied to solvent force when AA is in the center of mass.
      // 'additionalSolventForceThreshold' - maximum distance from the center of mass which triggers this increase of the force.
      // The additional force is described by the linear function of the AA distance from the center of mass
      // that passes through two points:
      // (0, additionalSolventForceMult) and (additionalSolventForceThreshold, 1).
      additionalSolventForceMult: {
        defaultValue: 4
      },
      additionalSolventForceThreshold: {
        defaultValue: 10,
        unitType: "length"
      },
      polarAAEpsilon: {
        defaultValue: -2
      },
      viscosity: {
        defaultValue: 1,
        storeInTickHistory: true
      },
      timeStepsPerTick: {
        defaultValue: 50,
        storeInTickHistory: true
      },
      DNAState: {
        defaultValue: "dna"
      },
      DNA: {
        defaultValue: "",
        validate: function (value) {
          if (/[agtc]/.test(value)) {
            value = value.toUpperCase();
          }
          if (/[^AGTC]/.test(value)) {
            throw new Error("DNA code on sense strand can be defined using only A, G, T or C characters.");
          }
          return value;
        }
      },
      DNAMutations: {
        defaultValue: true
      },
      useQuantumDynamics: {
        default: false,
        serialize: false
      }
    },

    viewOptions: {
      viewPortWidth: {
        unitType: "length",
        immutable: true
      },
      viewPortHeight: {
        unitType: "length",
        immutable: true
      },
      viewPortZoom: {
        defaultValue: 1
      },
      viewPortX: {
        unitType: "length"
      },
      viewPortY: {
        unitType: "length"
      },
      viewPortDrag: {
        // Supported values:
        // - true  -> dragging is enabled.
        // - "x"   -> dragging is limited only to X axis.
        // - "y"   -> dragging is limited only yo Y axis.
        // - false -> dragging is disabled.
        defaultValue: false
      },
      backgroundColor: {
        defaultValue: "#eeeeee"
      },
      showClock: {
        defaultValue: true,
        storeInTickHistory: true
      },
      markColor: {
        defaultValue: "#f8b500"
      },
      keShading: {
        defaultValue: false,
        storeInTickHistory: true
      },
      chargeShading: {
        defaultValue: false,
        storeInTickHistory: true
      },
      useThreeLetterCode: {
        defaultValue: true
      },
      aminoAcidColorScheme: {
        defaultValue: "hydrophobicity"
      },
      showChargeSymbols: {
        defaultValue: true
      },
      showVDWLines: {
        defaultValue: false,
        storeInTickHistory: true
      },
      VDWLinesCutoff: {
        defaultValue: "medium"
      },
      showVelocityVectors: {
        defaultValue: false,
        storeInTickHistory: true
      },
      showForceVectors: {
        defaultValue: false,
        storeInTickHistory: true
      },
      electricFieldDensity: {
        defaultValue: 0,
        storeInTickHistory: true
      },
      showAtomTrace: {
        defaultValue: false
      },
      atomTraceId: {
        defaultValue: 0
      },
      images: {
        defaultValue: []
      },
      imageMapping: {
        defaultValue: {}
      },
      textBoxes: {
        defaultValue: []
      },
      xlabel: {
        defaultValue: false
      },
      ylabel: {
        defaultValue: false
      },
      xunits: {
        defaultValue: false
      },
      yunits: {
        defaultValue: false
      },
      controlButtons: {
        defaultValue: "play"
      },
      gridLines: {
        defaultValue: false
      },
      atomNumbers: {
        defaultValue: false
      },
      enableAtomTooltips: {
        defaultValue: false
      },
      enableKeyboardHandlers: {
        defaultValue: true
      },
      atomTraceColor: {
        defaultValue: "#6913c5"
      },
      velocityVectors: {
        defaultValue: {
          color: "#000",
          width: 0.01,
          length: 2
        }
      },
      forceVectors: {
        defaultValue: {
          color: "#169C30",
          width: 0.01,
          length: 2
        }
      }
    },

    atom: {
      // Required properties:
      x: {
        required: true,
        unitType: "length"
      },
      y: {
        required: true,
        unitType: "length"
      },
      // Optional properties:
      element: {
        defaultValue: 0
      },
      vx: {
        defaultValue: 0,
        unitType: "velocity"
      },
      vy: {
        defaultValue: 0,
        unitType: "velocity"
      },
      ax: {
        defaultValue: 0,
        unitType: "acceleration",
        serialize: false
      },
      ay: {
        defaultValue: 0,
        unitType: "acceleration",
        serialize: false
      },
      charge: {
        defaultValue: 0,
        unitType: "charge"
      },
      friction: {
        defaultValue: 0,
        unitType: "dampingCoefficient"
      },
      visible: {
        defaultValue: 1
      },
      pinned: {
        defaultValue: 0
      },
      marked: {
        defaultValue: 0
      },
      draggable: {
        defaultValue: 0
      },
      // Read-only values, can be set only by engine:
      radius: {
        readOnly: true,
        unitType: "length",
        serialize: false
      },
      px: {
        readOnly: true,
        unitType: "momentum",
        serialize: false
      },
      py: {
        readOnly: true,
        unitType: "momentum",
        serialize: false
      },
      speed: {
        readOnly: true,
        unitType: "velocity",
        serialize: false
      },
      mass: {
        // Mass is defined per element, but this is a convenience shortcut for
        // quick access to mass of the given atom.
        readOnly: true,
        unitType: "mass",
        serialize: false
      },
      excitation: {
      }
    },

    element: {
      mass: {
        defaultValue: 120,
        unitType: "mass"
      },
      sigma: {
        defaultValue: 0.3,
        unitType: "length"
      },
      epsilon: {
        defaultValue: -0.1,
        unitType: "energy"
      },
      radius: {
        unitType: "length",
        readOnly: true,
        serialize: false
      },
      color: {
        defaultValue: -855310
      }
    },

    pairwiseLJProperties: {
      element1: {
        defaultValue: 0
      },
      element2: {
        defaultValue: 0
      },
      sigma: {
        unitType: "length"
      },
      epsilon: {
        unitType: "energy"
      }
    },

    obstacle: {
      // Required properties:
      width: {
        unitType: "length",
        required: true
      },
      height: {
        unitType: "length",
        required: true
      },
      // Optional properties:
      x: {
        defaultValue: 0,
        unitType: "length"
      },
      y: {
        defaultValue: 0,
        unitType: "length"
      },
      mass: {
        defaultValue: Infinity,
        unitType: "mass"
      },
      vx: {
        defaultValue: 0,
        unitType: "velocity"
      },
      vy: {
        defaultValue: 0,
        unitType: "velocity"
      },
      // Externally applied horizontal acceleration
      externalAx: {
        defaultValue: 0,
        unitType: "acceleration"
      },
      // Externally applied vertical acceleration
      externalAy: {
        defaultValue: 0,
        unitType: "accleration"
      },
      // Damping coefficient per mass unit (= acceleration / velocity = 1 / time)
      friction: {
        defaultValue: 0,
        unitType: "inverseTime"
      },
      // Pressure probe, west side.
      westProbe: {
        defaultValue: false
      },
      // Final value of pressure in Bars.
      westProbeValue: {
        unitType: "pressure",
        readOnly: true,
        serialize: false
      },
      // Pressure probe, north side.
      northProbe: {
        defaultValue: false
      },
      // Final value of pressure in Bars.
      northProbeValue: {
        unitType: "pressure",
        readOnly: true,
        serialize: false
      },
      // Pressure probe, east side.
      eastProbe: {
        defaultValue: false
      },
      // Final value of pressure in Bars.
      eastProbeValue: {
        unitType: "pressure",
        readOnly: true,
        serialize: false
      },
      // Pressure probe, south side.
      southProbe: {
        defaultValue: false
      },
      // Final value of pressure in Bars.
      southProbeValue: {
        unitType: "pressure",
        readOnly: true,
        serialize: false
      },
      // View options.
      colorR: {
        defaultValue: 128
      },
      colorG: {
        defaultValue: 128
      },
      colorB: {
        defaultValue: 128
      },
      visible: {
        defaultValue: true
      }
    },

    rectangle: {
      // Required properties:
      width: {
        unitType: "length",
        required: true
      },
      height: {
        unitType: "length",
        required: true
      },
      // Optional properties:
      x: {
        defaultValue: 0,
        unitType: "length"
      },
      y: {
        defaultValue: 0,
        unitType: "length"
      },
      fence: {
        defaultValue: false,
      },
      // View options.
      color: {
        defaultValue: "transparent"
      },
      lineColor: {
        defaultValue: "black"
      },
      lineDashes: {
        defaultValue: "none"
      },
      lineWeight: {
        defaultValue: 1
      },
      layer: {
        defaultValue: 1
      },
      visible: {
        defaultValue: true
      }
    },

    radialBond: {
      atom1: {
        defaultValue: 0
      },
      atom2: {
        defaultValue: 0
      },
      length: {
        unitType: "length",
        required: true
      },
      strength: {
        unitType: "stiffness",
        required: true
      },
      type: {
        defaultValue: 101
      }
    },

    angularBond: {
      atom1: {
        defaultValue: 0
      },
      atom2: {
        defaultValue: 0
      },
      atom3: {
        defaultValue: 0
      },
      strength: {
        unitType: "rotationalStiffness",
        required: true
      },
      angle: {
        unitType: "angle",
        required: true
      }
    },

    restraint: {
      atomIndex: {
        required: true
      },
      k: {
        defaultValue: 2000,
        unitType: "stiffness"
      },
      x0: {
        defaultValue: 0,
        unitType: "length"
      },
      y0: {
        defaultValue: 0,
        unitType: "length"
      }
    },

    textBox: {
      text: {
        defaultValue: ""
      },
      x: {
        defaultValue: 0,
        unitType: "length"
      },
      y: {
        defaultValue: 0,
        unitType: "length"
      },
      anchor: {
        defaultValue: "lower-left"
      },
      layer: {
        defaultValue: 1
      },
      width: {},
      height: {},
      frame: {},
      color: {},
      calloutPoint: {},
      backgroundColor: {
        defaultValue: "white"
      },
      strokeWidthEms: {
        defaultValue: 0.03
      },
      strokeOpacity: {
        defaultValue: 1.0
      },
      rotate: {
        defaultValue: 0
      },
      fontScale: {
        defaultValue: 1
      },
      hostType: {},
      hostIndex: {},
      textAlign: {}
    },

    quantumDynamics: {
      elementEnergyLevels: {
        defaultValue: []
      },
      photons: {
        defaultValue: {}
      },
      radiationlessEmissionProbability: {
        defaultValue: 1
      }
    },

    photon: {
      x: {
        serialize: true
      },
      y: {
        serialize: true
      },
      vx: {
        defaultValue: 0,
        serialize: true
      },
      vy: {
        defaultValue: 0,
        serialize: true
      },
      angularFrequency: {
        serialize: true
      }
    }
  };
});


/*
Custom pairwise Lennard Jones properties.
*/


(function() {
  var __hasProp = {}.hasOwnProperty;

  define('cs!md2d/models/engine/pairwise-lj-properties',['require','md2d/models/metadata','common/validator'],function(require) {
    var PairwiseLJProperties, metadata, validator;
    metadata = require("md2d/models/metadata");
    validator = require("common/validator");
    return PairwiseLJProperties = (function() {

      function PairwiseLJProperties(engine) {
        this._engine = engine;
        this._data = {};
      }

      PairwiseLJProperties.prototype.registerChangeHooks = function(changePreHook, changePostHook) {
        this._changePreHook = changePreHook;
        return this._changePostHook = changePostHook;
      };

      PairwiseLJProperties.prototype.set = function(i, j, props) {
        var key;
        props = validator.validate(metadata.pairwiseLJProperties, props);
        this._changePreHook();
        if (!(this._data[i] != null)) {
          this._data[i] = {};
        }
        if (!(this._data[j] != null)) {
          this._data[j] = {};
        }
        if (!(this._data[i][j] != null)) {
          this._data[i][j] = this._data[j][i] = {};
        }
        for (key in props) {
          if (!__hasProp.call(props, key)) continue;
          this._data[i][j][key] = props[key];
        }
        this._engine.setPairwiseLJProperties(i, j);
        return this._changePostHook();
      };

      PairwiseLJProperties.prototype.remove = function(i, j) {
        this._changePreHook();
        delete this._data[i][j];
        delete this._data[j][i];
        this._engine.setPairwiseLJProperties(i, j);
        return this._changePostHook();
      };

      PairwiseLJProperties.prototype.get = function(i, j) {
        if (this._data[i] && this._data[i][j]) {
          return this._data[i][j];
        } else {
          return void 0;
        }
      };

      PairwiseLJProperties.prototype.deserialize = function(array) {
        var el1, el2, props, _i, _len;
        for (_i = 0, _len = array.length; _i < _len; _i++) {
          props = array[_i];
          props = validator.validateCompleteness(metadata.pairwiseLJProperties, props);
          el1 = props.element1;
          el2 = props.element2;
          delete props.element1;
          delete props.element2;
          this.set(el1, el2, props);
        }
      };

      PairwiseLJProperties.prototype.serialize = function() {
        var innerObj, key1, key2, props, result, _ref;
        result = [];
        _ref = this._data;
        for (key1 in _ref) {
          if (!__hasProp.call(_ref, key1)) continue;
          innerObj = _ref[key1];
          for (key2 in innerObj) {
            if (!__hasProp.call(innerObj, key2)) continue;
            if (key1 < key2) {
              props = this.get(key1, key2);
              props.element1 = Number(key1);
              props.element2 = Number(key2);
              result.push(props);
            }
          }
        }
        return result;
      };

      /*
          Clone-Restore Interface.
      */


      PairwiseLJProperties.prototype.clone = function() {
        return $.extend(true, {}, this._data);
      };

      PairwiseLJProperties.prototype.restore = function(state) {
        var innerObj, key1, key2, _ref;
        this._data = state;
        _ref = this._data;
        for (key1 in _ref) {
          if (!__hasProp.call(_ref, key1)) continue;
          innerObj = _ref[key1];
          for (key2 in innerObj) {
            if (!__hasProp.call(innerObj, key2)) continue;
            if (key1 < key2) {
              this._engine.setPairwiseLJProperties(key1, key2);
            }
          }
        }
      };

      return PairwiseLJProperties;

    })();
  });

}).call(this);

/*global define */

// Simple wrapper for cloning and restoring hash of arrays.
// Such structure is widely used in md2d engine for keeping
// state of various objects (like atoms and obstacles).
// Use it in the following way:
// var obj = saveRestoreWrapper(hashOfArrays)
// var state = obj.clone();
// (...)
// obj.restore(state);

define('common/models/engines/clone-restore-wrapper',['require','arrays'],function (require) {
  // Dependencies.
  var arrays = require('arrays');

  return function CloneRestoreWrapper(hashOfArrays) {
    // Public API.
    return {
      // Clone hash of arrays
      clone: function() {
        var copy = {},
            prop;

        for (prop in hashOfArrays) {
          if (hashOfArrays.hasOwnProperty(prop)) {
            copy[prop] = arrays.clone(hashOfArrays[prop]);
          }
        }

        return copy;
      },

      // Restore internal arrays using saved state.
      restore: function (state) {
        var prop;

        for (prop in hashOfArrays) {
          if (hashOfArrays.hasOwnProperty(prop)) {
            arrays.copy(state[prop], hashOfArrays[prop]);
          }
        }
      }
    };
  };

});

/*global define */

// Cell lists (also sometimes referred to as Cell linked-lists) are a tool for
// finding all atom pairs within a given cut-off distance of each other in
// Molecular dynamics simulations.
// See: http://en.wikipedia.org/wiki/Cell_lists

define('md2d/models/engine/cell-list',[],function () {

  return function CellList(width, height, cellSize) {
    var api,
        colsNum,
        rowsNum,
        cellsNum,
        cell,

        init = function () {
          var i;
          colsNum = Math.ceil(width / cellSize);
          rowsNum = Math.ceil(height / cellSize);
          cellsNum = colsNum * rowsNum;
          cell = new Array(cellsNum);
          for(i = 0; i < cellsNum; i++) {
            cell[i] = [];
          }
        };

    init ();

    // Public API.
    api = {
      reinitialize: function (newCellSize) {
        if (newCellSize !== cellSize) {
          cellSize = newCellSize;
          init();
        }
      },

      addToCell: function (atomIdx, x, y) {
        var cellIdx = Math.floor(y / cellSize) * colsNum + Math.floor(x / cellSize);
        cell[cellIdx].push(atomIdx);
      },

      getCell: function (idx) {
        return cell[idx];
      },

      getRowsNum: function () {
        return rowsNum;
      },

      getColsNum: function () {
        return colsNum;
      },

      getNeighboringCells: function (rowIdx, colIdx) {
        var cellIdx = rowIdx * colsNum + colIdx,
            result = [];

        // Upper right.
        if (colIdx + 1 < colsNum && rowIdx + 1 < rowsNum) result.push(cell[cellIdx + colsNum + 1]);
        // Right.
        if (colIdx + 1 < colsNum) result.push(cell[cellIdx + 1]);
        // Bottom right.
        if (colIdx + 1 < colsNum && rowIdx - 1 >= 0) result.push(cell[cellIdx - colsNum + 1]);
        // Bottom.
        if (rowIdx - 1 >= 0) result.push(cell[cellIdx - colsNum]);

        return result;
      },

      clear: function () {
        var i;
        for (i = 0; i < cellsNum; i++) {
          cell[i].length = 0;
        }
      }
    };

    return api;
  };

});

/*global define */

// A Verlet list (named after Loup Verlet) is a data structure in molecular dynamics simulations
// to efficiently maintain a list of all particles within a given cut-off distance of each other.
// See: http://en.wikipedia.org/wiki/Verlet_list

define('md2d/models/engine/neighbor-list',['require','arrays','common/array-types'],function (require) {
  // Dependencies.
  var arrays     = require('arrays'),
      arrayTypes = require('common/array-types');

  return function NeighborList(atomsNum, maxDisplacement) {
    var api,
        maxAtomsNum,
        listIdx,
        listCapacity,
        list,
        head,
        tail,
        x,
        y,
        forceUpdate,

        init = function () {
          // Keep maximum capacity of lists bigger than actual number of atoms.
          maxAtomsNum = atomsNum + 10;
          listIdx = 0;
          listCapacity = maxAtomsNum * (maxAtomsNum - 1) / 2;
          forceUpdate = true;

          list = arrays.create(listCapacity, 0, arrayTypes.int16Type);
          head = arrays.create(maxAtomsNum, -1, arrayTypes.int16Type);
          tail = arrays.create(maxAtomsNum, -1, arrayTypes.int16Type);
          // Fill x and y with Infinity, so shouldUpdate(..)
          // will return true during first call after initialization.
          x    = arrays.create(maxAtomsNum, Infinity, arrayTypes.floatType);
          y    = arrays.create(maxAtomsNum, Infinity, arrayTypes.floatType);
        };

    init();

    // Public API.
    api = {
      reinitialize: function (newAtomsNum, newMaxDisplacement) {
        atomsNum = newAtomsNum;
        maxDisplacement = newMaxDisplacement;
        forceUpdate = true;

        if (atomsNum > maxAtomsNum) {
          init();
        }
      },
      clear: function () {
        var i;
        listIdx = 0;
        for (i = 0; i < atomsNum; i++) {
          head[i] = tail[i] = -1;
        }
      },
      getList: function () {
        return list;
      },
      markNeighbors: function (i, j) {
        if (head[i] < 0) {
          head[i] = listIdx;
        }
        list[listIdx] = j;
        listIdx++;
        tail[i] = listIdx;
      },
      getStartIdxFor: function (i) {
        return head[i];
      },
      getEndIdxFor: function (i) {
        return tail[i];
      },
      saveAtomPosition: function (i, xCoord, yCoord) {
        x[i] = xCoord;
        y[i] = yCoord;
      },
      invalidate: function () {
        forceUpdate = true;
      },
      shouldUpdate: function (newX, newY) {
        var maxDx = -Infinity,
            maxDy = -Infinity,
            i;

        if (forceUpdate) {
          forceUpdate = false;
          return true;
        }

        for (i = 0; i < atomsNum; i++) {
          if (Math.abs(newX[i] - x[i]) > maxDx) {
            maxDx = Math.abs(newX[i] - x[i]);
          }
          if (Math.abs(newY[i] - y[i]) > maxDy) {
            maxDy = Math.abs(newY[i] - y[i]);
          }
        }

        return Math.sqrt(maxDx * maxDx + maxDy * maxDy) > maxDisplacement;
      }
    };

    return api;
  };

});

/*global define */

// The PluginController manages an array of plugins, and can call arbitrary functions
// on any registered plugin that responds to that function.

// TODO:
//
//  1. Plugins should define engine component and modeler component
//  2. Plugins should validate their own properties
//  3. Plugin controller should handle initialization of plugins and mixing of appropriate methods
//     and properties into the modeler layer. The main modeler and engine layers should not have to
//     know details about which plugins are available, what they're named, where they are located,
//     etc.
//  4. Plugin controller have a 'getPluginFunction' method which accepts a function name and returns
//     a function that, when called, does the same thing as callPluginFunction(<function name>,...).
//     This avoids having to look up the plugin function by name every time it is called.

define('common/models/plugin-controller',[],function () {

  return function PluginController() {
    var plugins = [];

    // Public API.
    return {
      registerPlugin: function(plugin) {
        plugins.push(plugin);
      },

      /**
        Calls method 'funcName' of every plugin, for those plugins which have a property 'funcName',
        in the context of the plugin (i.e., 'this' value is the plugin object) and with the elements
        of the array 'args' as the argument array of the invocation.

        If 'callback' is defined, it will be invoked with the callback.

        The callback signature is callback(returnValue, index, plugin) where returnValue is the
        return value of the method called, i is the index of the plugin, and plugin is the plugin
        object itself.
      */
      callPluginFunction: function(funcName, args, callback) {
        var i, ii, func, retVal;

        for (i = 0, ii = plugins.length; i<ii; i++) {
          func = plugins[i][funcName];
          if (func) {
            retVal = func.apply(plugins[i], args);
          }
          if (callback) {
            callback(retVal, i, plugins[i]);
          }
        }
      }
    };
  };

});

/*global define: false*/
define('md2d/models/engine/utils',['require','arrays'],function(require) {

  var arrays = require('arrays');

  /**
    Extend all arrays in arrayContainer to `newLength`. Here, arrayContainer is expected to be `atoms`
    `elements`, `radialBonds`, etc. arrayContainer might be an array or an object.
    TODO: this is just interim solution, in the future only objects will be expected.
  */
  return {
    extendArrays: function(arrayContainer, newLength) {
      var i, len;
      if (Array.isArray(arrayContainer)) {
        // Array of arrays.
        for (i = 0, len = arrayContainer.length; i < len; i++) {
          if (arrays.isArray(arrayContainer[i]))
            arrayContainer[i] = arrays.extend(arrayContainer[i], newLength);
        }
      } else {
        // Object with arrays defined as properties.
        for (i in arrayContainer) {
          if(arrayContainer.hasOwnProperty(i)) {
            if (arrays.isArray(arrayContainer[i]))
              arrayContainer[i] = arrays.extend(arrayContainer[i], newLength);
          }
        }
      }
    }
  };
});

/*global define: true */

define('md2d/models/engine/md2d',['require','exports','module','arrays','common/array-types','common/console','./constants/index','cs!md2d/models/aminoacids-helper','./math/index','./potentials/index','./potentials/index','cs!./pairwise-lj-properties','common/models/engines/clone-restore-wrapper','./cell-list','./neighbor-list','common/models/plugin-controller','./utils'],function (require, exports) {

  var arrays               = require('arrays'),
      arrayTypes           = require('common/array-types'),
      console              = require('common/console'),
      constants            = require('./constants/index'),
      unit                 = constants.unit,
      aminoacidsHelper     = require('cs!md2d/models/aminoacids-helper'),
      math                 = require('./math/index'),
      coulomb              = require('./potentials/index').coulomb,
      lennardJones         = require('./potentials/index').lennardJones,
      PairwiseLJProperties = require('cs!./pairwise-lj-properties'),
      CloneRestoreWrapper  = require('common/models/engines/clone-restore-wrapper'),
      CellList             = require('./cell-list'),
      NeighborList         = require('./neighbor-list'),
      PluginController     = require('common/models/plugin-controller'),
      utils                = require('./utils'),

      // from A. Rahman "Correlations in the Motion of Atoms in Liquid Argon", Physical Review 136 pp. A405A411 (1964)
      ARGON_LJ_EPSILON_IN_EV = -120 * constants.BOLTZMANN_CONSTANT.as(unit.EV_PER_KELVIN),
      ARGON_LJ_SIGMA_IN_NM   = 0.34,

      ARGON_MASS_IN_DALTON = 39.95,
      ARGON_MASS_IN_KG = constants.convert(ARGON_MASS_IN_DALTON, { from: unit.DALTON, to: unit.KILOGRAM }),

      BOLTZMANN_CONSTANT_IN_JOULES = constants.BOLTZMANN_CONSTANT.as( unit.JOULES_PER_KELVIN ),

      cross = function(a0, a1, b0, b1) {
        return a0*b1 - a1*b0;
      },

      sumSquare = function(a,b) {
        return a*a + b*b;
      },

      /**
        Convert total kinetic energy in the container of N atoms to a temperature in Kelvin.

        Input units:
          KE: "MW Energy Units" (Dalton * nm^2 / fs^2)
        Output units:
          T: K
      */
      convertKEtoT = function(totalKEinMWUnits, N) {
        // In 2 dimensions, kT = (2/N_df) * KE

        var N_df = 2 * N,
            averageKEinMWUnits = (2 / N_df) * totalKEinMWUnits,
            averageKEinJoules = constants.convert(averageKEinMWUnits, { from: unit.MW_ENERGY_UNIT, to: unit.JOULE });

        return averageKEinJoules / BOLTZMANN_CONSTANT_IN_JOULES;
      },

      /**
        Convert a temperature in Kelvin to the total kinetic energy in the container of N atoms.

        Input units:
          T: K
        Output units:
          KE: "MW Energy Units" (Dalton * nm^2 / fs^2)
      */
      convertTtoKE = function(T, N) {
        var N_df = 2 * N,
            averageKEinJoules  = T * BOLTZMANN_CONSTANT_IN_JOULES,
            averageKEinMWUnits = constants.convert(averageKEinJoules, { from: unit.JOULE, to: unit.MW_ENERGY_UNIT }),
            totalKEinMWUnits = averageKEinMWUnits * N_df / 2;

        return totalKEinMWUnits;
      },

      validateTemperature = function(t) {
        var temperature = parseFloat(t);

        if (isNaN(temperature)) {
          throw new Error("md2d: requested temperature " + t + " could not be understood.");
        }
        if (temperature < 0) {
          throw new Error("md2d: requested temperature " + temperature + " was less than zero");
        }
        if (temperature === Infinity) {
          throw new Error("md2d: requested temperature was Infinity!");
        }
      };

  exports.createEngine = function() {

    var // the object to be returned
        engine,

        // Whether system dimensions have been set. This is only allowed to happen once.
        sizeHasBeenInitialized = false,

        pluginController = new PluginController(),

        // Whether to simulate Coulomb forces between particles.
        useCoulombInteraction = false,

        // Dielectric constant, it influences Coulomb interaction.
        // E.g. a dielectric of 80 means a Coulomb force 1/80th as strong.
        dielectricConst = 1,

        // Whether dielectric effect should be realistic or simplified. Realistic
        // version takes into account distance between charged particles and reduces
        // dielectric constant when particles are closer to each other.
        realisticDielectricEffect = true,

        // Parameter that reflects the watery extent of the solvent, when an effective
        // hydrophobic/hydrophilic interaction is used. A negative value represents oil environment
        // (usually -1). A positive one represents water environment (usually 1). A zero value means vacuum.
        solventForceType = 0,

        // State describing whether DNA translation is in progress.
        // TODO: move all functionality connected with DNA and proteins to engine plugins!
        dnaTranslationInProgress = false,

        // Parameter that influences strength of force applied to amino acids by water of oil (solvent).
        solventForceFactor = 1,

        // Additional force applied to amino acids that depends on distance from the center of mass. It affects
        // only AAs which are pulled into the center of mass (to stabilize shape of the protein).
        additionalSolventForceMult = 25,
        additionalSolventForceThreshold = 3,

        // Whether to simulate Lennard Jones forces between particles.
        useLennardJonesInteraction = true,

        // Whether to use the thermostat to maintain the system temperature near T_target.
        useThermostat = false,

        // A value to use in calculating if two atoms are close enough for a VDW line to be displayed
        vdwLinesRatio = 1.67,

        // If a numeric value include gravitational field in force calculations,
        // otherwise value should be false
        gravitationalField = false,

        // Whether a transient temperature change is in progress.
        temperatureChangeInProgress = false,

        // Desired system temperature, in Kelvin.
        T_target,

        // Tolerance for (T_actual - T_target) relative to T_target
        tempTolerance = 0.001,

        // System dimensions as [x, y] in nanometers. Default value can be changed until particles are created.
        size = [10, 10],

        // System dimensions as minX, minY, maxX, maxY. Default value can be changed until turles are created.
        minX =  0,
        minY =  0,
        maxX = 10,
        maxY = 10,

        // Viscosity of the medium of the model
        viscosity,

        // The current model time, in femtoseconds.
        time = 0,

        // The current integration time step, in femtoseconds.
        dt,

        // Square of integration time step, in fs^2.
        dt_sq,

        // ####################################################################
        //                      Atom Properties

        // Individual property arrays for the atoms, indexed by atom number
        radius, px, py, x, y, vx, vy, speed, ax, ay, charge, element, friction, pinned, mass, hydrophobicity,
        // Helper array, which may be used by various engine routines traversing atoms in untypical order.
        // Make sure that you reset it before use. At the moment, it's used by updateAminoAcidForces() function.
        visited,

        // An object that contains references to the above atom-property arrays
        atoms,

        // The number of atoms in the system.
        N = 0,

        // ####################################################################
        //                      Element Properties

        // Individual property arrays for the elements
        elementMass,
        elementEpsilon,
        elementSigma,
        elementRadius,
        elementColor,

        // An object that contains references to the above element-property arrays
        elements,

        // Number of actual elements (may be smaller than the length of the property arrays).
        N_elements = 0,

        // Additional structure, keeping information if given element is represented by
        // some atom in the model. Necessary for effective max cut-off distance calculation.
        elementUsed = [],

        // ####################################################################
        //                      Custom Pairwise LJ Properties
        pairwiseLJProperties,

        // ####################################################################
        //                      Radial Bond Properties

        // Individual property arrays for the "radial" bonds, indexed by bond number
        radialBondAtom1Index,
        radialBondAtom2Index,
        radialBondLength,
        radialBondStrength,
        radialBondType,

        // An object that contains references to the above radial-bond-property arrays.
        // Left undefined if there are no radial bonds.
        radialBonds,

        // An array of individual radial bond index values and properties.
        // Each object contains all radial bond properties (atom1, atom2, length, strength, style)
        // and additionally (x,y) coordinates of bonded atoms defined as x1, y1, x2, y2 properties.
        radialBondResults,

        // radialBondMatrix[i][j] === true when atoms i and j are "radially bonded"
        // radialBondMatrix[i][j] === undefined otherwise
        radialBondMatrix,

        // Number of actual radial bonds (may be smaller than the length of the property arrays).
        N_radialBonds = 0,

        // ####################################################################
        //                      Restraint Properties

        // Individual property arrays for the "restraint" bonds, indexed by bond number.
        restraintAtomIndex,
        restraintK,
        restraintX0,
        restraintY0,

        // An object that contains references to the above restraint-property arrays.
        // Left undefined if there are no restraints.
        restraints,

        // Number of actual restraint bonds (may be smaller than the length of the property arrays).
        N_restraints = 0,

        // ####################################################################
        //                      Angular Bond Properties

        // Individual property arrays for the "angular" bonds, indexed by bond number.
        angularBondAtom1Index,
        angularBondAtom2Index,
        angularBondAtom3Index,
        angularBondAngle,
        angularBondStrength,

        // An object that contains references to the above angular-bond-property arrays.
        // Left undefined if there are no angular bonds.
        angularBonds,

        // Number of actual angular bonds (may be smaller than the length of the property arrays).
        N_angularBonds = 0,

        // ####################################################################
        //                      Obstacle Properties

        // Individual properties for the obstacles
        obstacleX,
        obstacleY,
        obstacleWidth,
        obstacleHeight,
        obstacleVX,
        obstacleVY,
        obstacleExtAX,
        obstacleExtAY,
        obstacleFriction,
        obstacleMass,
        obstacleWestProbe,
        obstacleNorthProbe,
        obstacleEastProbe,
        obstacleSouthProbe,
        obstacleColorR,
        obstacleColorG,
        obstacleColorB,
        obstacleVisible,

        // Properties used only during internal calculations (e.g. shouldn't
        // be returned during getObstacleProperties(i) call - TODO!).
        obstacleXPrev,
        obstacleYPrev,

        // ### Pressure calculation ###
        // Arrays containing sum of impulses 2mv/dt from atoms hitting the probe.
        // These values are later stored in pressureBuffers object, interpolated
        // (last average of last PRESSURE_BUFFERS_LEN values) and converted
        // to value in Bar by getPressureFromProbe() function.
        obstacleWProbeValue,
        obstacleNProbeValue,
        obstacleEProbeValue,
        obstacleSProbeValue,

        // An object that contains references to the above obstacle-property arrays.
        // Left undefined if there are no obstacles.
        obstacles,

        // Number of actual obstacles
        N_obstacles = 0,

        // ####################################################################
        //                      Rectangle Properties

        // Individual properties for the rectangles
        rectangleX,
        rectangleY,
        rectangleWidth,
        rectangleHeight,
        rectangleFence,
        rectangleColor,
        rectangleLineColor,
        rectangleLineDashes,
        rectangleLineWeight,
        rectangleLayer,
        rectangleVisible,

        // An object that contains references to the above rectangle-property arrays.
        // Left undefined if there are no rectangles.
        rectangles,

        // Number of actual rectangles
        N_rectangles = 0,

        // ####################################################################
        //                      Misc Properties
        // Hash of arrays containing VdW pairs
        vdwPairs,

        // Number of VdW pairs
        N_vdwPairs,

        // Arrays of VdW pair atom #1 and atom #2 indices
        vdwPairAtom1Index,
        vdwPairAtom2Index,

        // Arrays for spring forces, which are forces defined between an atom and a point in space
        springForceAtomIndex,
        springForceX,
        springForceY,
        springForceStrength,

        // An array whose members are the above spring-force-property arrays
        springForces,

        // The number of spring forces currently being applied in the model.
        N_springForces = 0,

        // Cell list structure.
        cellList,

        // Neighbor (Verlet) list structure.
        neighborList,

        // Information whether neighbor list should be
        // recalculated in the current integration step.
        updateNeighborList,

        //
        // The location of the center of mass, in nanometers.
        x_CM, y_CM,

        // Linear momentum of the system, in Dalton * nm / fs.
        px_CM, py_CM,

        // Velocity of the center of mass, in nm / fs.
        vx_CM, vy_CM,

        // Angular momentum of the system wrt its center of mass
        L_CM,

        // (Instantaneous) moment of inertia of the system wrt its center of mass
        I_CM,

        // Angular velocity of the system about the center of mass, in radians / fs.
        // (= angular momentum about CM / instantaneous moment of inertia about CM)
        omega_CM,

        // instantaneous system temperature, in Kelvin
        T,

        // cutoff for force calculations, as a factor of sigma
        cutoff = 2,
        cutoffDistance_LJ_sq = [],

        // cutoff for neighbor list calculations, as a factor of sigma
        cutoffList = 2.5,
        cutoffNeighborListSquared = [],

        // Each object at ljCalculator[i,j] can calculate the magnitude of the Lennard-Jones force and
        // potential between elements i and j
        ljCalculator = [],

        // Optimization related variables:
        // Whether any atoms actually have charges
        hasChargedAtoms = false,

        // List of atoms with charge.
        chargedAtomsList = [],

        // List of particles representing cysteine amino acid, which can possibly create disulphide bonds.
        // So, each cysteine in this list is NOT already connected to other cysteine.
        freeCysteinesList = [],

        // Initializes basic data structures.
        initialize = function () {
          createElementsArray(0);
          createAtomsArray(0);
          createAngularBondsArray(0);
          createRadialBondsArray(0);
          createRestraintsArray(0);
          createVdwPairsArray(0);
          createSpringForcesArray(0);
          createObstaclesArray(0);
          createRectanglesArray(0);

          // Custom pairwise properties.
          pairwiseLJProperties = new PairwiseLJProperties(engine);

          radialBondMatrix = [];

          // Initialize radialBondResults[] array consisting of hashes of radial bond
          // index numbers and transposed radial bond properties.

          // FIXME. Why is the engine computing this? The modeler exists to insulate the engine
          // code from view concerns such as this "results" array.
          // See https://www.pivotaltracker.com/story/show/50086303
          radialBondResults = engine.radialBondResults = [];
        },

        // Throws an informative error if a developer tries to use the setCoefficients method of an
        // in-use LJ calculator. (Hint: for an interactive LJ chart, create a new LJ calculator with
        // the desired coefficients; call setElementProperties to change the LJ properties in use.)
        ljCoefficientChangeError = function() {
          throw new Error("md2d: Don't change the epsilon or sigma parameters of the LJ calculator being used by MD2D. Use the setElementProperties method instead.");
        },

        // Initialize epsilon, sigma, cutoffDistance_LJ_sq, cutoffNeighborListSquared, and ljCalculator
        // array elements for element pair i and j
        setPairwiseLJProperties = function(i, j) {
          var epsilon_i   = elementEpsilon[i],
              epsilon_j   = elementEpsilon[j],
              sigma_i     = elementSigma[i],
              sigma_j     = elementSigma[j],
              customProps = pairwiseLJProperties.get(i, j),
              e,
              s;

          if (customProps && customProps.epsilon !== undefined) {
            e = customProps.epsilon;
          } else {
            e = lennardJones.pairwiseEpsilon(epsilon_i, epsilon_j);
          }

          if (customProps && customProps.sigma !== undefined) {
            s = customProps.sigma;
          } else {
            s = lennardJones.pairwiseSigma(sigma_i, sigma_j);
          }

          // Cutoff for Lennard-Jones interactions.
          cutoffDistance_LJ_sq[i][j] = cutoffDistance_LJ_sq[j][i] = (cutoff * s) * (cutoff * s);
          // Cutoff for neighbor lists calculations.
          cutoffNeighborListSquared[i][j] = cutoffNeighborListSquared[j][i] = (cutoffList * s) * (cutoffList * s);

          ljCalculator[i][j] = ljCalculator[j][i] = lennardJones.newLJCalculator({
            epsilon: e,
            sigma:   s
          }, ljCoefficientChangeError);
        },

        // Calculates maximal cut-off used in the current model. Functions checks all used
        // elements at the moment. When new atom is added, maximum cut-off distance should
        // be recalculated.
        computeMaxCutoff = function() {
          var maxCutoff = 0,
              customProps,
              sigma,
              i, j;

          for (i = 0; i < N_elements; i++) {
            for (j = 0; j <= i; j++) {
              if (elementUsed[i] && elementUsed[j]) {
                customProps = pairwiseLJProperties.get(i, j);
                if (customProps && customProps.sigma !== undefined) {
                  sigma = customProps.sigma;
                } else {
                  sigma = lennardJones.pairwiseSigma(elementSigma[i], elementSigma[j]);
                }
                // Use cutoffList, as cell lists are used to calculate neighbor lists.
                if (cutoffList * sigma > maxCutoff) {
                  maxCutoff = cutoffList * sigma;
                }
              }
            }
          }
          // If maxCutoff === 0, return size of the model
          // as a default cutoff distance for empty model.
          return maxCutoff || Math.max(size[0], size[1]);
        },

        // Returns a minimal difference between "real" cutoff
        // and cutoff used in neighbor list. This can be considered
        // as a minimal displacement of atom, which triggers neighbor
        // list recalculation (or maximal allowed displacement to avoid
        // recalculation).
        computeNeighborListMaxDisplacement = function() {
          var maxDisplacement = Infinity,
              customProps,
              sigma,
              i, j;

          for (i = 0; i < N_elements; i++) {
            for (j = 0; j <= i; j++) {
              if (elementUsed[i] && elementUsed[j]) {
                customProps = pairwiseLJProperties.get(i, j);
                if (customProps && customProps.sigma !== undefined) {
                  sigma = customProps.sigma;
                } else {
                  sigma = lennardJones.pairwiseSigma(elementSigma[i], elementSigma[j]);
                }

                if ((cutoffList - cutoff) * sigma < maxDisplacement) {
                  maxDisplacement = (cutoffList - cutoff) * sigma;
                }
              }
            }
          }
          return maxDisplacement;
        },

        // Initializes special structure for short-range forces calculation
        // optimization. Cell lists support neighbor list.
        initializeCellList = function () {
          if (cellList === undefined) {
            cellList = new CellList(size[0], size[1], computeMaxCutoff());
          } else {
            cellList.reinitialize(computeMaxCutoff());
          }
        },

        // Initializes special structure for short-range forces calculation
        // optimization. Neighbor list cooperates with cell list.
        initializeNeighborList = function () {
          if (neighborList === undefined) {
            neighborList = new NeighborList(N, computeNeighborListMaxDisplacement());
          } else {
            neighborList.reinitialize(N, computeNeighborListMaxDisplacement());
          }
        },

        // Calculates radial bond matrix using existing radial bonds.
        calculateRadialBondMatrix = function () {
          var i, atom1, atom2;

          radialBondMatrix = [];

          for (i = 0; i < N_radialBonds; i++) {
            atom1 = radialBondAtom1Index[i];
            atom2 = radialBondAtom2Index[i];
            radialBondMatrix[atom1] = radialBondMatrix[atom1] || [];
            radialBondMatrix[atom1][atom2] = true;
            radialBondMatrix[atom2] = radialBondMatrix[atom2] || [];
            radialBondMatrix[atom2][atom1] = true;
          }
        },


        /**
          Set up "shortcut" references, e.g., x = atoms.x
        */
        assignShortcutReferences = {

          atoms: function() {
            radius         = atoms.radius;
            px             = atoms.px;
            py             = atoms.py;
            x              = atoms.x;
            y              = atoms.y;
            vx             = atoms.vx;
            vy             = atoms.vy;
            speed          = atoms.speed;
            ax             = atoms.ax;
            ay             = atoms.ay;
            charge         = atoms.charge;
            friction       = atoms.friction;
            element        = atoms.element;
            pinned         = atoms.pinned;
            mass           = atoms.mass;
            hydrophobicity = atoms.hydrophobicity;
            visited        = atoms.visited;
          },

          radialBonds: function() {
            radialBondAtom1Index  = radialBonds.atom1;
            radialBondAtom2Index  = radialBonds.atom2;
            radialBondLength      = radialBonds.length;
            radialBondStrength    = radialBonds.strength;
            radialBondType        = radialBonds.type;
          },

          restraints: function() {
            restraintAtomIndex  = restraints.atomIndex;
            restraintK          = restraints.k;
            restraintX0         = restraints.x0;
            restraintY0         = restraints.y0;
          },

          angularBonds: function() {
            angularBondAtom1Index  = angularBonds.atom1;
            angularBondAtom2Index  = angularBonds.atom2;
            angularBondAtom3Index  = angularBonds.atom3;
            angularBondAngle       = angularBonds.angle;
            angularBondStrength    = angularBonds.strength;
          },

          elements: function() {
            elementMass    = elements.mass;
            elementEpsilon = elements.epsilon;
            elementSigma   = elements.sigma;
            elementRadius  = elements.radius;
            elementColor   = elements.color;
          },

          obstacles: function() {
            obstacleX           = obstacles.x;
            obstacleY           = obstacles.y;
            obstacleWidth       = obstacles.width;
            obstacleHeight      = obstacles.height;
            obstacleMass        = obstacles.mass;
            obstacleVX          = obstacles.vx;
            obstacleVY          = obstacles.vy;
            obstacleExtAX       = obstacles.externalAx;
            obstacleExtAY       = obstacles.externalAy;
            obstacleFriction    = obstacles.friction;
            obstacleWestProbe   = obstacles.westProbe;
            obstacleNorthProbe  = obstacles.northProbe;
            obstacleEastProbe   = obstacles.eastProbe;
            obstacleSouthProbe  = obstacles.southProbe;
            obstacleWProbeValue = obstacles.westProbeValue;
            obstacleNProbeValue = obstacles.northProbeValue;
            obstacleEProbeValue = obstacles.eastProbeValue;
            obstacleSProbeValue = obstacles.southProbeValue;
            obstacleXPrev       = obstacles.xPrev;
            obstacleYPrev       = obstacles.yPrev;
            obstacleColorR      = obstacles.colorR;
            obstacleColorG      = obstacles.colorG;
            obstacleColorB      = obstacles.colorB;
            obstacleVisible     = obstacles.visible;
          },

          rectangles: function() {
            rectangleX             = rectangles.x;
            rectangleY             = rectangles.y;
            rectangleWidth         = rectangles.width;
            rectangleHeight        = rectangles.height;
            rectangleFence         = rectangles.fence;
            rectangleColor         = rectangles.color;
            rectangleLineColor     = rectangles.lineColor;
            rectangleLineDashes    = rectangles.lineDashes;
            rectangleLineWeight    = rectangles.lineWeight;
            rectangleLayer         = rectangles.layer;
            rectangleVisible       = rectangles.visible;
          },

          springForces: function() {
            springForceAtomIndex = springForces[0];
            springForceX         = springForces[1];
            springForceY         = springForces[2];
            springForceStrength  = springForces[3];
          },

          vdwPairs: function () {
            vdwPairAtom1Index = vdwPairs.atom1;
            vdwPairAtom2Index = vdwPairs.atom2;
          }

        },

        createElementsArray = function(num) {
          elements = engine.elements = {};

          elements.mass    = arrays.create(num, 0, arrayTypes.floatType);
          elements.epsilon = arrays.create(num, 0, arrayTypes.floatType);
          elements.sigma   = arrays.create(num, 0, arrayTypes.floatType);
          elements.radius  = arrays.create(num, 0, arrayTypes.floatType);
          elements.color   = arrays.create(num, 0, arrayTypes.int32Type);

          assignShortcutReferences.elements();
        },

        createAtomsArray = function(num) {
          atoms = {};

          // TODO. DRY this up by letting the property list say what type each array is
          atoms.radius         = arrays.create(num, 0, arrayTypes.floatType);
          atoms.px             = arrays.create(num, 0, arrayTypes.floatType);
          atoms.py             = arrays.create(num, 0, arrayTypes.floatType);
          atoms.x              = arrays.create(num, 0, arrayTypes.floatType);
          atoms.y              = arrays.create(num, 0, arrayTypes.floatType);
          atoms.vx             = arrays.create(num, 0, arrayTypes.floatType);
          atoms.vy             = arrays.create(num, 0, arrayTypes.floatType);
          atoms.speed          = arrays.create(num, 0, arrayTypes.floatType);
          atoms.ax             = arrays.create(num, 0, arrayTypes.floatType);
          atoms.ay             = arrays.create(num, 0, arrayTypes.floatType);
          atoms.charge         = arrays.create(num, 0, arrayTypes.floatType);
          atoms.friction       = arrays.create(num, 0, arrayTypes.floatType);
          atoms.element        = arrays.create(num, 0, arrayTypes.uint8Type);
          atoms.pinned         = arrays.create(num, 0, arrayTypes.uint8Type);
          atoms.mass           = arrays.create(num, 0, arrayTypes.floatType);
          atoms.hydrophobicity = arrays.create(num, 0, arrayTypes.int8Type);
          atoms.visited        = arrays.create(num, 0, arrayTypes.uint8Type);
          // For the sake of clarity, manage all atoms properties in one
          // place (engine). In the future, think about separation of engine
          // properties and view-oriented properties like these:
          atoms.marked         = arrays.create(num, 0, arrayTypes.uint8Type);
          atoms.visible        = arrays.create(num, 0, arrayTypes.uint8Type);
          atoms.draggable      = arrays.create(num, 0, arrayTypes.uint8Type);

          assignShortcutReferences.atoms();
        },

        createRadialBondsArray = function(num) {
          radialBonds = engine.radialBonds = {};

          radialBonds.atom1    = arrays.create(num, 0, arrayTypes.uint16Type);
          radialBonds.atom2    = arrays.create(num, 0, arrayTypes.uint16Type);
          radialBonds.length   = arrays.create(num, 0, arrayTypes.floatType);
          radialBonds.strength = arrays.create(num, 0, arrayTypes.floatType);
          radialBonds.type     = arrays.create(num, 0, arrayTypes.uint8Type);

          assignShortcutReferences.radialBonds();
        },

        createRestraintsArray = function(num) {
          restraints = engine.restraints = {};

          restraints.atomIndex = arrays.create(num, 0, arrayTypes.uint16Type);
          restraints.k         = arrays.create(num, 0, arrayTypes.floatType);
          restraints.x0        = arrays.create(num, 0, arrayTypes.floatType);
          restraints.y0        = arrays.create(num, 0, arrayTypes.floatType);

          assignShortcutReferences.restraints();
        },

        createAngularBondsArray = function(num) {
          angularBonds = engine.angularBonds = {};

          angularBonds.atom1    = arrays.create(num, 0, arrayTypes.uint16Type);
          angularBonds.atom2    = arrays.create(num, 0, arrayTypes.uint16Type);
          angularBonds.atom3    = arrays.create(num, 0, arrayTypes.uint16Type);
          angularBonds.angle    = arrays.create(num, 0, arrayTypes.floatType);
          angularBonds.strength = arrays.create(num, 0, arrayTypes.floatType);

          assignShortcutReferences.angularBonds();
        },

        createVdwPairsArray = function(num) {
          vdwPairs = engine.vdwPairs = {};

          vdwPairs.count = 0;
          vdwPairs.atom1 = arrays.create(num, 0, arrayTypes.uint16Type);
          vdwPairs.atom2 = arrays.create(num, 0, arrayTypes.uint16Type);
        },

        createSpringForcesArray = function(num) {
          springForces = engine.springForces = [];

          // TODO: not very descriptive. Use hash of arrays like elsewhere.
          springForces[0] = arrays.create(num, 0, arrayTypes.uint16Type);
          springForces[1] = arrays.create(num, 0, arrayTypes.floatType);
          springForces[2] = arrays.create(num, 0, arrayTypes.floatType);
          springForces[3] = arrays.create(num, 0, arrayTypes.floatType);

          assignShortcutReferences.springForces();
        },

        createObstaclesArray = function(num) {
          obstacles = engine.obstacles = {};

          obstacles.x           = arrays.create(num, 0, arrayTypes.floatType);
          obstacles.y           = arrays.create(num, 0, arrayTypes.floatType);
          obstacles.width       = arrays.create(num, 0, arrayTypes.floatType);
          obstacles.height      = arrays.create(num, 0, arrayTypes.floatType);
          obstacles.mass        = arrays.create(num, 0, arrayTypes.floatType);
          obstacles.vx          = arrays.create(num, 0, arrayTypes.floatType);
          obstacles.vy          = arrays.create(num, 0, arrayTypes.floatType);
          obstacles.externalAx  = arrays.create(num, 0, arrayTypes.floatType);
          obstacles.externalAy  = arrays.create(num, 0, arrayTypes.floatType);
          obstacles.friction    = arrays.create(num, 0, arrayTypes.floatType);
          obstacles.westProbe   = arrays.create(num, 0, arrayTypes.uint8Type);
          obstacles.northProbe  = arrays.create(num, 0, arrayTypes.uint8Type);
          obstacles.eastProbe   = arrays.create(num, 0, arrayTypes.uint8Type);
          obstacles.southProbe  = arrays.create(num, 0, arrayTypes.uint8Type);
          obstacles.westProbeValue = arrays.create(num, 0, arrayTypes.floatType);
          obstacles.northProbeValue = arrays.create(num, 0, arrayTypes.floatType);
          obstacles.eastProbeValue = arrays.create(num, 0, arrayTypes.floatType);
          obstacles.southProbeValue = arrays.create(num, 0, arrayTypes.floatType);
          obstacles.xPrev       = arrays.create(num, 0, arrayTypes.floatType);
          obstacles.yPrev       = arrays.create(num, 0, arrayTypes.floatType);
          obstacles.colorR      = arrays.create(num, 0, arrayTypes.floatType);
          obstacles.colorG      = arrays.create(num, 0, arrayTypes.floatType);
          obstacles.colorB      = arrays.create(num, 0, arrayTypes.floatType);
          obstacles.visible     = arrays.create(num, 0, arrayTypes.uint8Type);

          assignShortcutReferences.obstacles();
        },

		createRectanglesArray = function(num) {
          rectangles = engine.rectangles = {};

          rectangles.x             = arrays.create(num, 0, arrayTypes.floatType);
          rectangles.y             = arrays.create(num, 0, arrayTypes.floatType);
          rectangles.width         = arrays.create(num, 0, arrayTypes.floatType);
          rectangles.height        = arrays.create(num, 0, arrayTypes.floatType);
          rectangles.fence         = [];
          rectangles.color         = [];
          rectangles.lineColor     = [];
          rectangles.lineDashes    = [];
          rectangles.lineWeight    = arrays.create(num, 0, arrayTypes.floatType);
          rectangles.layer         = arrays.create(num, 0, arrayTypes.floatType);
          rectangles.visible       = arrays.create(num, 0, arrayTypes.uint8Type);

          assignShortcutReferences.rectangles();
        },

        // Function that accepts a value T and returns an average of the last n values of T (for some n).
        getTWindowed,

        // Dynamically determine an appropriate window size for use when measuring a windowed average of the temperature.
        getWindowSize = function() {
          return useCoulombInteraction && hasChargedAtoms ? 1000 : 1000;
        },

        // Whether or not the thermostat is not being used, begins transiently adjusting the system temperature; this
        // causes the adjustTemperature portion of the integration loop to rescale velocities until a windowed average of
        // the temperature comes within `tempTolerance` of `T_target`.
        beginTransientTemperatureChange = function()  {
          temperatureChangeInProgress = true;
          getTWindowed = math.getWindowedAverager( getWindowSize() );
        },

        // Calculates & returns instantaneous temperature of the system.
        computeTemperature = function() {
          var twoKE = 0,
              i;

          // Particles.
          for (i = 0; i < N; i++) {
            twoKE += mass[i] * (vx[i] * vx[i] + vy[i] * vy[i]);
          }
          // Obstacles.
          for (i = 0; i < N_obstacles; i++) {
            if (obstacleMass[i] !== Infinity) {
              twoKE += obstacleMass[i] *
                  (obstacleVX[i] * obstacleVX[i] + obstacleVY[i] * obstacleVY[i]);
            }
          }

          return convertKEtoT(twoKE / 2, N);
        },

        // Calculates & returns the instaneous temperature of a particular group of atoms
        computeTemperatureOfAtoms = function(atomIndices) {
          var twoKE = 0,
              i,
              j;

          // Particles.
          for (i = 0; i < atomIndices.length; i++) {
            j = atomIndices[i];
            twoKE += mass[j] * (vx[j] * vx[j] + vy[j] * vy[j]);
          }

          return convertKEtoT(twoKE / 2, atomIndices.length);
        },

        // Adds the velocity vector (vx_t, vy_t) to the velocity vector of particle i
        addVelocity = function(i, vx_t, vy_t) {
          vx[i] += vx_t;
          vy[i] += vy_t;

          px[i] = vx[i]*mass[i];
          py[i] = vy[i]*mass[i];
        },

        // Adds effect of angular velocity omega, relative to (x_CM, y_CM), to the velocity vector of particle i
        addAngularVelocity = function(i, omega) {
          vx[i] -= omega * (y[i] - y_CM);
          vy[i] += omega * (x[i] - x_CM);

          px[i] = vx[i]*mass[i];
          py[i] = vy[i]*mass[i];
        },

        // Subtracts the center-of-mass linear velocity and the system angular velocity from the velocity vectors
        removeTranslationAndRotationFromVelocities = function() {
          for (var i = 0; i < N; i++) {
            addVelocity(i, -vx_CM, -vy_CM);
            addAngularVelocity(i, -omega_CM);
          }
        },

        // currently unused, implementation saved here for future reference:

        // // Adds the center-of-mass linear velocity and the system angular velocity back into the velocity vectors
        // addTranslationAndRotationToVelocities = function() {
        //   for (var i = 0; i < N; i++) {
        //     addVelocity(i, vx_CM, vy_CM);
        //     addAngularVelocity(i, omega_CM);
        //   }
        // },

        // Subroutine that calculates the position and velocity of the center of mass, leaving these in x_CM, y_CM,
        // vx_CM, and vy_CM, and that then computes the system angular velocity around the center of mass, leaving it
        // in omega_CM.
        computeSystemTranslation = function() {
          var x_sum = 0,
              y_sum = 0,
              px_sum = 0,
              py_sum = 0,
              totalMass = engine.getTotalMass(),
              i;

          for (i = 0; i < N; i++) {
            x_sum += x[i];
            y_sum += y[i];
            px_sum += px[i];
            py_sum += py[i];
          }

          x_CM = x_sum / N;
          y_CM = y_sum / N;
          px_CM = px_sum;
          py_CM = py_sum;
          vx_CM = px_sum / totalMass;
          vy_CM = py_sum / totalMass;
        },

        // Subroutine that calculates the angular momentum and moment of inertia around the center of mass, and then
        // uses these to calculate the weighted angular velocity around the center of mass.
        // Updates I_CM, L_CM, and omega_CM.
        // Requires x_CM, y_CM, vx_CM, vy_CM to have been calculated.
        computeSystemRotation = function() {
          var L = 0,
              I = 0,
              m,
              i;

          for (i = 0; i < N; i++) {
            m = mass[i];
            // L_CM = sum over N of of mr_i x p_i (where r_i and p_i are position & momentum vectors relative to the CM)
            L += m * cross( x[i]-x_CM, y[i]-y_CM, vx[i]-vx_CM, vy[i]-vy_CM);
            I += m * sumSquare( x[i]-x_CM, y[i]-y_CM );
          }

          L_CM = L;
          I_CM = I;
          omega_CM = L_CM / I_CM;
        },

        computeCMMotion = function() {
          computeSystemTranslation();
          computeSystemRotation();
        },

        // ####################################################################
        // #              Functions handling different collisions.            #
        // ####################################################################

        // Constrain obstacle i to the area between the walls by simulating perfectly elastic collisions with the walls.
        bounceObstacleOffWalls = function(i) {
          var leftwall   = 0,
              bottomwall = 0,
              width  = size[0],
              height = size[1],
              rightwall = width - obstacleWidth[i],
              topwall   = height - obstacleHeight[i];

          // Bounce off vertical walls.
          if (obstacleX[i] < leftwall) {
            while (obstacleX[i] < leftwall - width) {
              obstacleX[i] += width;
            }
            obstacleX[i]  = leftwall + (leftwall - obstacleX[i]);
            obstacleVX[i] *= -1;
          } else if (obstacleX[i] > rightwall) {
            while (obstacleX[i] > rightwall + width) {
              obstacleX[i] -= width;
            }
            obstacleX[i]  = rightwall - (obstacleX[i] - rightwall);
            obstacleVX[i] *= -1;
          }

          // Bounce off horizontal walls.
          if (obstacleY[i] < bottomwall) {
            while (obstacleY[i] < bottomwall - height) {
              obstacleY[i] += height;
            }
            obstacleY[i]  = bottomwall + (bottomwall - obstacleY[i]);
            obstacleVY[i] *= -1;
          } else if (obstacleY[i] > topwall) {
            while (obstacleY[i] > topwall + width) {
              obstacleY[i] -= width;
            }
            obstacleY[i]  = topwall - (obstacleY[i] - topwall);
            obstacleVY[i] *= -1;
          }
        },

        // Constrain particle i to the area between the walls by simulating perfectly elastic collisions with the walls.
        // Note this may change the linear and angular momentum.
        bounceParticleOffWalls = function(i) {
          var r = radius[i],
              leftwall = r,
              bottomwall = r,
              width = size[0],
              height = size[1],
              rightwall = width - r,
              topwall = height - r;

          // Bounce off vertical walls.
          if (x[i] < leftwall) {
            while (x[i] < leftwall - width) {
              x[i] += width;
            }
            x[i]  = leftwall + (leftwall - x[i]);
            vx[i] *= -1;
            px[i] *= -1;
          } else if (x[i] > rightwall) {
            while (x[i] > rightwall + width) {
              x[i] -= width;
            }
            x[i]  = rightwall - (x[i] - rightwall);
            vx[i] *= -1;
            px[i] *= -1;
          }

          // Bounce off horizontal walls
          if (y[i] < bottomwall) {
            while (y[i] < bottomwall - height) {
              y[i] += height;
            }
            y[i]  = bottomwall + (bottomwall - y[i]);
            vy[i] *= -1;
            py[i] *= -1;
          } else if (y[i] > topwall) {
            while (y[i] > topwall + height) {
              y[i] -= height;
            }
            y[i]  = topwall - (y[i] - topwall);
            vy[i] *= -1;
            py[i] *= -1;
          }
        },
        bounceParticleOffObstacles = function(i, x_prev, y_prev, updatePressure) {
          // fast path if no obstacles
          if (N_obstacles < 1) return;

          var r,
              xi,
              yi,

              j,

              x_left,
              x_right,
              y_top,
              y_bottom,
              x_left_prev,
              x_right_prev,
              y_top_prev,
              y_bottom_prev,
              vxPrev,
              vyPrev,
              obs_vxPrev,
              obs_vyPrev,
              atom_mass,
              obs_mass,
              totalMass,
              bounceDirection;

          r = radius[i];
          xi = x[i];
          yi = y[i];

          for (j = 0; j < N_obstacles; j++) {

            x_left = obstacleX[j] - r;
            x_right = obstacleX[j] + obstacleWidth[j] + r;
            y_top = obstacleY[j] + obstacleHeight[j] + r;
            y_bottom = obstacleY[j] - r;

            x_left_prev = obstacleXPrev[j] - r;
            x_right_prev = obstacleXPrev[j] + obstacleWidth[j] + r;
            y_top_prev = obstacleYPrev[j] + obstacleHeight[j] + r;
            y_bottom_prev = obstacleYPrev[j] - r;

            // Reset bounceDirection, which indicates collision type.
            bounceDirection = 0;
            // Check all possibilities for a collision with the rectangular obstacle.
            if (xi > x_left && xi < x_right && yi > y_bottom && yi < y_top) {
              if (x_prev <= x_left_prev) {
                x[i] = x_left - (xi - x_left);
                bounceDirection = 1; // West wall collision.
              } else if (x_prev >= x_right_prev) {
                x[i] = x_right + (x_right - xi);
                bounceDirection = 2; // East wall collision.
              } else if (y_prev <= y_bottom_prev) {
                y[i] = y_bottom - (yi - y_bottom);
                bounceDirection = -1; // South wall collision.
              } else if (y_prev >= y_top_prev) {
                y[i] = y_top  + (y_top - yi);
                bounceDirection = -2; // North wall collision.
              }
            }

            obs_mass = obstacleMass[j];

            if (bounceDirection !== 0) {
              if (obs_mass !== Infinity) {
                // if we have real mass, perform a perfectly-elastic collision
                atom_mass = mass[i];
                totalMass = obs_mass + atom_mass;
                if (bounceDirection > 0) {
                  vxPrev = vx[i];
                  obs_vxPrev = obstacleVX[j];

                  vx[i] = (vxPrev * (atom_mass - obs_mass) + (2 * obs_mass * obs_vxPrev)) / totalMass;
                  obstacleVX[j] = (obs_vxPrev * (obs_mass - atom_mass) + (2 * px[i])) / totalMass;
                } else {
                  vyPrev = vy[i];
                  obs_vyPrev = obstacleVY[j];

                  vy[i] = (vyPrev * (atom_mass - obs_mass) + (2 * obs_mass * obs_vyPrev)) / totalMass;
                  obstacleVY[j] = (obs_vyPrev * (obs_mass - atom_mass) + (2 * py[i])) / totalMass;
                }
              } else {
                // if we have infinite mass, just reflect (like a wall)
                if (bounceDirection > 0) {
                  vx[i] *= -1;
                } else {
                  vy[i] *= -1;
                }
              }

              if (updatePressure) {
                // Update pressure probes if there are any.
                if (obstacleWestProbe[j] && bounceDirection === 1) {
                  // 1 is west wall collision.
                  obstacleWProbeValue[j] += mass[i] * ((vxPrev ? vxPrev : -vx[i]) - vx[i]);
                } else if (obstacleEastProbe[j] && bounceDirection === 2) {
                  // 2 is west east collision.
                  obstacleEProbeValue[j] += mass[i] * (vx[i] - (vxPrev ? vxPrev : -vx[i]));
                } else if (obstacleSouthProbe[j] && bounceDirection === -1) {
                  // -1 is south wall collision.
                  obstacleSProbeValue[j] += mass[i] * ((vyPrev ? vyPrev : -vy[i]) - vy[i]);
                } else if (obstacleNorthProbe[j] && bounceDirection === -2) {
                  // -2 is north wall collision.
                  obstacleNProbeValue[j] += mass[i] * (vy[i] - (vyPrev ? vyPrev : -vy[i]));
                }
              }

            }
          }
        },

        bounceParticleOffRectangles = function(i, x_prev, y_prev) {
          // fast path if no rectangles
          if (N_rectangles < 1) return;

          var r,
              xi,
              yi,

              j,

              x_inside_left,
              x_inside_right,
              y_inside_top,
              y_inside_bottom,
              x_outside_left,
              x_outside_right,
              y_outside_top,
              y_outside_bottom;

          r = radius[i];
          xi = x[i];
          yi = y[i];

          for (j = 0; j < N_rectangles; j++) {

            if(!rectangleFence[j]) continue;

            x_outside_left = rectangleX[j] - r;
            x_outside_right = rectangleX[j] + rectangleWidth[j] + r;
            y_outside_top = rectangleY[j] + rectangleHeight[j] + r;
            y_outside_bottom = rectangleY[j] - r;

            x_inside_left = rectangleX[j] + r;
            x_inside_right = rectangleX[j] + rectangleWidth[j] - r;
            y_inside_top = rectangleY[j] + rectangleHeight[j] - r;
            y_inside_bottom = rectangleY[j] + r;

            // Check all outside collisions
            if (xi > x_outside_left && xi < x_outside_right && yi > y_outside_bottom && yi < y_outside_top) {
              if (x_prev <= x_outside_left) {
                x[i] = x_outside_left - (xi - x_outside_left);
                vx[i] *= -1;
              } else if (x_prev >= x_outside_right) {
                x[i] = x_outside_right + (x_outside_right - xi);
                vx[i] *= -1;
              } else if (y_prev <= y_outside_bottom) {
                y[i] = y_outside_bottom - (yi - y_outside_bottom);
                vy[i] *= -1;
              } else if (y_prev >= y_outside_top) {
                y[i] = y_outside_top  + (y_outside_top - yi);
                vy[i] *= -1;
              }
            }
            //Check all inside collisions
            if (x_prev > x_inside_left && x_prev < x_inside_right && y_prev > y_inside_bottom && y_prev < y_inside_top) {
              if (xi <= x_inside_left) {
                x[i] = x_inside_left + (x_inside_left - xi);
                vx[i] *= -1;
              } else if (xi >= x_inside_right) {
                x[i] = x_inside_right - (xi - x_inside_right);
                vx[i] *= -1;
              } else if (yi <= y_inside_bottom) {
                y[i] = y_inside_bottom + (y_inside_bottom - yi);
                vy[i] *= -1;
              } else if (yi >= y_inside_top) {
                y[i] = y_inside_top - (yi - y_inside_top);
                vy[i] *= -1;
              }
            }
          }
        },

        // ####################################################################
        // #         Functions calculating forces and accelerations.          #
        // ####################################################################

        // Calculate distance and force (if distance < cut-off distance).
        calculateLJInteraction = function(i, j) {
          // Fast path.
          if (radialBondMatrix && radialBondMatrix[i] && radialBondMatrix[i][j]) return;

          var elI = element[i],
              elJ = element[j],
              dx  = x[j] - x[i],
              dy  = y[j] - y[i],
              rSq = dx * dx + dy * dy,
              fOverR, fx, fy;

          if (updateNeighborList && rSq < cutoffNeighborListSquared[elI][elJ]) {
            neighborList.markNeighbors(i, j);
          }

          if (rSq < cutoffDistance_LJ_sq[elI][elJ]) {
            fOverR = ljCalculator[elI][elJ].forceOverDistanceFromSquaredDistance(rSq);
            fx = fOverR * dx;
            fy = fOverR * dy;
            ax[i] += fx;
            ay[i] += fy;
            ax[j] -= fx;
            ay[j] -= fy;
          }
        },

        updateShortRangeForces = function () {
          // Fast path if Lennard Jones interaction is disabled.
          if (!useLennardJonesInteraction) return;

          if (updateNeighborList) {
            console.time('cell lists');
            shortRangeForcesCellList();
            console.timeEnd('cell lists');
          } else {
            console.time('neighbor list');
            shortRangeForcesNeighborList();
            console.timeEnd('neighbor list');
          }
        },

        shortRangeForcesCellList = function () {
          var rows = cellList.getRowsNum(),
              cols = cellList.getColsNum(),
              i, j, temp, cellIdx, cell1, cell2,
              a, b, atom1Idx, cell1Len, cell2Len,
              n, nLen, cellNeighbors;

          for (i = 0; i < rows; i++) {
            temp = i * cols;
            for (j = 0; j < cols; j++) {
              cellIdx = temp + j;

              cell1 = cellList.getCell(cellIdx);
              cellNeighbors = cellList.getNeighboringCells(i, j);

              for (a = 0, cell1Len = cell1.length; a < cell1Len; a++) {
                atom1Idx = cell1[a];

                // Interactions inside the cell.
                for (b = 0; b < a; b++) {
                  calculateLJInteraction(atom1Idx, cell1[b]);
                }
                // Interactions between neighboring cells.
                for (n = 0, nLen = cellNeighbors.length; n < nLen; n++) {
                  cell2 = cellNeighbors[n];
                  for (b = 0, cell2Len = cell2.length; b < cell2Len; b++) {
                    calculateLJInteraction(atom1Idx, cell2[b]);
                  }
                }
              }
            }
          }
        },

        shortRangeForcesNeighborList = function () {
          var nlist = neighborList.getList(),
              atom1Idx, atom2Idx, i, len;

          for (atom1Idx = 0; atom1Idx < N; atom1Idx++) {
            for (i = neighborList.getStartIdxFor(atom1Idx), len = neighborList.getEndIdxFor(atom1Idx); i < len; i++) {
              atom2Idx = nlist[i];
              calculateLJInteraction(atom1Idx, atom2Idx);
            }
          }
        },

        updateLongRangeForces = function() {
          // Fast path if Coulomb interaction is disabled or there are no charged atoms.
          if (!useCoulombInteraction || !hasChargedAtoms) return;

          var i, j, len, dx, dy, rSq, fOverR, fx, fy,
              charge1, atom1Idx, atom2Idx,
              bondingPartners;

          for (i = 0, len = chargedAtomsList.length; i < len; i++) {
            atom1Idx = chargedAtomsList[i];
            charge1 = charge[atom1Idx];
            bondingPartners = radialBondMatrix && radialBondMatrix[atom1Idx];
            for (j = 0; j < i; j++) {
              atom2Idx = chargedAtomsList[j];
              if (bondingPartners && bondingPartners[atom2Idx]) continue;

              dx = x[atom2Idx] - x[atom1Idx];
              dy = y[atom2Idx] - y[atom1Idx];
              rSq = dx*dx + dy*dy;

              fOverR = coulomb.forceOverDistanceFromSquaredDistance(rSq, charge1, charge[atom2Idx],
                dielectricConst, realisticDielectricEffect);

              fx = fOverR * dx;
              fy = fOverR * dy;
              ax[atom1Idx] += fx;
              ay[atom1Idx] += fy;
              ax[atom2Idx] -= fx;
              ay[atom2Idx] -= fy;
            }
          }
        },

        updateFrictionForces = function() {
          if (!viscosity) return;

          var i,
              drag;

          for (i = 0; i < N; i++) {
            drag = viscosity * friction[i];

            ax[i] += (-vx[i] * drag);
            ay[i] += (-vy[i] * drag);
          }
        },

        updateRadialBondForces = function() {
          // fast path if no radial bonds have been defined
          if (N_radialBonds < 1) return;

          var i, i1, i2, dx, dy,
              rSq, r, k, r0,
              fOverR, fx, fy;

          for (i = 0; i < N_radialBonds; i++) {
            i1 = radialBondAtom1Index[i];
            i2 = radialBondAtom2Index[i];

            dx = x[i2] - x[i1];
            dy = y[i2] - y[i1];
            rSq = dx*dx + dy*dy;
            r = Math.sqrt(rSq);

            // eV/nm^2
            k = radialBondStrength[i];

            // nm
            r0 = radialBondLength[i];

            // "natural" Next Gen MW force units / nm
            fOverR = constants.convert(k*(r-r0), { from: unit.EV_PER_NM, to: unit.MW_FORCE_UNIT }) / r;

            fx = fOverR * dx;
            fy = fOverR * dy;

            ax[i1] += fx;
            ay[i1] += fy;
            ax[i2] -= fx;
            ay[i2] -= fy;
          }
        },

        updateAngularBondForces = function() {
          // Fast path if no angular bonds have been defined.
          if (N_angularBonds < 1) return;

          var i, i1, i2, i3,
              dxij, dyij, dxkj, dykj, rijSquared, rkjSquared, rij, rkj,
              k, angle, theta, cosTheta, sinTheta,
              forceInXForI, forceInYForI, forceInXForK, forceInYForK,
              commonPrefactor, temp;

          for (i = 0; i < N_angularBonds; i++) {
            i1 = angularBondAtom1Index[i];
            i2 = angularBondAtom2Index[i];
            i3 = angularBondAtom3Index[i];

            // radian
            angle = angularBondAngle[i];

            // (eV/nm * nm) / radian
            k = angularBondStrength[i];

            // Calculate angle (theta) between two vectors:
            // Atom1-Atom3 and Atom2-Atom3
            // Atom1 -> i, Atom2 -> k, Atom3 -> j
            dxij = x[i1] - x[i3];
            dxkj = x[i2] - x[i3];
            dyij = y[i1] - y[i3];
            dykj = y[i2] - y[i3];
            rijSquared = dxij * dxij + dyij * dyij;
            rkjSquared = dxkj * dxkj + dykj * dykj;
            rij = Math.sqrt(rijSquared);
            rkj = Math.sqrt(rkjSquared);
            // Calculate cos using dot product definition.
            cosTheta = (dxij * dxkj + dyij * dykj) / (rij * rkj);
            if (cosTheta > 1.0) cosTheta = 1.0;
            else if (cosTheta < -1.0) cosTheta = -1.0;
            // Pythagorean trigonometric identity.
            sinTheta = Math.sqrt(1.0 - cosTheta * cosTheta);
            // Finally:
            theta = Math.acos(cosTheta);

            if (sinTheta < 0.0001) sinTheta = 0.0001;

            // Calculate force.
            // "natural" Next Gen MW force units / nm
            commonPrefactor = constants.convert(k * (theta - angle) / (sinTheta * rij),
                { from: unit.EV_PER_NM, to: unit.MW_FORCE_UNIT }) / rkj;

            // nm^2
            temp = dxij * dxkj + dyij * dykj;
            // Terms in brackets end up with nm unit.
            // commonPrefactor is in "natural" Next Gen MW force units / nm,
            // so everything is correct.
            forceInXForI = commonPrefactor * (dxkj - temp * dxij / rijSquared);
            forceInYForI = commonPrefactor * (dykj - temp * dyij / rijSquared);
            forceInXForK = commonPrefactor * (dxij - temp * dxkj / rkjSquared);
            forceInYForK = commonPrefactor * (dyij - temp * dykj / rkjSquared);

            ax[i1] += forceInXForI;
            ay[i1] += forceInYForI;
            ax[i2] += forceInXForK;
            ay[i2] += forceInYForK;
            ax[i3] -= (forceInXForI + forceInXForK);
            ay[i3] -= (forceInYForI + forceInYForK);
          }
        },

        // FIXME: eliminate duplication with springForces
        updateRestraintForces = function() {
          // fast path if no restraints have been defined
          if (N_restraints < 1) return;

          var i,
              dx, dy,
              r, r_sq,
              k,
              f_over_r,
              fx, fy,
              a;

          for (i = 0; i < N_restraints; i++) {
            a = restraintAtomIndex[i];

            dx = restraintX0[i] - x[a];
            dy = restraintY0[i] - y[a];

            if (dx === 0 && dy === 0) continue;   // force will be zero

            r_sq = dx*dx + dy*dy;
            r = Math.sqrt(r_sq);

            // eV/nm^2
            k = restraintK[i];

            f_over_r = constants.convert(k*r, { from: unit.EV_PER_NM, to: unit.MW_FORCE_UNIT }) / r;

            fx = f_over_r * dx;
            fy = f_over_r * dy;

            ax[a] += fx;
            ay[a] += fy;
          }
        },

        updateSpringForces = function() {
          if (N_springForces < 1) return;

          var i,
              dx, dy,
              r, r_sq,
              k,
              f_over_r,
              fx, fy,
              a;

          for (i = 0; i < N_springForces; i++) {
            a = springForceAtomIndex[i];

            dx = springForceX[i] - x[a];
            dy = springForceY[i] - y[a];

            if (dx === 0 && dy === 0) continue;   // force will be zero

            r_sq = dx*dx + dy*dy;
            r = Math.sqrt(r_sq);

            // eV/nm^2
            k = springForceStrength[i];

            f_over_r = constants.convert(k*r, { from: unit.EV_PER_NM, to: unit.MW_FORCE_UNIT }) / r;

            fx = f_over_r * dx;
            fy = f_over_r * dy;

            ax[a] += fx;
            ay[a] += fy;
          }
        },

        // Returns center of mass of given atoms set (molecule).
        getMoleculeCenterOfMass = function (molecule) {
          var xcm = 0,
              ycm = 0,
              totalMass = 0,
              atomIdx, atomMass, i, len;

          for (i = 0, len = molecule.length; i < len; i++) {
            atomIdx = molecule[i];
            atomMass = mass[atomIdx];
            xcm += x[atomIdx] * atomMass;
            ycm += y[atomIdx] * atomMass;
            totalMass += atomMass;
          }
          xcm /= totalMass;
          ycm /= totalMass;
          return {x: xcm, y: ycm};
        },

        updateAminoAcidForces = function () {
          // Fast path if there is no solvent defined or it doesn't have impact on AAs.
          if (solventForceType === 0 || solventForceFactor === 0 || N < 2) return;

          var moleculeAtoms, atomIdx, cm, solventFactor,
              dx, dy, r, fx, fy, temp, i, j, len;

          // Reset helper array.
          for (i = 0; i < N; i++) {
            visited[i] = 0;
          }

          // Set multiplier of force produced by the solvent.
          // Constants used in Classic MW: 5 * 0.00001 = 0.00005.
          // Multiply it by 0.01 * 120 = 1.2 to convert from
          // 0.1A * 120amu / fs^2 to nm * amu / fs^2.
          // solventForceType is the same like in Classic MW (unitless).
          // solventForceFactor is a new variable used only in Next Gen MW.
          solventFactor = 0.00006 * solventForceType * solventForceFactor;

          for (i = 0; i < N; i++) {
            // Calculate forces only *once* for amino acid.
            if (visited[i] === 1) continue;

            moleculeAtoms = engine.getMoleculeAtoms(i);
            moleculeAtoms.push(i);

            cm = getMoleculeCenterOfMass(moleculeAtoms);

            for (j = 0, len = moleculeAtoms.length; j < len; j++) {
              atomIdx = moleculeAtoms[j];
              // Mark that atom was part of processed molecule to avoid
              // calculating its molecule again.
              visited[atomIdx] = 1;

              if (hydrophobicity[atomIdx] !== 0) {
                dx = x[atomIdx] - cm.x;
                dy = y[atomIdx] - cm.y;
                r = Math.sqrt(dx * dx + dy * dy);

                if (r > 0) {
                  temp = hydrophobicity[atomIdx] * solventFactor;

                  // AAs being pulled into the center of mass should feel an additional force factor that depends
                  // on distance from the center of mass, ranging between 1 and 25, with 1 being furthest away from the CoM
                  // and 25 being the max when at the CoM or within a certain radius of the CoM. In some ways this
                  // is closer to nature as the core of a protein is less exposed to solvent and thus even more stable.
                  if (temp > 0 && r < additionalSolventForceThreshold) {
                    // Force towards the center of mass, distance from the CoM less than a given threshold.
                    // Multiply force by an additional factor defined by the linear function of 'r' defined by two points:
                    // (0, additionalSolventForceMult) and (additionalSolventForceThreshold, 1).
                    temp *= (1 - additionalSolventForceMult) * r / additionalSolventForceThreshold + additionalSolventForceMult;
                  }

                  fx = temp * dx / r;
                  fy = temp * dy / r;
                  ax[atomIdx] -= fx;
                  ay[atomIdx] -= fy;
                }
              }
            }
          }
        },

        updateGravitationalAccelerations = function() {
          // fast path if there is no gravitationalField
          if (!gravitationalField) return;
          var i;

          for (i = 0; i < N; i++) {
            ay[i] -= gravitationalField;
          }
        },

        // Push all amino acids above some Y coordinate during DNA translation.
        // TODO: this should be part of the MD2D plug-in for proteins engine!
        updateDNATranslationAccelerations = function() {
          if (!dnaTranslationInProgress) return;
          var i, diff;

          for (i = 0; i < N; i++) {
            diff = Math.min(1, 2.2 - y[i]);
            if (diff > 0) {
              ay[i] += 1e-4 * diff;
              ax[i] -= 3e-6;
            }
          }
        },

        // ####################################################################
        // #               Integration main helper functions.                 #
        // ####################################################################

        // For now, calculate only structures used by proteins engine.
        // TODO: move there calculation of various optimization structures like chargedAtomLists.
        calculateOptimizationStructures = function () {
          var cysteineEl = aminoacidsHelper.cysteineElement,
              idx, i;

          // Reset optimization data structure.
          freeCysteinesList.length = 0;

          for (i = 0; i < N; i++) {
            if (element[i] === cysteineEl) {
              // At the beginning, assume that each cysteine is "free" (ready to create disulfide bond).
              freeCysteinesList.push(i);
            }
          }

          for (i = 0; i < N_radialBonds; i++) {
            if (element[radialBondAtom1Index[i]] === cysteineEl && element[radialBondAtom2Index[i]] === cysteineEl) {
              // Two cysteines are already bonded, so remove them from freeCysteinsList.
              idx = freeCysteinesList.indexOf(radialBondAtom1Index[i]);
              if (idx !== -1) arrays.remove(freeCysteinesList, idx);
              idx = freeCysteinesList.indexOf(radialBondAtom2Index[i]);
              if (idx !== -1) arrays.remove(freeCysteinesList, idx);
            }
          }
        },

        // Accumulate acceleration into a(t + dt) from all possible interactions, fields
        // and forces connected with atoms.
        updateParticlesAccelerations = function () {
          var i, inverseMass;

          if (N === 0) return;

          // Zero out a(t) for accumulation of forces into a(t + dt).
          for (i = 0; i < N; i++) {
            ax[i] = ay[i] = 0;
          }

          // Check if the neighbor list should be recalculated.
          updateNeighborList = neighborList.shouldUpdate(x, y);

          if (updateNeighborList) {
            // Clear both lists.
            cellList.clear();
            neighborList.clear();

            for (i = 0; i < N; i++) {
              // Add particle to appropriate cell.
              cellList.addToCell(i, x[i], y[i]);
              // And save its initial position
              // ("initial" = position during neighbor list creation).
              neighborList.saveAtomPosition(i, x[i], y[i]);
            }
          }

          // ######################################
          // ax and ay are FORCES below this point
          // ######################################

          // Accumulate forces into a(t + dt) for all pairwise interactions between
          // particles:
          // Short-range forces (Lennard-Jones interaction).
          console.time('short-range forces');
          updateShortRangeForces();
          console.timeEnd('short-range forces');
          // Long-range forces (Coulomb interaction).
          console.time('long-range forces');
          updateLongRangeForces();
          console.timeEnd('long-range forces');

          // Accumulate forces from radially bonded interactions into a(t + dt).
          updateRadialBondForces();

          // Accumulate forces from angularly bonded interactions into a(t + dt).
          updateAngularBondForces();

          // Accumulate forces from restraint forces into a(t + dt).
          updateRestraintForces();

          // Accumulate forces from spring forces into a(t + dt).
          updateSpringForces();

          // Accumulate drag forces into a(t + dt).
          updateFrictionForces();

          // Apply forces caused by the hydrophobicity.
          // Affects only amino acids in the water or oil solvent.
          updateAminoAcidForces();

          // Convert ax, ay from forces to accelerations!
          for (i = 0; i < N; i++) {
            inverseMass = 1/mass[i];
            ax[i] *= inverseMass;
            ay[i] *= inverseMass;
          }

          // ############################################
          // ax and ay are ACCELERATIONS below this point
          // ############################################

          // Accumulate optional gravitational accelerations into a(t + dt).
          updateGravitationalAccelerations();

          // Push all amino acids above some Y coordinate during DNA translation.
          // TODO: this should be part of the MD2D plug-in for proteins engine!
          updateDNATranslationAccelerations();
        },

        // Half of the update of v(t + dt) and p(t + dt) using a. During a single integration loop,
        // call once when a = a(t) and once when a = a(t+dt).
        halfUpdateVelocity = function() {
          var i, m;
          for (i = 0; i < N; i++) {
            m = mass[i];
            vx[i] += 0.5 * ax[i] * dt;
            px[i] = m * vx[i];
            vy[i] += 0.5 * ay[i] * dt;
            py[i] = m * vy[i];
          }
        },

        // Calculate r(t + dt, i) from v(t + 0.5 * dt).
        updateParticlesPosition = function() {
          var width100  = size[0] * 100,
              height100 = size[1] * 100,
              xPrev, yPrev, i;

          for (i = 0; i < N; i++) {
            xPrev = x[i];
            yPrev = y[i];

            x[i] += vx[i] * dt;
            y[i] += vy[i] * dt;

            // Simple check if model has diverged. Prevents web browser from crashing.
            // isNaN tests not only x, y, but also vx, vy, ax, ay as test is done after
            // updateParticlesPosition(). If a displacement during one step is larger than width * 100
            // (or height * 100) it means that the velocity is far too big for the current time step.
            if (isNaN(x[i]) || isNaN(y[i]) ||
                Math.abs(x[i]) > width100 || Math.abs(y[i]) > height100) {
              throw new Error("Model has diverged!");
            }

            // Bounce off walls.
            bounceParticleOffWalls(i);
            // Bounce off obstacles, update pressure probes.
            bounceParticleOffObstacles(i, xPrev, yPrev, true);
            // Bounce off rectangles
            bounceParticleOffRectangles(i, xPrev, yPrev);
          }
        },

        // Removes velocity and acceleration from pinned atoms.
        pinAtoms = function() {
          var i;

          for (i = 0; i < N; i++) {
            if (pinned[i]) {
              vx[i] = vy[i] = ax[i] = ay[i] = 0;
            }
          }
        },

        // Update speed using velocities.
        updateParticlesSpeed = function() {
          var i;

          for (i = 0; i < N; i++) {
            speed[i] = Math.sqrt(vx[i] * vx[i] + vy[i] * vy[i]);
          }
        },

        // Calculate new obstacles position using simple integration method.
        updateObstaclesPosition = function() {
          var ax, ay, vx, vy,
              drag, extFx, extFy, i;

          for (i = 0; i < N_obstacles; i++) {
            // Fast path when obstacle isn't movable.
            if (obstacleMass[i] === Infinity) continue;

            vx = obstacleVX[i],
            vy = obstacleVY[i],
            // External forces are defined per mass unit!
            // So, they are accelerations in fact.
            extFx = obstacleExtAX[i],
            extFy = obstacleExtAY[i];

            if (vx || vy || extFx || extFy || gravitationalField) {
              drag = viscosity * obstacleFriction[i];
              ax = extFx - drag * vx;
              ay = extFy - drag * vy - gravitationalField;

              obstacleXPrev[i] = obstacleX[i];
              obstacleYPrev[i] = obstacleY[i];

              // Update positions.
              obstacleX[i] += vx * dt + 0.5 * ax * dt_sq;
              obstacleY[i] += vy * dt + 0.5 * ay * dt_sq;

              // Update velocities.
              obstacleVX[i] += ax * dt;
              obstacleVY[i] += ay * dt;

              bounceObstacleOffWalls(i);
            }
          }
        },

        // Sets total momentum of each molecule to zero.
        // Useful for proteins engine.
        zeroTotalMomentumOfMolecules = function() {
          var moleculeAtoms, atomIdx, sumX, sumY, invMass,
              i, j, len;

          for (i = 0; i < N; i++) {
            visited[i] = 0;
          }

          for (i = 0; i < N; i++) {
            // Process each particular atom only *once*.
            if (visited[i] === 1) continue;

            moleculeAtoms = engine.getMoleculeAtoms(i);
            if (moleculeAtoms.length === 0) continue;
            moleculeAtoms.push(i);

            sumX = sumY = invMass = 0;
            for (j = 0, len = moleculeAtoms.length; j < len; j++) {
              atomIdx = moleculeAtoms[j];
              // Mark that atom was part of processed molecule to avoid
              // calculating its molecule again.
              visited[atomIdx] = 1;
              if (!pinned[atomIdx]) {
                sumX += vx[atomIdx] * mass[atomIdx];
                sumY += vy[atomIdx] * mass[atomIdx];
                invMass += mass[atomIdx];
              }
            }
            invMass = 1.0 / invMass;
            for (j = 0, len = moleculeAtoms.length; j < len; j++) {
              atomIdx = moleculeAtoms[j];
              if (!pinned[atomIdx]) {
                vx[atomIdx] -= sumX * invMass;
                vy[atomIdx] -= sumY * invMass;
                // Update momentum.
                px[atomIdx] = vx[atomIdx] * mass[atomIdx];
                py[atomIdx] = vy[atomIdx] * mass[atomIdx];
              }
            }
          }
        },

        adjustTemperature = function(target, forceAdjustment) {
          var rescalingFactor, i;

          if (target == null) target = T_target;

          T = computeTemperature();

          if (T === 0) {
            // Special case when T is 0.
            for (i = 0; i < N; i++) {
              if (pinned[i] === false) {
                // Add some random velocity to unpinned atoms.
                vx[i] = Math.random() * 0.02 - 0.01;
                vy[i] = Math.random() * 0.02 - 0.01;
              }
            }
            // Update temperature.
            T = computeTemperature();

            if (T === 0) {
              // This means that all atoms are pinned. Nothing to do.
              return;
            }
          }

          if (temperatureChangeInProgress && Math.abs(getTWindowed(T) - target) <= target * tempTolerance) {
            temperatureChangeInProgress = false;
          }

          if (forceAdjustment || useThermostat || temperatureChangeInProgress && T > 0) {
            rescalingFactor = Math.sqrt(target / T);

            // Scale particles velocity.
            for (i = 0; i < N; i++) {
              vx[i] *= rescalingFactor;
              vy[i] *= rescalingFactor;
              px[i] *= rescalingFactor;
              py[i] *= rescalingFactor;
            }

            // Scale obstacles velocity.
            for (i = 0; i < N_obstacles; i++) {
              obstacleVX[i] *= rescalingFactor;
              obstacleVY[i] *= rescalingFactor;
            }

            T = target;
          }
        },

        // Two cysteine AAs can form a covalent bond between their sulphur atoms. We could model this such that
        // when two Cys AAs come close enough a covalent bond is formed (only one between a pair of cysteines).
        createDisulfideBonds = function () {
          var cys1Idx, cys2Idx, xDiff, yDiff, rSq, i, j, len;

          for (i = 0, len = freeCysteinesList.length; i < len; i++) {
            cys1Idx = freeCysteinesList[i];
            for (j = i + 1; j < len; j++) {
              cys2Idx = freeCysteinesList[j];

              xDiff = x[cys1Idx] - x[cys2Idx];
              yDiff = y[cys1Idx] - y[cys2Idx];
              rSq = xDiff * xDiff + yDiff * yDiff;

              // Check whether cysteines are close enough to each other.
              // As both are in the freeCysteinesList, they are not connected.
              if (rSq < 0.07) {
                // Connect cysteines.
                engine.addRadialBond({
                  atom1: cys1Idx,
                  atom2: cys2Idx,
                  length: Math.sqrt(rSq),
                  // Default strength of bonds between amino acids.
                  strength: 10000,
                  // Disulfide bond type.
                  type: 109
                });

                // Remove both cysteines from freeCysteinesList.
                arrays.remove(freeCysteinesList, i);
                arrays.remove(freeCysteinesList, j);

                // Update len, cys1Idx, j as freeCysteinesList has changed.
                // Not very pretty, but probably the fastest way.
                len = freeCysteinesList.length;
                cys1Idx = freeCysteinesList[i];
                j = i + 1;
              }
            }
          }
        },

        // ### Pressure calculation ###

        // Zero values of pressure probes. It should be called
        // at the beginning of the integration step.
        zeroPressureValues = function () {
          var i;
          for (i = 0; i < N_obstacles; i++) {
            if (obstacleNorthProbe[i]) {
              obstacleNProbeValue[i] = 0;
            }
            if (obstacleSouthProbe[i]) {
              obstacleSProbeValue[i] = 0;
            }
            if (obstacleEastProbe[i]) {
              obstacleEProbeValue[i] = 0;
            }
            if (obstacleWestProbe[i]) {
              obstacleWProbeValue[i] = 0;
            }
          }
        },

        // Update probes values so they contain final pressure value in Bar.
        // It should be called at the end of the integration step.
        calculateFinalPressureValues = function (duration) {
          var mult, i;
          // Classic MW converts impulses 2mv/dt to pressure in Bar using constant: 1666667.
          // See: the header of org.concord.mw2d.models.RectangularObstacle.
          // However, Classic MW also uses different units for mass and length:
          // - 120amu instead of 1amu,
          // - 0.1A instead of 1nm.
          // We should convert mass, velocity and obstacle height to Next Gen units.
          // Length units reduce themselves (velocity divided by height or width), only mass is left.
          // So, divide classic MW constant 1666667 by 120 - the result is 13888.89.
          // [ There is unit module available, however for reduction of computational cost,
          // include conversion in the pressure constant, especially considering the fact that
          // conversion from 120amu to amu is quite simple. ]
          mult = 13888.89 / duration;
          for (i = 0; i < N_obstacles; i++) {
            if (obstacleNorthProbe[i]) {
              obstacleNProbeValue[i] *= mult / obstacleWidth[i];
            }
            if (obstacleSouthProbe[i]) {
              obstacleSProbeValue[i] *= mult / obstacleWidth[i];
            }
            if (obstacleEastProbe[i]) {
              obstacleEProbeValue[i] *= mult / obstacleHeight[i];
            }
            if (obstacleWestProbe[i]) {
              obstacleWProbeValue[i] *= mult / obstacleHeight[i];
            }
          }
        };

        // ####################################################################
        // ####################################################################

    engine = {

      // Adds a new plugin. Plugin will be initialized with the object arrys, so that
      // it can add to them as necessary, and will then be registered in the controller,
      // allowing it to respond to functions passed to the controller from arbitrary
      // points in the md2d code.
      addPlugin: function(plugin) {
        if (plugin.initialize) {
          // plugins can update the data arrays as needed so we pass in the arrays.
          // we do this as an object, so we can add new arrays as needed by the plugins
          // without needing to update all existing plugins
          plugin.initialize({atoms: atoms, elements: elements});
        }

        pluginController.registerPlugin(plugin);
      },

      useCoulombInteraction: function(v) {
        useCoulombInteraction = !!v;
      },

      useLennardJonesInteraction: function(v) {
        useLennardJonesInteraction = !!v;
      },

      useThermostat: function(v) {
        useThermostat = !!v;
      },

      setVDWLinesRatio: function(vdwlr) {
        if (typeof vdwlr === "number" && vdwlr !== 0) {
          vdwLinesRatio = vdwlr;
        }
      },

      setGravitationalField: function(gf) {
        if (typeof gf === "number" && gf !== 0) {
          gravitationalField = gf;
        } else {
          gravitationalField = false;
        }
      },

      setTemperatureOfAtoms: function(atomIndices, targetT) {

        var i, j, vxtmp, vytmp, smallT, smallKE, scale, s, groupT,
            nGroup = atomIndices.length;

        // Assign a random direction and speed to atoms with velocity exactly equal to 0 (e.g.
        // cooled drastically or newly created). This ensures that we don't just rescale the
        // velocities of the (possibly small or nonexistent) group of atoms that already have some
        // velocity. After rescaling, the net effect is to transfer some velocity from moving atoms
        // to non-moving atoms.

        // Pick a small temperature to assign to non-moving atoms
        smallT = (computeTemperatureOfAtoms(atomIndices) || targetT) * 0.0001;
        smallKE = convertTtoKE(smallT, 1);

        // Assign moveable, non-moving atoms a small temperature
        for (i = 0; i < nGroup; i++) {
          j = atomIndices[i];
          if (!pinned[j] && vx[j] === 0 && vy[j] === 0) {
            vxtmp = Math.random() - 0.5;
            vytmp = Math.random() - 0.5;
            s  = Math.sqrt( (2*smallKE/mass[j]) / (vxtmp*vxtmp + vytmp*vytmp) );
            vx[j] = vxtmp * s;
            vy[j] = vytmp * s;
          }
        }

        T      = computeTemperature();
        groupT = computeTemperatureOfAtoms(atomIndices);

        scale = Math.sqrt( targetT / groupT );

        for (i = 0; i < nGroup; i++) {
          j = atomIndices[i];
          engine.setAtomProperties(j, {
            vx: vx[j] * scale,
            vy: vy[j] * scale
          });
        }
      },

      getTemperatureOfAtoms: function(atomIndices) {
        return computeTemperatureOfAtoms(atomIndices);
      },

      setTargetTemperature: function(v) {
        validateTemperature(v);
        T_target = v;
      },

      setDielectricConstant: function(dc) {
        dielectricConst = dc;
      },

      setRealisticDielectricEffect: function (r) {
        realisticDielectricEffect = r;
      },

      setSolventForceType: function(sft) {
        solventForceType = sft;
      },

      setDNAState: function (s) {
        // Don't store DNAState, it's not necessary. Just
        // information whether translation is in progress is useful.
        dnaTranslationInProgress = s.indexOf("translation:") === 0;
      },

      setSolventForceFactor: function(sff) {
        solventForceFactor = sff;
      },

      setAdditionalSolventForceMult: function(asfm) {
        additionalSolventForceMult = asfm;
      },

      setAdditionalSolventForceThreshold: function(asft) {
        additionalSolventForceThreshold = asft;
      },

      // Our timekeeping is really a convenience for users of this lib, so let them reset time at will
      setTime: function(t) {
        time = t;
      },

      setDimensions: function(v) {
        // NB. We may want to create a simple state diagram for the md engine (as well as for the 'modeler' defined in
        // lab.molecules.js)
        if (sizeHasBeenInitialized) {
          throw new Error("The molecular model's size has already been set, and cannot be reset.");
        }
        minX = v[0];
        minY = v[1];
        maxX = v[2];
        maxY = v[3];
        size = [maxX - minX, maxY - minY];
        sizeHasBeenInitialized = true;
      },

      getDimensions: function() {
        return [minX, minY, maxX, maxY];
      },

      getLJCalculator: function() {
        return ljCalculator;
      },

      setAtomProperties: function (i, props) {
        var cysteineEl = aminoacidsHelper.cysteineElement,
            key, idx, rest, amino, j;

        if (props.element !== undefined) {
          if (props.element < 0 || props.element >= N_elements) {
            throw new Error("md2d: Unknown element " + props.element + ", an atom can't be created.");
          }

          // Special case when cysteine AA is morphed into other AA type,
          // which can't create disulphide bonds. Remove a connected
          // disulphide bond if it exists.
          if (element[i] === cysteineEl && props.element !== cysteineEl) {
            for (j = 0; j < N_radialBonds; j++) {
              if ((radialBondAtom1Index[j] === i || radialBondAtom2Index[j] === i) &&
                   radialBondType[j] === 109) {
                // Remove the radial bond representing disulphide bond.
                engine.removeRadialBond(j);
                // One cysteine can create only one disulphide bond so there is no need to continue the loop.
                break;
              }
            }
          }

          // Mark element as used by some atom (used by performance optimizations).
          elementUsed[props.element] = true;

          // Update mass and radius when element is changed.
          props.mass   = elementMass[props.element];
          props.radius = elementRadius[props.element];

          if (aminoacidsHelper.isAminoAcid(props.element)) {
            amino = aminoacidsHelper.getAminoAcidByElement(props.element);
            // Setup properties which are relevant to amino acids.
            props.charge = amino.charge;
            // Note that we overwrite value set explicitly in the hash.
            // So, while setting element of atom, it's impossible to set also its charge.
            props.hydrophobicity = amino.hydrophobicity;
          }
        }

        // Update charged atoms list (performance optimization).
        if (!charge[i] && props.charge) {
          // !charge[i]   => shortcut for charge[i] === 0 || charge[i] === undefined (both cases can occur).
          // props.charge => shortcut for props.charge !== undefined && props.charge !== 0.
          // Save index of charged atom.
          chargedAtomsList.push(i);
        } else if (charge[i] && props.charge === 0) {
          // charge[i] => shortcut for charge[i] !== undefined && charge[i] !== 0 (both cases can occur).
          // Remove index from charged atoms list.
          idx = chargedAtomsList.indexOf(i);
          rest = chargedAtomsList.slice(idx + 1);
          chargedAtomsList.length = idx;
          Array.prototype.push.apply(chargedAtomsList, rest);
        }
        // Update optimization flag.
        hasChargedAtoms = !!chargedAtomsList.length;

        // Set all properties from props hash.
        for (key in props) {
          if (props.hasOwnProperty(key)) {
            atoms[key][i] = props[key];
          }
        }

        // Update properties which depend on other properties.
        px[i]    = vx[i] * mass[i];
        py[i]    = vy[i] * mass[i];
        speed[i] = Math.sqrt(vx[i] * vx[i] + vy[i] * vy[i]);
      },

      setRadialBondProperties: function(i, props) {
        var key, atom1Idx, atom2Idx;

        // Unset current radial bond matrix entry.
        // Matrix will be updated when new properties are set.
        atom1Idx = radialBondAtom1Index[i];
        atom2Idx = radialBondAtom2Index[i];
        if (radialBondMatrix[atom1Idx] && radialBondMatrix[atom1Idx][atom2Idx])
          radialBondMatrix[atom1Idx][atom2Idx] = false;
        if (radialBondMatrix[atom2Idx] && radialBondMatrix[atom2Idx][atom1Idx])
          radialBondMatrix[atom2Idx][atom1Idx] = false;

        // Set all properties from props hash.
        for (key in props) {
          if (props.hasOwnProperty(key)) {
            radialBonds[key][i]       = props[key];
            // Update radial bond results also.
            radialBondResults[i][key] = props[key];
          }
        }

        // Update radial bond matrix.
        atom1Idx = radialBondAtom1Index[i];
        atom2Idx = radialBondAtom2Index[i];
        if (!radialBondMatrix[atom1Idx]) radialBondMatrix[atom1Idx] = [];
        radialBondMatrix[atom1Idx][atom2Idx] = true;
        if (!radialBondMatrix[atom2Idx]) radialBondMatrix[atom2Idx] = [];
        radialBondMatrix[atom2Idx][atom1Idx] = true;
      },

      setAngularBondProperties: function(i, props) {
        var key;
        // Set all properties from props hash.
        for (key in props) {
          if (props.hasOwnProperty(key)) {
            angularBonds[key][i] = props[key];
          }
        }
      },

      setRestraintProperties: function(i, props) {
        var key;
        // Set all properties from props hash.
        for (key in props) {
          if (props.hasOwnProperty(key)) {
            restraints[key][i] = props[key];
          }
        }
      },

      setElementProperties: function(i, properties) {
        var j, newRadius;
        // FIXME we cached mass into its own array, which is now probably unnecessary (position-update
        // calculations have since been speeded up by batching the computation of accelerations from
        // forces.) If we remove the mass[] array we also remove the need for the loop below:

        if (properties.mass != null && properties.mass !== elementMass[i]) {
            elementMass[i] = properties.mass;
          for (j = 0; j < N; j++) {
            if (element[j] === i) mass[j] = properties.mass;
          }
        }

        if (properties.sigma != null) {
          elementSigma[i] = properties.sigma;
          newRadius = lennardJones.radius(properties.sigma);

          if (elementRadius[i] !== newRadius) {
            elementRadius[i] = newRadius;
            for (j = 0; j < N; j++) {
              if (element[j] === i) radius[j] = newRadius;
            }
          }
        }

        if (properties.epsilon != null) elementEpsilon[i] = properties.epsilon;

        if (properties.color != null) {
          elementColor[i] = properties.color;
        }

        for (j = 0; j < N_elements; j++) {
          setPairwiseLJProperties(i, j);
        }
        // Reinitialize optimization structures, as sigma can be changed.
        initializeCellList();
        initializeNeighborList();
      },

      setPairwiseLJProperties: function (i, j) {
        // Call private (closure) version of this funcion.
        setPairwiseLJProperties(i, j);
        // Reinitialize optimization structures, as sigma can be changed.
        initializeCellList();
        initializeNeighborList();
      },

      setObstacleProperties: function (i, props) {
        var key;

        if (!engine.canPlaceObstacle(props.x, props.y, props.width, props.height, i))
          throw new Error("Obstacle can't be placed at " + props.x + ", " + props.y);

        // If position is manually changed, update previous
        // position also.
        if (props.x !== undefined) {
          props.xPrev = props.x;
        }
        if (props.y !== undefined) {
          props.yPrev = props.y;
        }
        // Try to parse mass, as it may be string "Infinity".
        if (typeof props.mass === 'string') {
          props.mass = parseFloat(props.mass);
        }

        // Set properties from props hash.
        for (key in props) {
          if (props.hasOwnProperty(key)) {
            obstacles[key][i] = props[key];
          }
        }
      },

      setRectangleProperties: function (i, props) {
        var key;
        // Set properties from props hash.
        for (key in props) {
          if (props.hasOwnProperty(key)) {
            rectangles[key][i] = props[key];
          }
        }
      },

      /**
        The canonical method for adding an atom to the collections of atoms.

        If there isn't enough room in the 'atoms' array, it (somewhat inefficiently)
        extends the length of the typed arrays by ten to have room for more atoms.

        @returns the index of the new atom
      */
      addAtom: function(props) {
        if (N + 1 > atoms.x.length) {
          utils.extendArrays(atoms, N + 10);
          assignShortcutReferences.atoms();
        }

        // Set acceleration of new atom to zero.
        props.ax = props.ay = 0;

        // Increase number of atoms.
        N++;

        // Set provided properties of new atom.
        engine.setAtomProperties(N - 1, props);

        // Initialize helper structures for optimizations.
        initializeCellList();
        initializeNeighborList();
      },

      removeAtom: function(idx) {
        var i, len, prop,
            l, list, lists;

        if (idx >= N) {
          throw new Error("Atom " + idx + " doesn't exist, so it can't be removed.");
        }

        // Start from removing all bonds connected to this atom.
        // Note that we are removing only radial bonds. Angular bonds
        // will be removed while removing radial bond, not atom!

        // Use such "strange" form of loop, as while removing one bonds,
        // other change their indexing. So, after removal of bond 5, we
        // should check bond 5 again, as it would be another bond (previously
        // indexed as 6).
        i = 0;
        while (i < N_radialBonds) {
          if (radialBondAtom1Index[i] === idx || radialBondAtom2Index[i] === idx)
            engine.removeRadialBond(i);
          else
            i++;
        }

        // Try to remove atom from charged atoms list.
        i = chargedAtomsList.indexOf(idx);
        if (i !== -1) {
          arrays.remove(chargedAtomsList, i);
        }


        // Finally, remove atom.

        // Shift atoms properties and zero last element.
        // It can be optimized by just replacing the last
        // atom with atom 'i', however this approach
        // preserves more expectable atoms indexing.
        for (i = idx; i < N; i++) {
          for (prop in atoms) {
            if (atoms.hasOwnProperty(prop)) {
              if (i === N - 1)
                atoms[prop][i] = 0;
              else
                atoms[prop][i] = atoms[prop][i + 1];
            }
          }
        }

        // Update number of atoms!
        N--;

        // Shift indices of atoms in various lists.
        lists = [
          chargedAtomsList,
          radialBondAtom1Index, radialBondAtom2Index,
          angularBondAtom1Index, angularBondAtom2Index, angularBondAtom3Index
        ];

        for (l = 0; l < lists.length; l++) {
          list = lists[l];
          for (i = 0, len = list.length; i < len; i++) {
            if (list[i] > idx)
              list[i]--;
          }
        }

        // Also in radial bonds results...
        // TODO: they should be recalculated while computing output state.
        for (i = 0, len = radialBondResults.length; i < len; i++) {
          if (radialBondResults[i].atom1 > idx)
            radialBondResults[i].atom1--;
          if (radialBondResults[i].atom2 > idx)
            radialBondResults[i].atom2--;
        }

        // Recalculate radial bond matrix, as indices have changed.
        calculateRadialBondMatrix();

        // (Re)initialize helper structures for optimizations.
        initializeCellList();
        initializeNeighborList();

        neighborList.invalidate();

        // Update accelerations of atoms.
        updateParticlesAccelerations();
      },

      /**
        The canonical method for adding an element.
      */
      addElement: function(props) {
        var i;

        if (N_elements >= elementEpsilon.length) {
          utils.extendArrays(elements, N_elements + 10);
          assignShortcutReferences.elements();
        }

        elementMass[N_elements]    = props.mass;
        elementEpsilon[N_elements] = props.epsilon;
        elementSigma[N_elements]   = props.sigma;
        elementRadius[N_elements]  = lennardJones.radius(props.sigma);
        elementColor[N_elements]   = props.color;

        ljCalculator[N_elements]              = [];
        cutoffDistance_LJ_sq[N_elements]      = [];
        cutoffNeighborListSquared[N_elements] = [];

        for (i = 0; i <= N_elements; i++) {
          setPairwiseLJProperties(N_elements, i);
        }
        // Note that we don't have to reinitialize optimization
        // structures (cell lists and neighbor list). They are
        // based only on the properties of *used* elements, so
        // adding a new atom should trigger reinitialization instead.

        N_elements++;
      },

      /**
        The canonical method for adding a radial bond to the collection of radial bonds.
      */
      addRadialBond: function(props) {
        if (N_radialBonds + 1 > radialBondAtom1Index.length) {
          utils.extendArrays(radialBonds, N_radialBonds + 10);
          assignShortcutReferences.radialBonds();
        }

        N_radialBonds++;

        // Add results object.
        radialBondResults[N_radialBonds - 1] = {idx: N_radialBonds - 1};
        // Set new radial bond properties.
        engine.setRadialBondProperties(N_radialBonds - 1, props);
      },

      removeRadialBond: function(idx) {
        var i, prop, atom1, atom2;

        if (idx >= N_radialBonds) {
          throw new Error("Radial bond " + idx + " doesn't exist, so it can't be removed.");
        }

        // Start from removing angular bonds.
        atom1 = radialBondAtom1Index[idx];
        atom2 = radialBondAtom2Index[idx];

        // Use such "strange" form of loop, as while removing one bonds,
        // other change their indexing. So, after removal of bond 5, we
        // should check bond 5 again, as it would be another bond (previously
        // indexed as 6).
        i = 0;
        while (i < N_angularBonds) {
          // Remove angular bond only when one of atoms is the CENTRAL atom of the given angular bond.
          // It means that this radial bond creates given angular bond.
          // Atom3Index is index of central atom in angular bonds.
          if (angularBondAtom3Index[i] === atom1 || angularBondAtom3Index[i] === atom2)
            engine.removeAngularBond(i);
          else
            i++;
        }

        // Shift radial bonds properties and zero last element.
        // It can be optimized by just replacing the last
        // radial bond with radial bond 'i', however this approach
        // preserves more expectable indexing.
        // TODO: create some general function for that, as it's duplicated
        // in each removeObject method.
        for (i = idx; i < N_radialBonds; i++) {
          for (prop in radialBonds) {
            if (radialBonds.hasOwnProperty(prop)) {
              if (i === N_radialBonds - 1)
                radialBonds[prop][i] = 0;
              else
                radialBonds[prop][i] = radialBonds[prop][i + 1];
            }
          }
        }

        N_radialBonds--;

        arrays.remove(radialBondResults, idx);

        // Recalculate radial bond matrix.
        calculateRadialBondMatrix();
      },

      /**
        The canonical method for adding an 'restraint' bond to the collection of restraints.

        If there isn't enough room in the 'restraints' array, it (somewhat inefficiently)
        extends the length of the typed arrays by ten to have room for more bonds.
      */
      addRestraint: function(props) {
        if (N_restraints + 1 > restraints.atomIndex.length) {
          utils.extendArrays(restraints, N_restraints + 10);
          assignShortcutReferences.restraints();
        }

        N_restraints++;

        // Set new restraint properties.
        engine.setRestraintProperties(N_restraints - 1, props);
      },

      /**
        The canonical method for adding an angular bond to the collection of angular bonds.

        If there isn't enough room in the 'angularBonds' array, it (somewhat inefficiently)
        extends the length of the typed arrays by ten to have room for more bonds.
      */
      addAngularBond: function(props) {
        if (N_angularBonds + 1 > angularBonds.atom1.length) {
          utils.extendArrays(angularBonds, N_angularBonds + 10);
          assignShortcutReferences.angularBonds();
        }

        N_angularBonds++;

        // Set new angular bond properties.
        engine.setAngularBondProperties(N_angularBonds - 1, props);
      },

      removeAngularBond: function(idx) {
        var i, prop;

        if (idx >= N_angularBonds) {
          throw new Error("Angular bond " + idx + " doesn't exist, so it can't be removed.");
        }

        // Shift angular bonds properties and zero last element.
        // It can be optimized by just replacing the last
        // angular bond with angular bond 'i', however this approach
        // preserves more expectable indexing.
        // TODO: create some general function for that, as it's duplicated
        // in each removeObject method.
        for (i = idx; i < N_angularBonds; i++) {
          for (prop in angularBonds) {
            if (angularBonds.hasOwnProperty(prop)) {
              if (i === N_angularBonds - 1)
                angularBonds[prop][i] = 0;
              else
                angularBonds[prop][i] = angularBonds[prop][i + 1];
            }
          }
        }

        N_angularBonds--;
      },

      /**
        Adds a spring force between an atom and an x, y location.

        @returns the index of the new spring force.
      */
      addSpringForce: function(atomIndex, x, y, strength) {
        // conservatively just add one spring force
        if (N_springForces + 1 > springForces[0].length) {
          utils.extendArrays(springForces, N_springForces + 1);
          assignShortcutReferences.springForces();
        }

        springForceAtomIndex[N_springForces]  = atomIndex;
        springForceX[N_springForces]          = x;
        springForceY[N_springForces]          = y;
        springForceStrength[N_springForces]   = strength;

        return N_springForces++;
      },

      updateSpringForce: function(i, x, y) {
        springForceX[i] = x;
        springForceY[i] = y;
      },

      removeSpringForce: function(idx) {
        var i, j;

        if (idx >= N_springForces) {
          throw new Error("Spring force " + idx + " doesn't exist, so it can't be removed.");
        }

        N_springForces--;

        // Shift spring forces properties.
        for (i = idx; i < N_springForces; i++) {
          for (j = 0; j < 4; j++) {
            springForces[j][i] = springForces[j][i + 1];
          }
        }
      },

      springForceAtomIndex: function(i) {
        return springForceAtomIndex[i];
      },

      addObstacle: function(props) {
        if (!engine.canPlaceObstacle(props.x, props.y, props.width, props.height))
          throw new Error("Obstacle can't be placed at " + props.x + ", " + props.y + ".");

        if (N_obstacles + 1 > obstacles.x.length) {
          // Extend arrays each time (as there are only
          // a few obstacles in typical model).
          utils.extendArrays(obstacles, N_obstacles + 1);
          assignShortcutReferences.obstacles();
        }

        N_obstacles++;

        // Set properties of new obstacle.
        engine.setObstacleProperties(N_obstacles - 1, props);
      },

      removeObstacle: function(idx) {
        var i, prop;

        if (idx >= N_obstacles) {
          throw new Error("Obstacle " + idx + " doesn't exist, so it can't be removed.");
        }

        N_obstacles--;

        // Shift obstacles properties.
        // It can be optimized by just replacing the last
        // obstacle with obstacle 'i', however this approach
        //  preserves more expectable obstacles indexing.
        for (i = idx; i < N_obstacles; i++) {
          for (prop in obstacles) {
            if (obstacles.hasOwnProperty(prop)) {
              obstacles[prop][i] = obstacles[prop][i + 1];
            }
          }
        }

        // FIXME: This shouldn't be necessary, however various modules
        // (e.g. views) use obstacles.x.length as the real number of obstacles.
        utils.extendArrays(obstacles, N_obstacles);
        assignShortcutReferences.obstacles();
      },

      addRectangle: function(props) {
        if (N_rectangles + 1 > rectangles.x.length) {
          // Extend arrays each time (as there are only
          // a few rectangles in typical model).
          utils.extendArrays(rectangles, N_rectangles + 1);
          assignShortcutReferences.rectangles();
        }

        N_rectangles++;

        // Set properties of new rectangle.
        engine.setRectangleProperties(N_rectangles - 1, props);
      },

      removeRectangle: function(idx) {
        var i, prop;

        if (idx >= N_rectangles) {
          throw new Error("Rectangle " + idx + " doesn't exist, so it can't be removed.");
        }

        N_rectangles--;

        // Shift rectangles properties.
        // It can be optimized by just replacing the last
        // rectangle with rectangle 'i', however this approach
        //  preserves more expectable rectangles indexing.
        for (i = idx; i < N_rectangles; i++) {
          for (prop in rectangles) {
            if (rectangles.hasOwnProperty(prop)) {
              rectangles[prop][i] = rectangles[prop][i + 1];
            }
          }
        }

        // FIXME: This shouldn't be necessary, however various modules
        // (e.g. views) use rectangles.x.length as the real number of rectangles.
        utils.extendArrays(rectangles, N_rectangles);
        assignShortcutReferences.rectangles();
      },

      atomInBounds: function(_x, _y, i) {
        var r = radius[i], j;

        if (_x < r || _x > size[0] - r || _y < r || _y > size[1] - r) {
          return false;
        }
        for (j = 0; j < N_obstacles; j++) {
          if (_x > (obstacleX[j] - r) && _x < (obstacleX[j] + obstacleWidth[j] + r) &&
              _y > (obstacleY[j] - r) && _y < (obstacleY[j] + obstacleHeight[j] + r)) {
            return false;
          }
        }
        return true;
      },

      /**
        Checks to see if an uncharged atom could be placed at location x,y
        without increasing the PE (i.e. overlapping with another atom), and
        without being on an obstacle or past a wall.

        Optionally, an atom index i can be included which will tell the function
        to ignore the existance of atom i. (Used when moving i around.)
      */
      canPlaceAtom: function(element, _x, _y, i) {
        var orig_x,
            orig_y,
            PEAtLocation,
            testX, testY, testXMax, testYMax,
            j;

        // first do the simpler check to see if we're outside the walls
        if ( !engine.atomInBounds(_x, _y, i) ) {
          return false;
        }

        // Check collision with obstacles.
        for (j = 0; j < N_obstacles; j++) {
          testX = obstacleX[j];
          testY = obstacleY[j];
          testXMax = testX + obstacleWidth[j];
          testYMax = testY + obstacleHeight[j];
          if ((_x > testX && _x < testXMax) &&
              (_y > testY && _y < testYMax)) {
            return false;
          }
        }

        // then check PE at location
        if (typeof i === "number") {
          orig_x = x[i];
          orig_y = y[i];
          x[i] = y[i] = Infinity;   // move i atom away
        }

        PEAtLocation = engine.newPotentialCalculator(element, 0, false)(_x, _y);

        if (typeof i === "number") {
          x[i] = orig_x;
          y[i] = orig_y;
        }

        return PEAtLocation <= 0;
      },

      /**
        Checks to see if an obstacle could be placed at location x, y
        without being on an atom, another obstacle or past a wall.

        idx parameter is optional. It should be defined and equal to id
        of an existing obstacle when the existing obstacle should be checked.
        It prevents an algorithm from comparing the obstacle with itself during
        collisions detection.
      */
      canPlaceObstacle: function (obsX, obsY, obsWidth, obsHeight, idx) {
        var obsXMax = obsX + obsWidth,
            obsYMax = obsY + obsHeight,
            testX, testY, testXMax, testYMax,
            r, i;

        // Check collision with walls.
        if (obsX < 0 || obsXMax > size[0] || obsY < 0 || obsYMax > size[0]) {
          return false;
        }

        // Check collision with atoms.
        for (i = 0; i < N; i++) {
          r = radius[i];
          if (x[i] > (obsX - r) && x[i] < (obsXMax + r) &&
              y[i] > (obsY - r) && y[i] < (obsYMax + r)) {
            return false;
          }
        }

        // Check collision with other obstacles.
        for (i = 0; i < N_obstacles; i++) {
          if (idx !== undefined && idx === i) {
            // If we are checking existing obstacle,
            // avoid comparing it with itself.
            continue;
          }
          testX = obstacleX[i];
          testY = obstacleY[i];
          testXMax = testX + obstacleWidth[i];
          testYMax = testY + obstacleHeight[i];
          if ((obsXMax > testX && obsX < testXMax) &&
              (obsYMax > testY && obsY < testYMax)) {
            return false;
          }
        }

        return true;
      },

      setupAtomsRandomly: function(options) {

        var // if a temperature is not explicitly requested, we just need any nonzero number
            temperature = options.temperature || 100,

            nrows = Math.floor(Math.sqrt(N)),
            ncols = Math.ceil(N/nrows),

            i, r, c, rowSpacing, colSpacing,
            vMagnitude, vDirection, props;

        validateTemperature(temperature);

        colSpacing = size[0] / (1 + ncols);
        rowSpacing = size[1] / (1 + nrows);

        // Arrange molecules in a lattice. Not guaranteed to have CM exactly on center, and is an artificially low-energy
        // configuration. But it works OK for now.
        i = -1;

        for (r = 1; r <= nrows; r++) {
          for (c = 1; c <= ncols; c++) {
            i++;
            if (i === N) break;
            vMagnitude = math.normal(1, 1/4);
            vDirection = 2 * Math.random() * Math.PI;

            props = {
              element: Math.floor(Math.random() * options.userElements), // random element
              x:       c * colSpacing,
              y:       r * rowSpacing,
              vx:      vMagnitude * Math.cos(vDirection),
              vy:      vMagnitude * Math.sin(vDirection),
              charge:  2 * (i % 2) - 1 // alternate negative and positive charges
            };
            engine.setAtomProperties(i, props);
          }
        }

        // now, remove all translation of the center of mass and rotation about the center of mass
        computeCMMotion();
        removeTranslationAndRotationFromVelocities();

        // Scale randomized velocities to match the desired initial temperature.
        //
        // Note that although the instantaneous temperature will be 'temperature' exactly, the temperature will quickly
        // settle to a lower value because we are initializing the atoms spaced far apart, in an artificially low-energy
        // configuration.
        //
        adjustTemperature(temperature, true);
      },

      getVdwPairsArray: function() {
        var i,
            j,
            dx,
            dy,
            r_sq,
            x_i,
            y_i,
            sigma_i,
            epsilon_i,
            sigma_j,
            epsilon_j,
            index_i,
            index_j,
            sig,
            eps,
            distanceCutoff_sq = vdwLinesRatio * vdwLinesRatio;

        N_vdwPairs = 0;

        for (i = 0; i < N; i++) {
          // pairwise interactions
          index_i = element[i];
          sigma_i   = elementSigma[index_i];
          epsilon_i = elementSigma[index_i];
          x_i = x[i];
          y_i = y[i];

          for (j = i+1; j < N; j++) {
            if (N_radialBonds !== 0 && (radialBondMatrix[i] && radialBondMatrix[i][j])) continue;

            index_j = element[j];
            sigma_j   = elementSigma[index_j];
            epsilon_j = elementSigma[index_j];

            if (charge[i]*charge[j] <= 0) {
              dx = x[j] - x_i;
              dy = y[j] - y_i;
              r_sq = dx*dx + dy*dy;


              sig = 0.5 * (sigma_i+sigma_j);
              sig *= sig;
              eps = epsilon_i * epsilon_j;

              if (r_sq < sig * distanceCutoff_sq && eps > 0) {
                if (N_vdwPairs + 1 > vdwPairs.atom1.length) {
                  utils.extendArrays(vdwPairs, (N_vdwPairs + 1) * 2);
                  assignShortcutReferences.vdwPairs();
                }
                vdwPairAtom1Index[N_vdwPairs] = i;
                vdwPairAtom2Index[N_vdwPairs] = j;
                N_vdwPairs++;
              }
            }
          }
        }

        vdwPairs.count = N_vdwPairs;
        return vdwPairs;
      },

      relaxToTemperature: function(T) {

        // FIXME this method needs to be modified. It should rescale velocities only periodically
        // and stop when the temperature approaches a steady state between rescalings.

        if (T != null) T_target = T;

        validateTemperature(T_target);

        beginTransientTemperatureChange();
        while (temperatureChangeInProgress) {
          engine.integrate();
        }
      },

      // Velocity Verlet integration scheme.
      // See: http://en.wikipedia.org/wiki/Verlet_integration#Velocity_Verlet
      // The current implementation is:
      // 1. Calculate: v(t + 0.5 * dt) = v(t) + 0.5 * a(t) * dt
      // 2. Calculate: r(t + dt) = r(t) + v(t + 0.5 * dt) * dt
      // 3. Derive a(t + dt) from the interaction potential using r(t + dt)
      // 4. Calculate: v(t + dt) = v(t + 0.5 * dt) + 0.5 * a(t + dt) * dt
      integrate: function(duration, _dt) {
        var steps, iloop, tStart = time;

        // How much time to integrate over, in fs.
        if (duration === undefined)  duration = 100;

        // The length of an integration timestep, in fs.
        if (_dt === undefined) _dt = 1;

        dt = _dt;        // dt is a closure variable that helpers need access to
        dt_sq = dt * dt; // the squared time step is also needed by some helpers.

        // Prepare optimization structures to ensure that they are valid during integration.
        // Note that when user adds or removes various objects (like atoms, bonds), such structures
        // can become invalid. That's why we update them each time before integration.
        // It's also safer and easier to do recalculate each structure than to modify it while
        // engine state is changed by user.
        calculateOptimizationStructures();

        // Calculate accelerations a(t), where t = 0.
        // Later this is not necessary, as a(t + dt) from
        // previous step is used as a(t) in the current step.
        if (time === 0) {
          updateParticlesAccelerations();
        }

        // Number of steps.
        steps = Math.floor(duration / dt);

        // Zero values of pressure probes at the beginning of
        // each integration step.
        zeroPressureValues();

        for (iloop = 1; iloop <= steps; iloop++) {
          time = tStart + iloop * dt;

          // Calculate v(t + 0.5 * dt) using v(t) and a(t).
          halfUpdateVelocity();

          // Update r(t + dt) using v(t + 0.5 * dt).
          updateParticlesPosition();

          // Accumulate accelerations into a(t + dt) from all possible interactions, fields
          // and forces connected with atoms.
          updateParticlesAccelerations();

          // Clearing the acceleration here from pinned atoms will cause the acceleration
          // to be zero for both halfUpdateVelocity methods and updateParticlesPosition, freezing the atom.
          pinAtoms();

          // Calculate v(t + dt) using v(t + 0.5 * dt) and a(t + dt).
          halfUpdateVelocity();

          // Now that we have velocity v(t + dt), update speed.
          updateParticlesSpeed();

          // Move obstacles using very simple integration.
          updateObstaclesPosition();

          // Adjust temperature, e.g. when heat bath is enabled.
          adjustTemperature();

          // If solvent is different from vacuum (water or oil), ensure that
          // the total momentum of each molecule is equal to zero. This
          // prevents amino acids chains from drifting towards one boundary of
          // the model. Don't do it during translation process to let the protein
          // freely fold.
          if (solventForceType !== 0 && !dnaTranslationInProgress) {
            zeroTotalMomentumOfMolecules();
          }

          pluginController.callPluginFunction('performActionWithinIntegrationLoop', [neighborList, dt]);

        } // end of integration loop

        // Collisions between particles and obstacles are collected during
        // updateParticlesPosition() execution. This function takes into account
        // time which passed and converts raw data from pressure probes to value
        // in Bars.
        calculateFinalPressureValues(duration);

        // After each integration loop try to create new disulfide bonds between cysteines.
        // It's enough to do it outside the inner integration loop (performance).
        createDisulfideBonds();
      },

      // Minimize energy using steepest descend method.
      minimizeEnergy: function () {
            // Maximal length of displacement during one step of minimization.
        var stepLength   = 1e-3,
            // Maximal acceleration allowed.
            accThreshold = 1e-4,
            // Maximal number of iterations allowed.
            iterLimit    = 3000,
            maxAcc, delta, xPrev, yPrev, i, iter;

        // Calculate accelerations.
        updateParticlesAccelerations();
        pinAtoms();
        // Get maximum value.
        maxAcc = 0;
        for (i = 0; i < N; i++) {
          if (maxAcc < Math.abs(ax[i]))
            maxAcc = Math.abs(ax[i]);
          if (maxAcc < Math.abs(ay[i]))
            maxAcc = Math.abs(ay[i]);
        }

        iter = 0;
        while (maxAcc > accThreshold && iter < iterLimit) {
          iter++;

          delta = stepLength / maxAcc;
          for (i = 0; i < N; i++) {
            xPrev = x[i];
            yPrev = y[i];
            x[i] += ax[i] * delta;
            y[i] += ay[i] * delta;

            // Keep atoms in bounds.
            bounceParticleOffWalls(i);
            // Bounce off obstacles, but DO NOT update pressure probes.
            bounceParticleOffObstacles(i, xPrev, yPrev, false);
            // Bounce off rectangles
            bounceParticleOffRectangles(i, xPrev, yPrev);
          }

          // Calculate accelerations.
          updateParticlesAccelerations();
          pinAtoms();
          // Get maximum value.
          maxAcc = 0;
          for (i = 0; i < N; i++) {
            if (maxAcc < Math.abs(ax[i]))
              maxAcc = Math.abs(ax[i]);
            if (maxAcc < Math.abs(ay[i]))
              maxAcc = Math.abs(ay[i]);
          }
        }
      },

      getRadialBondsForAtom: function(index) {
        var rbonds = [],
            i,
            i1,
            i2;

        for (i = 0; i < N_radialBonds; i++) {
          i1 = radialBondAtom1Index[i];
          i2 = radialBondAtom2Index[i];
          if (index === i1 || index === i2) {
            rbonds.push(i);
          }
        }
        return rbonds;
      },

      getAngularBondsForAtom: function(index) {
        var abonds = [],
            i,
            i1,
            i2,
            i3;

        for (i = 0; i < N_angularBonds; i++) {
          i1 = angularBondAtom1Index[i];
          i2 = angularBondAtom2Index[i];
          i3 = angularBondAtom3Index[i];
          if (index === i1 || index === i2 || index === i3) {
            abonds.push(i);
          }
        }
        return abonds;
      },

      // Total mass of all particles in the system, in Dalton (atomic mass units).
      getTotalMass: function() {
        var totalMass = 0, i;
        for (i = 0; i < N; i++) {
          totalMass += mass[i];
        }
        return totalMass;
      },

      getRadiusOfElement: function(el) {
        return elementRadius[el];
      },

      getNumberOfAtoms: function() {
        return N;
      },

      getNumberOfElements: function() {
        return N_elements;
      },

      getNumberOfObstacles: function() {
        return N_obstacles;
      },

			getNumberOfRectangles: function() {
        return N_rectangles;
      },

      getNumberOfRadialBonds: function() {
        return N_radialBonds;
      },

      getNumberOfAngularBonds: function() {
        return N_angularBonds;
      },

      getNumberOfRestraints: function() {
        return N_restraints;
      },

      getNumberOfSpringForces: function() {
        return N_springForces;
      },

      /**
        Compute the model state and store into the passed-in 'state' object.
        (Avoids GC hit of throwaway object creation.)
      */
      // TODO: [refactoring] divide this function into smaller chunks?
      computeOutputState: function(state) {
        var i, j,
            i1, i2, i3,
            el1, el2,
            dx, dy,
            dxij, dyij, dxkj, dykj,
            cosTheta, theta,
            r_sq, rij, rkj,
            k, dr, angleDiff,
            gravPEInMWUnits,
            // Total kinetic energy, in MW units.
            KEinMWUnits,
            // Potential energy, in eV.
            PE;

        // Calculate potentials in eV. Note that we only want to do this once per call to integrate(), not once per
        // integration loop!
        PE = 0;
        KEinMWUnits = 0;

        for (i = 0; i < N; i++) {

          // gravitational PE
          if (gravitationalField) {
            gravPEInMWUnits = mass[i] * gravitationalField * y[i];
            PE += constants.convert(gravPEInMWUnits, { from: unit.MW_ENERGY_UNIT, to: unit.EV });
          }

          KEinMWUnits += 0.5 * mass[i] * (vx[i] * vx[i] + vy[i] * vy[i]);

          // pairwise interactions
          for (j = i+1; j < N; j++) {
            dx = x[j] - x[i];
            dy = y[j] - y[i];

            r_sq = dx*dx + dy*dy;

            // FIXME the signs here don't really make sense
            if (useLennardJonesInteraction) {
              PE -=ljCalculator[element[i]][element[j]].potentialFromSquaredDistance(r_sq);
            }
            if (useCoulombInteraction && hasChargedAtoms) {
              PE += coulomb.potential(Math.sqrt(r_sq), charge[i], charge[j], dielectricConst, realisticDielectricEffect);
            }
          }
        }

        // radial bonds
        for (i = 0; i < N_radialBonds; i++) {
          i1 = radialBondAtom1Index[i];
          i2 = radialBondAtom2Index[i];
          el1 = element[i1];
          el2 = element[i2];

          dx = x[i2] - x[i1];
          dy = y[i2] - y[i1];
          r_sq = dx*dx + dy*dy;

          // eV/nm^2
          k = radialBondStrength[i];

          // nm
          dr = Math.sqrt(r_sq) - radialBondLength[i];

          PE += 0.5*k*dr*dr;

          // Remove the Lennard Jones potential for the bonded pair
          if (useLennardJonesInteraction) {
            PE += ljCalculator[el1][el2].potentialFromSquaredDistance(r_sq);
          }
          if (useCoulombInteraction && charge[i1] && charge[i2]) {
            PE -= coulomb.potential(Math.sqrt(r_sq), charge[i1], charge[i2], dielectricConst, realisticDielectricEffect);
          }

          // Also save the updated position of the two bonded atoms
          // in a row in the radialBondResults array.
          radialBondResults[i].x1 = x[i1];
          radialBondResults[i].y1 = y[i1];
          radialBondResults[i].x2 = x[i2];
          radialBondResults[i].y2 = y[i2];
        }

        // Angular bonds.
        for (i = 0; i < N_angularBonds; i++) {
          i1 = angularBondAtom1Index[i];
          i2 = angularBondAtom2Index[i];
          i3 = angularBondAtom3Index[i];

          // Calculate angle (theta) between two vectors:
          // Atom1-Atom3 and Atom2-Atom3
          // Atom1 -> i, Atom2 -> k, Atom3 -> j
          dxij = x[i1] - x[i3];
          dxkj = x[i2] - x[i3];
          dyij = y[i1] - y[i3];
          dykj = y[i2] - y[i3];
          rij = Math.sqrt(dxij * dxij + dyij * dyij);
          rkj = Math.sqrt(dxkj * dxkj + dykj * dykj);
          // Calculate cos using dot product definition.
          cosTheta = (dxij * dxkj + dyij * dykj) / (rij * rkj);
          if (cosTheta > 1.0) cosTheta = 1.0;
          else if (cosTheta < -1.0) cosTheta = -1.0;
          theta = Math.acos(cosTheta);

          // Finally, update PE.
          // radian
          angleDiff = theta - angularBondAngle[i];
          // angularBondStrength unit: eV/radian^2
          PE += 0.5 * angularBondStrength[i] * angleDiff * angleDiff;
        }

        // update PE for 'restraint' bonds
        for (i = 0; i < N_restraints; i++) {
          i1 = restraintAtomIndex[i];
          el1 = element[i1];

          dx = restraintX0[i] - x[i1];
          dy = restraintY0[i] - y[i1];
          r_sq = dx*dx + dy*dy;

          // eV/nm^2
          k = restraintK[i];

          // nm
          dr = Math.sqrt(r_sq);

          PE += 0.5*k*dr*dr;
       }

        // Process all obstacles.
        for (i = 0; i < N_obstacles; i++) {

          if (obstacleMass[i] !== Infinity) {
            // Gravitational potential energy.
            if (gravitationalField) {
              gravPEInMWUnits = obstacleMass[i] * gravitationalField * obstacleY[i];
              PE += constants.convert(gravPEInMWUnits, { from: unit.MW_ENERGY_UNIT, to: unit.EV });
            }
            // Kinetic energy.
            KEinMWUnits += 0.5 * obstacleMass[i] *
                (obstacleVX[i] * obstacleVX[i] + obstacleVY[i] * obstacleVY[i]);
          }
        }

        // Update temperature.
        T = convertKEtoT(KEinMWUnits, N);

        // "macro" state
        state.time           = time;
        state.PE             = PE;
        state.KE             = constants.convert(KEinMWUnits, { from: unit.MW_ENERGY_UNIT, to: unit.EV });
        state.temperature    = T;
        state.pCM            = [px_CM, py_CM]; // TODO: GC optimization? New array created each time.
        state.CM             = [x_CM, y_CM];
        state.vCM            = [vx_CM, vy_CM];
        state.omega_CM       = omega_CM;

        // "micro" state. TODO: put radial bonds, etc here.
        state.atoms = atoms;
      },


      /**
        Given a test element and charge, returns a function that returns for a location (x, y) in nm:
         * the potential energy, in eV, of an atom of that element and charge at location (x, y)
         * optionally, if calculateGradient is true, the gradient of the potential as an
           array [gradX, gradY]. (units: eV/nm)
      */
      newPotentialCalculator: function(testElement, testCharge, calculateGradient) {

        return function(testX, testY) {
          var PE = 0,
              fx = 0,
              fy = 0,
              gradX,
              gradY,
              ljTest = ljCalculator[testElement],
              i,
              dx,
              dy,
              r_sq,
              r,
              f_over_r,
              lj;

          for (i = 0; i < N; i++) {
            dx = testX - x[i];
            dy = testY - y[i];
            r_sq = dx*dx + dy*dy;
            f_over_r = 0;

            if (useLennardJonesInteraction) {
              lj = ljTest[element[i]];
              PE += -lj.potentialFromSquaredDistance(r_sq, testElement, element[i]);
              if (calculateGradient) {
                f_over_r += lj.forceOverDistanceFromSquaredDistance(r_sq);
              }
            }

            if (useCoulombInteraction && hasChargedAtoms && testCharge) {
              r = Math.sqrt(r_sq);
              PE += -coulomb.potential(r, testCharge, charge[i], dielectricConst, realisticDielectricEffect);
              if (calculateGradient) {
                f_over_r += coulomb.forceOverDistanceFromSquaredDistance(r_sq, testCharge, charge[i],
                  dielectricConst, realisticDielectricEffect);
              }
            }

            if (f_over_r) {
              fx += f_over_r * dx;
              fy += f_over_r * dy;
            }
          }

          if (calculateGradient) {
            gradX = constants.convert(fx, { from: unit.MW_FORCE_UNIT, to: unit.EV_PER_NM });
            gradY = constants.convert(fy, { from: unit.MW_FORCE_UNIT, to: unit.EV_PER_NM });
            return [PE, [gradX, gradY]];
          }

          return PE;
        };
      },

      /**
        Starting at (x,y), try to find a position which minimizes the potential energy change caused
        by adding at atom of element el.
      */
      findMinimumPELocation: function(el, x, y, charge) {
        var pot    = engine.newPotentialCalculator(el, charge, true),
            radius = elementRadius[el],

            res =  math.minimize(pot, [x, y], {
              bounds: [ [radius, size[0]-radius], [radius, size[1]-radius] ]
            });

        if (res.error) return false;
        return res[1];
      },

      /**
        Starting at (x,y), try to find a position which minimizes the square of the potential energy
        change caused by adding at atom of element el, i.e., find a "farthest from everything"
        position.
      */
      findMinimumPESquaredLocation: function(el, x, y, charge) {
        var pot = engine.newPotentialCalculator(el, charge, true),

            // squared potential energy, with gradient
            potsq = function(x,y) {
              var res, f, grad;

              res = pot(x,y);
              f = res[0];
              grad = res[1];

              // chain rule
              grad[0] *= (2*f);
              grad[1] *= (2*f);

              return [f*f, grad];
            },

            radius = elementRadius[el],

            res = math.minimize(potsq, [x, y], {
              bounds: [ [radius, size[0]-radius], [radius, size[1]-radius] ],
              stopval: 1e-4,
              precision: 1e-6
            });

        if (res.error) return false;
        return res[1];
      },

      atomsInMolecule: [],
      depth: 0,

      /**
        Returns all atoms in the same molecule as atom i
        (not including i itself)
      */
      getMoleculeAtoms: function(i) {
        this.atomsInMolecule.push(i);

        var moleculeAtoms = [],
            bondedAtoms = this.getBondedAtoms(i),
            depth = this.depth,
            j, jj,
            atomNo;

        this.depth++;

        for (j=0, jj=bondedAtoms.length; j<jj; j++) {
          atomNo = bondedAtoms[j];
          if (!~this.atomsInMolecule.indexOf(atomNo)) {
            moleculeAtoms = moleculeAtoms.concat(this.getMoleculeAtoms(atomNo)); // recurse
          }
        }
        if (depth === 0) {
          this.depth = 0;
          this.atomsInMolecule = [];
        } else {
          moleculeAtoms.push(i);
        }
        return moleculeAtoms;
      },

      /**
        Returns all atoms directly bonded to atom i
      */
      getBondedAtoms: function(i) {
        var bondedAtoms = [],
            j, jj;
        if (radialBonds) {
          for (j = 0, jj = N_radialBonds; j < jj; j++) {
            // console.log("looking at bond from "+radialBonds)
            if (radialBondAtom1Index[j] === i) {
              bondedAtoms.push(radialBondAtom2Index[j]);
            }
            if (radialBondAtom2Index[j] === i) {
              bondedAtoms.push(radialBondAtom1Index[j]);
            }
          }
        }
        return bondedAtoms;
      },

      getCoulombForceAt: function(testX, testY, resultObj) {
        // Let client code reuse objects.
        resultObj = resultObj || {};
        // Fast path if Coulomb interaction is disabled or there are no charged atoms.
        if (!useCoulombInteraction || !hasChargedAtoms) {
          resultObj.fx = resultObj.fy = 0;
          return resultObj;
        }

        var fx = 0, fy = 0,
            i, len, dx, dy, rSq, fOverR, atomCharge, atomIdx;

        for (i = 0, len = chargedAtomsList.length; i < len; i++) {
          atomIdx = chargedAtomsList[i];
          atomCharge = charge[atomIdx];

          dx = x[atomIdx] - testX;
          dy = y[atomIdx] - testY;
          rSq = dx * dx + dy * dy;

          fOverR = coulomb.forceOverDistanceFromSquaredDistance(rSq, 1, atomCharge,
            dielectricConst, realisticDielectricEffect);

          fx += fOverR * dx;
          fy += fOverR * dy;
        }
        resultObj.fx = constants.convert(fx, { from: unit.MW_FORCE_UNIT, to: unit.EV_PER_NM });
        resultObj.fy = constants.convert(fy, { from: unit.MW_FORCE_UNIT, to: unit.EV_PER_NM });
        return resultObj;
      },

      /**
        Returns Kinetic Energy of single atom i, in eV.
      */
      getAtomKineticEnergy: function(i) {
        var KEinMWUnits = 0.5 * mass[i] * (vx[i] * vx[i] + vy[i] * vy[i]);
        return constants.convert(KEinMWUnits, { from: unit.MW_ENERGY_UNIT, to: unit.EV });
      },

      getAtomNeighbors: function(idx) {
        var res = [],
            list = neighborList.getList(),
            i, len;

        for (i = neighborList.getStartIdxFor(idx), len = neighborList.getEndIdxFor(idx); i < len; i++) {
          res.push(list[i]);
        }
        return res;
      },

      getNeighborList: function () {
        return neighborList;
      },

      setViscosity: function(v) {
        viscosity = v;
      },

      // ######################################################################
      //                State definition of the engine

      // Return array of objects defining state of the engine.
      // Each object in this list should implement following interface:
      // * .clone()        - returning complete state of that object.
      // * .restore(state) - restoring state of the object, using 'state'
      //                     as input (returned by clone()).
      getState: function() {
        var state = [
          // Use wrapper providing clone-restore interface to save the hashes-of-arrays
          // that represent model state.
          new CloneRestoreWrapper(elements),
          new CloneRestoreWrapper(atoms),
          new CloneRestoreWrapper(obstacles),
          new CloneRestoreWrapper(rectangles),
          new CloneRestoreWrapper(radialBonds),
          new CloneRestoreWrapper(angularBonds),
          new CloneRestoreWrapper(restraints),
          new CloneRestoreWrapper(springForces),
          // PairwiseLJProperties class implements Clone-Restore Interface.
          pairwiseLJProperties,

          // Also save toplevel state (time, number of atoms, etc):
          {
            clone: function () {
              return {
                time          : time,
                N             : N,
                N_elements    : N_elements,
                N_obstacles   : N_obstacles,
                N_rectangles  : N_rectangles,
                N_radialBonds : N_radialBonds,
                N_angularBonds: N_angularBonds,
                N_restraints  : N_restraints,
                N_springForces: N_springForces
              };
            },
            restore: function(state) {
              time           = state.time;
              N              = state.N;
              N_elements     = state.N_elements;
              N_rectangles   = state.N_rectangles;
              N_radialBonds  = state.N_radialBonds;
              N_angularBonds = state.N_angularBonds;
              N_restraints   = state.N_restraints;
              N_springForces = state.N_springForces;
            }
          }
        ];

        pluginController.callPluginFunction('getState', [], function(pluginState) {
          state = state.concat(pluginState);
        });

        return state;
      },

      // FIXME. Not a sustainable pattern. This is just a temporary pass-through of modeler-level
      // methods that are implemented in the quantumDynamics plugin, because for now the plugin is
      // only callable from the engine.
      callPluginAccessor: function(accessorMethodName) {
        var returnValue;
        pluginController.callPluginFunction(accessorMethodName, [], function(_) {
          returnValue = _;
        });
        return returnValue;
      }
    };



    // Initialization
    initialize();

    // Export initialized objects to Public API.
    // To ensure that client code always has access to these public properties,
    // they should be initialized  only once during the engine lifetime (in the initialize method).
    engine.pairwiseLJProperties = pairwiseLJProperties;

    // Finally, return Public API.
    return engine;
  };
});

/*global define: false, d3: false */
/**

  This module provides support which Lab model types can use to implement observable properties that
  have custom getters, setters, and validation. It is specialized for the needs of interactive,
  computationally intensive simulations which want to enable UI bindings to simulation-state
  variables that evolve in time and change at potentially every clock tick.

  For example, if the model object using PropertySupport is 'model':

    > model.addObserver('kineticEnergy', function() { console.log(model.properties.kineticEnergy); })
    > model.start()
    3.10225948103683
    3.102259509874652
    3.1022595094558194
    ...
    > model.addObserver('property', function() { console.log('property changed!'); })
    > model.properties.property = 1
    property changed!
    > model.properties.property
    1

  Or, using the "legacy" interface:

    > model.addObserver('kineticEnergy', function() { console.log(model.get('kineticEnergy'); })
    > model.start()
    3.10225948103683
    3.102259509874652
    3.1022595094558194
    ...
    > model.addObserver('property', function() { console.log('property changed!'); })
    > model.set('property', 1)
    property changed!
    > model.get('property')
    1

  The design of this module differs in several ways than the property support implemented by general
  web MVC frameworks such as Backbone, Ember, and Angular.

  First, we assume that the properties module is used to enable UI binding and state saving for a
  simulation engine which has its own internal data structures and which executes many iterations of
  its inner loop between each screen refresh. As a result, we must assume that any computed property
  can change between "clock ticks" and that most computed properties are not simple functions of
  the value of other properties. Therefore we provide mechanisms that must be explicitly invoked by
  the model to synchronize the engine's internal state to the exposed property values when the
  engine considers it appropriate to do so.

  Second, we assume that the most properties are numbers that represent physical quantities that
  either parameterize the simulation or are computed by it.

  Third, we assume that, the simulation may need to save and restore the values of a subset of
  properties outside the usual setter/getter cycle. Specifically, we allow the simulation to define
  two subsets of properties: one that represents the entire set of properties required to restore
  the state of the model, for use when saving the model to storage; and a smaller subset of
  properties that represent the time-varying state of the model, for use when rewinding or fast-
  forwarding the model while it retains the remainder of its state in memory.

*/
define('common/property-support',[],function() {

  // If at all possible, avoid adding dependencies to this module.

  // These are the properties that can be passed as the 'descriptor' argument to defineProperty.
  var descriptorProperties = {

    /**
      A getter function that will be executed whenever the value of this property is read.

      Use this, for example, to make a property reflect internal state of the simulation.

      The property will be considered a "computed property" if and only if it has a getter. The
      return value of the getter is considered the "raw" property value and will be passed through
      the afterGetTransform, if one is defined, to generate the final value of the property.

      The (untransformed) raw getter value will be cached unless the enableCaching property of the
      propertySupport object is false. The cache can be cleared by calling the
      deleteComputedPropertyCachedValues method of the propertySupport object. The caching normally
      occurs lazily, but paired calls to the storeComputedProperties and
      notifyChangedComputedProperties methods of the propertySupport object cause all properties
      with getters to be computed and then recomputed, triggering notification of the observers of
      properties whose value changed between the calls.

      Optional.
    */
    get: {
      defaultValue: undefined,
      type: 'function'
    },

    /**
      A setter function that will be executed when the value of this property is assigned.

      Use this, for example, to modify simulation state when the property is changed.

      Note that this function is not required to store the value in any way; a corresponding getter
      does not need to be defined, although one could be. This setter is normally executed just to
      make sure the correct side effects occur when a property assignment is made.

      The value received by this function is a "raw" value. That is, if the value of this property
      is set "normally", then the value is first passed through the beforeSetTransform, if one is
      defined, and the transformed value is passed to this function. (If that sounds backwards,
      consider "raw" values to be of the type operated on by the simulation engine; transformed
      values are what are visible in the user interface.)

      The set function is called whenever a normal assignment is made to the property, but it may or
      may not be called when the property value is set "behind the scenes" by the setRawValues
      method. It will be called if and onlyh if this property key is present in the hash sent to
      setRawValues *and* the invokeSetterAfterBulkRestore descriptor value for this property is
      true.

      This is useful for distinguishing between properties whose setters must manipulate private
      state variables when they are called, and properties whose setter action operates entirely
      by setting publicly visible
    */
    set: {
      defaultValue: undefined,
      type: 'function'
    },

    /**
      A function that will be called with the new, "raw" value of this property whenever the
      property is assigned to.

      This function *must* return input value if it is correct. If the value is invalid,
      the validate function should throw an exception. Note that custom validate function
      can be used to autmatically "fix" the value (e.g. change lower case to upper case or
      do any other transformation related to notation of the value).

      The validate function is *not* called when the property value is set via setRawValues.
    */
    validate: {
      defaultValue: undefined,
      type: 'function'
    },

    /**
      A callback that is called before assignment to the property. (Exception: it is not called
      when the value is set via the setRawValues method of propertySupport.)

      Use this to detect changes which may cause other property values to need to be updated.

      For convenience, the property key is passed to the callback. The callback's return value is
      discarded.
    */
    beforeSetCallback: {
      defaultValue: undefined,
      type: 'function'
    },

    /**
      A callback that is called after assignment to the property. (Exception: it is not called
      when the value is set via the setRawValues method of propertySupport.)

      Use this to detect changes which may cause other property values to need to be updated.

      For convenience, the property key is passed to the callback. The callback's return value is
      discarded.
    */
    afterSetCallback: {
      defaultValue: undefined,
      type: 'function'
    },

    /**
      A function that is called with the return value of the get method whenever this property value
      is read. The value returned by this function is returned as the value of the property.

      If the transform is not defined, no transform is applied and the value of the property is
      simply the value returned by the get method.

      The expected use of this transform (and the associated beforeSetTransform) is to allow the
      same simulation engine to appear to operate at different length scales. Currently, the MD2D
      engine uses afterGetTransforms to convert values that are nominally in microscopic units (nm,
      for example) to values in a macroscopic unit system (m).
    */
    afterGetTransform: {
      defaultValue: undefined,
      type: 'function'
    },

    /**
      A function that is called to transform the property value to a "raw" value which is passed to
      the set function whenever this property is assigned to.

      If the transform is not defined, no transform is applied and the value that is assigned to the
      property is the value that is passed to the set method.
    */
    beforeSetTransform: {
      defaultValue: undefined,
      type: 'function'
    },

    /**
      If true, the property is considered read-only (and, practically speaking, must have a getter).

      Attempts to assign to the property will throw an error whether the property is directly
      assigned to or a value for the property is passed to the setRawValues method of the
      propertySupport object.

      Note that the native 'writable' property of ES5 Object descriptors does not apply to accessor
      properties (those with setters and getters, such as we construct in this module).
    */
    writable: {
      defaultValue: true,
      type: 'boolean'
    },

    /**
      If true, then the raw value of this property will be included in historyStateRawValues hash.
    */
    includeInHistoryState: {
      defaultValue: false,
      type: 'boolean'
    },

    /**
      If true, and this property's descriptor also includes a set function, then the set function
      will be called when the value of this property is updated via the setRawValues method of the
      PropertySupport object.

      If false, setRawValues will update the property without calling the set method.

      It is useful to set this to false for properties whose setter action operates entirely by
      directly or indirectly manipulating other properties. When setRawValues is used to restore the
      value of those properties during navigation of simulation history, it would be undesirable to
      repeat the setter action as it is entirely accounted for by the value of the other properties.
    */
    invokeSetterAfterBulkRestore: {
      defaultValue: true,
      type: 'boolean'
    },

    /**
      A string that represents the user-defined categorization of this property.

      When the propertySupport object is initialized, it can be passed a list of strings
      containing the different property types the engine wishes to use to categorize its properties.

      PRopertySupport mixes into its target object a method called propertiesOfType which can be
      used to filter the set of properties by category

      (For example, MD2D defines "mainProperties", "viewOptions", "parameters", and "outputs")
    */
    type: {
      defaultValue: undefined,
      type: 'propertyType'
    },

    /**
      An arbitrary object that will be returned when this property's key is passed to the
      getPropertyDescription method of the target object.

      Use this (possibly combined with enumeration and categorization of properties) to expose the
      list of properties to client code for use by e.g,. a UI builder or live scripting help.
    */
    description: {
      defaultValue: undefined
    }
  };

  function validateIsType(type, propertyKey, value) {
    // This is sufficient for functions and strings, which is all we test for.
    if (typeof value !== type) {
      throw new TypeError(propertyKey + " must be a " + type + ".");
    }
  }

  function copy(a) {
    var ret = [];
    a.forEach(function(item) {
      ret.push(item);
    });
    return ret;
  }

  // Constructs a propertySupport object for use by client code. Client code (e.g., models) can maintain a
  // private reference to the propertySupport objectg and delegate property handling to it, and they
  // can optionally call the mixInto method of the propertySupport method to mix in a useful set of
  // public-facing methods and properties.

  // Accepts an args object with an optional 'types' arg, which should be a list of strings that
  // represent user-defined categories of properties.
  return function PropertySupport(args) {

    var propertyTypes = args && args.types && copy(args.types) || [],
        propertyInformation = {},
        cachedPropertiesObjects = {
          all: undefined,
          byType: {}
        },
        cachingIsEnabled = true,
        notificationsAreBatched = false,

        dispatch = d3.dispatch("beforeInvalidatingChange",
                               "afterInvalidatingChange",
                               "afterInvalidatingChangeSequence"),

        invalidatingChangeNestingLevel = 0,
        suppressInvalidatingChangeHooks = false,

        // all properties that were notified while notifications were batched
        changedPropertyKeys = [],

        // all properties with a getter
        computedPropertyKeys = [],

        // all properties for which includeInHistoryState is true
        historyStatePropertyKeys = [],

        // public API
        api;


    // observed properties with a getter
    function observedComputedPropertyKeys() {
      return computedPropertyKeys.filter(function(key) {
        return propertyInformation[key].observers.length > 0;
      });
    }

    function validateIsPropertyType(value) {
      if (propertyTypes.indexOf(value) < 0) {
        throw new TypeError(value + " is not a recognized property type.");
      }
    }

    // Copy the properties described in descriptorProperties from 'descriptor' to return value;
    // validate each value of descriptor according to descriptorProperties[key].type and,
    // if no value is supplied for a given key in 'descriptor' use the default value specified
    // in descriptorProperties[key].default
    function validateDescriptor(descriptor) {
      var ret = {};

      Object.keys(descriptorProperties).forEach(function(key) {
        var descriptorProperty = descriptorProperties[key];

        if (descriptor[key] !== undefined) {
          ret[key] = descriptor[key];
          switch (descriptorProperty.type) {
            case 'boolean':
              ret[key] = !!ret[key];
              break;
            case 'function':
              validateIsType('function', key, descriptor[key]);
              break;
            case 'string':
              validateIsType('string', key, descriptor[key]);
              break;
            case 'propertyType':
              validateIsPropertyType(descriptor[key]);
              break;
          }
        } else {
          ret[key] = descriptorProperty.defaultValue;
        }
      });

      return ret;
    }

    // Given a list of callbacks, invoke each one in order, but skip repeats.
    function notifyCallbacksOnce(callbacks) {
      var called = [];
      callbacks.forEach(function(callback) {
        // TODO: explore ES6 Map/WeakMap shim that would allow this check to happen in O(1)
        if (called.indexOf(callback) < 0) {
          callback();
          called.push(callback);
        }
      });
    }

    // Execute closure after setting a flag which causes the notify function to queue a list of
    // notified properties, rather than notifying their observers immediately. After the closure
    // finishes, notify the observers, making sure to call each callback at most once.
    function withBatchedNotifications(closure) {
      var callbacks = [];

      notificationsAreBatched = true;
      closure();
      notificationsAreBatched = false;

      changedPropertyKeys.forEach(function(key) {
        propertyInformation[key].observers.forEach(function(callback) {
          callbacks.push(callback);
        });
      });
      changedPropertyKeys = [];
      notifyCallbacksOnce(callbacks);
    }

    // Notify observers of the passed-in property immediately if notifications are not batched
    // (see withBatchedNotifications), or else queue the passed-in property key for later
    // notification
    function notify(key) {
      if (notificationsAreBatched) {
        changedPropertyKeys.push(key);
      } else {
        notifyCallbacksOnce(propertyInformation[key].observers);
      }
    }

    // Private implementation of the getter for the property specified by 'key'. Handles caching
    // concerns, but not afterGetTransform, etc.
    function get(key) {
      var info = propertyInformation[key];

      if (!info.descriptor.get) {
        return info.cachedValue;
      }

      if (cachingIsEnabled) {
        if (!info.hasCachedValue) {
          info.hasCachedValue = true;
          info.cachedValue = info.descriptor.get();
        }
        return info.cachedValue;
      }
      return info.descriptor.get();
    }

    // Private implementation of the setter for the property specified by 'key'. Handles caching
    // and the writable check (which, remember, is always applied) but does not handle observer
    // notification, validation, the beforeSetTransform, or beforeSet/afterSet callbacks.
    function set(key, value) {
      var info = propertyInformation[key];

      if (!info.descriptor.writable) {
        throw new Error("Attempt to set read-only property " + key);
      }

      if (info.descriptor.get && !cachingIsEnabled) {
        info.hasCachedValue = false;
      } else {
        info.hasCachedValue = true;
        info.cachedValue = value;
      }
    }

    function invalidateCachedPropertiesObjects(type) {
      cachedPropertiesObjects.all = undefined;
      if (type) {
        cachedPropertiesObjects.byType[type] = undefined;
      }
    }

    // This is the meat. Adds an enumerable property to the properties object returned by the
    // propertySupport object, with custom getters and setters that implement the behavior supported
    // by this module.
    function constructProperty(object, key) {
      var info = propertyInformation[key];

      Object.defineProperty(object, key, {
        enumerable:   true,
        configurable: false,

        // This is the publicly-accessible getter for the property. This is invoked whenever the
        // property is read via code such as `var value = model.properties[key]`, or when the `get`
        // method mixed into the target is called (this might look like `model.get(key)`). It is
        // not invoked when a 'raw values' hash is constructed by the historyStateRawValues or
        // rawValues property accessors.
        get: function() {
          var value = get(key);
          if (info.descriptor.afterGetTransform) {
            value = info.descriptor.afterGetTransform(value);
          }
          return value;
        },

        // This is the publicly-accessible setter for the property. It is invoked whenever the
        // property is assigned to via code such as `model.properties[key] = value;`, or when the
        // `set` method mixed into the target is called (this might look like `model.set(key,
        // value)`). It is never invoked when the setRawValues method of the propertySupport object
        // is called.
        //
        // If beforeSetCallback or afterSetCallback properties have been defined on propertySupport,
        // then they will be called, respectively, before and after the body of this function
        // executes. Note again that setRawValues bypasses these callbacks.
        set: function(value) {
          if (info.descriptor.beforeSetCallback) {
            info.descriptor.beforeSetCallback();
          }

          if (info.descriptor.beforeSetTransform) {
            value = info.descriptor.beforeSetTransform(value);
          }
          if (info.descriptor.validate) {
            value = info.descriptor.validate(value);
          }

          set(key, value);

          if (info.descriptor.set) {
            info.descriptor.set(value);
          }

          if (info.descriptor.afterSetCallback) {
            info.descriptor.afterSetCallback();
          }

          notify(key);
        }
      });
    }

    // Private support for the `properties` and `propertiesOfType` accessor and method of the
    // propertySupport object. Returns the cached properties object if one exists, or constructs a
    // new one. Note that adding a property to the list of properties invalidates the cached object,
    // forcing construction of a new one when it is requested.
    function getPropertiesObject(type) {
      var object = type ? cachedPropertiesObjects.byType[type] : cachedPropertiesObjects.all;

      if (!object) {
        object = {};
        Object.keys(propertyInformation).forEach(function(key) {
          if (!type || type === propertyInformation[key].descriptor.type) {
            constructProperty(object, key);
          }
        });

        if (Object.seal) {
          Object.seal(object);
        }

        if (type) {
          cachedPropertiesObjects.byType[type] = object;
        } else {
          cachedPropertiesObjects.all = object;
        }
      }
      return object;
    }

    // The public methods and properties of the propertySupport object
    api = {

      /**
        Mixes a useful set of methods and properties into the target object. Lab models are expected
        to provide themselves as the target, i.e., mix these methods/properties into themselves.
      */
      mixInto: function(target) {

        /**
          The 'properties' property mixed into 'target' is a sealed Object whose enumerable
          properties are all the properties defined by calls to the defineProperty method of the
          propertySupport object. Creating this object is the main feature of the PropertySupport
          module.

          Reading the value of a computed property of the 'properties' object causes that value to
          be cached, unless the `enableCaching` property of the propertySupport object is false. The
          cached value is returned on subsequent reads, unless `enableCaching` is set to false,
          or `deleteComputedPropertyCachedValues` is called.

          Assigning to a property of the 'properties' object always triggers the observers of that
          property, if any.

          Because the 'properties' object is sealed, if `defineProperty` is subsequently called, the
          value of the 'properties' property will be updated to a new object containing the updated
          set of properties.
        */
        Object.defineProperty(target, 'properties', {
          configurable: false,
          enumerable: true,
          get: function() {
            return getPropertiesObject();
          }
        });

        /**
          The 'propertiesOfType' method mixed in to 'target' returns a sealed Object whose
          enumerable properties are all the properties defined by calls to the defineProperty
          method with the value 'type' as the type descriptor option.

          These properties behave the same as properties of the 'properties' object.
        */
        target.propertiesOfType = function(type) {
          return getPropertiesObject(type);
        };

        /**
          The 'set' method mixed into 'target' sets the value of one or more properties.

          Calling `target.set(key, value)` is equivalent to `target.properties[key] = value`

          However, if the first argument is a hash of properties, then the hash is treated as a
          set of key-value pairs to be assigned. In that case, observer notification is delayed
          until after all property values in the hash have been assigned.
        */
        target.set = function(key, value) {
          var hash;
          if (typeof key === 'string') {
            target.properties[key] = value;
          } else {
            hash = key;
            withBatchedNotifications(function() {
              Object.keys(hash).forEach(function(key) {
                target.properties[key] = hash[key];
              });
            });
          }
        };

        /**
          The 'get' method mixed into target reads the value of one property.

          Calling `target.get(key)` is equivalent to accessing `target.properties[key]`
        */
        target.get = function(key) {
          return target.properties[key];
        };

        /**
          The 'addObserver' method mixed into 'target' adds 'callback' to the end of the list of
          property observers of the property specified by 'key'. Note that adding a callback more
          than once to the observer list for a given property has no effect.

          Whenever the property 'key' is assigned to, the callback will be called. As noted above,
          sometimes property assignment is batched (e.g., by passing a hash to`target.set`). When
          this is the case, 'callback' is guaranteed to be called only once after the batched
          assignment, regardless of how many keys it is registered for. (Of course, if one of those
          observers then assigns to a property observed by 'callback', a second call will occur.)

          If 'key' represents a computed property, then observer notification is supported but
          happends according to a different cycle. Specifically, notification of the observer will
          happen if the value of the property changes between paired calls to
          `storeComputedProperties` and `notifyChangedComputedProperties`, or whenever
          `notifyAllComputedProperties` is called (regardless of the current or previous value of
          the property). As with batched property assignment, each callback is guaranteed to be
          called directly by `notifyAllComputedProperties` or `notifyChangedComputedProperties`
          at most once per invocation.

          Notification is never triggered by simply accessing the property, regardless of whether or
          not the access causes the property to be recalcuated

          Note that there are only 2 arguments accepted by addObserver; it does not support
          'this'-binding to a target object.
        */
        target.addObserver = function(key, callback) {
          if (!propertyInformation[key]) {
            return;
          }
          var observers = propertyInformation[key].observers;
          if (observers.indexOf(callback) < 0) {
            observers.push(callback);
          }
        };

        /**
          The 'removeObserver' method mixed into 'target' removes 'callback' from the list of
          callbacks registered for the propery specified by key.
        */
        target.removeObserver = function(key, callback) {
          var observers = propertyInformation[key].observers,
              index = observers.indexOf(callback);

          if (index > 0) {
            observers.splice(index, 1);
          }
        };

        /**
          The 'getPropertyDescription' method mixed into 'target' simply returns the object passed
          in as the 'description' property of the descriptor passed to `defineProperty` when the
          property named 'key' was defined.
        */
        target.getPropertyDescription = function(key) {
          return propertyInformation[key].descriptor.description;
        };

        /**
          The 'getPropertyType' method mixed into 'target' simply returns the 'type' value passed
          in as the 'type' property of the descriptor passed to 'defineProperty'when the property
          named 'key' was defined.
        */
        target.getPropertyType = function(key) {
          return propertyInformation[key].descriptor.type;
        };

        /**
          The 'getPropertyValidateFunc' method mixed into 'target' simply returns the 'validate' function
          passed in as the 'validate' property of the descriptor passed to 'defineProperty' when the
          property named 'key' was defined.
        */
        target.getPropertyValidateFunc = function(key) {
          return propertyInformation[key].descriptor.validate;
        };

        /**
          The 'makeInvalidatingChange' method mixed into 'target' lets client code perform an action
          that will invalidate all computed properties.
         */
        target.makeInvalidatingChange = function (closure) {
          api.invalidatingChangePreHook();
          closure();
          api.invalidatingChangePostHook();
        };

        // TODO: probably it's unnecessary, addObserver can support multiple
        // properties instead.
        target.addPropertiesListener = function(properties, callback) {
          if (typeof properties === 'string') {
            target.addObserver(properties, callback);
          } else {
            properties.forEach(function(property) {
              target.addObserver(property, callback);
            });
          }
        };
      },

      /**
        The defineProperty method allows the client object to define a new property named 'key'. The
        'descriptor' property should be a hash containing property descriptors; see the comments on
        the descriptorProperties constant, above.
      */

      defineProperty: function(key, descriptor) {
        descriptor = validateDescriptor(descriptor || {});

        propertyInformation[key] = {
          descriptor: descriptor,
          observers: [],
          hasCachedValue: false,
          cachedValue: undefined,
          previousValue: undefined
        };

        if (descriptor.get) {
          computedPropertyKeys.push(key);
        }
        if (descriptor.includeInHistoryState) {
          historyStatePropertyKeys.push(key);
        }

        invalidateCachedPropertiesObjects(descriptor.type);
      },

      /**
        The 'deleteComputedPropertyCachedValues' method removes the cached value of all computed
        properties (i.e., all properties with getters.)

        The next access of the property (either caused directly by code that explicitly accesses the
        property, or indirectly by `notifyChangedComputedProperties`, which retrieves the current
        value of all observed computed properties) will cause a recomputation of the property.
      */
      deleteComputedPropertyCachedValues: function() {
        computedPropertyKeys.forEach(function(key) {
          propertyInformation[key].hasCachedValue = false;
          propertyInformation[key].cachedValue = undefined;
        });
      },

      /**
        The 'storeComputedProperties' method retrieves the current value of all computed properties,
        respecting any previously-cached value, and stores it in a secondary cache for subsequent
        comparison to an updated value, by `notifyChangedComputedProperties`.

        Normally, one would call this method prior to updating the simulation clock, and then call
        `deleteComputedPropertyCachedValues` and notifyChangedComputedProperties` after updating
        the simulation clock.
      */
      storeComputedProperties: function() {
        observedComputedPropertyKeys().forEach(function(key) {
          propertyInformation[key].previousValue = get(key);
        });
      },

      /**
        Retrieves the current value of all computed properties, respecting any cached value it
        finds, and compares them to the previous values of the properties stored by
        `storeComputedProperties`

        Notifies the observers of any properties whose values differ from the previous value. Note
        that observers are called strictly after all computed property values are calculated, and
        each observer callback is guaranteed to be called directly by this method only once per
        invocation.

        (However, it would be possible for any given callback to be called again as a side effect of
        previous observers.)

        Note that, because this method observes the cache, you probably want to call
        `deleteComputedPropertyCachedValues` after calling `storeComputedProperties`,
      */
      notifyChangedComputedProperties: function() {
        withBatchedNotifications(function() {
          observedComputedPropertyKeys().forEach(function(key) {
            if (get(key) !== propertyInformation[key].previousValue) {
              notify(key);
            }
            propertyInformation[key].previousValue = undefined;
          });
        });
      },

      /**
        Blanket-notifies the observers of all computed properties. As described above, each observer
        callback will only be called directly by this method only once per invocation, but the side
        effects of some observer callbacks may result in subsequent calls to any given observer
        callback.
      */
      notifyAllComputedProperties: function() {
        withBatchedNotifications(function() {
          observedComputedPropertyKeys().forEach(function(key) {
            notify(key);
          });
        });
      },

      /**
        The 'properties' object is the main object containing the properties defined using this
        module. This is the same object that is mixed into the mixin target, and it is described
        above in detail.
      */
      get properties() {
        return getPropertiesObject();
      },

      /**
        The 'propertiesOfType' method behaves the same as the `propertiesOfType` method mixed into
        the mixin target, and it is describd above.
      */
      propertiesOfType: function(type) {
        return getPropertiesObject(type);
      },

      /**
        The enableCaching property indicates whether computed property values should be cached.
        When multiple cycles of property changes are triggered by a single change to the simulation
        state, you may want to turn off property caching until all cycles complete.
      */

      get enableCaching() {
        return cachingIsEnabled;
      },

      set enableCaching(value) {
        cachingIsEnabled = !!value;
      },

      /**
        The 'historyStateRawValues' property is a hash of key-value pairs of those properties which
        have the `includeInHistoryState` descriptor property set to true.

        The underlying values are 'raw' values, i.e., those which have been passed through the
        beforeSetTransform.
      */
      get historyStateRawValues() {
        var ret = {};
        historyStatePropertyKeys.forEach(function(key) {
          ret[key] = get(key);
        });
        return ret;
      },

      /**
        The 'rawValues' property is a hash of key-value pairs of all properties.

        The underlying values are 'raw' values, i.e., those which have been passed through the
        beforeSetTransform.
      */
      get rawValues() {
        var ret = {};
        Object.keys(propertyInformation).forEach(function(key) {
          ret[key] = get(key);
        });
        return ret;
      },

      /**
        The 'setRawValues' method accepts a hash of key-value pairs of some properties.

        Unlike the argument accepted by the 'set' method mixed into the mixin target, the values are
        expected to be 'raw' values, i.e., those which have already passed through the
        beforeSetTransform.

        Furthermore, notification of observers is only triggered for those properties whose value
        changed. This is because setRawValues is expected to be used as a system interface for
        restoring past states of the simulation, e.g., rewinding a simulation, and it would be
        undesirable to notify every observer, every time a history state was revisited.

        Additionally, for each property in the passed-in hash, the 'internal' setter is called if
        and only if that property has its `invokeSetterAfterBulkRestore` descriptor property set
        to true.
      */
      setRawValues: function(values) {
        withBatchedNotifications(function() {
          Object.keys(values).forEach(function(key) {
            var info = propertyInformation[key];
            if (!info) {
              return;
            }
            // During bulk state restoration, only actually changed values should trigger observers!
            if (get(key) !== values[key]) {
              notify(key);
            }
            set(key, values[key]);
            if (info.descriptor.invokeSetterAfterBulkRestore && info.descriptor.set) {
              info.descriptor.set(get(key));
            }
          });
        });
      },

      invalidatingChangePreHook: function() {
        if (suppressInvalidatingChangeHooks) return;

        if (invalidatingChangeNestingLevel === 0) {
          api.storeComputedProperties();
          api.deleteComputedPropertyCachedValues();
          api.enableCaching = false;
        }
        invalidatingChangeNestingLevel++;

        dispatch.beforeInvalidatingChange();
      },

      invalidatingChangePostHook: function() {
        if (suppressInvalidatingChangeHooks) return;

        invalidatingChangeNestingLevel--;

        dispatch.afterInvalidatingChange();

        if (invalidatingChangeNestingLevel === 0) {
          api.enableCaching = true;
          api.notifyChangedComputedProperties();

          dispatch.afterInvalidatingChangeSequence();
        }
      },

      startBatch: function() {
        api.invalidatingChangePreHook();
        suppressInvalidatingChangeHooks = true;
      },

      endBatch: function() {
        suppressInvalidatingChangeHooks = false;
        api.invalidatingChangePostHook();
      },

      on: function (type, listener) {
        dispatch.on(type, listener);
      }
    };

    return api;
  };
});

/*global define, d3 */
/*jshint eqnull:true boss:true */

define('common/property-description',['require','underscore'],function(require) {

  var _ = require('underscore');

  function isUndefined(val) {
    return val === "";
  }

  function PropertyDescription(unitDefinition, descriptionHash) {
    var u;

    this._descriptionHash = descriptionHash;
    this._label = descriptionHash.label || "";

    this._unitName         = "";
    this._unitPluralName   = "";
    this._unitAbbreviation = "";

    if (descriptionHash.unitType) {
      if ( !(u = unitDefinition.units[descriptionHash.unitType]) ) {
        throw new Error("PropertyDescription: couldn't find unitType " + descriptionHash.unitType + " in the supplied units definition.");
      }
      this._unitType         = descriptionHash.unitType;
      this._unitName         = u.name;
      this._unitPluralName   = u.pluralName;
      this._unitAbbreviation = u.symbol;
    }

    // allow overriding the unit properties, or specifying custom ones for which there is no
    // current unit definition.
    if (descriptionHash.unitName) this._unitName = descriptionHash.unitName;
    if (descriptionHash.unitPluralName) this._unitPluralName = descriptionHash.unitPluralName;
    if (descriptionHash.unitAbbreviation) this._unitAbbreviation = descriptionHash.unitAbbreviation;

    this.setFormat(descriptionHash.format);
  }

  PropertyDescription.prototype.getHash = function() {
    return _.extend(
      _.reject({
          unitName:         this.getUnitName(),
          unitPluralName:   this.getUnitPluralName(),
          unitAbbreviation: this.getUnitAbbreviation()
        }, isUndefined),
      this._descriptionHash);
  };

  PropertyDescription.prototype.getLabel = function() {
    return this._label;
  };

  PropertyDescription.prototype.getUnitType = function() {
    return this._unitType;
  };

  PropertyDescription.prototype.getUnitName = function() {
    return this._unitName;
  };

  PropertyDescription.prototype.getUnitPluralName = function() {
    return this._unitPluralName;
  };

  PropertyDescription.prototype.getUnitAbbreviation = function() {
    return this._unitAbbreviation;
  };

  PropertyDescription.prototype.setFormat = function(s) {
    if (s) this._formatter = d3.format(s);
    else   this._formatter = function (val) { return val; };
  };

  PropertyDescription.prototype.format = function(val, opts) {
    opts = opts || {};

    var formatter,
        formattedVal,
        plural,
        abbreviated = true;

    if (opts.format) {
      if (opts.format === this._lastFormat) {
        formatter = this._lastFormatter;
      } else {
        formatter = d3.format(opts.format);
        this._lastFormat = opts.format;
        this._lastFormatter = formatter;
      }
    } else {
      formatter = this._formatter;
    }

    formattedVal = formatter(val);

    if (opts && opts.abbreviated != null) abbreviated = opts.abbreviated;

    if (abbreviated) {
      return formattedVal + " " + this._unitAbbreviation;
    }

    plural = parseFloat(formattedVal) !== 1;
    return formattedVal + " " + (plural ? this._unitPluralName : this._unitName);
  };

  return PropertyDescription;
});

/*global define: false */

define('common/parameter-support',['require','common/property-description'],function (require) {

  var PropertyDescription  = require('common/property-description');

  return function ParameterSupport(args) {
    var propertySupport = args.propertySupport,
        unitsDefinition = args.unitsDefinition || {};

    return {
      mixInto: function(target) {

        /**
          Define a property of the model to be treated as a custom parameter. Custom parameters are
          (generally, user-defined) read/write properties that trigger a setter action when set, and
          whose values are automatically persisted in the tick history.

          Because custom parameters are not intended to be interpreted by the engine, but instead simply
          *represent* states of the model that are otherwise fully specified by the engine state and
          other properties of the model, and because the setter function might not limit itself to a
          purely functional mapping from parameter value to model properties, but might perform any
          arbitrary stateful change, (stopping the model, etc.), the setter is NOT called when custom
          parameters are updated by the tick history.
        */
        target.defineParameter = function(key, descriptionHash, setter) {
          var descriptor = {
                type: 'parameter',
                includeInHistoryState: true,
                invokeSetterAfterBulkRestore: false,
                description: new PropertyDescription(unitsDefinition, descriptionHash),
                beforeSetCallback: propertySupport.invalidatingChangePreHook,
                afterSetCallback: propertySupport.invalidatingChangePostHook
              };

          // In practice, some parameters are meant only to be observed, and have no setter
          if (setter) {
            descriptor.set = function(value) {
              setter.call(target, value);
            };
          }
          propertySupport.defineProperty(key, descriptor);
        };
      }
    };
  };
});

(function() {

  define('cs!common/running-average-filter',['require'],function(require) {
    /*
      Filter implementing running average.
      This filter assumes that provided samples are samples of some unknown function.
      The function is interpolated using linear interpolation. Later, integration is
      used to get mean value of the function on the given time period.
    */

    var RunningAverageFilter;
    return RunningAverageFilter = (function() {
      /*
          Construct new Running Average Filter.
          @periodLength - length of time period, in fs, which is used to calculate averaged value.
      */

      function RunningAverageFilter(periodLength) {
        this.periodLength = periodLength;
        this._value = [];
        this._time = [];
        this._idx = -1;
        this._maxBufferLength = this.periodLength;
      }

      /*
          Add a new sample of a function which is going to be averaged.
          Note that samples must be provided in order, sorted by time.
          @t - time
          @val - value of the sample
      */


      RunningAverageFilter.prototype.addSample = function(t, val) {
        var _results;
        if (this._time[this._idx] === t) {
          this._value[this._idx] = val;
          return;
        } else if (this._time[this._idx] > t) {
          throw new Error("RunningAverageFilter: cannot add sample with @_time less than previous sample.");
        }
        this._idx++;
        this._value.push(val);
        this._time.push(t);
        _results = [];
        while (this._value.length > this._maxBufferLength) {
          this._time.shift();
          this._value.shift();
          _results.push(this._idx--);
        }
        return _results;
      };

      /*
          Return averaged value n the specified time period (using available samples).
      */


      RunningAverageFilter.prototype.calculate = function() {
        var i, minTime, minVal, timeDiff, timeSum, valSum;
        minTime = Math.max(this._time[this._idx] - this.periodLength, 0);
        valSum = 0;
        timeSum = 0;
        i = this._idx;
        while (i > 0 && this._time[i - 1] >= minTime) {
          timeDiff = this._time[i] - this._time[i - 1];
          timeSum += timeDiff;
          valSum += timeDiff * (this._value[i - 1] + this._value[i]) / 2.0;
          i--;
        }
        if (i > 0 && this._time[i] > minTime && this._time[i - 1] < minTime) {
          timeDiff = this._time[i] - minTime;
          timeSum += timeDiff;
          minVal = this._value[i - 1] + (this._value[i] - this._value[i - 1]) * (minTime - this._time[i - 1]) / (this._time[i] - this._time[i - 1]);
          valSum += timeDiff * (this._value[i] + minVal) / 2.0;
        }
        if (timeSum) {
          return valSum / timeSum;
        } else {
          return this._value[0] || 0;
        }
      };

      /*
          Return current length of the buffers used to store samples.
      */


      RunningAverageFilter.prototype.getCurrentBufferLength = function() {
        return this._value.length;
      };

      /*
          Set limit of the buffer which stores samples.
      */


      RunningAverageFilter.prototype.setMaxBufferLength = function(maxLength) {
        return this._maxBufferLength = maxLength;
      };

      /*
          Return current time.
      */


      RunningAverageFilter.prototype.getCurrentTime = function() {
        return this._time[this._idx];
      };

      /*
          Return current step index.
      */


      RunningAverageFilter.prototype.getCurrentStep = function() {
        return this._idx;
      };

      /*
          Set current step to @location.
          It allows to get average value of the function in various moments in time.
      */


      RunningAverageFilter.prototype.setCurrentStep = function(location) {
        if (location < -1 || location >= this._value.length) {
          throw new Error("RunningAverageFilter: cannot seek, location outside available range.");
        }
        return this._idx = location;
      };

      /*
          Remove all samples *after* @location.
      */


      RunningAverageFilter.prototype.invalidate = function(location) {
        this._value.length = location + 1;
        this._time.length = location + 1;
        return this._idx = location;
      };

      return RunningAverageFilter;

    })();
  });

}).call(this);

/*global define: false */

define('common/output-support',['require','common/property-description','cs!common/running-average-filter'],function (require) {

  var PropertyDescription  = require('common/property-description'),
      RunningAverageFilter = require('cs!common/running-average-filter');

  return function OutputSupport(args) {
    var propertySupport = args.propertySupport,
        unitsDefinition = args.unitsDefinition || {},
        tickHistory     = args.tickHistory || null,

        filteredOutputs = [];

    function updateFilteredOutputs() {
      filteredOutputs.forEach(function(output) {
        output.addSample();
      });
    }

    // TODO: is it necessary? It follows the old solution.
    // In theory filtered outputs could be updated only on time change
    // or on filtered property value change. Check it!
    propertySupport.on("afterInvalidatingChange.output-support", updateFilteredOutputs);

    return {
      mixInto: function(target) {

        /**
          Add an "output" property to the model. Output properties are expected to change at every
          model tick, and may also be changed indirectly, outside of a model tick, by a change to model
          properties or the atom, element, etc. properties.

          `key` should be the name of the output. The property value will be accessed by
          `model.get(<key>);`

          `description` should be a hash of metadata about the property.

          `getter` should be a no-arg function which calculates the property value. These values are not
          translated after getter returns because we expect that most output getters are authored
          scripts, which operate entirely with already-translated units. Therefore, getters defined
          internally in modeler.js needs to make sure to translate any "model units" values out of the
          model-unit domain.
        */
        target.defineOutput = function(key, descriptionHash, getter) {
          propertySupport.defineProperty(key, {
            type: 'output',
            writable: false,
            get: getter,
            includeInHistoryState: false,
            description: new PropertyDescription(unitsDefinition, descriptionHash)
          });
        };


        /**
          Add an "filtered output" property to the model. This is special kind of output property, which
          is filtered by one of the built-in filters based on time (like running average). Note that filtered
          outputs do not specify calculate function - instead, they specify property which should filtered.
          It can be another output, model parameter or custom parameter.

          Filtered output properties are extension of typical output properties. They share all features of
          output properties, so they are expected to change at every model tick, and may also be changed indirectly,
          outside of a model tick, by a change to the model parameters or to the configuration of atoms and other
          objects in the model.

          `key` should be the name of the parameter. The property value will be accessed by
          `target.get(<key>);`

          `description` should be a hash of metadata about the property. Right now, these metadata are not
          used. However, example metadata include the label and units name to be used when graphing
          this property.

          `filteredPropertyKey` should be name of the basic property which should be filtered.

          `type` should be type of filter, defined as string. For now only "RunningAverage" is supported.

          `period` should be number defining length of time period used for calculating filtered value. It should
          be specified in femtoseconds.

        */
        target.defineFilteredOutput = function(key, description, filteredPropertyKey, type, period) {
          var filter, initialValue;

          if (type === "RunningAverage") {
            filter = new RunningAverageFilter(period);
          } else {
            throw new Error("FilteredOutput: unknown filter type " + type + ".");
          }

          // Add initial sample
          initialValue = target.properties[filteredPropertyKey];
          if (initialValue === undefined || isNaN(Number(initialValue))) {
            throw new Error("FilteredOutput: property is not a valid numeric value or it is undefined.");
          }
          filter.addSample(target.properties.time, initialValue);

          if (tickHistory) {
            // Create simple adapter implementing TickHistoryCompatible Interface
            // and register it in tick history.
            tickHistory.registerExternalObject({
              push: function () {
                // Filtered outputs are updated only at the end of tick() operation,
                // druing tickHistory.push() call. So they are *not* updated
                // immediately after property change, e.g. using model.set("prop", 5).
                // Filtered ouput bound to "prop" property will reflect this change
                // in the next tick.
                filter.addSample(target.properties.time, target.properties[filteredPropertyKey]);
              },
              extract: function (idx) {
                filter.setCurrentStep(idx);
              },
              invalidate: function (idx) {
                filter.invalidate(idx);
              },
              setHistoryLength: function (length) {
                filter.setMaxBufferLength(length);
              }
            });
          } else {
            filteredOutputs.push({
              addSample: function() {
                filter.addSample(target.properties.time, target.properties[filteredPropertyKey]);
              }
            });
          }

          // Extend description to contain information about filter
          description.property = filteredPropertyKey;
          description.type = type;
          description.period = period;

          target.defineOutput(key, description, function () {
            return filter.calculate();
          });
        };

        /**
          Call this method after moving to a different model time (e.g., after stepping the model
          forward or back, seeking to a different time, or on model initialization) to update all output
          properties and notify their listeners. This method is more efficient for that case than
          updateOutputPropertiesAfterChange because it can assume that all output properties are
          invalidated by the model step. It therefore does not need to calculate any output property
          values; it allows them to be evaluated lazily instead. Property values are calculated when and
          if listeners request them. This method also guarantees that all properties have their updated
          value when they are requested by any listener.

          Technically, this method first updates the 'viewAtoms' array and macrostate variables, then
          invalidates any  cached output-property values, and finally notifies all output-property
          listeners.

          Note that this method and updateOutputPropertiesAfterChange are the only methods which can
          flush the cached value of an output property. Therefore, be sure to not to make changes
          which would invalidate a cached value without also calling one of these two methods.
        */
        target.updateAllOutputProperties = function () {
          propertySupport.deleteComputedPropertyCachedValues();
          propertySupport.notifyAllComputedProperties();
          updateFilteredOutputs();
        };
      }
    };
  };
});

/*global define: false, d3: false */
/**
 * This module provides event dispatch based on d3.dispatch:
 * https://github.com/mbostock/d3/wiki/Internals#wiki-d3_dispatch
 *
 * The main improvement over raw d3.dispatch is that this wrapper provides
 * event batching. You can start batch mode (.startBatch()) and while it is
 * active events won't be dispatched immediately. They will be dispatched
 * at the end of batch mode (.endBatch()) or when you call .flush() method.
 *
 * Note that there is one *significant limitation*: arguments passed during
 * event dispatching will be lost! All events will be merged into single
 * event without any argument. Please keep this in mind while using this module.
 *
 * e.g.
 *   dispatch.on("someEvent", function(arg) { console.log(arg); });
 *   dispatch.someEvent(123);     // console output: 123
 *   dispatch.someEvent("test");  // console output: "test"
 * However...
 *   dispatch.startBatch();
 *   dispatch.someEvent(123);
 *   dispatch.someEvent("test");
 *   dispatch.endBatch();         // console output: undefined (!)
 *
 * Rest of the interface is exactly the same like in d3.dispatch (.on()).
 * Under the hood delegation to d3.dispatch instance is used.
 */
define('common/dispatch-support',[],function() {

  // Converts arguments object to regular array.
  function argsToArray(args) {
    return [].slice.call(args);
  }

  return function DispatchSupport() {
    var api,
        d3dispatch,
        types,

        batchMode = false,
        suppressedEvents = d3.set();

    function init(newTypes) {
      var i, len;

      types = newTypes;

      d3dispatch = d3.dispatch.apply(null, types);

      // Provide wrapper around typical calls like dispatch.someEvent().
      for (i = 0, len = types.length; i < len; i++) {
        api[types[i]] = dispatchEvent(types[i]);
      }
    }

    function dispatchEvent(name) {
      return function () {
        if (!batchMode) {
          d3dispatch[name].apply(d3dispatch, arguments);
        } else {
          suppressedEvents.add(name);
        }
      };
    }

    function delegate(funcName) {
      return function () {
        d3dispatch[funcName].apply(d3dispatch, arguments);
      };
    }

    // Public API.
    api = {
      // Copy d3.dispatch API:

      /**
       * Adds or removes an event listener for the specified type. Please see:
       * https://github.com/mbostock/d3/wiki/Internals#wiki-dispatch_on
       */
      on: delegate("on"),

      // New API specific for Lab DispatchSupport:

      mixInto: function(target) {
        target.on = api.on;
        target.suppressEvents = api.suppressEvents;
      },

      /**
       * Adds new event types. Old event types are still supported, but
       * all previously registered listeners will be removed!
       *
       * e.g. dispatch.addEventTypes("newEvent", "anotherEvent")
       */
      addEventTypes: function () {
        if (arguments.length) {
          init(types.concat(argsToArray(arguments)));
        }
      },

      /**
       * Starts batch mode. Events won't be dispatched immediately after call.
       * They will be merged into single event and dispatched when .flush()
       * or .endBatch() is called.
       */
      startBatch: function () {
        batchMode = true;
      },

      /**
       * Ends batch mode and dispatches suppressed events.
       */
      endBatch: function () {
        batchMode = false;
        api.flush();
      },

      /**
       * Dispatches suppressed events.
       * @return {[type]} [description]
       */
      flush: function () {
        suppressedEvents.forEach(function (eventName) {
          d3dispatch[eventName]();
        });
        // Reset suppressed events.
        suppressedEvents = d3.set();
      },

      /**
       * Allows to execute some action without dispatching any events.
       * @param {function} action
       */
      suppressEvents: function(action) {
        batchMode = true;
        action();
        batchMode = false;
        // Reset suppressed events without dispatching them.
        suppressedEvents = d3.set();
      }
    };

    init(argsToArray(arguments));

    return api;
  };
});

/*global define: false, d3: false */

define('common/playback-support',['require','common/console'],function (require) {
  var console = require('common/console');

  return function PlaybackSupport(args) {
        // DispatchSupport instance or compatible module.
    var dispatch = args && args.dispatch || null,
        // Properties object - it can be used to define 'modelSampleRate'. It
        // can be simple plain object or more sophisticated object returned by
        // PropertiesSupport module.
        properties = args && args.properties || null,

        eventsSupported = (function() {
          // Events support is optional. It should be provided by the
          // DispatchSupport (common/dispatch-support) or another compatible
          // module.
          if (dispatch) {
            if (dispatch.on && dispatch.addEventTypes) {
              dispatch.addEventTypes("play", "stop");
              return true;
            } else {
              throw new Error("[PlaybackSupport] Provided Dispatch object doesn't implement required interface!");
            }
          } else {
            return false;
          }
        }()),

        stopped = true,
        stopRequest = false,
        restartRequest = false;

    /**
      Repeatedly calls `f` at an interval defined by the modelSampleRate property, until f returns
      true. (This is the same signature as d3.timer.)

      If modelSampleRate === 'default', try to run at the "requestAnimationFrame rate"
      (i.e., using d3.timer(), after running f, also request to run f at the next animation frame)

      If modelSampleRate !== 'default', instead uses setInterval to schedule regular calls of f with
      period (1000 / sampleRate) ms, corresponding to sampleRate calls/s
    */
    function timer(f) {
      var intervalID,
          // When target support properties and it defines
          // 'modelSampleRate', it will be used.
          sampleRate = properties && properties.modelSampleRate || 'default';

      if (sampleRate === 'default') {
        // use requestAnimationFrame via d3.timer
        d3.timer(f);
      } else {
        // set an interval to run the model more slowly.
        intervalID = window.setInterval(function() {
          if (f()) {
            window.clearInterval(intervalID);
          }
        }, 1000/sampleRate);
      }
    }

    return {
      mixInto: function(target) {

        if (typeof target.tick !== "function") {
          target.tick = function () {
            console.warn("[PlaybackSupport] .tick() method should be overwritten by target!");
          };
        }

        target.start = function() {
          // Cleanup stop and restart requests.
          stopRequest = false;
          restartRequest = false;

          if (!stopped) {
            // Do nothing, model is running.
            return target;
          }

          stopped = false;

          timer(function timerTick(elapsedTime) {
            console.timeEnd('gap between frames');
            // Cancel the timer and refuse to to step the model, if the model is stopped.
            // This is necessary because there is no direct way to cancel a d3 timer.
            // See: https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_timer)
            if (stopRequest) {
              stopped = true;
              return true;
            }

            if (restartRequest) {
              setTimeout(target.start, 0);
              stopped = true;
              return true;
            }

            target.tick(elapsedTime);

            console.time('gap between frames');
            return false;
          });

          if (eventsSupported) dispatch.play();

          console.time('gap between frames');
          return target;
        };

        target.restart = function() {
          restartRequest = true;
          return target;
        };

        target.stop = function() {
          stopRequest = true;
          if (eventsSupported) dispatch.stop();
          return target;
        };

        target.isStopped = function () {
          return stopped || stopRequest;
        };
      }
    };
  };
});

/*global define: false */

define('common/define-builtin-properties',['require','common/validator','common/property-description'],function (require) {

  var validator            = require('common/validator'),
      PropertyDescription  = require('common/property-description');

  return function defineBuiltinProperties(args) {
    var propertySupport   = args.propertySupport,
        metadata          = args.metadata,
        // Optional:
        unitsDefinition   = args.unitsDefinition || {},
        unitsTranslation  = args.unitsTranslation || null,
        setters           = args.setters || {},
        initialProperties = args.initialProperties || null;

    function defineBuiltinProperty(key, type, setter) {
      var metadataForType,
          descriptor,
          propertyChangeInvalidates,
          unitType;

      if (type === 'mainProperty') {
        metadataForType = metadata.mainProperties;
      } else if (type === 'viewOption') {
        metadataForType = metadata.viewOptions;
      } else {
        throw new Error(type + " is not a supported built-in property type");
      }

      propertyChangeInvalidates = validator.propertyChangeInvalidates(metadataForType[key]);

      descriptor = {
        type: type,
        writable: validator.propertyIsWritable(metadataForType[key]),
        set: setter,
        includeInHistoryState: !!metadataForType[key].storeInTickHistory,
        validate: function(value) {
          return validator.validateSingleProperty(metadataForType[key], key, value, false);
        },
        beforeSetCallback: propertyChangeInvalidates ? propertySupport.invalidatingChangePreHook : undefined,
        afterSetCallback: propertyChangeInvalidates ? propertySupport.invalidatingChangePostHook : undefined
      };

      unitType = metadataForType[key].unitType;
      if (unitType) {
        descriptor.description = new PropertyDescription(unitsDefinition, { unitType: unitType });
        if (unitsTranslation) {
          descriptor.beforeSetTransform = function(value) {
            return unitsTranslation.translateToModelUnits(value, unitType);
          };
          descriptor.afterGetTransform = function(value) {
            return unitsTranslation.translateFromModelUnits(value, unitType);
          };
        }
      }

      propertySupport.defineProperty(key, descriptor);
    }

    (function() {
      var mainProperties,
          viewOptions;

      // Define built-in properties using provided metadata.
      Object.keys(metadata.mainProperties).forEach(function (key) {
        defineBuiltinProperty(key, 'mainProperty', setters[key]);
      });
      Object.keys(metadata.viewOptions).forEach(function (key) {
        defineBuiltinProperty(key, 'viewOption', setters[key]);
      });

      if (initialProperties) {
        mainProperties = validator.validateCompleteness(metadata.mainProperties, initialProperties);
        propertySupport.setRawValues(mainProperties);

        viewOptions = validator.validateCompleteness(metadata.viewOptions, initialProperties.viewOptions || {});
        propertySupport.setRawValues(viewOptions);
      }
    }());
  };
});

/*global define: false */

define('common/lab-modeler-mixin',['require','common/property-support','common/parameter-support','common/output-support','common/dispatch-support','common/playback-support','common/define-builtin-properties'],function (require) {

  var PropertySupport         = require('common/property-support'),
      ParameterSupport        = require('common/parameter-support'),
      OutputSupport           = require('common/output-support'),
      DispatchSupport         = require('common/dispatch-support'),
      PlaybackSupport         = require('common/playback-support'),
      defineBuiltinProperties = require('common/define-builtin-properties');

  return function LabModelerMixin(args) {

    var api,

        /**
         * Accepted arguments:
         */
        metadata          = args.metadata,
        setters           = args.setters,
        unitsDefinition   = args.unitsDefinition,
        unitsTranslation  = args.unitsTranslation,
        initialProperties = args.initialProperties,
        tickHistory       = args.tickHistory,

        propertySupport = new PropertySupport({
          types: ["output", "parameter", "mainProperty", "viewOption"]
        }),
        parameterSupport = new ParameterSupport({
          propertySupport: propertySupport,
          unitsDefinition: unitsDefinition
        }),
        outputSupport = new OutputSupport({
          propertySupport: propertySupport,
          unitsDefinition: unitsDefinition,
          tickHistory: tickHistory
        }),
        dispatchSupport = new DispatchSupport(),
        playbackSupport = new PlaybackSupport({
          dispatch: dispatchSupport,
          properties: propertySupport.properties
        });

    // FIXME: These events have to be available as some other modules try to
    // add listeners. Probably they aren't necessary, trace it and fix.
    dispatchSupport.addEventTypes("reset", "stepForward", "stepBack", "seek", "invalidation");

    api = {
      mixInto: function(target) {
        propertySupport.mixInto(target);
        parameterSupport.mixInto(target);
        outputSupport.mixInto(target);
        dispatchSupport.mixInto(target);
        playbackSupport.mixInto(target);

        if (metadata) {
          defineBuiltinProperties({
            propertySupport: propertySupport,
            metadata: metadata,

            unitsDefinition: unitsDefinition,
            unitsTranslation: unitsTranslation,
            setters: setters,
            initialProperties: initialProperties
          });
        }
      },

      get propertySupport() {
        return propertySupport;
      },

      get parameterSupport() {
        return parameterSupport;
      },

      get outputSupport() {
        return outputSupport;
      },

      get dispatchSupport() {
        return dispatchSupport;
      },

      get playbackSupport() {
        return playbackSupport;
      }
    };

    return api;
  };
});

/*global define: false */
/*jslint onevar: true devel:true eqnull: true */

define('common/models/tick-history',[],function() {


  /**
    Class which handles tick history. It supports saving and restoring state
    of core state objects defined by the modeler and engine. However, while
    adding a new object which should also be saved in tick history, consider
    utilization of "external objects" - this is special object which should
    implement TickHistoryCompatible Interface:
      #setHistoryLength(number)
      #push()
      #extract(index)
      #invalidate(index)

      Note that index argument is *always* limited to [0, historyLength) range.

    "External objects" handle changes of the current step itself. TickHistory
    only sends requests to perform various operations. To register new
    external object use #registerExternalObject(object) method.

    It allows to decentralize management of tick history and tight coupling
    TickTistory with API of various objects.
  */
  return function TickHistory(modelState, model, size) {
    var tickHistory = {},
        initialState,
        list,
        listState,
        defaultSize = 1000,
        // List of objects defining TickHistoryCompatible Interface.
        externalObjects = [],

        // Provide the "old" interface for models that don't use PropertySupport yet, but provide
        // a different, new interface for models using PropertySupport for their parameters, etc.
        // Such models are smart enough to send a single hash of raw property values for all the
        // properties (parameters, main properties, view properties, etc) we need to save. Older
        // models need to provide us with separate lists of "regular" properties and parameters,
        // with their own separate restore callbacks.
        //
        //     ***      Remember to remove this when all models use PropertySupport!        ***
        //
        useNewInterface = !!modelState.getProperties;

    function newState() {
      return { input: {}, state: [], parameters: {} };
    }

    function reset() {
      list = [];
      listState = {
        // Equal to list.length:
        length: 0,
        // Drop oldest state in order to keep list no longer than this:
        maxSize: size,
        // Index into `list` of the current state:
        index: -1,
        // Total length of "total history" (counting valid history states that have been dropped)
        counter: -1,
        // Index in "total history" of the oldest state in the list.
        // Invariant: counter == index + startCounter
        startCounter: 0
      };
    }

    function copyModelState(destination) {
      var i,
          prop,
          state,
          parameters,
          name;

      if (useNewInterface) {
        // we expect that modelState.getProperties returns us a hash we can keep
        destination.input = modelState.getProperties();
      } else {
        // save model input properties
        for (i = 0; i < modelState.input.length; i++) {
          prop = modelState.input[i];
          destination.input[prop] = modelState.getRawPropertyValue(prop);
        }

        // save model parameters
        parameters = modelState.parameters;
        for (name in parameters) {
          if (parameters.hasOwnProperty(name) && parameters[name].isDefined) {
            destination.parameters[name] = modelState.getRawPropertyValue(name);
          }
        }
      }

      // save model objects defining state
      state = modelState.state;
      for (i = 0; i < state.length; i++) {
        destination.state[i] = state[i].clone();
      }
    }

    /** Copy the current model state into the list at list[listState.index+1] and updates listState.
        Removes any (now-invalid) states in the list that come after the newly pushed state.
    */
    function push() {
      var lastState = newState(),
          i;

      copyModelState(lastState);
      list[listState.index+1] = lastState;

      // Drop the oldest state if we went over the max list size
      if (list.length > listState.maxSize) {
        list.splice(0,1);
        listState.startCounter++;
      } else {
        listState.index++;
      }
      listState.counter = listState.index + listState.startCounter;

      // Send push request to external objects defining TickHistoryCompatible Interface.
      for (i = 0; i < externalObjects.length; i++) {
        externalObjects[i].push();
      }

      invalidateFollowingState();
      listState.length = list.length;
    }

    /** Invalidate (remove) all history after current index. For example, after seeking backwards
        and then pushing new state */
    function invalidateFollowingState() {
      var i;

      list.length = listState.index+1;
      listState.length = list.length;

      // Invalidate external objects defining TickHistoryCompatible Interface.
      for (i = 0; i < externalObjects.length; i++) {
        externalObjects[i].invalidate(listState.index);
      }
    }

    function extract(savedState) {
      var i,
          state;

      // restore model input properties
      modelState.restoreProperties(savedState.input);

      if (!useNewInterface) {
        // old interface requires restoring parameters separately
        modelState.restoreParameters(savedState.parameters);
      }

      // restore model objects defining state
      state = savedState.state;
      for (i = 0; i < state.length; i++) {
        modelState.state[i].restore(state[i]);
      }

      // Send extract request to external objects defining TickHistoryCompatible Interface.
      for (i = 0; i < externalObjects.length; i++) {
        externalObjects[i].extract(listState.index);
      }
    }

    function checkIndexArg(index) {
      if (index < 0) {
        throw new Error("TickHistory: extract index [" + index + "] less than 0");
      }
      if (index >= list.length) {
        throw new Error("TickHistory: extract index [" + index + "] greater than list.length: " + list.length);
      }
      return index;
    }

    //
    // Public methods
    //
    tickHistory.isEmpty = function() {
      return listState.index === 0;
    };

    tickHistory.push = function() {
      push();
    };

    tickHistory.returnTick = function(ptr) {
      var i;
      if (typeof ptr === 'number') {
        i = ptr;
      } else {
        i = listState.index;
      }
      checkIndexArg(i);
      return list[i];
    };

    tickHistory.extract = function(ptr) {
      var i;
      if (typeof ptr === 'number') {
        i = ptr;
      } else {
        i = listState.index;
      }
      checkIndexArg(i);
      extract(list[i]);
    };

    tickHistory.restoreInitialState = function() {
      reset();
      extract(initialState);
      push();
    };

    tickHistory.reset = reset;

    tickHistory.decrementExtract = function() {
      if (listState.counter > listState.startCounter) {
        listState.index--;
        listState.counter--;
        extract(list[listState.index]);
      }
    };

    tickHistory.incrementExtract = function() {
      listState.index++;
      listState.counter++;
      extract(list[listState.index]);
    };

    tickHistory.seekExtract = function(ptr) {
      if (ptr < listState.startCounter) ptr = listState.startCounter;
      if (ptr >= listState.startCounter + listState.length) ptr = listState.startCounter + listState.length - 1;
      listState.counter = ptr;
      listState.index = ptr - listState.startCounter;
      extract(list[listState.index]);
    };

    tickHistory.invalidateFollowingState = invalidateFollowingState;

    tickHistory.get = function(key) {
      return listState[key];
    };

    tickHistory.set = function(key, val) {
      return listState[key] = val;
    };

    /**
      Registers a new external object. It is a special object, which handles changes of step itself.
      TickHistory object only sends requests for various actions.
      External object should implement TickHistoryCompatible Interface:
        #setHistoryLength(number)
        #push()
        #extract(index)
        #invalidate(index)
    */
    tickHistory.registerExternalObject = function (externalObj) {
      externalObj.setHistoryLength(listState.maxSize);
      externalObjects.push(externalObj);
    };

    //
    // Initialization
    //
    if (size == null) size = defaultSize;
    initialState = newState();
    copyModelState(initialState);

    reset();
    push();
    return tickHistory;
  };
});

(function() {

  define('cs!md2d/models/solvent',['require'],function(require) {
    var Solvent, TYPES;
    TYPES = {
      vacuum: {
        forceType: 0,
        dielectricConstant: 1,
        color: "#eee"
      },
      oil: {
        forceType: -1,
        dielectricConstant: 10,
        color: "#f5f1dd"
      },
      water: {
        forceType: 1,
        dielectricConstant: 80,
        color: "#B8EBF0"
      }
    };
    /*
      Simple class representing a solvent.
    */

    return Solvent = (function() {
      /*
          Constructs a new Solvent.
          @type is expected to be 'oil', 'water' or 'vacuum' string.
      */

      function Solvent(type) {
        var property, propsHash, value;
        this.type = type;
        propsHash = TYPES[this.type];
        if (!(propsHash != null)) {
          throw new Error("Solvent: unknown type. Use 'vacuum', 'oil' or 'water'.");
        }
        for (property in propsHash) {
          value = propsHash[property];
          this[property] = value;
        }
      }

      return Solvent;

    })();
  });

}).call(this);

/*global define: false, $ */

define('common/serialize',['require','arrays'],function(require) {

  var arrays = require('arrays'),

      infinityToString = function (obj) {
        var i, len;
        if (arrays.isArray(obj)) {
          for (i = 0, len = obj.length; i < len; i++) {
            if (obj[i] === Infinity || obj[i] === -Infinity) {
              obj[i] = obj[i].toString();
            }
          }
        } else {
          for (i in obj) {
            if (obj.hasOwnProperty(i)) {
              if (obj[i] === Infinity || obj[i] === -Infinity) {
                obj[i] = obj[i].toString();
              }
              if (typeof obj[i] === 'object' || arrays.isArray(obj[i])) {
                infinityToString(obj[i]);
              }
            }
          }
        }
      };

  return function serialize(metaData, propertiesHash, count) {
    var result = {}, propName, prop;
    for (propName in metaData) {
      if (metaData.hasOwnProperty(propName)) {
        if (propertiesHash[propName] !== undefined && metaData[propName].serialize !== false) {
          prop = propertiesHash[propName];
          if (arrays.isArray(prop)) {
            result[propName] = count !== undefined ? arrays.copy(arrays.extend(prop, count), []) : arrays.copy(prop, []);
          }
          else if (typeof prop === 'object') {
            result[propName] = $.extend(true, {}, prop);
          }
          else {
            result[propName] = prop;
          }
        }
      }
    }
    // JSON doesn't allow Infinity values so convert them to strings.
    infinityToString(result);
    // TODO: to make serialization faster, replace arrays.copy(prop, [])
    // with arrays.clone(prop) to use typed arrays whenever they are available.
    // Also, do not call "infinityToString" function. This can be useful when
    // we decide to use serialization in tick history manager.
    // Then we can provide toString() function which will use regular arrays,
    // replace each Infinity value with string and finally call JSON.stringify().
    return result;
  };

});

/*global define */
/*jshint multistr: true */

define('md2d/views/nucleotide-paths',[],function () {
  return {
    "outline": {
      "A": "M20.7,0.4l-0.075-0.075C20.672,0.273,20.73,0.231,20.8,0.2 \
            c0.122-0.049,0.247-0.058,0.375-0.025c0.031,0.002,0.064,0.011,0.1,0.025c0.151,0.054,0.26,0.154,0.325,0.3l6.35,14.15 \
            c0.026,0.065,0.043,0.132,0.05,0.2c0.092,0.104,0.142,0.229,0.15,0.375c0.01,0.163-0.041,0.304-0.15,0.425l-9.025,9.85 \
            c-1.65,1.667-3.292,3.55-4.925,5.65L0.2,15.65c-0.11-0.121-0.16-0.262-0.15-0.425c0.008-0.146,0.058-0.271,0.15-0.375 \
            c0.005-0.068,0.021-0.134,0.05-0.2L6.6,0.5c0.074-0.146,0.19-0.246,0.35-0.3c0.151-0.064,0.301-0.064,0.45,0 \
            c0.038,0.019,0.071,0.043,0.1,0.075C7.593,0.339,7.66,0.431,7.7,0.55c0.047,0.112-0.012,0.154-0.175,0.125 \
            C7.461,0.656,7.386,0.63,7.3,0.6L1.65,15.125l12.4,13.625l12.6-13.725L20.7,0.4z",
      "C": "M12.45,0c2.167,0.5,4.066,1.95,5.7,4.35 \
            c2.033,2.967,3.05,6.533,3.05,10.7c0,3.8-0.867,7.117-2.6,9.95c-0.067,0.133-0.167,0.217-0.3,0.25c-0.133,0.067-0.267,0.067-0.4,0 \
            c-0.133-0.033-0.233-0.117-0.3-0.25c-0.133-0.233-0.283-0.45-0.45-0.65V24.3c-1.8-2.667-3.983-4-6.55-4 \
            c-2.567,0.034-4.767,1.383-6.6,4.05c-0.167,0.2-0.3,0.417-0.4,0.65c-0.1,0.133-0.217,0.217-0.35,0.25 \
            c-0.133,0.067-0.267,0.067-0.4,0c-0.133-0.033-0.233-0.117-0.3-0.25C0.85,22.167,0,18.85,0,15.05c0-4.167,1-7.733,3-10.7 \
            C4.633,1.95,6.55,0.5,8.75,0H12.45z M4,5.05V5C3.991,5.016,3.982,5.033,3.975,5.05C2.289,7.935,1.431,11.126,1.4,14.625 \
            c-0.03,3.519,0.536,6.477,1.7,8.875c2.066-3.39,4.566-5.064,7.5-5.025c2.933,0.04,5.433,1.731,7.5,5.075 \
            c1.088-2.518,1.605-5.559,1.55-9.125c-0.055-3.565-0.888-6.69-2.5-9.375V5c-1.8-2.397-3.983-3.589-6.55-3.575 \
            C8.033,1.439,5.833,2.647,4,5.05z",
      "G": "M8.75,0h3.675c2.191,0.504,4.1,1.963,5.725,4.375V4.35 \
            c2.035,2.963,3.052,6.53,3.05,10.7c0.001,4.17-1.015,7.737-3.05,10.7v-0.025c-2.066,3.065-4.583,4.59-7.55,4.575 \
            c-2.966,0.023-5.5-1.494-7.6-4.55v-0.025C0.999,22.77-0.001,19.211,0,15.05c-0.001-4.161,0.999-7.72,3-10.675V4.35 \
            C4.647,1.953,6.564,0.503,8.75,0z M17.15,25.05c1.754-2.938,2.621-6.354,2.6-10.25c-0.022-3.895-0.889-7.145-2.6-9.75V5.025 \
            c-1.8-2.269-3.984-3.402-6.55-3.4C8.033,1.63,5.833,2.771,4,5.05V5.025c-1.646,2.778-2.496,6.12-2.55,10.025 \
            C1.396,18.955,2.246,22.297,4,25.075V25.05c1.583,2.593,3.667,3.985,6.25,4.175c2.583,0.189,4.883-1.194,6.9-4.15V25.05z",
      "T": "M7.45,0.2H7.9C7.794,0.442,7.677,0.709,7.55,1 \
            C6.388,3.721,4.504,8.396,1.9,15.025l6.9,8.35l1.025-1.35c1.258-1.424,2.55-2.816,3.875-4.175l0.025-0.025 \
            c0.148-0.186,0.314-0.336,0.5-0.45c0.046-0.028,0.096-0.036,0.15-0.025c0.059,0.007,0.109,0.032,0.15,0.075l5.325,5.95l6.95-8.35 \
            C24.252,8.584,22.369,3.909,21.15,1c-0.127-0.284-0.243-0.551-0.35-0.8h0.6h0.575c0.041,0.045,0.075,0.095,0.1,0.15l6.35,14.15 \
            c0.028,0.066,0.053,0.133,0.075,0.2c0.087,0.129,0.137,0.279,0.15,0.45c0.01,0.238-0.065,0.447-0.225,0.625l-8.2,8.95 \
            c-0.102,0.12-0.227,0.204-0.375,0.25c-0.167,0.043-0.334,0.043-0.5,0c-0.147-0.046-0.272-0.129-0.375-0.25l-4.675-5.1l-4.625,5.1 \
            c-0.101,0.121-0.226,0.204-0.375,0.25c-0.167,0.043-0.334,0.043-0.5,0c-0.147-0.046-0.272-0.129-0.375-0.25l-8.15-8.95 \
            c-0.16-0.178-0.235-0.387-0.225-0.625c0.014-0.168,0.063-0.318,0.15-0.45c0.019-0.066,0.044-0.133,0.075-0.2l6.35-14.15V0.325 \
            C6.649,0.28,6.674,0.238,6.7,0.2H7.45z",
      "U": "M20.8,0.2h0.6h0.575c0.041,0.045,0.075,0.095,0.1,0.15 \
            l6.35,14.15c0.028,0.066,0.053,0.133,0.075,0.2c0.087,0.129,0.137,0.279,0.15,0.45c0.01,0.238-0.065,0.447-0.225,0.625l-8.2,8.95 \
            c-0.102,0.12-0.227,0.204-0.375,0.25c-0.167,0.043-0.334,0.043-0.5,0c-0.147-0.046-0.272-0.129-0.375-0.25l-4.675-5.1l-4.625,5.1 \
            c-0.101,0.121-0.226,0.204-0.375,0.25c-0.167,0.043-0.334,0.043-0.5,0c-0.147-0.046-0.272-0.129-0.375-0.25l-8.15-8.95 \
            c-0.16-0.178-0.235-0.387-0.225-0.625c0.014-0.168,0.063-0.318,0.15-0.45c0.019-0.066,0.044-0.133,0.075-0.2l6.35-14.15V0.325 \
            C6.649,0.28,6.674,0.238,6.7,0.2h0.75H7.9C7.794,0.442,7.677,0.709,7.55,1C6.388,3.721,4.504,8.396,1.9,15.025l6.9,8.35 \
            l1.025-1.35c1.258-1.424,2.55-2.816,3.875-4.175l0.025-0.025c0.148-0.186,0.314-0.336,0.5-0.45 \
            c0.046-0.028,0.096-0.036,0.15-0.025c0.059,0.007,0.109,0.032,0.15,0.075l5.325,5.95l6.95-8.35C24.252,8.584,22.369,3.909,21.15,1 \
            C21.023,0.716,20.907,0.449,20.8,0.2z"
    },
    "interior": {
      "A": "M21.175,0.175C21.046,0.143,20.921,0.151,20.8,0.2 \
            c-0.069,0.031-0.128,0.073-0.175,0.125c-0.055,0.054-0.097,0.121-0.125,0.2c-0.063,0.16,0.003,0.118,0.2-0.125l5.95,14.625 \
            L14.05,28.75L1.65,15.125L7.3,0.6c0.086,0.03,0.161,0.056,0.225,0.075C7.688,0.704,7.747,0.662,7.7,0.55 \
            C7.66,0.431,7.593,0.339,7.5,0.275L7.6,0.2c4.8-0.067,7.283-0.1,7.45-0.1l6.1,0.05L21.175,0.175z",
      "C": "M3.975,5.05H4c1.833-2.402,4.033-3.611,6.6-3.625 \
            C13.167,1.411,15.35,2.603,17.15,5v0.05c1.612,2.685,2.445,5.81,2.5,9.375c0.055,3.566-0.461,6.607-1.55,9.125 \
            c-2.067-3.344-4.567-5.035-7.5-5.075c-2.934-0.04-5.434,1.635-7.5,5.025c-1.164-2.398-1.73-5.356-1.7-8.875 \
            C1.431,11.126,2.289,7.935,3.975,5.05z",
      "G": "M17.15,25.05v0.025c-2.017,2.956-4.317,4.339-6.9,4.15 \
            C7.667,29.035,5.583,27.643,4,25.05v0.025c-1.754-2.778-2.604-6.12-2.55-10.025C1.504,11.145,2.354,7.803,4,5.025V5.05 \
            c1.833-2.278,4.033-3.42,6.6-3.425c2.566-0.002,4.75,1.131,6.55,3.4V5.05c1.711,2.605,2.578,5.855,2.6,9.75 \
            C19.771,18.695,18.904,22.112,17.15,25.05z",
      "T": "M21.4,0.2h-0.6c0.107,0.249,0.223,0.516,0.35,0.8 \
            c1.219,2.909,3.103,7.584,5.65,14.025l-6.95,8.35l-5.325-5.95c-0.041-0.042-0.091-0.067-0.15-0.075 \
            c-0.054-0.011-0.104-0.003-0.15,0.025c-0.186,0.114-0.352,0.264-0.5,0.45L13.7,17.85c-1.325,1.358-2.617,2.75-3.875,4.175 \
            L8.8,23.375l-6.9-8.35C4.504,8.396,6.388,3.721,7.55,1C7.677,0.709,7.794,0.442,7.9,0.2H7.45c0.133-0.067,0.333-0.1,0.6-0.1 \
            c0.406,0,1.606-0.008,3.6-0.025l-1.375,0.05C17.28,0.048,20.955,0.056,21.3,0.15C21.334,0.164,21.368,0.181,21.4,0.2z",
      "U": "M7.9,0.2l0.15-0.1c0.406,0,1.606-0.008,3.6-0.025l-1.375,0.05 \
            c6.009-0.066,9.568-0.066,10.675,0L20.8,0.2c0.107,0.249,0.223,0.516,0.35,0.8c1.219,2.909,3.103,7.584,5.65,14.025l-6.95,8.35 \
            l-5.325-5.95c-0.041-0.042-0.091-0.067-0.15-0.075c-0.054-0.011-0.104-0.003-0.15,0.025c-0.186,0.114-0.352,0.264-0.5,0.45 \
            L13.7,17.85c-1.325,1.358-2.617,2.75-3.875,4.175L8.8,23.375l-6.9-8.35C4.504,8.396,6.388,3.721,7.55,1 \
            C7.677,0.709,7.794,0.442,7.9,0.2z"
    },
    "letter": {
      "A": {
        "1": "M12.85,12.55h2.6l-1.3-3.95L12.85,12.55z M13,6.25h2.4l3.55,10.1 \
              h-2.3L16,14.3h-3.7l-0.7,2.05H9.4L13,6.25z",
        "2": "M18.7,5.95l-3.55,10.1h-2.4l-3.6-10.1h2.2L12.05,8h3.7l0.65-2.05 \
              H18.7z M12.6,9.75l1.3,3.95l1.3-3.95H12.6z"
      },
      "C": {
        "1": "M10.45,6.4c1.667,0,2.883,0.55,3.65,1.65 \
              c0.433,0.633,0.667,1.267,0.7,1.9h-2.1c-0.133-0.5-0.3-0.867-0.5-1.1c-0.4-0.434-0.967-0.65-1.7-0.65S9.183,8.5,8.75,9.1 \
              C8.317,9.733,8.1,10.617,8.1,11.75c0,1.1,0.217,1.933,0.65,2.5c0.467,0.567,1.05,0.85,1.75,0.85c0.733,0,1.283-0.233,1.65-0.7 \
              c0.233-0.267,0.417-0.667,0.55-1.2h2.05c-0.167,1.1-0.617,2-1.35,2.7c-0.733,0.7-1.683,1.05-2.85,1.05 \
              c-1.433,0-2.566-0.467-3.4-1.4c-0.8-0.933-1.2-2.216-1.2-3.85c0-1.767,0.466-3.117,1.4-4.05C8.15,6.817,9.183,6.4,10.45,6.4z",
        "2": "M15,12.35c-0.033,0.633-0.267,1.267-0.7,1.9 \
              c-0.767,1.1-1.983,1.65-3.65,1.65c-1.267,0-2.3-0.417-3.1-1.25c-0.933-0.933-1.4-2.283-1.4-4.05c0-1.633,0.4-2.917,1.2-3.85 \
              c0.833-0.933,1.967-1.4,3.4-1.4c1.167,0,2.117,0.35,2.85,1.05c0.733,0.7,1.183,1.6,1.35,2.7H12.9 \
              c-0.133-0.533-0.316-0.934-0.55-1.2c-0.367-0.467-0.917-0.7-1.65-0.7c-0.7,0-1.284,0.283-1.75,0.85 \
              c-0.434,0.567-0.65,1.4-0.65,2.5c0,1.133,0.217,2.017,0.65,2.65c0.433,0.6,1.017,0.9,1.75,0.9c0.733,0,1.3-0.217,1.7-0.65 \
              c0.2-0.233,0.367-0.6,0.5-1.1H15z"
      },
      "G": {
        "1": "M14.8,10.8h-2.05c-0.167-0.667-0.567-1.133-1.2-1.4 \
              c-0.333-0.167-0.716-0.25-1.15-0.25c-0.8,0-1.467,0.3-2,0.9c-0.5,0.633-0.75,1.567-0.75,2.8s0.283,2.1,0.85,2.6 \
              c0.567,0.533,1.2,0.8,1.9,0.8c0.7,0,1.283-0.217,1.75-0.65c0.434-0.4,0.717-0.934,0.85-1.6h-2.35v-1.65h4.2v5.4h-1.4l-0.2-1.25 \
              c-0.4,0.467-0.767,0.8-1.1,1C11.583,17.833,10.9,18,10.1,18c-1.333,0-2.434-0.467-3.3-1.4c-0.867-0.9-1.3-2.167-1.3-3.8 \
              s0.45-2.933,1.35-3.9c0.867-1,2.05-1.5,3.55-1.5c1.267,0,2.3,0.333,3.1,1C14.267,9.033,14.7,9.833,14.8,10.8z",
        "2": "M10.65,9.65c-0.7,0-1.333,0.267-1.9,0.8 \
              c-0.567,0.5-0.85,1.367-0.85,2.6c0,1.233,0.25,2.167,0.75,2.8c0.533,0.6,1.2,0.9,2,0.9c0.434,0,0.817-0.083,1.15-0.25 \
              c0.633-0.267,1.034-0.733,1.2-1.4h2.05c-0.1,0.967-0.533,1.767-1.3,2.4c-0.8,0.667-1.833,1-3.1,1c-1.5,0-2.683-0.5-3.55-1.5 \
              c-0.9-0.967-1.35-2.267-1.35-3.9s0.433-2.9,1.3-3.8c0.867-0.933,1.967-1.4,3.3-1.4c0.8,0,1.483,0.167,2.05,0.5 \
              c0.333,0.2,0.7,0.533,1.1,1l0.2-1.25h1.4v5.4h-4.2V11.9h2.35c-0.133-0.667-0.417-1.2-0.85-1.6C11.933,9.867,11.35,9.65,10.65,9.65z"
      },
      "T": {
        "1": "M10.3,5 L18.45,5 L18.45,6.8 L15.4,6.8 L15.4,15.1 L13.3,15.1 \
              L13.3,6.8 L10.3,6.8z",
        "2": "M10.2,14.65 L10.2,12.85 L13.2,12.85 L13.2,4.55 L15.3,4.55 \
              L15.3,12.85 L18.35,12.85 L18.35,14.65z"
      },
      "U": {
        "1": "M10.15,10.8V4.6h2.15v6.2c0,0.7,0.083,1.217,0.25,1.55 \
              c0.267,0.566,0.817,0.85,1.65,0.85c0.867,0,1.417-0.284,1.65-0.85c0.167-0.333,0.25-0.85,0.25-1.55V4.6h2.15v6.2 \
              c0,1.067-0.167,1.9-0.5,2.5c-0.633,1.1-1.817,1.65-3.55,1.65c-1.733,0-2.917-0.55-3.55-1.65C10.317,12.7,10.15,11.867,10.15,10.8z",
        "2": "M12.45,8.4v6.2H10.3V8.4c0-1.066,0.167-1.9,0.5-2.5 \
              c0.633-1.1,1.817-1.65,3.55-1.65S17.267,4.8,17.9,5.9c0.333,0.6,0.5,1.434,0.5,2.5v6.2h-2.15V8.4c0-0.7-0.083-1.217-0.25-1.55 \
              C15.767,6.283,15.217,6,14.35,6c-0.833,0-1.383,0.283-1.65,0.85C12.533,7.183,12.45,7.7,12.45,8.4z"
      }
    }
  };
});

/*global define, d3 */

define('md2d/views/nucleotides',['require','md2d/views/nucleotide-paths'],function (require) {
  var nucleotidePaths = require('md2d/views/nucleotide-paths'),

      SCALE = 0.007,
      W = {
        "BACKB": 52,
        "A": 28.151,
        "C": 21.2,
        "G": 21.2,
        "T": 28.651,
        "U": 28.651,
        "A_GLOW": 44.125,
        "C_GLOW": 37.2,
        "G_GLOW": 36.2,
        "T_GLOW": 45.566
      },
      H = {
        "BACKB": 14,
        "A": 31.15,
        "C": 25.3,
        "G": 30.3,
        "T": 25.007,
        "U": 25.007,
        "A_GLOW": 44.55,
        "C_GLOW": 41.417,
        "G_GLOW": 45.3,
        "T_GLOW": 40.65
      };

  (function () {
    var name;
    for (name in W) {
      if (W.hasOwnProperty(name)) {
        W[name] *= SCALE;
      }
    }
    for (name in H) {
      if (H.hasOwnProperty(name)) {
        H[name] *= SCALE;
      }
    }
  }());

  function nucleotides() {
    var m2px = null,
        sequence = "",
        direction = 1,
        bonds = 1,
        backbone = "DNA", // if enabled, "RNA" or "DNA" is expected.
        stopCodonsHash = null,
        randomEnter = true,
        glow = false,
        enterExitOnly = false,

        xShift = 0,
        yShift = 0;

    function shift(enabled) {
      var t, r;
      if (enabled) {
        // While adding a new mRNA segment, choose a random starting point along a
        // circle with a certain radius that extends beyond the top DNA strand.
        // Use parametric circle equation: x = r cos(t), y = r sin(t)
        // Limit range of the "t" parameter to: [0.25 * PI, 0.75 * PI) and [1.25 * PI, 1.75 * PI),
        // so new mRNA segments will come only from the top or bottom side of the container.
        t = Math.random() >= 0.5 ? Math.PI * 0.25 : Math.PI * 1.25;
        t += Math.random() * Math.PI * 0.5;
        r = nucleotides.HEIGHT * 6;
        xShift = r * Math.cos(t);
        yShift = r * Math.sin(t);
      } else {
        xShift = yShift = 0;
      }
    }

    function translate(d) {
      return "translate(" + m2px(xShift + nucleotides.WIDTH * (d.idx)) + " " + m2px(yShift) + ")";
    }

    function nucleo(g) {
      g.each(function(d, i) {
        var g = d3.select(this),

            yOffset = backbone ? 0.9 * H.BACKB : 0,
            yStart = m2px(yOffset + 0.5 * H.A),
            yEnd = m2px(yOffset + H.A * 0.97),

            seq = typeof sequence === "function" ? sequence(d, i) : sequence,

            nucleo, nucleoEnter, nucleoExit, nucleoGEnter, backboneEnter,
            nucleoShape, nucleoSVG, nucleoSVGUpdate, nucleoTrans, targetScale;

        if (typeof seq === "string") {
          // seq is a string, generate data array. Change it to array of objects.
          // e.g. "AG" will be change to [{idx: 0, type: "A"}, {idx: 1, type: "G"}].
          seq = seq.split("");
          seq.forEach(function(val, i) {
            seq[i] = {id: i, idx: i, type: val};
          });
        }

        // Join data by ID.
        nucleo = g.selectAll(".nucleotide").data(seq, function (d) { return d.id; });
        nucleoEnter = nucleo.enter();
        nucleoExit = nucleo.exit();

        // Enter.
        // Random initial positions of the new mRNAs.
        shift(randomEnter);
        nucleoEnter = nucleoEnter.append("g").attr({
          "transform": translate
        }).style({
          "opacity": randomEnter ? 0 : 1
        });
        // Additional container for scaling.
        nucleoGEnter = nucleoEnter.append("g").attr({
          "class": "scale",
          "transform": "scale(1, " + (direction  === 1 ? 1 : -1) + ")",
        });
        // Bonds.
        nucleoGEnter.append("path").attr("class", "bonds")
          .style({
            "stroke-width": m2px(0.01),
            "stroke": "#fff"
          });
        // Main shape.
        nucleoShape = nucleoGEnter.append("g")
          .classed("nucleo-shape", true)
          .classed("clickable-nucleo", function (d) {
            return d.region === "c" && glow;
          }).on("click", function () {
            // Mobile Safari will only produce mouse events when the user taps
            // on a clickable element, like a link. You can make an element
            // clickable by adding an onClick event handler to it, even if that
            // handler does nothing. It's necessary, as nucleotides should be
            // clickable, e.g. to show context menu.
          });
        // Optional glow image.
        if (glow) {
          nucleoShape.append("image").attr({
            "class": "glow",
            "y": m2px(yOffset - 0.17 * W.G_GLOW),  // move glow closer to the backbone
            "preserveAspectRatio": "none"
          });
        }
        // Parts of nucleotide shape (outline, interior, letter).
        nucleoSVG = nucleoShape.append("svg").attr({
          "y": m2px(yOffset),
          "preserveAspectRatio": "none",
        });
        nucleoSVG.append("path").attr({
          "class": "outline",
          "fill-rule": "evenodd",
          "clip-rule": "evenodd"
        });
        nucleoSVG.append("path").attr({
          "class": "interior",
          "fill-rule": "evenodd",
          "clip-rule": "evenodd"
        });
        nucleoSVG.append("path").attr({
          "class": "letter",
          "fill-rule": "evenodd",
          "clip-rule": "evenodd",
          "d": function (d) { return nucleotidePaths.letter[d.type][direction]; }
        });
        // Optional backbone.
        if (backbone) {
          backboneEnter = nucleoGEnter.append("image").attr({
            "class": "backbone",
            "x": 0,
            "y": 0,
            "width": m2px(W.BACKB),
            "height": m2px(H.BACKB),
            "preserveAspectRatio": "none",
            "xlink:href": "resources/dna/Backbone_" + backbone + ".svg"
          });
        }

        // Update.
        if (enterExitOnly) {
          // Special mode when we update ONLY nucleotides from enter and exit
          // subselections. It's useful to add new nucleotides while other
          // are being modified by transition at the same time, so it won't
          // be affected.
          nucleo = nucleoEnter;
        }

        // Update without transition.
        nucleo.attr("class", function(d) {
          var regionClass = "";
          switch(d.region) {
            case "c": regionClass = "coding-region"; break;
            case "j": regionClass = "junk-region"; break;
            case "p": regionClass = "promoter-region"; break;
            case "t": regionClass = "terminator-region"; break;
          }
          return "nucleotide " + regionClass;
        });
        nucleo.select(".bonds").attr("d", function (d) {
          if (d.type === "C" || d.type === "G") {
            return "M" + m2px(SCALE * 20) + " " + yStart + " L " + m2px(SCALE * 20) + " " + yEnd +
                   "M" + m2px(SCALE * 26) + " " + yStart + " L " + m2px(SCALE * 26) + " " + yEnd +
                   "M" + m2px(SCALE * 32) + " " + yStart + " L " + m2px(SCALE * 32) + " " + yEnd;
          } else {
            return "M" + m2px(SCALE * 22) + " " + yStart + " L " + m2px(SCALE * 22) + " " + yEnd +
                   "M" + m2px(SCALE * 30) + " " + yStart + " L " + m2px(SCALE * 30) + " " + yEnd;
          }
        });
        nucleo.select(".glow").attr({
          "x": function (d) { return m2px(W.BACKB) / 2 - m2px(W[d.type + "_GLOW"]) / 2; },
          "width": function (d) { return m2px(W[d.type + "_GLOW"]); },
          "height": function (d) { return m2px(H[d.type + "_GLOW"]); },
          "xlink:href": function (d) { return "resources/dna/NucleotideGlow_" + d.type + ".svg"; }
        });
        nucleoSVGUpdate = nucleo.select(".nucleo-shape > svg");
        nucleoSVGUpdate.attr({
          "class": function (d) {
            var className = "type-" + d.type;
            if (stopCodonsHash && stopCodonsHash[d.idx]) {
              className += " stop-codon";
            }
            return className;
          },
          "viewBox": function (d) { return "0 0 " + (W[d.type] / SCALE) + " " + (H[d.type] / SCALE); },
          "x": function (d) { return m2px(W.BACKB) / 2 - m2px(W[d.type]) / 2; },
          "width": function (d) { return m2px(W[d.type]); },
          "height": function (d) { return m2px(H[d.type]); }
        });
        nucleoSVGUpdate.select("path.interior").attr("d", function (d) {
          return nucleotidePaths.interior[d.type];
        });
        nucleoSVGUpdate.select("path.outline").attr("d", function (d) {
          return nucleotidePaths.outline[d.type];
        });

        // Update with transition.
        shift(false);
        nucleoTrans = d3.transition(nucleo)
          .attr("transform", translate)
          .style("opacity", 1);

        // Animate also bonds opacity.
        nucleoTrans.select(".bonds").style("opacity", bonds);

        // Duck test whether nucleoTrans is really translation. See D3 API
        // Reference - d3.transition(selection) returns transition only when
        // called in the context of other transition. Otherwise it returns
        // selection.
        if (nucleoTrans.attrTween) {
          // Scale. We can't simply use .attr, as rotation is used (to make
          // scale change fancier?). attrTween enforces simple change from
          // scale(1,1) to scale(1,-1) without using rotation.
          targetScale  = "scale(1, " + (direction  === 1 ? 1 : -1) + ")";
          nucleoTrans.select("g.scale").attrTween("transform", function(d, i, a) {
            return d3.interpolateString(a, targetScale);
          });
          // Letters. Default d3 interpolator creates some
          // results which can't be parsed. Use custom interpolator,
          // which changes letters in the middle of transition.
          nucleoTrans.select("path.letter").attrTween("d", function (d, i, a) {
            return function(t) {
              return t < 0.5 ? a : nucleotidePaths.letter[d.type][direction];
            };
          });
        } else {
          // The same operations, but without using transition.
          nucleo.select("g.scale").attr("transform", "scale(1, " + (direction  === 1 ? 1 : -1) + ")");
          nucleo.select("path.letter")
            .attr("d", function (d) { return nucleotidePaths.letter[d.type][direction]; });
        }

        // Exit.
        shift(true);
        d3.transition(nucleoExit)
          .attr("transform", translate)
          .style("opacity", 0)
          .remove();
      });
    }

    nucleo.sequence = function (s) {
      if (!arguments.length) return sequence;
      sequence = s;
      return nucleo;
    };

    nucleo.model2px = function (m) {
      if (!arguments.length) return m2px;
      m2px = m;
      return nucleo;
    };

    nucleo.direction = function (d) {
      if (!arguments.length) return direction;
      direction = d;
      return nucleo;
    };

    nucleo.bonds = function (b) {
      if (!arguments.length) return bonds;
      bonds = b;
      return nucleo;
    };

    nucleo.randomEnter = function (r) {
      if (!arguments.length) return randomEnter;
      randomEnter = r;
      return nucleo;
    };

    /**
     * Enables or disables nucleotide glowing on hover.
     * @param  {boolean} g
     */
    nucleo.glow = function (g) {
      if (!arguments.length) return glow;
      glow = g;
      return nucleo;
    };

    /**
     * @param  {String} b "DNA" or "RNA".
     */
    nucleo.backbone = function (b) {
      if (!arguments.length) return backbone;
      backbone = b;
      return nucleo;
    };

    nucleo.stopCodonsHash = function (s) {
      if (!arguments.length) return stopCodonsHash;
      stopCodonsHash = s;
      return nucleo;
    };

    /**
     * Special mode for quick update of rendered nucleotides number.
     * When this option is set to true, only new nucleotides will be
     * added and other possibly removed. None of existing
     * nucleotides will be updated. It's useful to add new nucleotides
     * while there is an ongoing transition on existing nucleoties.
     * @param  {boolean} ee
     */
    nucleo.enterExitOnly = function (ee) {
      if (!arguments.length) return enterExitOnly;
      enterExitOnly = ee;
      return nucleo;
    };

    return nucleo;
  }

  // Width of the nucleotide is width of the DNA backbone.
  // * 0.92 to ensure that DNA backbone doesn't contain any visual discontinuities.
  // There are two bugs connected with it. First is in Chrome, where preserveAspectRatio
  // is ignored for images, the second one is in Safari, which has problems with correct
  // width of the images. Please see:
  // https://www.pivotaltracker.com/story/show/48453261
  nucleotides.WIDTH  = W.BACKB * 0.92;
  // Height of the nucleotide is height of the DNA backbone + A nucleotide (tallest one).
  // * 0.96 because it simply... looks better. This value is used to determine distance
  // between two strands of DNA and this multiplier causes that they are closer to each other.
  nucleotides.HEIGHT = (H.BACKB * 0.9 + H.A) * 0.96;

  return nucleotides;
});

/*global d3, define */

define('md2d/models/engine/genetic-engine',['require','cs!md2d/models/aminoacids-helper','common/alert','md2d/views/nucleotides'],function (require) {

  var aminoacidsHelper = require('cs!md2d/models/aminoacids-helper'),
      alert            = require('common/alert'),
      NUCLEO_WIDTH     = require('md2d/views/nucleotides').WIDTH,

      STATES = [
        "undefined",
        "intro-cells",
        "intro-zoom1",
        "intro-zoom2",
        "intro-zoom3",
        "intro-polymerase",
        "dna",
        "transcription",
        "transcription-end",
        "after-transcription",
        "before-translation",
        "translation",
        "translation-end"
      ],
      STATE_INDEX = {},

      NUCLEO_LAST_ID = 0,

      PROMOTER_SEQ   = "TGACCTCTCCGCGCCATCTATAAACCGAAGCGCTAGCTACA",
      TERMINATOR_SEQ = "ACCACAGGCCGCCAGTTCCGCTGGCGGCATTTT",
      PROMOTER_COMP_SEQ   = complementarySequence(PROMOTER_SEQ),
      TERMINATOR_COMP_SEQ = complementarySequence(TERMINATOR_SEQ),
      JUNK_SEQ,
      JUNK_COMP_SEQ,

      DEF_EVENT = "change";

  function complementarySequence(DNA) {
    // A-T (A-U)
    // G-C
    // T-A (U-A)
    // C-G

    // Use lower case during conversion to
    // avoid situation when you change A->T,
    // and later T->A again.
    return DNA
            .replace(/A/g, "t")
            .replace(/G/g, "c")
            .replace(/T/g, "a")
            .replace(/C/g, "g")
            .toUpperCase();
  }
  // Generates junk DNA sequence.
  function junkSequence(len) {
    var letters = ["A", "G", "T", "C"],
        lettersLen = letters.length,
        seq = "", i;
    for (i = 0; i < len; i++) {
      seq += letters[Math.floor(Math.random() * lettersLen)];
    }
    return seq;
  }

  function getNucleoID() {
    return NUCLEO_LAST_ID++;
  }

  (function () {
    var i, len;
    for (i = 0, len = STATES.length; i < len; i++) {
      STATE_INDEX[STATES[i]] = i;
    }
    JUNK_SEQ = junkSequence(50);
    JUNK_COMP_SEQ = complementarySequence(JUNK_SEQ);
  }());

  return function GeneticProperties(model) {
    var api,
        // Do not change this variable manually. It's changed in set() private
        // function. It decides what type of event should be dispatched when
        // DNA or DNAState is updated.
        eventMode = DEF_EVENT,
        // List of transitions, which are currently ongoing (index 0)
        // or scheduled (index > 0).
        ongoingTransitions = [],
        // DNA complementary sequence.
        DNAComp = "",
        // Complete mRNA based on current DNA. Useful for codon() method,
        // which needs to know the whole sequence in advance.
        mRNA = "",
        // Stop codons.
        stopCodonsHash,
        // Index of the first stop codon.
        lastTranslationStep,

        dispatch = d3.dispatch("change", "transition"),

        calculatemRNA = function () {
          var newCode = mRNACode(0),
              mRNA = "";
          while(newCode) {
            mRNA += newCode;
            newCode = mRNACode(mRNA.length);
          }
          return mRNA;
        },

        calculateStopCodonsHash = function () {
          var codon, i, len;

          stopCodonsHash = {};
          lastTranslationStep = null;
          for (i = 0, len = mRNA.length; i < len; i += 3) {
            codon = mRNA.substr(i, 3);
            if (aminoacidsHelper.codonToAbbr(codon) === "STOP") {
              if (lastTranslationStep === null) {
                lastTranslationStep = i / 3;
              }
              // Note that codonToAbbr returns "STOP" also when codon length is
              // smaller than 3. In this case, we want to mark only codons which
              // are a "real" STOP codons, so check their length.
              if (codon.length === 3) {
                stopCodonsHash[i] = stopCodonsHash[i + 1] = stopCodonsHash[i + 2] = true;
              }
            }
          }
          if (lastTranslationStep === null) {
            // No stop codon found.
            lastTranslationStep = Math.floor(mRNA.length / 3);
          }
        },

        mRNACode = function (index) {
          if (index >= DNAComp.length) {
            // No more DNA to transcribe, return null.
            return null;
          }
          switch (DNAComp[index]) {
            case "A": return "U";
            case "G": return "C";
            case "T": return "A";
            case "C": return "G";
          }
        },

        generateMRNAViewModel = function (array, sequence) {
          var i, len, nucleo;
          // Set size of the existing array to the size of new DNA sequence.
          array.length = sequence.length;
          for (i = 0, len = sequence.length; i < len; i++) {
            nucleo = array[i] || {}; // reuse existing objects.
            nucleo.idx = i;
            // Note that only nucleotides whose type doesn't match sequence
            // will receive new ID. It lets you to update this array manually,
            // so the ID as prevented in case of need (e.g. single insertion
            // or deletion during mutation).
            if (nucleo.type !== sequence[i]) {
              nucleo.type = sequence[i];
              nucleo.id   = getNucleoID();
              // This block will be also executed when we insert objects for
              // the first time so update the array[i] reference.
              array[i] = nucleo;
            }
          }
          return array;
        },

        generateDNAViewModel = function (array, DNA, comp) {
          var sequence = !comp ? JUNK_SEQ + PROMOTER_SEQ + DNA + TERMINATOR_SEQ + JUNK_SEQ :
                         JUNK_COMP_SEQ + PROMOTER_COMP_SEQ + DNA + TERMINATOR_COMP_SEQ + JUNK_COMP_SEQ,
              junkBound = JUNK_SEQ.length,
              promoterBound = junkBound + PROMOTER_SEQ.length,
              codingBound = promoterBound + DNA.length,
              terminatorBound = codingBound + TERMINATOR_SEQ.length,
              i, len, nucleo;

          // Set size of the existing array to the size of new DNA sequence.
          array.length = sequence.length;
          for (i = 0, len = sequence.length; i < len; i++) {
            nucleo = array[i] || {}; // reuse existing objects.
            nucleo.idx = i;
            if (i < junkBound)            nucleo.region = "j";
            else if (i < promoterBound)   nucleo.region = "p";
            else if (i < codingBound)     nucleo.region = "c";
            else if (i < terminatorBound) nucleo.region = "t";
            else                          nucleo.region = "j";
            // Note that only nucleotides whose type doesn't match sequence
            // will receive new ID. It lets you to update this array manually,
            // so the ID as prevented in case of need (e.g. single insertion
            // or deletion during mutation).
            if (nucleo.type !== sequence[i]) {
              nucleo.type = sequence[i];
              nucleo.id   = getNucleoID();
              // This block will be also executed when we insert objects for
              // the first time so update the array[i] reference.
              array[i] = nucleo;
            }
          }
          return array;
        },

        updateGeneticProperties = function () {
          var DNA = model.get("DNA");

          generateDNAViewModel(api.viewModel.DNA, DNA, false);

          DNAComp = complementarySequence(DNA);
          generateDNAViewModel(api.viewModel.DNAComp, DNAComp, true);

          mRNA = calculatemRNA();
          calculateStopCodonsHash();
          // mRNA view array is also based on the current state.
          if (api.stateBefore("transcription:0")) {
            generateMRNAViewModel(api.viewModel.mRNA, "");
          } else if (api.state().name === "transcription") {
            generateMRNAViewModel(api.viewModel.mRNA, mRNA.substr(0, api.state().step));
          } else if (api.stateAfter("transcription")) {
            // So, the first state which triggers it is "transcription-end".
            generateMRNAViewModel(api.viewModel.mRNA, mRNA);
          }

          if (eventMode !== "transition") {
            // While jumping between states, ensure that user can see a valid
            // number of amino acids.
            if (api.stateBefore("translation:1")) {
              removeAminoAcids();
            } else if (api.stateEqual("translation-end")) {
              generateFinalProtein();
            }
          }
        },

        removeAminoAcids = function () {
          var aaCount;

          aaCount = model.getNumberOfAtoms();
          if (aaCount > 0) {
            model.startBatch();
            while(aaCount > 0) {
              model.removeAtom(aaCount - 1);
              aaCount--;
            }
            model.endBatch();
          }
          model.stop();
        },

        generateFinalProtein = function () {
          var aaSequenece = [],
              i = 0,
              abbr = aminoacidsHelper.codonToAbbr(api.codon(0));

          while(abbr !== "STOP") {
            aaSequenece.push(abbr);
            abbr = aminoacidsHelper.codonToAbbr(api.codon(++i));
          }
          api.generateProtein(aaSequenece, undefined, 2.3, 0.3);
          api.centerProtein();
          model.start();
        },

        nextState = function (state) {
          var name = state.name,
              next, abbr;

          if (name === "transcription") {
            if (state.step < model.get("DNA").length - 1) {
              return "transcription:" + (state.step + 1);
            } else {
              return "transcription-end";
            }
          } else if (name === "translation") {
            abbr = aminoacidsHelper.codonToAbbr(api.codon(state.step));
            if (abbr !== "STOP") {
              return "translation:" + (state.step + 1);
            } else {
              return "translation-end";
            }
          } else {
            // "Typical" state.
            next = STATES[STATE_INDEX[state.name] + 1];
            if (next === "transcription" || next === "translation") {
              next += ":0";
            }
            return next;
          }
        },

        prevState = function (state) {
          var name = state.name,
              step = state.step;

          if (name === "transcription" && step > 0) {
            return "transcription:" + (step - 1);
          } else if (name === "transcription-end") {
            return "transcription:" + (model.get("DNA").length - 1);
          } else if (name === "translation-end" || (name === "translation" && step > 0)) {
            // Note that we always return state translation:0,
            // as jumping between translation steps is not allowed.
            return "translation:0";
          } else {
            return STATES[STATE_INDEX[name] - 1];
          }
        },

        // DNA states comparator.
        stateComp = function (stateA, stateB) {
          if (stateA === stateB) {
            return 0;
          }
          stateA = api.parseState(stateA);
          stateB = api.parseState(stateB);
          if (stateA.name === stateB.name) {
            if (isNaN(stateA.step) || isNaN(stateB.step)) {
              // Note that when you compare e.g. "translate"
              // and "translate:5" these steps are considered to be equal.
              return 0;
            }
            return stateA.step < stateB.step ? -1 : 1;
          }
          return STATE_INDEX[stateA.name] < STATE_INDEX[stateB.name] ? -1 : 1;
        },

        transitionToState = function (name) {
          if (typeof name === "undefined") return;
          if (ongoingTransitions.length > 0) {
            // Some transition are in progress, so only enqueue a new state.
            ongoingTransitions.push(name);
          } else {
            // Mark transition as ongoing (by adding it to the list)
            // and do transition.
            ongoingTransitions.push(name);
            doStateTransition(name);
          }
        },

        doStateTransition = function (name) {
          set("DNAState", name, "transition");
        },

        doDNATransition = function (newDNA) {
          set("DNA", newDNA, "transition");
        },

        dispatchChange = function (suppressViewportUpdate) {
          // Cancel transitions when we are going to dispatch "change" event.
          ongoingTransitions.length = 0;
          model.cancelTransitions();

          dispatch.change(suppressViewportUpdate);
        },

        // Use this function if you want to change DNA or DNAState
        // and dispatch event different than "change" (which causes immediate
        // rendering). Options are:
        // - "change",
        // - "transition",
        // - "suppress".
        set = function(name, value, eventType) {
          eventMode = eventType || DEF_EVENT;
          model.properties[name] = value;
          eventMode = DEF_EVENT;
        },

        stateUpdated = function () {
          var state = model.get("DNAState");

          if (eventMode === "suppress") {
            return;
          }

          updateGeneticProperties();

          if (eventMode === "transition") {
            dispatch.transition(state);
          } else {

            if (api.stateAfter("translation:0") && api.stateBefore("translation-end")) {
              // It means that state was set to 'translation:x', where x > 0.
              // Use the last safe state ('translation:0') instead.
              alert("'" + state + "' cannot be set explicitly. " +
                "'translation:0' should be set and then animation to '" +
                state + "' should be triggered.");
              set("DNAState", "translation:0");
              return;
            }

            dispatchChange();
          }
        },

        DNAUpdated = function () {
          if (eventMode === "suppress") {
            return;
          }

          if (api.stateAfter("translation:0") && api.stateBefore("translation-end")) {
            // Reset translation if DNA is changed. This will remove all
            // existing amino acids and notify renderer (via stateUpdated
            // callback).
            set("DNAState", "translation:0");
            return;
          }

          updateGeneticProperties();

          if (eventMode === "transition") {
            dispatch.transition("dna-updated", true);
          } else {
            dispatchChange(true);
          }
        };

    // Public API.
    api = {
      /**
       * Number of nucleotides before coding region (so, in junk and promoter regions).
       * @type {number}
       */
      PRECODING_LEN: JUNK_SEQ.length + PROMOTER_SEQ.length,

      /**
       * Hash of arrays containing nucleotides objects. Each array can be
       * consumed by the view. References to arrays are guaranteed to be
       * untouched during whole life cycle of the GeneticEngine instance.
       * Only arrays' lengths and content can be changed.
       *
       * Each nucleotide is defined by:
       * type   - letter ("A", "T", "U", "G" or "C"),
       * idx    - its position,
       * id     - unique id,
       * coding - true if nucleotide is a part of coding region (not junk, terminator or promoter).
       */
      viewModel: {
        mRNA: [],
        DNA: [],
        DNAComp: []
      },

      /**
       * Registers listener for given event type. Supported events
       * are: "change" and "transition".
       * @param  {string} type
       * @param  {function} listener
       */
      on: function(type, listener) {
        dispatch.on(type, listener);
      },

      /**
       * Performs substitution mutation on DNA coding region.
       * @param  {number} idx            position in DNA.
       * @param  {string} newType        "A", "T", "G" or "C".
       * @param  {boolean} DNAComplement if true, mutation is performed
       *                                 on DNA complementary strand.
       */
      mutate: function(idx, newType, DNAComplement) {
        var DNA = model.get("DNA"),
            pos = idx - api.PRECODING_LEN;

        if (pos < 0 || pos >= DNA.length) {
          throw new Error("Mutation can be performed only on DNA coding region.");
        }

        DNA = DNA.substr(0, pos) +
              (DNAComplement ? complementarySequence(newType) : newType) +
              DNA.substr(pos + 1);
        // Update DNA. This will also call updateGeneticProperties(), so
        // other, related properties will be also updated.
        set("DNA", DNA);
      },

      /**
       * Performs insertion mutation on DNA coding region.
       * @param  {number} idx            position in DNA.
       * @param  {string} type           "A", "T", "G" or "C".
       * @param  {boolean} DNAComplement if true, mutation is performed
       *                                 on DNA complementary strand.
       */
      insert: function(idx, type, DNAComplement) {
        var newDNANucleo = {
              type: DNAComplement ? complementarySequence(type) : type,
              id: getNucleoID(),
              region: "c"
            },
            newDNACompNucleo = {
              type: DNAComplement ? type : complementarySequence(type),
              id: getNucleoID(),
              region: "c"
            },
            newMRNANucleo = {
              type: DNAComplement ? complementarySequence(type) : type,
              id: getNucleoID(),
              region: "c"
            },
            DNA = model.get("DNA"),
            state = api.state(),
            pos = idx - api.PRECODING_LEN;

        if (pos < 0 || pos >= DNA.length) {
          throw new Error("Mutation can be performed only on DNA coding region.");
        }

        // Update view model arrays. It isn't necessary, but as we update them
        // correctly, nucleotides will preserve their IDs and view will know
        // exactly what part of DNA have been changed.
        api.viewModel.DNA.splice(idx, 0, newDNANucleo);
        api.viewModel.DNAComp.splice(idx, 0, newDNACompNucleo);
        api.viewModel.mRNA.splice(pos, 0, newMRNANucleo);

        // Update DNA. This will also call updateGeneticProperties(), so
        // other, related properties will be also updated.
        DNA = DNA.substr(0, pos) + newDNANucleo.type + DNA.substr(pos);

        // Special case for transcription process (and state):
        // If we keep the same DNAState and we insert something
        // before state.step position, it would cause that the last
        // transcribed nucleotide would be removed. Avoid that, as this can be
        // confusing for users.
        if (state.name === "transcription" && pos < state.step) {
          // Note that we can't use nextState(state), as in that case, as
          // state can be changed to transcription-end too fast (as DNA isn't
          // updated yet).
          set("DNAState", state.name + ":" + (state.step + 1), "suppress");
        }
        doDNATransition(DNA);
      },

      /**
       * Performs deletion mutation on DNA coding region.
       * @param  {number} idx position in DNA.
       */
      delete: function(idx) {
        var DNA = model.get("DNA"),
            state = api.state(),
            pos = idx - api.PRECODING_LEN;

        if (pos < 0 || pos >= DNA.length) {
          throw new Error("Mutation can be performed only on DNA coding region.");
        }

        // Update view model arrays. It isn't necessary, but as we update them
        // correctly, nucleotides will preserve their IDs and view will know
        // exactly what part of DNA have been changed.
        api.viewModel.DNA.splice(idx, 1);
        api.viewModel.DNAComp.splice(idx, 1);
        api.viewModel.mRNA.splice(pos, 1);

        // Update DNA. This will also call updateGeneticProperties(), so
        // other, related properties will be also updated.
        DNA = DNA.substr(0, pos) + DNA.substr(pos + 1);

        // Special case for transcription process (and state):
        // If we keep the same DNAState and we delete something
        // before state.step position, it would cause that new transcribed
        // mRNA nucleotide will be added. Avoid that, as this can be
        // confusing for users.
        if (state.name === "transcription" && pos < state.step) {
          set("DNAState", prevState(state), "suppress");
        }
        doDNATransition(DNA);
      },

      /**
       * Triggers transition to the next DNA state.
       *
       * If any transition was ongoing, it's canceled.
       */
      transitionToNextState: function () {
        api.stopTransition();
        if (ongoingTransitions.length === 0) {
          transitionToState(nextState(api.lastState()));
        }
      },

      /**
       * Stops current animation.
       * @return {boolean} true when some transitions are canceled, false otherwise.
       */
      stopTransition: function () {
        if (ongoingTransitions.length > 1) {
          // Cleanup queue of waiting transitions. ongoingTransitions[0] is
          // the current transition, don't remove it.
          ongoingTransitions.length = 1;
        }
      },

      jumpToNextState: function () {
        if (api.stateBefore("translation:0")) {
          set("DNAState", nextState(api.state()));
        } else if (api.stateBefore("translation-end")) {
          set("DNAState", "translation-end");
        }
      },

      jumpToPrevState: function () {
        if (api.stateAfter("intro-cells")) {
          set("DNAState", prevState(api.state()));
        }
      },

      /**
       * Triggers transition to the given DNA state.
       * e.g. transitionTo("transcription-end")
       *
       * @param  {string} stateName name of the state.
       */
      transitionTo: function (stateName) {
        while (api.lastStateBefore(stateName)) {
          transitionToState(nextState(api.lastState()));
        }
      },

      /**
       * Triggers only one step of DNA transcription.
       * This method also accepts optional parameter - expected nucleotide.
       * When it's available, transcription step will be performed only
       * when passed nucleotide code matches nucleotide, which should
       * be actually joined to mRNA in this transcription step. When
       * expected nucleotide code is wrong, this method does nothing.
       *
       * e.g.
       * transcribeStep("A") will perform transcription step only
       * if "A" nucleotide should be added to mRNA in this step.
       *
       * @param  {string} expectedNucleotide code of the expected nucleotide ("U", "C", "A" or "G").
       */
      transcribeStep: function (expectedNucleotide) {
        var state, newCode;

        state = api.state();
        if (state.name === "dna" && typeof expectedNucleotide === "undefined") {
          api.transitionToNextState();
        } else if (state.name === "transcription") {
          newCode = mRNACode(state.step);
          if (expectedNucleotide && expectedNucleotide.toUpperCase() !== newCode) {
            // Expected nucleotide is wrong, so simply do nothing.
            return;
          }
          api.transitionToNextState();
        }
      },

      // Helper methods used mainly by the genetic renderer.

      /**
       * Returns parsed *current* DNA state.
       * e.g.
       * {
       *   name: "translation",
       *   step: 5
       * }
       *
       * @return {Object} current state object (see above).
       */
      state: function () {
        return api.parseState(model.get("DNAState"));
      },

      stateBefore: function (name) {
        return stateComp(model.get("DNAState"), name) === -1;
      },

      stateEqual: function (name) {
        return stateComp(model.get("DNAState"), name) === 0;
      },

      stateAfter: function (name) {
        return stateComp(model.get("DNAState"), name) === 1;
      },

      /**
       * Returns parsed *last* enqueued state.
       * When there is no state enqueued or in progress,
       * it returns simply current state.
       *
       * e.g.
       * {
       *   name: "translation",
       *   step: 5
       * }
       *
       * @return {Object} last enqueued state object (see above).
       */
      lastState: function () {
        var queueLen = ongoingTransitions.length;
        if (queueLen > 0) {
          return api.parseState(ongoingTransitions[queueLen - 1]);
        }
        return api.state();
      },

      lastStateBefore: function (name) {
        var queueLen = ongoingTransitions.length,
            lastStateName = queueLen ? ongoingTransitions[queueLen - 1] : model.get("DNAState");
        return stateComp(lastStateName, name) === -1 ? true : false;
      },

      lastStateAfter: function (name) {
        var queueLen = ongoingTransitions.length,
            lastStateName = queueLen ? ongoingTransitions[queueLen - 1] : model.get("DNAState");
        return stateComp(lastStateName, name) === 1 ? true : false;
      },

      parseState: function (state) {
        // State can contain ":" and info about step.
        // e.g. translation:0, translation:1 etc.
        state = state.split(":");
        return {
          name: state[0],
          step: Number(state[1]) // can be NaN when step is undefined.
        };
      },

      codon: function (index) {
        return mRNA.substr(3 * index, 3);
      },

      codonComplement: function (index) {
        return api.codon(index)
            .replace(/A/g, "u")
            .replace(/G/g, "c")
            .replace(/U/g, "a")
            .replace(/C/g, "g")
            .toUpperCase();
      },

      translationStepStarted: function (codonIdx, x, y, xEnd, yEnd, duration) {
        var abbr = aminoacidsHelper.codonToAbbr(api.codon(codonIdx)),
            elID = aminoacidsHelper.abbrToElement(abbr);

        // Add some entropy to y position to avoid perfectly straight line of
        // amino acids what can affect folding process.
        yEnd += Math.random() * 0.02 - 0.01;
        model.addAtom({x: x, y: y, element: elID, visible: true, pinned: true}, {suppressCheck: true});
        // Transition new amino acid to its final position.
        model.atomTransition().id(codonIdx).duration(duration).prop("x", xEnd);
        model.atomTransition().id(codonIdx).duration(duration).prop("y", yEnd);
        // Ensure that the simulation is started.
        model.start();
      },

      shiftAminoAcids: function (count, xShift, duration) {
        if (count < 1) return;
        var i, x, y;
        // Shift amino acids to the right.
        for (i = 0; i < count; i++) {
          x = model.getAtomProperties(i).x + xShift;
          y = model.getAtomProperties(i).y;
          model.atomTransition().id(i).duration(duration).prop("x", x);
          // This is required to keep Y coordinate constant during this
          // transition, some forces applied by the MD2D engine can
          // change trajectory of the particle.
          model.atomTransition().id(i).duration(duration).prop("y", y);
        }
      },

      centerProtein: function (duration) {
        model.batch(function () {
          var cm = api.proteinCenterOfMass(),
              xDiff = model.properties.viewPortX +
                      model.properties.viewPortWidth / 2 - cm.x,
              yDiff = model.properties.viewPortY +
                      model.properties.viewPortHeight / 2 - cm.y,
              minX = model.properties.minX + 0.1,
              maxX = model.properties.maxX - 0.1,
              minY = model.properties.minY + 0.1,
              maxY = model.properties.maxY - 0.1,
              len  = model.getNumberOfAtoms(),
              i, x, y;

          for (i = 0; i < len; i++) {
            x = model.getAtomProperties(i).x;
            y = model.getAtomProperties(i).y;
            if (x + xDiff > maxX) xDiff = maxX - x;
            if (x + xDiff < minX) xDiff = minX - x;
            if (y + yDiff > maxY) yDiff = maxY - y;
            if (y + yDiff < minY) yDiff = minY - y;
          }
          for (i = 0; i < len; i++) {
            x = model.getAtomProperties(i).x + xDiff;
            y = model.getAtomProperties(i).y + yDiff;
            if (duration) {
              model.atomTransition().id(i).duration(duration).prop("x", x);
              model.atomTransition().id(i).duration(duration).prop("y", y);
            } else {
              model.setAtomProperties(i, {x: x, y: y});
            }
          }
        });
        if (model.isStopped()) {
          // FIXME: ugly workaround to update position, as setAtomProperties
          // doesn't dispatch any events in contrast to minimize energy.
          model.minimizeEnergy();
        }
      },

      connectAminoAcid: function (codonIdx) {
        if (codonIdx < 1) return;
        var r1 = model.getAtomProperties(codonIdx - 1).radius,
            r2 = model.getAtomProperties(codonIdx).radius,
            // Length of bond is based on the radii of AAs.
            bondLen = (r1 + r2) * 1.25;
        // 10000 is a typical strength for bonds between AAs.
        model.addRadialBond({atom1: codonIdx, atom2: codonIdx - 1, length: bondLen, strength: 10000});
        model.setAtomProperties(codonIdx - 1, {pinned: false});
      },

      translationCompleted: function () {
        var atomsCount = model.getNumberOfAtoms();
        if (atomsCount > 0) {
          // Unpin the last atom. Note that sometimes translation
          // can end without any atom.
          model.setAtomProperties(atomsCount - 1, {pinned: false});
        }
      },

      transitionEnded: function () {
        // Transition has just ended so remove it
        // from transitions list.
        ongoingTransitions.shift();
        if (ongoingTransitions.length > 0) {
          doStateTransition(ongoingTransitions[0]);
        }
      },

      stopCodonsHash: function () {
        return stopCodonsHash;
      },

      lastTranslationStep: function () {
        return lastTranslationStep;
      },

      /**
       * Returns center of mass coridantes of the whole protein.
       * When there are no amino acids, returns null.
       *
       * @return {Object|null} protein's center of mass, e.g. {x: 1, y: 2}
       *                       or null when there are no amino acids.
       */
      proteinCenterOfMass: function () {
        var totalMass = 0,
            xcm = 0,
            ycm = 0,
            len = model.getNumberOfAtoms(),
            atom, i;

        if (len === 0) {
          return null;
        }

        // Note that there is a strong asumption that there are *only* amino
        // acids in the model.
        for (i = 0, len = model.getNumberOfAtoms(); i < len; i++) {
          atom = model.getAtomProperties(i);
          xcm += atom.x * atom.mass;
          ycm += atom.y * atom.mass;
          totalMass += atom.mass;
        }
        xcm /= totalMass;
        ycm /= totalMass;
        return {
          x: xcm,
          y: ycm
        };
      },

      /**
       * Generates a new protein (and removes all existing atoms before).
       *
       * @param  {array} aaSequence      defines expected sequence of amino acids. Pass undefined and provide
       *                                 'expectedLength' if you want to generate a random protein.
       * @param  {Number} expectedLength controls the maximum (and expected) number of amino
       *                                 acids of the resulting protein. Provide this parameter only when 'aaSequence'
       *                                 is undefined. When expected length is too big (due to limited area of the model),
       *                                 the protein will be truncated and its real length returned.
       * @return {Number}                number of created amino acids (<= expectedLength).
       */
      generateProtein: function (aaSequence, expectedLength, paddingTop, paddingBottom) {
        // Process arguments.
        expectedLength = aaSequence ? aaSequence.length : expectedLength;
        paddingTop = paddingTop || 0;
        paddingBottom = paddingBottom || 0;

        var minX = model.properties.minX,
            minY = model.properties.minY + paddingBottom,
            maxX = model.properties.maxX,
            maxY = model.properties.maxY - paddingTop,
            createdAA = 0;

        // First, make sure that model is empty.
        removeAminoAcids();

        model.batch(function () {
              // Options for .addAtom modeler's method.
          var opt = {suppressCheck: true},
              width   = maxX - minX,
              height  = maxY - minY,
              aaCount = aminoacidsHelper.lastElementID - aminoacidsHelper.firstElementID + 1,
              xPos, yPos, xStep, yStep, el, props, radius, prevRadius, bondLen, i,

              // This function controls how X coordinate is updated,
              // using current Y coordinate as input.
              turnHeight = 0.6,
              xStepFunc = function(y) {
                if (y > height - turnHeight || y < turnHeight) {
                  // Close to the boundary increase X step.
                  return 0.1;
                }
                return 0.02 - Math.random() * 0.04;
              },

              // This function controls how Y coordinate is updated,
              // using current Y coordinate and previous result as input.
              changeHeight = 0.3,
              yStepFunc = function(y, prev) {
                if (prev === 0) {
                  // When previously 0 was returned,
                  // now it's time to switch direction of Y step.
                  if (y > 0.5 * maxY) {
                    return -0.1;
                  }
                  return 0.1;
                }
                if (yPos > maxY - changeHeight || yPos < changeHeight) {
                  // Close to the boundary return 0 to make smoother turn.
                  return 0;
                }
                // In a typical situation, just return previous value.
                return prev;
              },

              getRandomAA = function() {
                return Math.floor(aaCount * Math.random()) + aminoacidsHelper.firstElementID;
              };

          // Add the first amino acid. Start from the lower-left corner of
          // model area.
          xPos = minX + 0.1;
          yPos = minY + 0.1;
          xStep  = 0;
          yStep  = 0;
          el     = aaSequence ? aminoacidsHelper.abbrToElement(aaSequence[0]) : getRandomAA();
          radius = model.getElementProperties(el).radius;
          props  = {x: xPos, y: yPos, element: el, visible: true};

          model.addAtom(props, opt);
          createdAA += 1;

          // Add remaining amino acids.
          for (i = 1; i < expectedLength; i++) {
            xPos = props.x;
            yPos = props.y;

            // Update step.
            xStep = xStepFunc(yPos);
            yStep = yStepFunc(yPos, yStep);

            // Update coordinates of new AA.
            xPos += xStep * 1.7;
            yPos += yStep * 1.7;

            if (xPos > width - 0.1) {
              // No space left for new AA.
              return;
            }

            el = aaSequence ? aminoacidsHelper.abbrToElement(aaSequence[i]) : getRandomAA();
            props = {x: xPos, y: yPos, element: el, visible: true};
            model.addAtom(props, opt);
            createdAA += 1;

            // Length of bond is based on the radii of AAs.
            prevRadius = radius;
            radius = model.getElementProperties(el).radius;
            bondLen = (radius + prevRadius) * 1.25;
            // 10000 is a typical strength for bonds between AAs.
            model.addRadialBond({atom1: i, atom2: i - 1, length: bondLen, strength: 10000});
          }
        });
        // We have to use a new batch so atoms array will be updated and we
        // can use getAtomProperties for recently added atoms.
        model.batch(function () {
          // Center protein (X coords only) in the viewport. Make sure
          // that we don't exceed model boundaries.
          var proteinsMaxX   = model.getAtomProperties(createdAA - 1).x,
              proteinsCenter = (proteinsMaxX - minX) / 2,
              viewPortCenter = model.properties.viewPortX + model.properties.viewPortWidth / 2,
              spaceOnRight   = maxX - proteinsMaxX,
              shift = Math.max(0, Math.min(viewPortCenter - proteinsCenter, spaceOnRight)),
              i;

          // Shift all AAs.
          for (i = 0; i < expectedLength; i++) {
            model.setAtomProperties(i, {x: model.getAtomProperties(i).x + shift});
          }
        });

        // Minize energy so the protein will look better.
        model.minimizeEnergy();

        // Return number of created AA.
        return createdAA;
      }
    };

    model.addPropertiesListener(["DNA"], DNAUpdated);
    model.addPropertiesListener(["DNAState"], stateUpdated);
    updateGeneticProperties();
    return api;
  };

});

/*global define: false */

// Definitions of the default MD2D units. Every model property exposed by md2d/models/modeler.js is
// in one of the unit types below.

// This particular set of definitions is for reference and for generating the correct labels on
// output properties; it's not used for computation. Unit conversions that need to happen during
// calculations in the MD2D engine itself are "baked in" using the engine's internal constants and
// units module 'md2d/models/engine/constants/index.js')

// Additionally, since we don't yet offer user-facing methods which do unit conversions (e.g.,
// allowing a property setter to accept an argument containing a value and a unit) there is no
// need for quantitative information in this definition.

define('md2d/models/unit-definitions/md2d',[],function() {
  return {
    name: "md2d",
    translated: false,
    units: {

      length: {
        name: "nanometer",
        pluralName: "nanometers",
        symbol: "nm"
      },

      // Internally, we've referred to "Dalton" but amu is probably more common. Dalton is
      // officially more correct but it still seems mostly to be used for protein masses, etc.
      mass: {
        name: "atomic mass unit",
        pluralName: "atomic mass units",
        symbol: "amu"
      },

      time: {
        name: "femtosecond",
        pluralName: "femtoseconds",
        symbol: "fs",
        displayValue: {
          unitsPerBaseUnit: 1e-3,
          pluralName: "picoseconds",
          name: "picosecond",
          symbol: "ps"
        }
      },

      // For unclear reasons, Classic MW scales the damping coefficient of obstacles linearly with
      // the obstacle's mass, so the acceleration due to friction is a constant times the velocity:
      //   a(friction) = -cv
      // For compatibility, MD2D does the same.
      // The units of the constant c (called "obstacle friction") are therefore 1 / time.
      inverseTime: {
        name: "1/femtosecond",
        pluralName: "1/femtoseconds",
        symbol: "1/fs"
      },

      velocity: {
        name: "nanometer per femtosecond",
        pluralName: "nanometers per second",
        symbol: "nm/s"
      },

      acceleration: {
        name: "nanometer per femtosecond squared",
        pluralName: "nanometers per femtosecond squared",
        symbol: "nm/fs"
      },

      momentum: {
        name: "amu nanometer per femtosecond",
        pluralName: "amu nanometers per femtosecond",
        symbol: "amunm/fs"
      },

      // Forces haven't typically been exposed to Classic MW users in a quantitative way, and indeed
      // they aren't yet exposed in Next Gen MW, so MD2D doesn't try to translate the
      // (computationally convenient) amu nm/fs to "user friendly" units. That said, Classic MW
      // could be said to use eV/nm implicitly, since spring constants are in eV/nm.
      force: {
        name: "amu nanometer per femtosecond squared",
        pluralName: "amu nanometers per femtosecond squared",
        symbol: "amunm/fs"
      },

      energy: {
        name: "electron volt",
        pluralName: "electron volts",
        symbol: "eV"
      },

      // force / velocity = mass / time; given the composite force unit we use, this is much simpler
      // to write as amu/fs than anything else.
      dampingCoefficient: {
        name: "amu per femtosecond",
        pluralName: "amu per femtoseconds",
        symbol: "amu/fs"
      },

      // aka spring constant (= eV/nm per nm)
      stiffness: {
        name: "electron volt per nanometer squared",
        pluralName: "electron volts per nanometer squared",
        symbol: "eV/nm"
      },

      // aka torsional spring constant.
      // Dimensions are torque / angle = force (eV/nm) x lever arm (nm) / angle (radians). This is
      // dimensionally equivalent to energy / angle (eV/radians) but the interpretation of force x
      // distance is different for energy than it is for torque.
      rotationalStiffness: {
        name: "electron volt per radian",
        pluralName: "electron volts per radian",
        symbol: "eV/rad"
      },

      charge: {
        name: "elementary charge",
        pluralName: "elementary charges",
        symbol: "e"
      },

      temperature: {
        // Not "degrees Kelvin", just "Kelvin".
        name: "Kelvin",
        // Not "Kelvins", just "Kelvin".
        pluralName: "Kelvin",
        symbol: "K"
      },

      pressure: {
        name: "bar",
        // e.g., "50 bar"
        pluralName: "bar",
        symbol: "bar"
      },

      angle: {
        name: "radian",
        pluralName: "radians",
        symbol: "rad"
      }
    }
  };
});

/*global define: false */

// Definitions of the MKS units used for macroscopic models. We simulate macroscopic models by
// declaring that some value in (microscopic) MD2D units actually represents one macroscopic-scale
// unit of the same type, e.g., we choose 1 nm (a value of 1 in any MD2D property that has unitType
// "length") to represent 1 m.
//
// Such microscopic:macroscopic ratios as 1nm:1m can only be freely chosen for three unit types:
// length, mass, and time. The remaining unit ratios are computed by the UnitsTranslation module.
// See http://lab.dev.concord.org/doc/models/md2d/macroscopic-units/ for an overview of the
// calculations.
//
// In order to compute these ratios, the UnitsTranslation requires two pieces of
// data about each unit:
//
// (1) for mass, length, and time only, the "representationInMD2DUnits" property, which tells
//     how many MD2D units of the same type represent 1 macroscopic unit.
// (2) for each unit type, the "valueInSIUnits" property, which tells the value of that unit in
//     SI units. This is required, for example, if we wanted to have a unit system that represented
//     acceleration in g (multiples of Earth gravity.) We can automatically translate from the MD2D
//     system of units (nm/fs) to SI/MKS, but without further information relating the value of 1g
//     to units of m/s we cannot translate MD2D units to g.
//
// Additionally, angle, pressure, and temperature are not included below. That is because angle
// units require no translation, and temperature, while nominally applicable to macroscale models,
// is computed from kinetic energy in a way that is not really applicable to, e.g., a macroscopic
// mass-spring model. Moreover pressure units in Classic MW are somewhat fake, and we don't really
// anticipate trying to compute the pressure exerted by a box of bouncing macroscopic balls.

define('md2d/models/unit-definitions/mks',[],function() {
  return {
    name: "mks",
    translated: true,
    units: {

      length: {
        name: "meter",
        pluralName: "meters",
        symbol: "m",
        representationInMD2DUnits: 1,
        valueInSIUnits: 1
      },

      mass: {
        name: "kilogram",
        pluralName: "kilograms",
        symbol: "kg",
        representationInMD2DUnits: 1,
        valueInSIUnits: 1
      },

      time: {
        name: "second",
        pluralName: "seconds",
        symbol: "s",
        representationInMD2DUnits: 1e4,
        valueInSIUnits: 1
      },

      inverseTime: {
        name: "1/second",
        pluralName: "1/seconds",
        symbol: "1/s",
        valueInSIUnits: 1
      },

      velocity: {
        name: "meter per second",
        pluralName: "meters per second",
        symbol: "m/s",
        valueInSIUnits: 1
      },

      acceleration: {
        name: "meter per second squared",
        pluralName: "meters per second squared",
        symbol: "m/s",
        valueInSIUnits: 1
      },

      force: {
        name: "Newton",
        pluralName: "Newtons",
        symbol: "N",
        valueInSIUnits: 1
      },

      energy: {
        name: "Joule",
        pluralName: "Joules",
        symbol: "J",
        valueInSIUnits: 1
      },

      dampingCoefficient: {
        name: "Newton second per meter",
        pluralName: "Newton seconds per meter",
        symbol: "Ns/m",
        valueInSIUnits: 1
      },

      // aka spring constant
      stiffness: {
        name: "Newton per meter",
        pluralName: "Newtons per meter",
        symbol: "N/m",
        valueInSIUnits: 1
      },

      // aka torsional spring constant
      rotationalStiffness: {
        name: "Newton-meter per radian",
        pluralName: "Newton-meters per radian",
        symbol: "Nm/rad",
        valueInSIUnits: 1
      },

      charge: {
        name: "Coulomb",
        pluralName: "Coulombs",
        symbol: "C",
        valueInSIUnits: 1
      }
    }
  };
});

/*global define*/

define('md2d/models/unit-definitions/index',['require','md2d/models/unit-definitions/md2d','md2d/models/unit-definitions/mks','underscore'],function(require) {
  var defs = {
        md2d: require('md2d/models/unit-definitions/md2d'),
        mks: require('md2d/models/unit-definitions/mks')
      },
      _ = require('underscore');

  return {
    get: function(name) {
      var ret;
      if (name === 'md2d') return defs.md2d;

      // For any unit type not in defs[name].units (e.g., temperature does not need to be redefined
      // in MKS), fall back to the MD2D unit definition.
      ret = _.extend({}, defs[name]);
      ret.units = _.extend({}, defs.md2d.units, defs[name].units);
      return ret;
    }
  };
});

/*global define*/
/*jshint eqnull: true*/

define('md2d/models/units-translation',['require','underscore','md2d/models/engine/constants/index','md2d/models/engine/potentials/coulomb'],function(require) {

  var _ = require('underscore'),
      constants = require('md2d/models/engine/constants/index'),
      coulomb = require('md2d/models/engine/potentials/coulomb'),
      COULOMB_CONSTANT = constants.COULOMB_CONSTANT.as(constants.unit.METERS_PER_FARAD),
      baseUnitTypes = ['length', 'mass', 'time'];

  return function UnitsTranslation(unitsDefinition) {

    var // multiply MD2D-units value by this to get the value in SI units
        siFactor = {},

        // multiply MD2D-units value by this to get the value in translated (macroscopic) units
        factor = {},

        force;

    _.each(baseUnitTypes, function (unitType) {
      var u = unitsDefinition.units[unitType];
      siFactor[unitType] = u.valueInSIUnits / u.representationInMD2DUnits;
    });

    siFactor.inverseTime = 1 / siFactor.time;
    siFactor.velocity = siFactor.length / siFactor.time;
    siFactor.acceleration = siFactor.velocity / siFactor.time;
    siFactor.force = siFactor.mass * siFactor.acceleration;

    // The factor should first convert an MD2D value, which is in *eV*, to amu nm/fs^2:
    siFactor.energy = constants.ratio(constants.unit.MW_ENERGY_UNIT, { per: constants.unit.EV });
    // Then it should convert amu/fs^2 to N and nm to m, yielding Joules:
    siFactor.energy *= siFactor.force * siFactor.length;

    siFactor.dampingCoefficient = siFactor.force / siFactor.velocity;
    // stiffness is eV/nm^2; convert eV -> J and 1/nm^2 -> 1/m^2 (yielding N/m)
    siFactor.stiffness = siFactor.energy / siFactor.length / siFactor.length;
    // rotational stiffness is in eV/rad; convert eV -> Nm -- no need to convert radians
    siFactor.rotationalStiffness = siFactor.energy / siFactor.length;

    // Force between charge +1 and -1, 1 distance unit apart, with dielectric constant 1
    force = coulomb.force(1, -1, 1, 1);
    // See disdcussion at http://lab.dev.concord.org/doc/models/md2d/macroscopic-units/
    siFactor.charge = Math.sqrt(force * siFactor.force * siFactor.length * siFactor.length / COULOMB_CONSTANT);

    _.each(_.keys(siFactor), function(unitType) {
      factor[unitType] = siFactor[unitType] / unitsDefinition.units[unitType].valueInSIUnits;
    });

    return {
      translateToModelUnits: function(translatedUnitsValue, unitType) {
        if (factor[unitType] == null) {
          return translatedUnitsValue;
        }
        return translatedUnitsValue / factor[unitType];
      },

      translateFromModelUnits: function(md2dUnitsValue, unitType) {
        if (factor[unitType] == null) {
          return md2dUnitsValue;
        }
        return md2dUnitsValue * factor[unitType];
      }
    };
  };
});

/*global define, $ */

define('md2d/models/performance-optimizer',[],function() {

  var MIN_FPS = 2.5;

  function PerformanceOptimizer(model) {
    /** @private */
    this._model = model;
    /** @private */
    this._initialTimeStep = this._model.get('timeStep');
    /** @private */
    this._maxTimeStep = this._initialTimeStep * 2;
    /** @private */
    this._targetProgressRate = this._initialTimeStep * this._model.get('timeStepsPerTick') * 60; // 60fps
    /**
     * Indicates whether performance optimizer is enabled or not.
     * @type {Boolean}
     */
    this.enabled = false;
  }

  PerformanceOptimizer.prototype._assessPerformance = function() {
    if (!this.enabled || this._model.isStopped()) {
      return;
    }

    var progressRate = this._model.getSimulationProgressRate(),
        fps = this._model.getFPS(),
        timeStep = this._model.get('timeStep'),
        timeStepsPerTick = this._model.get('timeStepsPerTick'),
        currentMaxTimeStep = this._model.get('temperatureControl') ? this._maxTimeStep * 2.5 : this._maxTimeStep;

    if (progressRate < 0.9 * this._targetProgressRate) {
      // Try to increase timeStep and if it's impossible,
      // touch timeStepsPerTick (what probably decrease FPS and
      // animation smoothness).
      if (1.1 * timeStep < currentMaxTimeStep) {
        this._model.set('timeStep', 1.1 * timeStep);
      } else if (fps > MIN_FPS) {
        this._model.set('timeStepsPerTick', Math.round(1.1 * timeStepsPerTick + 0.5));
      }
    } else if (progressRate > 1.1 * this._targetProgressRate) {
      // If simulation is going to fast, decrease timeStepsPerTick
      // what should make animations smoother.
      this._model.set('timeStepsPerTick', Math.round(0.9 * timeStepsPerTick - 0.5));
    }
    setTimeout($.proxy(this._assessPerformance, this), 250);
  };

  PerformanceOptimizer.prototype.enable = function() {
    if (this.enabled) {
      return;
    }
    this._model.start();
    this.enabled = true;
    this._model.set('timeStepsPerTick', 5);
    setTimeout($.proxy(this._assessPerformance, this), 250);
  };

  PerformanceOptimizer.prototype.disable = function() {
    this.enabled = false;
  };

  return PerformanceOptimizer;
});

/*global define, d3 */

define('common/models/property-transition',[],function() {

  /**
   * Abstract class, which defines basic interface for property transition.
   * It allows to smoothly change property over desired time period.
   *
   * Note that this class *can't* be instantiated. It should be used
   * as a base class for other classes, which should implement following
   * interface:
   *  - getObjectProperties(id)
   *  - setObjectProperties(id, props)
   *
   * Note that under the hood D3 ease and interpolate methods are used.
   * Also interface is similar to D3 transitions.
   */
  function PropertyTransition() {
    this.isFinished = false;
    this._duration = 0;
    this._easeFunc = d3.ease("cubic-in-out"); // also default in d3
    this._elapsedTime = 0;
    this._id = null;
    this._propName = null;
    this._endValue = null;
    this._interpolator = null;

    // Check whether required methods are implemented.
    // This class can't be instantiated, only subclasses
    // implementing specified interface:
    if (this.getObjectProperties == null) {
      throw new Error("getObjectProperties method must be implemented by descendant!");
    }
    if (this.setObjectProperties == null) {
      throw new Error("setObjectProperties method must be implemented by descendant!");
    }
  }

  /**
   * Sets ID of processed object. It will be passed to
   * getObjectProperties and setObjectProperties.
   * @param  {*} id
   * @return {PropertyTransition} this (method chaining).
   */
  PropertyTransition.prototype.id = function(id) {
    this._id = id;
    return this;
  };

  /**
   * Sets property name and its final value.
   * @param  {String} propName
   * @param  {*}      endValue
   * @return {PropertyTransition} this (method chaining).
   */
  PropertyTransition.prototype.prop = function(propName, endValue) {
    this._propName = propName;
    this._endValue = endValue;
    return this;
  };

  /**
   * Sets transition duration.
   * @param  {number} duration Transition duration.
   * @return {PropertyTransition} this (method chaining).
   */
  PropertyTransition.prototype.duration = function (duration) {
    this._duration = duration;
    return this;
  };

  /**
   * Sets transition delay.
   * @param  {number} delay Transition delay.
   * @return {PropertyTransition} this (method chaining).
   */
  PropertyTransition.prototype.delay = function (delay) {
    this._elapsedTime = -delay;
    return this;
  };

  /**
   * Sets easing function duration. Note that under the hood
   * d3.ease function is used to generate easing function.
   * Please see:
   * https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease
   *
   * @param  {string} funcName Function name.
   * @return {PropertyTransition} this (method chaining).
   */
  PropertyTransition.prototype.ease = function (funcName) {
    this._easeFunc = d3.ease(funcName);
    return this;
  };

  /**
   * Processes the transition. This should be used by the model
   * implementing transitions support. When transition is finished,
   * isFinished field will be set to true.
   * @param  {number} elapsedTime elapsed time, units have to be
   *                              consistent with duration time.
   */
  PropertyTransition.prototype.process = function (elapsedTime) {
    if (this.isFinished || this._incompleteSpec()) {
      return;
    }
    var t, props;

    this._elapsedTime += elapsedTime;
    if (this._elapsedTime < 0) {
      // Elapsed time can be negative when there was a delay specified (which
      // sets elapsedTime to -delay).
      return;
    }
    if (this._interpolator == null) {
      this._interpolator = d3.interpolate(this.getObjectProperties(this._id)[this._propName], this._endValue);
    }
    t = Math.min(1, this._elapsedTime / this._duration);
    t = this._easeFunc(t);
    props = {};
    props[this._propName] = this._interpolator(t);
    // Update object properties.
    this.setObjectProperties(this._id, props);
    if (t >= 1) {
      // This ensures that 1 value is always reached.
      this.isFinished = true;
    }
  };

  /**
   * getObjectProperties method must be implemented by descendant!
   * Required interface:
   * @param  {*}      id Object ID, value passed
   *                     to .id() method will be used.
   * @return {Object} Properties hash.
   */
  PropertyTransition.prototype.getObjectProperties = null;

  /**
   * setObjectProperties method must be implemented by descendant!
   * Required interface:
   * @param  {*}      id Object ID, value passed
   *                     to .id() method will be used.
   * @param  {Object} props Properties hash.
   */
  PropertyTransition.prototype.setObjectProperties = null;

  /**
   * @private
   * @return {boolean} true when transition specification is incomplete.
   */
  PropertyTransition.prototype._incompleteSpec = function () {
    return this._id == null || this._propName == null || this._endValue == null;
  };

  return PropertyTransition;
});
/*global define */

define('md2d/models/atom-transition',['require','common/inherit','common/models/property-transition'],function (require) {

  var inherit            = require("common/inherit"),
      PropertyTransition = require("common/models/property-transition");

  function AtomTransition(model) {
    // Call super constructor.
    PropertyTransition.call(this);
    this._model = model;
  }
  inherit(AtomTransition, PropertyTransition);


  AtomTransition.prototype.setObjectProperties = function(id, props) {
    this._model.setAtomProperties(id, props);
  };

  AtomTransition.prototype.getObjectProperties = function (id) {
    return this._model.getAtomProperties(id);
  };

  return AtomTransition;
});

/*global define */

/**
  This plugin adds quantum dynamics functionality to the MD2D engine.

  Datatable changes`
    atoms:
      excitation: an int representing the current level of excitation of an atom, from
        floor (0) to an arbitrary level. In this model each atom is assumed to have one
        single electron that can be excited to any of a finite number of levels. The
        actual energy of each level is defined by the atom's element

  New serialized properties:

    elementEnergyLevels: A 2-dimensional array defining energy levels for each element

*/


define('md2d/models/engine/plugins/quantum-dynamics',['require','common/models/engines/clone-restore-wrapper','../constants/index','../utils','arrays','common/array-types','md2d/models/metadata','common/validator'],function(require) {

  // static variables
  var CloneRestoreWrapper = require('common/models/engines/clone-restore-wrapper'),
      constants           = require('../constants/index'),
      utils               = require('../utils'),

      // in reality, 6.626E-34 m^2kg/s. Classic MW uses 0.2 in its units (eV * fs)
      PLANCK_CONSTANT = constants.convert(0.2, { from: constants.unit.EV, to: constants.unit.MW_ENERGY_UNIT }),

      // Speed of light.
      // in reality, about 300 nm/fs! Classic uses 0.2 in its units (0.1/fs), which is 0.002 nm/fs:
      C = 0.002,
      TWO_PI = 2 * Math.PI,

      // expected value of lifetime of excited energy state, in fs
      LIFETIME = 1000,
      EMISSION_PROBABILITY_PER_FS = 1/LIFETIME;

  return function QuantumDynamics(engine, _properties) {

    var arrays               = require('arrays'),
        arrayTypes           = require('common/array-types'),
        metadata             = require('md2d/models/metadata'),
        validator            = require('common/validator'),

        properties           = validator.validateCompleteness(metadata.quantumDynamics, _properties),

        api,

        elementEnergyLevels  = properties.elementEnergyLevels,
        pRadiationless       = properties.radiationlessEmissionProbability,

        dimensions           = engine.getDimensions(),

        atoms,
        elements,
        photons,

        viewPhotons = [],

        updateAtomsTable = function() {
          var length = atoms.x.length;

          atoms.excitation = arrays.create(length, 0, arrayTypes.int8Type);
        },

        createPhotonsTable = function(serializedPhotons) {
          var length = 0;

          if (serializedPhotons.x) {
            length = Math.ceil(serializedPhotons.x.length / 10) * 10;
          }

          photons =  {
            x     : arrays.create(length, 0, arrayTypes.floatType),
            y     : arrays.create(length, 0, arrayTypes.floatType),
            vx    : arrays.create(length, 0, arrayTypes.floatType),
            vy    : arrays.create(length, 0, arrayTypes.floatType),
            angularFrequency : arrays.create(length, 0, arrayTypes.floatType)
          };
        },

        currentlyOperatedPairs = [],  // all pairs being currently operated on

        atom1Idx, atom2Idx,           // current pair of atoms during thermal excitation

        u1, u2,                       // temporary velocity-calculation variables
        w1, w2,
        dx, dy,

        numPhotons = 0,

        copyPhotonData = function(serializedPhotons) {
          if (!serializedPhotons || !serializedPhotons.x) {
            return;
          }
          ['x', 'y', 'vx', 'vy', 'angularFrequency'].forEach(function(key) {
            arrays.copy(serializedPhotons[key], photons[key]);
          });

          for (var i = 0; i < photons.x.length; i++) {
            if (photons.vx[i] || photons.vy[i]) {
              numPhotons++;
            }
          }
        },

        // If a pair of atoms are close enough, QD interactions may occur.
        //
        // This is called at the end of every integration loop.
        performInteractionsBetweenCloseAtoms = function(neighborList) {
          var N     = engine.getNumberOfAtoms(),
              nlist = neighborList.getList(),
              currentlyClosePairs = [],
              a1, a2,
              i, len,
              el1, el2,
              energyLevels1, energyLevels2,
              xi, yi, xij, yij, ijsq,
              avrSigma, avrSigmaSq,
              atomWasExcited, atomWasDeexcited;

          if (!elementEnergyLevels) return;

          // get all proximal pairs of atoms, using neighborList
          for (a1 = 0; a1 < N; a1++) {

            xi = atoms.x[a1];
            yi = atoms.y[a1];

            for (i = neighborList.getStartIdxFor(a1), len = neighborList.getEndIdxFor(a1); i < len; i++) {
              a2 = nlist[i];

              el1 = atoms.element[a1];
              el2 = atoms.element[a2];
              energyLevels1 = elementEnergyLevels[el1];
              energyLevels2 = elementEnergyLevels[el2];

              // if neither atom is of an element with energy levels, skip
             if (!energyLevels1.length && !energyLevels2.length) {
               continue;
             }

              // if we aren't close (within the avrSigma of two atoms), skip
              xij = xi - atoms.x[a2];
              yij = yi - atoms.y[a2];
              ijsq = xij * xij + yij * yij;
              avrSigma = 0.5 * (elements.sigma[el1] + elements.sigma[el2]);
              avrSigmaSq = avrSigma * avrSigma;

              if (ijsq >= avrSigmaSq) {
                continue;
              }

              currentlyClosePairs[a1] = a2;   // add this pair to our temporary list of close pairs

              if (currentlyOperatedPairs[a1] === a2) {
                // we have already operated on this pair, and the atoms have not yet
                // left each other's neighborhoods, so we skip so as not to operate
                // on them twice in one collision
                continue;
              }

              // first try to see if we can excite atoms
              atomWasExcited = tryToThermallyExciteAtoms(a1, a2);

              // if we didn't excite, see if this pair wants to de-excite
              if (!atomWasExcited) {
                atomWasDeexcited = tryToDeexciteAtoms(a1, a2);
              }

              if (atomWasExcited || atomWasDeexcited) {
                // add pair to our operation list
                currentlyOperatedPairs[a1] = a2;
                currentlyOperatedPairs[a2] = a1;
              }
            }
          }

          // go through list of currently-operated pairs, and if any of them aren't in
          // our temporary list of close pairs, they have left each other so we can
          // strike them from the list
          for (a1 = 0, len = currentlyOperatedPairs.length; a1 < len; a1++) {
            a2 = currentlyOperatedPairs[a1];
            if (!isNaN(a2)) {
              if (!(currentlyClosePairs[a1] === a2 || currentlyClosePairs[a2] === a1)) {
                delete currentlyOperatedPairs[a1];
                delete currentlyOperatedPairs[a2];
              }
            }
          }
        },

        // If a pair of atoms are close enough, and their relative KE is greater than
        // the energy required to reach a new excitation level of a random member of
        // the pair, increase the excitation level of that atom and adjust the velocity
        // of the pair as required.
        tryToThermallyExciteAtoms = function(a1, a2) {
          var atomWasExcited,
              selection;

          atom1Idx = a1;
          atom2Idx = a2;

          // excite a random atom, or pick the excitable one if only one can be excited
          selection = Math.random() < 0.5 ? atom1Idx : atom2Idx;
          atomWasExcited = tryToExcite(selection);
          if (!atomWasExcited) {
            // if we couldn't excite the first, excite the other one
            atomWasExcited = tryToExcite(atom1Idx+atom2Idx-selection);
          }

          return atomWasExcited;
        },

        // Excites an atom to a new energy level if the relative KE of the pair atom1Idx
        // and atom2Idx is high enough, and updates the velocities of atoms as necessary
        tryToExcite = function(i) {
          var energyLevels   =   elementEnergyLevels[atoms.element[i]],
              currentEnergyLevel,
              currentElectronEnergy,
              relativeKE,
              energyRequired, highest,
              nextEnergyLevel, energyAbsorbed,
              j, jj;

          if (!energyLevels) return;

          precalculateVelocities();

          relativeKE = getRelativeKE();

          currentEnergyLevel = atoms.excitation[i];
          currentElectronEnergy = energyLevels[currentEnergyLevel];

          // get the highest energy level above the current that the relative KE can reach
          for (j = currentEnergyLevel+1, jj = energyLevels.length; j < jj; j++) {
            energyRequired = energyLevels[j] - currentElectronEnergy;
            if (relativeKE < energyRequired) {
              break;
            }
            highest = j;
          }
          if (!highest) {
            // there is no higher energy level we can reach
            return false;
          }

          // assuming that all the energy levels above have the same chance of
          // getting the excited electron, we randomly pick one.
          highest = highest - currentEnergyLevel;
          nextEnergyLevel = Math.ceil(Math.random() * highest) + currentEnergyLevel;

          atoms.excitation[i] = nextEnergyLevel;
          energyAbsorbed = energyLevels[nextEnergyLevel] - currentElectronEnergy;
          updateVelocities(energyAbsorbed);
          return true;
        },

        precalculateVelocities = function() {
          dx = atoms.x[atom2Idx] - atoms.x[atom1Idx];
          dy = atoms.y[atom2Idx] - atoms.y[atom1Idx];

          var normalizationFactor = 1 / Math.sqrt(dx*dx + dy*dy);

          dx *= normalizationFactor;
          dy *= normalizationFactor;

          // Decompose v1 into components u1 (parallel to d) and w1 (orthogonal to d)
          u1 = atoms.vx[atom1Idx] * dx + atoms.vy[atom1Idx] * dy;
          w1 = atoms.vy[atom1Idx] * dx - atoms.vx[atom1Idx] * dy;

          // Decompose v2 similarly
          u2 = atoms.vx[atom2Idx] * dx + atoms.vy[atom2Idx] * dy;
          w2 = atoms.vy[atom2Idx] * dx - atoms.vx[atom2Idx] * dy;
        },

        getRelativeKE = function() {
          var du   = u2 - u1;

          return 0.5 * du * du * atoms.mass[atom1Idx] * atoms.mass[atom2Idx] / (atoms.mass[atom1Idx] + atoms.mass[atom2Idx]);
        },

        updateVelocities = function(delta) {
          var m1 = atoms.mass[atom1Idx],
              m2 = atoms.mass[atom2Idx],
              j  = m1 * u1 * u1 + m2 * u2 * u2 - delta,
              g  = m1 * u1 + m2 * u2,
              v1 = (g - Math.sqrt(m2 / m1 * (j * (m1 + m2) - g * g))) / (m1 + m2),
              v2 = (g + Math.sqrt(m1 / m2 * (j * (m1 + m2) - g * g))) / (m1 + m2);

          atoms.vx[atom1Idx] = v1 * dx - w1 * dy;
          atoms.vy[atom1Idx] = v1 * dy + w1 * dx;
          atoms.vx[atom2Idx] = v2 * dx - w2 * dy;
          atoms.vy[atom2Idx] = v2 * dy + w2 * dx;
        },

        // If one atom has an electron in a higher energy state (and we didn't
        // just excite this pair) the atom may deexcite during a collision. This
        // will either release a photon (NOT YET IMPLEMENTED) or will increase
        // the relative KE of the atoms (radiationless transition), with the
        // probabilities of each depending on the model settings.
        tryToDeexciteAtoms = function(a1, a2) {
          var selection,
              excitation1 = atoms.excitation[a1],
              excitation2 = atoms.excitation[a2];

          atom1Idx = a1;
          atom2Idx = a2;

          if (!excitation1 && !excitation2) {
            return false;
          }

          // excite a random atom, or pick the excitable one if only one can be excited
          if (!excitation1) {
            selection = atom2Idx;
          } else if (!excitation2) {
            selection = atom1Idx;
          } else {
            selection = Math.random() < 0.5 ? atom1Idx : atom2Idx;
          }
          deexcite(selection);
          return true;
        },

        deexcite = function(i) {
          var energyLevels   = elementEnergyLevels[atoms.element[i]],
              currentLevel   = atoms.excitation[i],
              newLevel       = Math.floor(Math.random() * currentLevel),
              energyReleased = energyLevels[newLevel] - energyLevels[currentLevel];

          atoms.excitation[i] = newLevel;

          if (Math.random() < pRadiationless) {
            // new energy goes into increasing atom velocities after collision
            precalculateVelocities();
            updateVelocities(energyReleased);
          } else {
            emitPhoton(i, energyReleased);
          }
        },

        addPhoton = function() {
          var length = photons.x.length,
              i;

          numPhotons++;

          if (numPhotons > length) {
            utils.extendArrays(photons, length+10);
            return numPhotons - 1;
          }

          for (i = 0; i < length; i++) {
            if (!photons.vx[i] && !photons.vy[i]) {
              return i;
            }
          }
        },

        removePhoton = function(i) {
          numPhotons--;
          photons.x[i] = photons.y[i] = photons.vx[i] = photons.vy[i] = photons.angularFrequency[i] = 0;
        },

        emitPhoton = function(atomIndex, energy) {
          var angle = Math.random() * TWO_PI,
              cosA  = Math.cos(angle),
              sinA  = Math.sin(angle),
              sigma = elements.sigma[atoms.element[atomIndex]],

              // set photon location just outside atom's sigma
              x           = atoms.x[atomIndex] + (sigma * 0.51 * cosA),
              y           = atoms.y[atomIndex] + (sigma * 0.51 * sinA),
              vx          = C * cosA,
              vy          = C * sinA,
              angularFreq = energy / PLANCK_CONSTANT,

              photonIndex = addPhoton();

          photons.x[photonIndex]     = x;
          photons.y[photonIndex]     = y;
          photons.vx[photonIndex]    = vx;
          photons.vy[photonIndex]    = vy;
          photons.angularFrequency[photonIndex] = angularFreq;
        },

        movePhotons = function(dt) {
          var i, ii,
              x, y;

          for (i = 0, ii = photons.x.length; i < ii; i++) {
            if (!photons.vx[i] && !photons.vy[i]) continue;

            x = photons.x[i] += photons.vx[i] * dt;
            y = photons.y[i] += photons.vy[i] * dt;

            if (x < dimensions[0] || x > dimensions[2] || y < dimensions[1] || y > dimensions[3]) {
              removePhoton(i);
            }
          }
        },

        spontaneousEmission = function(dt) {
          if (!elementEnergyLevels) { return; }

          for (var i = 0, N = engine.getNumberOfAtoms(); i < N; i++) {
            tryToSpontaneouslyEmit(i, dt);
          }
        },

        tryToSpontaneouslyEmit = function(atomIndex, dt) {

          if (atoms.excitation[atomIndex] === 0) { return; }

          // The probability of an emission in the current timestep is the probability that an
          // exponential random variable T with expected value LIFETIME has value t less than dt.
          // For dt < ~0.1 * LIFETIME, this probability is approximately equal to dt/LIFETIME.

          if (Math.random() > dt * EMISSION_PROBABILITY_PER_FS) { return; }

          // Randomly select an energy level. Reference:
          // https://github.com/concord-consortium/mw/blob/6e2f2d4630323b8e993fcfb531a3e7cb06644fef/src/org/concord/mw2d/models/SpontaneousEmission.java#L48-L70

          var u1 = Math.random(),
              u2 = Math.random(),
              energyLevels,
              excessEnergy,
              i,
              m = atoms.excitation[atomIndex],
              mInverse = 1/m;

          for (i = 0; i < m; i++) {
            if (i*mInverse <= u1 && u1 < (i+1)*mInverse && pRadiationless < u2) {
              energyLevels = elementEnergyLevels[atoms.element[atomIndex]];
              excessEnergy = energyLevels[m] - energyLevels[i];
              atoms.excitation[atomIndex] = i;
              emitPhoton(atomIndex, excessEnergy);
              return;
            }
          }
        };

    // Public API.
    api = {
      initialize: function(dataTables) {
        atoms     = dataTables.atoms;
        elements  = dataTables.elements;
        updateAtomsTable();
        createPhotonsTable(properties.photons);
        copyPhotonData(properties.photons);
      },

      performActionWithinIntegrationLoop: function(neighborList, dt) {
        performInteractionsBetweenCloseAtoms(neighborList);
        spontaneousEmission(dt);
        movePhotons(dt);
      },

      getPhotons: function() {
        return photons;
      },

      getNumPhotons: function() {
        return numPhotons;
      },

      // TODO/FIXME: This is a modeler-level method; it's here until the plugin mechanism is
      // extended to allow plugins to define both engine-level and modeler-level parts.
      // Additionally, this can be split into updateViewPhotons which can happen in the
      // modeler's readModelState method, and a simple getViewPhotons accessor used by the view.
      getViewPhotons: function() {
        var n = 0,
            // avoid using closure variable as this method will be relocated to modeler
            photons = this.getPhotons(),
            viewPhoton,
            i,
            len;

        for (i = 0, len = photons.x.length; i < len; i++) {
          if (photons.vx[i] || photons.vy[i]) {
            if (!viewPhotons[n]) {
              viewPhotons[n] = {
                idx: n
              };
            }

            viewPhoton = viewPhotons[n];

            viewPhoton.x  = photons.x[i];
            viewPhoton.y  = photons.y[i];
            viewPhoton.vx = photons.vx[i];
            viewPhoton.vy = photons.vy[i];
            viewPhoton.angularFrequency = photons.angularFrequency[i];

            n++;
          }
        }

        viewPhotons.length = this.getNumPhotons();

        return viewPhotons;
      },

      getElementEnergyLevels: function() {
        return elementEnergyLevels;
      },

      getRadiationlessEmissionProbability: function() {
        return pRadiationless;
      },

      getState: function() {
        return [
          new CloneRestoreWrapper(photons),
          {
            clone: function() {
              return {
                numPhotons: numPhotons
              };
            },
            restore: function(state) {
              numPhotons = state.numPhotons;
            }
          }
        ];
      }
    };

    return api;
  };

});

/*global define: false, d3: false */

define('md2d/models/modeler',['require','common/console','common/performance','md2d/models/engine/md2d','md2d/models/metadata','common/lab-modeler-mixin','common/output-support','common/models/tick-history','cs!md2d/models/solvent','common/serialize','common/validator','md2d/models/aminoacids-props','cs!md2d/models/aminoacids-helper','md2d/models/engine/genetic-engine','md2d/models/engine/constants/units','md2d/models/unit-definitions/index','md2d/models/units-translation','md2d/models/performance-optimizer','md2d/models/atom-transition','underscore','md2d/models/engine/plugins/quantum-dynamics'],function(require) {
  // Dependencies.
  var console              = require('common/console'),
      performance          = require('common/performance'),
      md2d                 = require('md2d/models/engine/md2d'),
      metadata             = require('md2d/models/metadata'),
      LabModelerMixin      = require('common/lab-modeler-mixin'),
      OutputSupport        = require('common/output-support'),
      TickHistory          = require('common/models/tick-history'),
      Solvent              = require('cs!md2d/models/solvent'),
      serialize            = require('common/serialize'),
      validator            = require('common/validator'),
      aminoacids           = require('md2d/models/aminoacids-props'),
      aminoacidsHelper     = require('cs!md2d/models/aminoacids-helper'),
      GeneticEngine        = require('md2d/models/engine/genetic-engine'),
      units                = require('md2d/models/engine/constants/units'),
      unitDefinitions      = require('md2d/models/unit-definitions/index'),
      UnitsTranslation     = require('md2d/models/units-translation'),
      PerformanceOptimizer = require('md2d/models/performance-optimizer'),
      AtomTransition       = require('md2d/models/atom-transition'),
      _ = require('underscore'),

      // plugins
      QuantumDynamics      = require('md2d/models/engine/plugins/quantum-dynamics');

  return function Model(initialProperties) {

    // all models created with this constructor will be of type: "md2d"
    this.constructor.type = "md2d";

    var model = {},

        customSetters = {
          targetTemperature: function (value) {
            engine.setTargetTemperature(value);
          },

          temperatureControl: function(value) {
            engine.useThermostat(value);
          },

          lennardJonesForces: function(value) {
            engine.useLennardJonesInteraction(value);
          },

          coulombForces: function(value) {
            engine.useCoulombInteraction(value);
          },

          solventForceType: function(value) {
            engine.setSolventForceType(value);
          },

          DNAState: function(value) {
            engine.setDNAState(value);
          },

          solventForceFactor: function(value) {
            engine.setSolventForceFactor(value);
          },

          additionalSolventForceMult: function(value) {
            engine.setAdditionalSolventForceMult(value);
          },

          additionalSolventForceThreshold: function(value) {
            engine.setAdditionalSolventForceThreshold(value);
          },

          dielectricConstant: function(value) {
            engine.setDielectricConstant(value);
          },

          realisticDielectricEffect: function(value) {
            engine.setRealisticDielectricEffect(value);
          },

          VDWLinesCutoff: function(value) {
            var ratio = VDWLinesCutoffMap[value];
            if (ratio) {
              engine.setVDWLinesRatio(ratio);
            }
          },

          gravitationalField: function(value) {
            engine.setGravitationalField(value);
          },

          modelSampleRate: function() {
            if (!model.isStopped()) model.restart();
          },

          viscosity: function(value) {
            engine.setViscosity(value);
          },

          polarAAEpsilon: function (value) {
            var polarAAs, element1, element2,
                i, j, len;

            // Set custom pairwise LJ properties for polar amino acids.
            // They should attract stronger to better mimic nature.
            polarAAs = aminoacidsHelper.getPolarAminoAcids();
            for (i = 0, len = polarAAs.length; i < len; i++) {
              element1 = polarAAs[i];
              for (j = i + 1; j < len; j++) {
                element2 = polarAAs[j];
                // Set custom pairwise LJ epsilon (default one for AA is -0.1).
                engine.pairwiseLJProperties.set(element1, element2, {epsilon: value});
              }
            }
          },

          electricFieldDensity: function (value) {
            electricField.length = 0; // reuse existing array!
            if (!value) return;
            var minX = 0,
                minY = 0,
                maxX = model.properties.width,
                maxY = model.properties.height,
                diff = model.properties.width / value,
                yOffset = ((maxY / diff) % 1) * diff,
                y = minY + 0.5 * (yOffset + (diff <= maxY ? diff : 0)),
                x;
            while(y < maxY) {
              x = minX + 0.5 * diff;
              while(x < maxX) {
                electricField.push({x: x, y: y});
                x += diff;
              }
              y += diff;
            }
          }
        },

        // The set of units currently in effect. (Determined by the 'unitsScheme' property of the
        // model; default value is 'md2d')
        unitsDefinition = unitDefinitions.get(initialProperties.unitsScheme || 'md2d'),

        // Object that translates between 'native' md2d units and the units defined
        // by unitsDefinition.
        unitsTranslation = (function() {
          var scheme = initialProperties.unitsScheme || 'md2d';
          // If we're not using MD2D units, we need a translation (which, for each unit type, allows some
          // number of "native" MD2D units to stand for 1 translated unit, e.g., 1 nm represents 1m, with
          // the relationships between these ratios set up so that the calculations reamin physically
          // consistent.
          if (scheme !== 'md2d') {
            return new UnitsTranslation(unitsDefinition);
          }
          return undefined;
        }()),

        labModelerMixin = new LabModelerMixin({
          metadata: metadata,
          setters: customSetters,
          unitsDefinition: unitsDefinition,
          unitsTranslation: unitsTranslation,
          initialProperties: initialProperties
        }),

        dispatch = (function() {
          var d = labModelerMixin.dispatchSupport;
          d.addEventTypes("tick","willReset",
                          "addAtom", "removeAtom", "addRadialBond", "removeRadialBond",
                          "removeAngularBond", "invalidation", "textBoxesChanged");
          return d;
        }()),

        propertySupport = labModelerMixin.propertySupport,

        outputSupport,

        VDWLinesCutoffMap = {
          "short": 1.33,
          "medium": 1.67,
          "long": 2.0
        },
        defaultMaxTickHistory = 1000,
        newStep = false,
        lastSampleTime,
        sampleTimes = [],

        // FIXME: do we need global reference?
        modelState = window.state = {},
        tickHistory,

        // Transitions list.
        transitions = [],

        // Molecular Dynamics engine.
        engine = (function() {
          var e = md2d.createEngine();
          // Register invalidating change hooks.
          // pairwiseLJProperties object allows to change state which defines state of the whole simulation.
          e.pairwiseLJProperties.registerChangeHooks(propertySupport.invalidatingChangePreHook, propertySupport.invalidatingChangePostHook);
          return e;
        }()),

        // Genetic engine.
        geneticEngine,

        // An array of elements object.
        editableElements,

        // ######################### Main Data Structures #####################
        // They are initialized at the end of this function. These data strucutres
        // are mainly managed by the engine.

        // A hash of arrays consisting of arrays of element property values
        elements,

        // A hash of arrays consisting of arrays of obstacle property values
        obstacles,

        // A hash of arrays consisting of arrays of rectangle property values
        rectangles,

        // A hash of arrays consisting of arrays of radial bond property values
        radialBonds,

        // A hash of arrays consisting of arrays of angular bond property values
        angularBonds,

        // A hash of arrays consisting of arrays of restraint property values
        // (currently atom-only)
        restraints,

        // ####################################################################

        // An array of objects consisting of atom index numbers and atom property values, for easy
        // consumption by the view. It is updated conservatively from the "unrolled" form used for
        // speedy computation by the engine.
        viewAtoms = [],

        // An array of objects consisting of photon index numbers and property values, for easy
        // consumption by the view. Only defined if the quantum dynamics plugin is used.
        viewPhotons,

        // An array of objects consisting of point coordinates and electric field force at that point
        // (e.g. [{ x: 1, y: 2, fx: 0.1, fy: 0.3 }, ...]).
        electricField = [],

        // A two dimensional array consisting of radial bond index numbers, radial bond
        // properties, and the postions of the two bonded atoms.
        // FIXME. Engine should not be calculating this.
        radialBondResults,

        // The index of the "spring force" used to implement dragging of atoms in a running model
        liveDragSpringForceIndex = null,

        // Cached value of the 'friction' property of the atom being dragged in a running model
        liveDragSavedFriction,

        // Properties hashes for use by plugins
        pluginProperties;

    function processTransitions(timeDiff) {
      var i, len;
      model.startBatch();
      for (i = 0, len = transitions.length; i < len; i++) {
        transitions[i].process(timeDiff);
      }
      // Cleanup finished transitions.
      i = 0;
      while(i < transitions.length) {
        if (transitions[i].isFinished) {
          transitions.splice(i, 1);
        } else {
          i++;
        }
      }
      model.endBatch();
    }

    // Returns a copy of 'obj' with value replaced by fn(key, value) for every (key, value) pair.
    // (Underscore doesn't do this: https://github.com/documentcloud/underscore/issues/220)
    function mapValues(obj, fn) {
      obj = _.extend({}, obj);
      for (var k in obj) {
        if (obj.hasOwnProperty(k)) obj[k] = fn(k, obj[k]);
      }
      return obj;
    }

    // Modifies a properties hash which has translated units to have MD2D units. Leaves properties
    // without a unitType (or with an unrecognized unitType) unmodified.
    // Returns 'properties' unmodified (not a copy) if there is no units translation in effect.
    function translateToMD2DUnits(properties, metadata) {
      if (!unitsTranslation) return properties;
      return mapValues(properties, function(key, value) {
        return unitsTranslation.translateToModelUnits(value, metadata[key] && metadata[key].unitType);
      });
    }

    // Modifies a properties hash which has MD2D units to have translated units. Leaves properties
    // without a unitType (or with an unrecognized unitType) unmodified.
    // Returns 'properties' unmodified (not a copy) if there is no units translation in effect.
    function translateFromMD2DUnits(properties, metadata) {
      if (!unitsTranslation) return properties;
      return mapValues(properties, function(key, value) {
        return unitsTranslation.translateFromModelUnits(value, metadata[key] && metadata[key].unitType);
      });
    }

    /**
      Executes the closure 'extract' which extracts from the tick history, then dispatches
      addAtom/removeAtom, etc, events as needed.

      This prevents unneessary creation and removal of atoms.
    */
    var runAndDispatchObjectNumberChanges = (function() {
      var objects = [{
        getNum: 'getNumberOfAtoms',
        addEvent: 'addAtom',
        removeEvent: 'removeAtom'
      }, {
        getNum: 'getNumberOfRadialBonds',
        addEvent: 'addRadialBond',
        removeEvent: 'removeRadialBond'
      }];

      return function (extract) {
        var i, o, newNum;
        for (i = 0; i < objects.length; i++) {
          o = objects[i];
          o.num = engine[o.getNum]();
        }

        extract();

        for (i = 0; i < objects.length; i++) {
          o = objects[i];
          newNum = engine[o.getNum]();
          if (newNum > o.num) {
            dispatch[o.addEvent]();
          } else if (newNum < o.num) {
            dispatch[o.removeEvent]();
          }
        }
      };
    })();

    /**
      This method is called to refresh the viewAtoms array and macrostate variables (KE, PE,
      temperature) whenever an engine integration occurs or the model state is otherwise changed.

      Normally, you should call the methods updateOutputPropertiesAfterChange or
      updateAllOutputProperties rather than calling this method. Calling this method directly does
      not cause output-property listeners to be notified, and calling it prematurely will confuse
      the detection of changed properties.
    */
    function readModelState() {
      engine.computeOutputState(modelState);
      // remember that getViewPhotons will eventually be a modeler-layer method that ingests a raw
      // representation provided by modelState.photons
      viewPhotons = engine.callPluginAccessor('getViewPhotons');
      updateViewAtoms(modelState.atoms);
      updateViewElectricField();
    }

    // Transpose 'atoms' object into 'viewAtoms' for consumption by view code
    var updateViewAtoms = (function() {
      var isAminoAcid = function () {
        return aminoacidsHelper.isAminoAcid(this.element);
      };

      return function(atoms) {
        var n = engine.getNumberOfAtoms(),
            i,
            prop,
            amino,
            viewAtom;

        // TODO: refactor whole approach to creation of objects from flat arrays.
        // Think about more general way of detecting and representing amino acids.
        // However it would be reasonable to perform such refactoring later, when all requirements
        // related to proteins engine are clearer.

        viewAtoms.length = n;

        for (i = 0, n; i < n; i++) {
          if (!viewAtoms[i]) {
            viewAtoms[i] = {
              idx: i
            };
          }
          viewAtom = viewAtoms[i];

          for (prop in atoms) {
            if (atoms.hasOwnProperty(prop)) {
              viewAtom[prop] = atoms[prop][i];
            }
          }

          // Provide convenience function for view, do not force it to ask
          // model / engine directly. In the future, atom objects should be
          // represented by a separate class.
          viewAtom.isAminoAcid = isAminoAcid;

          // Additional properties, used only by view.
          if (viewAtom.isAminoAcid()) {
            amino = aminoacidsHelper.getAminoAcidByElement(atoms.element[i]);
            viewAtom.symbol = amino.symbol;
            viewAtom.label  = amino.abbreviation;
          }
        }
      };
    }());

    function updateViewElectricField() {
      if (!electricField.length) return;
      var i, len, p;
      for (i = 0, len = electricField.length; i < len; i++) {
        p = electricField[i];
        engine.getCoulombForceAt(p.x, p.y, p);
      }
    }

    /**
      return a random element index ... which is *not* an amino acid element
    */
    function randomElement() {
      var len = engine.getNumberOfElements(),
          el = Math.floor( Math.random() * len );
      while(aminoacidsHelper.isAminoAcid(el)) {
        el = Math.floor( Math.random() * len );
      }
      return el;
    }

    /**
      Create set of amino acids elements. Use descriptions
      provided in 'aminoacids' array.
    */
    function createAminoAcids() {
      var sigmaIn01Angstroms,
          sigmaInNm,
          i, len;

      // Note that amino acids ALWAYS have IDs from
      // AMINO_ELEMENT_FIRST_IDX (= 5) to AMINO_ELEMENT_LAST_IDX (= 24).
      // This is enforced by backward compatibility with Classic MW.

      // At the beginning, ensure that elements from 0 to 24 exists.
      for (i = engine.getNumberOfElements(); i <= aminoacidsHelper.lastElementID; i++) {
        model.addElement({
          id: i
        });
      }

      // Set amino acids properties using elements from 5 to 24.
      for (i = 0, len = aminoacids.length; i < len; i++) {
        // Note that sigma is calculated using Classic MW approach.
        // See: org.concord.mw2d.models.AminoAcidAdapter
        // Basic length unit in Classic MW is 0.1 Angstrom.
        sigmaIn01Angstroms = 18 * Math.pow(aminoacids[i].volume / aminoacids[0].volume, 0.3333333333333);
        sigmaInNm = units.convert(sigmaIn01Angstroms / 10, { from: units.unit.ANGSTROM, to: units.unit.NANOMETER });
        // Use engine's method instead of modeler's method to avoid validation.
        // Modeler's wrapper ensures that amino acid is immutable, so it won't allow
        // to set properties of amino acid.
        engine.setElementProperties(aminoacidsHelper.firstElementID + i, {
          mass: aminoacids[i].molWeight,
          sigma: sigmaInNm
          // Don't provide epsilon, as default value should be used.
          // Classic MW uses epsilon 0.1 for all amino acids, which is default one.
          // See: org.concord.mw2d.models.AtomicModel.resetElements()
        });
      }
    }

    // ------------------------------------------------------------
    //
    // Public functions
    //
    // ------------------------------------------------------------

    /**
      Current seek position
    */
    model.stepCounter = function() {
      return tickHistory.get("counter");
    };

    /**
      Current position of first value in tick history, normally this will be 0.
      This will be greater than 0 if maximum size of tick history has been exceeded.
    */
    model.stepStartCounter = function() {
      return tickHistory.get("startCounter");
    };

    /** Total number of ticks that have been run & are stored, regardless of seek
        position
    */
    model.steps = function() {
      return tickHistory.get("length");
    };

    model.isNewStep = function() {
      return newStep;
    };

    model.seek = function(location) {
      if (!arguments.length) { location = 0; }
      if (!model.isStopped()) {
        model.stop();
      }
      newStep = false;
      runAndDispatchObjectNumberChanges(function() {
        tickHistory.seekExtract(location);
        readModelState();
        model.updateAllOutputProperties();
        dispatch.seek();
      });
      return tickHistory.get("counter");
    };

    model.stepBack = function(num) {
      if (!arguments.length) { num = 1; }
      if (!model.isStopped()) {
        model.stop();
      }
      newStep = false;
      runAndDispatchObjectNumberChanges(function() {
        var i, index;
        i = -1; while(++i < num) {
          index = tickHistory.get("index");
          if (index > 0) {
            tickHistory.decrementExtract();
            readModelState();
            model.updateAllOutputProperties();
            dispatch.stepBack();
          }
        }
      });
      return tickHistory.get("counter");
    };

    model.stepForward = function(num) {
      if (!arguments.length) { num = 1; }
      if (!model.isStopped()) {
        model.stop();
      }
      runAndDispatchObjectNumberChanges(function() {
        var i, index, size;
        i=-1; while(++i < num) {
          index = tickHistory.get("index");
          size = tickHistory.get("length");
          if (index < size-1) {
            tickHistory.incrementExtract();
            readModelState();
            model.updateAllOutputProperties();
            dispatch.stepForward();
          } else {
            model.tick();
          }
        }
      });
      return tickHistory.get("counter");
    };

    /**
      Initialize minX, minYm, maxX, maxY from width and height
      when these options are undefined.
    */
    function initializeDimensions(properties) {
      var minX = properties.minX,
          minY = properties.minY,
          maxX = properties.maxX,
          maxY = properties.maxY;

      properties.minX = minX != null ? minX : 0;
      properties.maxX = maxX != null ? maxX : properties.width;
      properties.minY = minY != null ? minY : 0;
      properties.maxY = maxY != null ? maxY : properties.height;
    }

    /**
      Creates a new md2d engine and leaves it in 'engine'.
    */
    function initializeEngine(properties, pluginProperties) {
      engine.setDimensions([properties.minX, properties.minY, properties.maxX, properties.maxY]);

      if (pluginProperties.quantumDynamics) {
        properties.useQuantumDynamics = true;
        engine.addPlugin(new QuantumDynamics(engine, pluginProperties.quantumDynamics));
      } else {
        properties.useQuantumDynamics = false;
      }

      // Copy reference to basic properties.
      // FIXME. This should go away. https://www.pivotaltracker.com/story/show/50086079
      elements = engine.elements;
      radialBonds = engine.radialBonds;
      radialBondResults = engine.radialBondResults;
      angularBonds = engine.angularBonds;
      restraints = engine.restraints;
      obstacles = engine.obstacles;
      rectangles = engine.rectangles;
    }

    model.createElements = function(_elements) {
      var i, num, prop, elementProps;

      // Start batch process
      model.startBatch();

      if (_elements === undefined) {
        // Special case when elements are not defined.
        // Empty object will be filled with default values.
        model.addElement({id: 0});
        model.endBatch();
        return;
      }

      // _elements is hash of arrays (as specified in JSON model).
      // So, for each index, create object containing properties of
      // element 'i'. Later, use these properties to add element
      // using basic addElement method.
      for (i = 0, num = _elements.mass.length; i < num; i++) {
        elementProps = {};
        for (prop in _elements) {
          if (_elements.hasOwnProperty(prop)) {
            elementProps[prop] = _elements[prop][i];
          }
        }
        model.addElement(elementProps);
      }

      // End batch process
      model.endBatch();

      return model;
    };

    /**
      Creates a new set of atoms.

      config: a hash specifying the x,y,vx,vy properties of the atoms
    */
    model.createAtoms = function(config) {
          // Options for addAtom method.
      var options = {
            // Do not check the position of atom, assume that it's valid.
            suppressCheck: true
          },
          i, num, prop, atomProps;

      dispatch.willReset();

      // Start batch process
      model.startBatch();

      num = config.x.length;

      // config is hash of arrays (as specified in JSON model). So, for each index, create object
      // containing properties of atom 'i'. Later, use these properties to add atom using basic
      // addAtom method.
      for (i = 0; i < num; i++) {
        atomProps = {};
        for (prop in config) {
          if (config.hasOwnProperty(prop)) {
            atomProps[prop] = config[prop][i];
          }
        }
        model.addAtom(atomProps, options);
      }

      // End batch process
      model.endBatch();

      // Listeners should consider resetting the atoms a 'reset' event
      dispatch.reset();
    };

    model.createRadialBonds = function(_radialBonds) {
      var num = _radialBonds.strength.length,
          i, prop, radialBondProps;

      // Start batch process
      model.startBatch();

      // _radialBonds is hash of arrays (as specified in JSON model).
      // So, for each index, create object containing properties of
      // radial bond 'i'. Later, use these properties to add radial bond
      // using basic addRadialBond method.
      for (i = 0; i < num; i++) {
        radialBondProps = {};
        for (prop in _radialBonds) {
          if (_radialBonds.hasOwnProperty(prop)) {
            radialBondProps[prop] = _radialBonds[prop][i];
          }
        }
        model.addRadialBond(radialBondProps);
      }

      // End batch process
      model.endBatch();

      return model;
    };

    model.createAngularBonds = function(_angularBonds) {
      var num = _angularBonds.strength.length,
          i, prop, angularBondProps;

      // Start batch process
      model.startBatch();

      // _angularBonds is hash of arrays (as specified in JSON model).
      // So, for each index, create object containing properties of
      // angular bond 'i'. Later, use these properties to add angular bond
      // using basic addAngularBond method.
      for (i = 0; i < num; i++) {
        angularBondProps = {};
        for (prop in _angularBonds) {
          if (_angularBonds.hasOwnProperty(prop)) {
            angularBondProps[prop] = _angularBonds[prop][i];
          }
        }
        model.addAngularBond(angularBondProps);
      }

      // End batch process
      model.endBatch();

      return model;
    };

    model.createRestraints = function(_restraints) {
      var num = _restraints.atomIndex.length,
          i, prop, restraintsProps;

      // _restraints is hash of arrays (as specified in JSON model).
      // So, for each index, create object containing properties of
      // restraint 'i'. Later, use these properties to add restraint
      // using basic addRestraint method.
      for (i = 0; i < num; i++) {
        restraintsProps = {};
        for (prop in _restraints) {
          if (_restraints.hasOwnProperty(prop)) {
            restraintsProps[prop] = _restraints[prop][i];
          }
        }
        model.addRestraint(restraintsProps);
      }

      return model;
    };

    model.createObstacles = function(_obstacles) {
      var numObstacles = _obstacles.x.length,
          i, prop, obstacleProps;

      // _obstacles is hash of arrays (as specified in JSON model).
      // So, for each index, create object containing properties of
      // obstacle 'i'. Later, use these properties to add obstacle
      // using basic addObstacle method.
      for (i = 0; i < numObstacles; i++) {
        obstacleProps = {};
        for (prop in _obstacles) {
          if (_obstacles.hasOwnProperty(prop)) {
            obstacleProps[prop] = _obstacles[prop][i];
          }
        }
        model.addObstacle(obstacleProps);
      }

      return model;
    };
    model.createRectangles = function(_rectangles) {
      var numRectangles = _rectangles.x.length,
          i, prop, rectangleProps;

      // See function above
      for (i = 0; i < numRectangles; i++) {
        rectangleProps = {};
        for (prop in _rectangles) {
          if (_rectangles.hasOwnProperty(prop)) {
            rectangleProps[prop] = _rectangles[prop][i];
          }
        }
        model.addRectangle(rectangleProps);
      }

      return model;
    };

    model.reset = function() {
      dispatch.willReset();
      propertySupport.invalidatingChangePreHook();
      engine.setTime(0);
      tickHistory.restoreInitialState();
      propertySupport.invalidatingChangePostHook();
      dispatch.reset();
    };

    model.getTotalMass = function() {
      return engine.getTotalMass();
    };

    model.getAtomKineticEnergy = function(i) {
      return engine.getAtomKineticEnergy(i);
    };

    /**
      Attempts to add an 0-velocity atom to a random location. Returns false if after 10 tries it
      can't find a location. (Intended to be exposed as a script API method.)

      Optionally allows specifying the element (default is to randomly select from all editableElements) and
      charge (default is neutral).
    */
    model.addRandomAtom = function(el, charge) {
      if (el == null) el = randomElement();
      if (charge == null) charge = 0;

      var width = model.get('width'),
          height = model.get('height'),
          minX = model.get('minX'),
          minY = model.get('minY'),
          radius = engine.getRadiusOfElement(el),
          x,
          y,
          loc,
          numTries = 0,
          // try at most ten times.
          maxTries = 10;

      do {
        x = minX + Math.random() * width - 2*radius;
        y = minY + Math.random() * height - 2*radius;

        // findMinimimuPELocation will return false if minimization doesn't converge, in which case
        // try again from a different x, y
        loc = engine.findMinimumPELocation(el, x, y, 0, 0, charge);
        if (loc && model.addAtom({ element: el, x: loc[0], y: loc[1], charge: charge })) return true;
      } while (++numTries < maxTries);

      return false;
    },

    /**
      Adds a new atom defined by properties.
      Intended to be exposed as a script API method also.

      Adjusts (x,y) if needed so that the whole atom is within the walls of the container.

      Returns false and does not add the atom if the potential energy change of adding an *uncharged*
      atom of the specified element to the specified location would be positive (i.e, if the atom
      intrudes into the repulsive region of another atom), or if atom is placed inside an obstacle

      Otherwise, returns true.

      silent = true disables this check.
    */
    model.addAtom = function(props, options) {
      var minX = model.get('minX'),
          minY = model.get('minY'),
          maxX = model.get('maxX'),
          maxY = model.get('maxY'),
          radius;

      options = options || {};

      // Validate properties, provide default values.
      props = validator.validateCompleteness(metadata.atom, props);

      // As a convenience to script authors, bump the atom within bounds
      radius = engine.getRadiusOfElement(props.element);
      if (props.x < (minX + radius)) props.x = minX + radius;
      if (props.x > (maxX - radius)) props.x = maxX - radius;
      if (props.y < (minY + radius)) props.y = minY + radius;
      if (props.y > (maxY - radius)) props.y = maxY - radius;

      // check the potential energy change caused by adding an *uncharged* atom at (x,y)
      if (!options.suppressCheck && !engine.canPlaceAtom(props.element, props.x, props.y)) {
        // return false on failure
        return false;
      }

      // When atoms are being deserialized, the deserializing function
      // should handle change hooks due to performance reasons.
      if (!options.deserialization) {
        propertySupport.invalidatingChangePreHook();
      }

      engine.addAtom(props);

      if (!options.deserialization) {
        propertySupport.invalidatingChangePostHook();
      }

      if (!options.suppressEvent) {
        dispatch.addAtom();
      }

      return true;
    },

    model.removeAtom = function(i, options) {
      var prevRadBondsCount = engine.getNumberOfRadialBonds(),
          prevAngBondsCount = engine.getNumberOfAngularBonds();

      options = options || {};

      propertySupport.invalidatingChangePreHook();
      engine.removeAtom(i);
      // Enforce modeler to recalculate viewAtoms array.
      viewAtoms.length = 0;
      propertySupport.invalidatingChangePostHook();

      if (!options.suppressEvent) {
        // Notify listeners that atoms is removed.
        dispatch.removeAtom();

        // Removing of an atom can also cause removing of
        // the connected radial bond. Detect it and notify listeners.
        if (engine.getNumberOfRadialBonds() !== prevRadBondsCount) {
          dispatch.removeRadialBond();
        }
        if (engine.getNumberOfAngularBonds() !== prevAngBondsCount) {
          dispatch.removeAngularBond();
        }
      }
    },

    model.addElement = function(props) {
      // Validate properties, use default values if there is such need.
      props = validator.validateCompleteness(metadata.element, props);
      // Finally, add radial bond.
      engine.addElement(props);
    };

    model.addObstacle = function(props) {
      var validatedProps;

      if (props.color !== undefined && props.colorR === undefined) {
        // Convert color definition.
        // Both forms are supported:
        //   color: [ 128, 128, 255 ]
        // or
        //   colorR: 128,
        //   colorB: 128,
        //   colorG: 255
        props.colorR = props.color[0];
        props.colorG = props.color[1];
        props.colorB = props.color[2];
      }
      // Validate properties, use default values if there is such need.
      validatedProps = validator.validateCompleteness(metadata.obstacle, props);
      // Finally, add obstacle.
      propertySupport.invalidatingChangePreHook();
      engine.addObstacle(validatedProps);
      propertySupport.invalidatingChangePostHook();
    };

    model.addRectangle = function(props) {
      var validatedProps;
      // Validate properties, use default values if there is such need.
      validatedProps = validator.validateCompleteness(metadata.rectangle, props);
      // Finally, add rectangle.
      propertySupport.invalidatingChangePreHook();
      engine.addRectangle(validatedProps);
      propertySupport.invalidatingChangePostHook();
    };

    model.removeObstacle = function (idx) {
      propertySupport.invalidatingChangePreHook();
      engine.removeObstacle(idx);
      propertySupport.invalidatingChangePostHook();
    };

	model.removeRectangle = function (idx) {
      propertySupport.invalidatingChangePreHook();
      engine.removeRectangle(idx);
      propertySupport.invalidatingChangePostHook();
    };

    model.addRadialBond = function(props, options) {
      // Validate properties, use default values if there is such need.
      props = validator.validateCompleteness(metadata.radialBond, props);

      // During deserialization change hooks are managed manually.
      if (!options || !options.deserialization) {
        propertySupport.invalidatingChangePreHook();
      }

      // Finally, add radial bond.
      engine.addRadialBond(props);

      if (!options || !options.deserialization) {
        propertySupport.invalidatingChangePostHook();
      }

      dispatch.addRadialBond();
    },

    model.removeRadialBond = function(idx) {
      propertySupport.invalidatingChangePreHook();
      engine.removeRadialBond(idx);
      propertySupport.invalidatingChangePreHook();
      dispatch.removeRadialBond();
    };

    model.addAngularBond = function(props, options) {
      // Validate properties, use default values if there is such need.
      props = validator.validateCompleteness(metadata.angularBond, props);

      // During deserialization change hooks are managed manually.
      if (!options || !options.deserialization) {
        propertySupport.invalidatingChangePreHook();
      }

      // Finally, add angular bond.
      engine.addAngularBond(props);

      if (!options || !options.deserialization) {
        propertySupport.invalidatingChangePostHook();
      }
    };

    model.removeAngularBond = function(idx) {
      propertySupport.invalidatingChangePreHook();
      engine.removeAngularBond(idx);
      propertySupport.invalidatingChangePostHook();
      dispatch.removeAngularBond();
    };

    model.addRestraint = function(props) {
      // Validate properties, use default values if there is such need.
      props = validator.validateCompleteness(metadata.restraint, props);
      // Finally, add restraint.
      propertySupport.invalidatingChangePreHook();
      engine.addRestraint(props);
      propertySupport.invalidatingChangePostHook();
    };

    /** Return the bounding box of the molecule containing atom 'atomIndex', with atomic radii taken
        into account.

       @returns an object with properties 'left', 'right', 'top', and 'bottom'. These are translated
       relative to the center of atom 'atomIndex', so that 'left' represents (-) the distance in nm
       between the leftmost edge and the center of atom 'atomIndex'.
    */
    model.getMoleculeBoundingBox = function(atomIndex) {

      var atoms = modelState.atoms,
          moleculeAtoms,
          i,
          x,
          y,
          r,
          top = -Infinity,
          left = Infinity,
          bottom = Infinity,
          right = -Infinity,
          cx,
          cy;

      moleculeAtoms = engine.getMoleculeAtoms(atomIndex);
      moleculeAtoms.push(atomIndex);

      for (i = 0; i < moleculeAtoms.length; i++) {
        x = atoms.x[moleculeAtoms[i]];
        y = atoms.y[moleculeAtoms[i]];
        r = atoms.radius[moleculeAtoms[i]];

        if (x-r < left  ) left   = x-r;
        if (x+r > right ) right  = x+r;
        if (y-r < bottom) bottom = y-r;
        if (y+r > top   ) top    = y+r;
      }

      cx = atoms.x[atomIndex];
      cy = atoms.y[atomIndex];

      return { top: top-cy, left: left-cx, bottom: bottom-cy, right: right-cx };
    },

    model.setTemperatureOfAtoms = function(atomIndices, T) {
      propertySupport.invalidatingChangePreHook();
      engine.setTemperatureOfAtoms(atomIndices, T);
      propertySupport.invalidatingChangePostHook();
    };

    model.getTemperatureOfAtoms = function(atomIndices) {
      return engine.getTemperatureOfAtoms(atomIndices);
    };

    /**
        A generic method to set properties on a single existing atom.

        Example: setAtomProperties(3, {x: 5, y: 8, px: 0.5, charge: -1})

        This can optionally check the new location of the atom to see if it would
        overlap with another another atom (i.e. if it would increase the PE).

        This can also optionally apply the same dx, dy to any atoms in the same
        molecule (if x and y are being changed), and check the location of all
        the bonded atoms together.
      */
    model.setAtomProperties = function(i, props, checkLocation, moveMolecule) {
      var atoms = modelState.atoms,
          moleculeAtoms,
          dx, dy,
          new_x, new_y,
          j, jj;

      // Validate properties.
      props = validator.validate(metadata.atom, props);

      if (moveMolecule) {
        moleculeAtoms = engine.getMoleculeAtoms(i);
        if (moleculeAtoms.length > 0) {
          dx = typeof props.x === "number" ? props.x - atoms.x[i] : 0;
          dy = typeof props.y === "number" ? props.y - atoms.y[i] : 0;
          for (j = 0, jj=moleculeAtoms.length; j<jj; j++) {
            new_x = atoms.x[moleculeAtoms[j]] + dx;
            new_y = atoms.y[moleculeAtoms[j]] + dy;
            if (!model.setAtomProperties(moleculeAtoms[j], {x: new_x, y: new_y}, checkLocation, false)) {
              return false;
            }
          }
        }
      }

      if (checkLocation) {
        var x  = typeof props.x === "number" ? props.x : atoms.x[i],
            y  = typeof props.y === "number" ? props.y : atoms.y[i],
            el = typeof props.element === "number" ? props.y : atoms.element[i];

        if (!engine.canPlaceAtom(el, x, y, i)) {
          return false;
        }
      }

      propertySupport.invalidatingChangePreHook();
      engine.setAtomProperties(i, translateToMD2DUnits(props, metadata.atom));
      propertySupport.invalidatingChangePostHook();
      return true;
    };

    model.getAtomProperties = function(i) {
      var atoms = modelState.atoms,
          atomMetaData = metadata.atom,
          props = {},
          propName;

      for (propName in atomMetaData) {
        if (atomMetaData.hasOwnProperty(propName) && atoms[propName]) {
          props[propName] = atoms[propName][i];
        }
      }
      return translateFromMD2DUnits(props, atomMetaData);
    };

    model.getRadialBondsForAtom = function(i) {
      return engine.getRadialBondsForAtom(i);
    };

    model.getAngularBondsForAtom = function(i) {
      return engine.getAngularBondsForAtom(i);
    };

    model.getMoleculeAtoms = function(i) {
      return engine.getMoleculeAtoms(i);
    };

    model.setElementProperties = function(i, props) {
      // Validate properties.
      props = validator.validate(metadata.element, props);
      if (aminoacidsHelper.isAminoAcid(i)) {
        throw new Error("Elements: elements with ID " + i + " cannot be edited, as they define amino acids.");
      }
      propertySupport.invalidatingChangePreHook();
      engine.setElementProperties(i, translateToMD2DUnits(props, metadata.element));
      propertySupport.invalidatingChangePostHook();
    };

    model.getElementProperties = function(i) {
      var elementMetaData = metadata.element,
          props = {},
          propName;
      for (propName in elementMetaData) {
        if (elementMetaData.hasOwnProperty(propName)) {
          props[propName] = elements[propName][i];
        }
      }
      return translateFromMD2DUnits(props, elementMetaData);
    };

    model.setObstacleProperties = function(i, props) {
      // Validate properties.
      props = validator.validate(metadata.obstacle, props);
      propertySupport.invalidatingChangePreHook();
      engine.setObstacleProperties(i, translateToMD2DUnits(props, metadata.obstacle));
      propertySupport.invalidatingChangePostHook();
    };

    model.getObstacleProperties = function(i) {
      var obstacleMetaData = metadata.obstacle,
          props = {},
          propName;
      for (propName in obstacleMetaData) {
        if (obstacleMetaData.hasOwnProperty(propName)) {
          props[propName] = obstacles[propName][i];
        }
      }
      return translateFromMD2DUnits(props, obstacleMetaData);
    };

    model.setRectangleProperties = function(i, props) {
      // Validate properties.
      props = validator.validate(metadata.rectangle, props);
      propertySupport.invalidatingChangePreHook();
      engine.setRectangleProperties(i, translateToMD2DUnits(props, metadata.rectangle));
      propertySupport.invalidatingChangePostHook();
    };

    model.getRectangleProperties = function(i) {
      var rectangleMetaData = metadata.rectangle,
          props = {},
          propName;
      for (propName in rectangleMetaData) {
        if (rectangleMetaData.hasOwnProperty(propName)) {
          props[propName] = rectangles[propName][i];
        }
      }
      return translateFromMD2DUnits(props, rectangleMetaData);
    };

    model.setRadialBondProperties = function(i, props) {
      // Validate properties.
      props = validator.validate(metadata.radialBond, props);
      propertySupport.invalidatingChangePreHook();
      engine.setRadialBondProperties(i, translateToMD2DUnits(props, metadata.radialBond));
      propertySupport.invalidatingChangePostHook();
    };

    model.getRadialBondProperties = function(i) {
      var radialBondMetaData = metadata.radialBond,
          props = {},
          propName;
      for (propName in radialBondMetaData) {
        if (radialBondMetaData.hasOwnProperty(propName)) {
          props[propName] = radialBonds[propName][i];
        }
      }
      return translateFromMD2DUnits(props, radialBondMetaData);
    };

    model.setRestraintProperties = function(i, props) {
      // Validate properties.
      props = validator.validate(metadata.restraint, props);
      propertySupport.invalidatingChangePreHook();
      engine.setRestraintProperties(i, translateToMD2DUnits(props, metadata.restraint));
      propertySupport.invalidatingChangePostHook();
    };

    model.getRestraintProperties = function(i) {
      var restraintMetaData = metadata.restraint,
          props = {},
          propName;
      for (propName in restraintMetaData) {
        if (restraintMetaData.hasOwnProperty(propName)) {
          props[propName] = restraints[propName][i];
        }
      }
      return translateFromMD2DUnits(props, restraintMetaData);
    };

    model.setAngularBondProperties = function(i, props) {
      // Validate properties.
      props = validator.validate(metadata.angularBond, props);
      propertySupport.invalidatingChangePreHook();
      engine.setAngularBondProperties(i, translateToMD2DUnits(props, metadata.angularBond));
      propertySupport.invalidatingChangePostHook();
    };

    model.getAngularBondProperties = function(i) {
      var angularBondMetaData = metadata.angularBond,
          props = {},
          propName;
      for (propName in angularBondMetaData) {
        if (angularBondMetaData.hasOwnProperty(propName)) {
          props[propName] = angularBonds[propName][i];
        }
      }
      return translateFromMD2DUnits(props, angularBondMetaData);
    };

    model.setSolvent = function (solventName) {
      var solvent = new Solvent(solventName),
          props = {
            solventForceType: solvent.forceType,
            dielectricConstant: solvent.dielectricConstant,
            backgroundColor: solvent.color
          };
      model.set(props);
    };

    /** A "spring force" is used to pull atom `atomIndex` towards (x, y). We expect this to be used
       to drag atoms interactively using the mouse cursor (in which case (x,y) is the mouse cursor
       location.) In these cases, use the liveDragStart, liveDrag, and liveDragEnd methods instead
       of this one.

       The optional springConstant parameter (measured in eV/nm^2) is used to adjust the strength
       of the "spring" pulling the atom toward (x, y)

       @returns ID (index) of the spring force among all spring forces
    */
    model.addSpringForce = function(atomIndex, x, y, springConstant) {
      if (springConstant == null) springConstant = 500;

      if (unitsTranslation) {
        springConstant = unitsTranslation.translateToModelUnits(springConstant, 'stiffness');
      }
      return engine.addSpringForce(atomIndex, x, y, springConstant);
    };

    /**
      Update the (x, y) position of a spring force.
    */
    model.updateSpringForce = function(springForceIndex, x, y) {
      engine.updateSpringForce(springForceIndex, x, y);
    };

    /**
      Remove a spring force.
    */
    model.removeSpringForce = function(springForceIndex) {
      engine.removeSpringForce(springForceIndex);
    };

    model.addTextBox = function(props) {
      props = validator.validateCompleteness(metadata.textBox, props);
      model.get('textBoxes').push(props);
      dispatch.textBoxesChanged();
    };

    model.removeTextBox = function(i) {
      var text = model.get('textBoxes');
      if (i >=0 && i < text.length) {
        model.set('textBoxes', text.slice(0,i).concat(text.slice(i+1)));
        dispatch.textBoxesChanged();
      } else {
        throw new Error("Text box \"" + i + "\" does not exist, so it cannot be removed.");
      }
    };

    model.setTextBoxProperties = function(i, props) {
      var textBox = model.get('textBoxes')[i],
          prop;

      if (textBox) {
        props = validator.validate(metadata.textBox, props);
        for (prop in props) {
          if (props.hasOwnProperty(prop)) {
            textBox[prop] = props[prop];
          }
        }
        dispatch.textBoxesChanged();
      } else {
        throw new Error("Text box \"" + i + "\" does not exist, so it cannot have properties set.");
      }
    };

    /**
      Implements dragging of an atom in a running model, by creating a spring force that pulls the
      atom towards the mouse cursor position (x, y) and damping the resulting motion by temporarily
      adjusting the friction of the dragged atom.
    */
    model.liveDragStart = function(atomIndex, x, y) {
      if (liveDragSpringForceIndex != null) return;    // don't add a second liveDrag force

      if (x == null) x = modelState.atoms.x[atomIndex];
      if (y == null) y = modelState.atoms.y[atomIndex];

      liveDragSavedFriction = model.getAtomProperties(atomIndex).friction;

      // Use setAtomProperties so that we handle things correctly if a web worker is integrating
      // the model. (Here we follow the rule that we must assume that an integration might change
      // any property of an atom, and therefore cause changes to atom properties in the main thread
      // to be be lost. This is true even though common sense tells us that the friction property
      // won't change during an integration.)

      model.setAtomProperties(atomIndex, { friction: model.LIVE_DRAG_FRICTION });

      liveDragSpringForceIndex = model.addSpringForce(atomIndex, x, y, 500);
    };

    /**
      Updates the drag location after liveDragStart
    */
    model.liveDrag = function(x, y) {
      model.updateSpringForce(liveDragSpringForceIndex, x, y);
    };

    /**
      Cancels a live drag by removing the spring force that is pulling the atom, and restoring its
      original friction property.
    */
    model.liveDragEnd = function() {
      var atomIndex = engine.springForceAtomIndex(liveDragSpringForceIndex);

      model.setAtomProperties(atomIndex, { friction: liveDragSavedFriction });
      model.removeSpringForce(liveDragSpringForceIndex);
      liveDragSpringForceIndex = null;
    };

    /**
     * Returns number of frames per second.
     * @return {number} frames per second.
     */
    model.getFPS = function() {
      var s = 0,
          n = sampleTimes.length,
          i = -1;

      while (++i < n) {
        s += sampleTimes[i];
      }
      s /= n;
      return (s ? 1 / s * 1000 : 0);
    };

    /**
     * Returns "simulation progress rate".
     * It indicates how much of simulation time is calculated for
     * one second of real time.
     * @return {number} simulation progress rate.
     */
    model.getSimulationProgressRate = function() {
      return model.getFPS() * model.get('timeStep') * model.get('timeStepsPerTick');
    };

    model.get_elements = function() {
      return elements;
    };

    model.getAtoms = function() {
      return viewAtoms;
    };

    model.getElectricField = function() {
      return electricField;
    };

    model.getPhotons = function() {
      return viewPhotons;
    },

    model.get_radial_bond_results = function() {
      return radialBondResults;
    };

    /**
      Returns the total number of atoms, or else the number of atoms matching some criterion.

      If the argument 'f' is present, it is called once for each atom, passing the atom as the
      argument to f. The number of atoms for which f evaluates to true is returned.

      Example

        model.getNumberOfAtoms(function(atom) { return atom.mass < 50; })

      returns the number of atoms having mass < 50
    */
    model.getNumberOfAtoms = function(f) {
      if (!f) {
        return viewAtoms.length;
      }
      return viewAtoms.reduce(function(total, atom) {
        return f(atom) ? total + 1 : total;
      }, 0);
    };

    model.get_obstacles = function() {
      return obstacles;
    };
    model.get_rectangles = function() {
      return rectangles;
    };

    model.get_rectangles = function() {
      return rectangles;
    };

    // FIXME. Should be an output property.
    model.getNumberOfElements = function () {
      return engine.getNumberOfElements();
    };

    // FIXME. Should be an output property.
    model.getNumberOfObstacles = function () {
      return engine.getNumberOfObstacles();
    };

    model.getNumberOfRectangles = function () {
      return engine.getNumberOfRectangles();
    };

    // FIXME. Should be an output property.
    model.getNumberOfRadialBonds = function () {
      return engine.getNumberOfRadialBonds();
    };

    // FIXME. Should be an output property.
    model.getNumberOfAngularBonds = function () {
      return engine.getNumberOfAngularBonds();
    };

    // FIXME. Should be an output property.
    model.getNumberOfSpringForces = function () {
      return engine.getNumberOfSpringForces();
    };

    model.get_radial_bonds = function() {
      return radialBonds;
    };

    model.get_restraints = function() {
      return restraints;
    };

    model.getPairwiseLJProperties = function() {
      return engine.pairwiseLJProperties;
    };

    model.geneticEngine = function() {
      return geneticEngine;
    };

    model.get_vdw_pairs = function() {
      return engine.getVdwPairsArray();
    };

    model.tickInPlace = function() {
      dispatch.tick();
      return model;
    };

    model.tick = function(elapsedTime) {
      var timeStep = model.get('timeStep'),
          // Save number of radial bonds in engine before integration,
          // as integration can create new disulfide bonds. This is the
          // only type of objects which can be created by the engine autmatically.
          prevNumOfRadialBonds = engine.getNumberOfRadialBonds(),
          t, sampleTime;

      if (unitsTranslation) {
        timeStep = unitsTranslation.translateToModelUnits(timeStep, 'time');
      }

      if (!model.isStopped()) {
        t = performance.now();
        if (lastSampleTime) {
          sampleTime = t - lastSampleTime;
          lastSampleTime = t;
          sampleTimes.push(sampleTime);
          sampleTimes.splice(0, sampleTimes.length - 64);

          // Process all transitions which are in progress
          // and remove finished.
          processTransitions(sampleTime);
        } else {
          lastSampleTime = t;
        }
      }

      // timeStepsPerTick is defined in Classic MW as the number of timesteps per view update.
      // However, in MD2D we prefer the more physical notion of integrating for a particular
      // length of time.
      console.time('integration');
      engine.integrate(model.get('timeStepsPerTick') * timeStep, timeStep);
      console.timeEnd('integration');
      console.time('reading model state');
      readModelState();
      model.updateAllOutputProperties();
      console.timeEnd('reading model state');

      console.time('tick history push');
      tickHistory.push();
      console.timeEnd('tick history push');

      newStep = true;

      if (prevNumOfRadialBonds < engine.getNumberOfRadialBonds()) {
        dispatch.addRadialBond();
      }

      dispatch.tick();
    };

    model.minimizeEnergy = function () {
      propertySupport.invalidatingChangePreHook();
      engine.minimizeEnergy();
      propertySupport.invalidatingChangePostHook();
      // Positions of atoms could change, so
      // dispatch tick event.
      dispatch.tick();
      return model;
    };

    model.dimensions = function() {
      return engine.getDimensions();
    };

    model.format = function(property, opts) {
      opts = opts || {};

      var desc = model.getPropertyDescription(property);
      if (desc) {
        return desc.format(model.get(property), opts);
      }
      return d3.format(opts.format || 'g')(model.get(property));
    };

    /**
      Return a unitDefinition in the current unitScheme for a quantity
      such as 'length', 'mass', etc.
    */
    model.getUnitDefinition = function(name) {
      return unitsDefinition.units[name];
    };

    /**
     * Returns atom transition object. It can be used to smoothly change
     * atom properties over specified time. It's similar to D3 transitions.
     *
     * Atom transition object provides following methods:
     *  id(id)          - sets ID of the atom (required!).
     *  duration(d)     - sets duration in ms (required!).
     *  prop(name, val) - sets property name and its final value (required!).
     *  delay(d)        - sets delay in ms (default is 0).
     *  ease(name)      - sets easing function (default is "cubic-in-out").
     *                    Please see:
     *                    https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease
     *
     * e.g.
     *  atomTransition().id(0).duration(1000).ease("linear").prop("x", 10);
     *
     * This will change "x" property of the atom with ID=0
     * to value 10 over 1000ms using linear easing function.
     *
     * @return {AtomTransition} AtomTransition instance.
     */
    model.atomTransition = function () {
      var t = new AtomTransition(model);
      transitions.push(t);
      return t;
    };

    /**
     * Cancels all transitions which are currently in progress.
     */
    model.cancelTransitions = function () {
      transitions.length = 0;
    };

    /**
      Call before running a function that would otherwise trigger a number
      of invalidatingChangePre/PostHooks, which would slow down the model when
      each change causes a recalculation. This can be used whenever you can
      safely assume that all actions executed between startBatch and endBatch
      will not depend on triggered property changes.

      endBatch() *must* be called after the actions are complete, or output
      properties will no longer be updated.
      */
    model.startBatch = function() {
      propertySupport.startBatch();
      // Suppress events dispatching. They will be dispatched during
      // .endBatch() execution.
      dispatch.startBatch();
    };

    model.endBatch = function() {
      propertySupport.endBatch();
      // All events will be dispatched now (but just once per event type).
      dispatch.endBatch();
    };

    /**
     * Executes function between .startBatch() and .endBatch() calls.
     * @param  {Function} action function that should be executed.
     */
    model.batch = function(action) {
      model.startBatch();
      action();
      model.endBatch();
    };

    // Convert array of hashes to a hash of arrays
    // TODO. Move to a new utils module, share with mml parser
    function unroll(array) {
      var ret = {};

      if (array.length === 0) {
        return {};
      }

      Object.keys(array[0]).forEach(function(key) {
        ret[key] = [];
      });

      array.forEach(function(object) {
        Object.keys(object).forEach(function(key) {
          ret[key].push(object[key]);
        });
      });
      return ret;
    }

    function serializeQuantumDynamics() {
      var photons = model.getPhotons();

      return {
        photons: serialize(metadata.photon, unroll(photons), photons.length),
        elementEnergyLevels: engine.callPluginAccessor('getElementEnergyLevels'),
        radiationlessEmissionProbability: engine.callPluginAccessor('getRadiationlessEmissionProbability')
      };
    }

    model.serialize = function() {
      var propCopy = {},
          ljProps, i, len,
          rawProperties = propertySupport.rawValues,

          removeAtomsArrayIfDefault = function(name, defaultVal) {
            if (propCopy.atoms[name].every(function(i) {
              return i === defaultVal;
            })) {
              delete propCopy.atoms[name];
            }
          };

      propCopy = serialize(metadata.mainProperties, rawProperties);
      propCopy.viewOptions = serialize(metadata.viewOptions, rawProperties);
      propCopy.atoms = serialize(metadata.atom, modelState.atoms, engine.getNumberOfAtoms());

      if (engine.getNumberOfRadialBonds()) {
        propCopy.radialBonds = serialize(metadata.radialBond, radialBonds, engine.getNumberOfRadialBonds());
      }
      if (engine.getNumberOfAngularBonds()) {
        propCopy.angularBonds = serialize(metadata.angularBond, angularBonds, engine.getNumberOfAngularBonds());
      }
      if (engine.getNumberOfObstacles()) {
        propCopy.obstacles = serialize(metadata.obstacle, obstacles, engine.getNumberOfObstacles());

        propCopy.obstacles.color = [];
        // Convert color from internal representation to one expected for serialization.
        for (i = 0, len = propCopy.obstacles.colorR.length; i < len; i++) {
          propCopy.obstacles.color.push([
            propCopy.obstacles.colorR[i],
            propCopy.obstacles.colorG[i],
            propCopy.obstacles.colorB[i]
          ]);

          // Silly, but allows to pass current serialization tests.
          // FIXME: try to create more flexible tests for serialization.
          propCopy.obstacles.westProbe[i] = Boolean(propCopy.obstacles.westProbe[i]);
          propCopy.obstacles.northProbe[i] = Boolean(propCopy.obstacles.northProbe[i]);
          propCopy.obstacles.eastProbe[i] = Boolean(propCopy.obstacles.eastProbe[i]);
          propCopy.obstacles.southProbe[i] = Boolean(propCopy.obstacles.southProbe[i]);
        }
        delete propCopy.obstacles.colorR;
        delete propCopy.obstacles.colorG;
        delete propCopy.obstacles.colorB;
      }
      if (engine.getNumberOfRectangles()) {
        propCopy.rectangles = serialize(metadata.rectangle, rectangles, engine.getNumberOfRectangles());

        propCopy.rectangles.color = [];
        propCopy.rectangles.lineColor = [];
        // Convert color from internal representation to one expected for serialization.
        for (i = 0, len = propCopy.rectangles.colorR.length; i < len; i++) {
          propCopy.rectangles.color.push([
            propCopy.rectangles.colorR[i],
            propCopy.rectangles.colorG[i],
            propCopy.rectangles.colorB[i]
          ]);
          propCopy.rectangles.lineColor.push([
            propCopy.rectangles.lineColorR[i],
            propCopy.rectangles.lineColorG[i],
            propCopy.rectangles.lineColorB[i]
          ]);
        }
        delete propCopy.rectangles.colorR;
        delete propCopy.rectangles.colorG;
        delete propCopy.rectangles.colorB;
        delete propCopy.rectangles.lineColorR;
        delete propCopy.rectangles.lineColorR;
        delete propCopy.rectangles.lineColorR;
      }
      if (engine.getNumberOfRestraints() > 0) {
        propCopy.restraints = serialize(metadata.restraint, restraints, engine.getNumberOfRestraints());
      }

      // FIXME: for now Amino Acid elements are *not* editable and should not be serialized
      // -- only copy first five elements
      propCopy.elements = serialize(metadata.element, elements, 5);

      // The same situation for Custom LJ Properties. Do not serialize properties for amino acids.
      propCopy.pairwiseLJProperties = [];
      ljProps = engine.pairwiseLJProperties.serialize();
      for (i = 0, len = ljProps.length; i < len; i++) {
        if (ljProps[i].element1 <= 5 && ljProps[i].element2 <= 5) {
          propCopy.pairwiseLJProperties.push(ljProps[i]);
        }
      }

      // Do the weird post processing of the JSON, which is also done by MML parser.
      // Remove targetTemperature when heat-bath is disabled.
      if (propCopy.temperatureControl === false) {
        delete propCopy.targetTemperature;
      }
      // Remove atomTraceId when atom tracing is disabled.
      if (propCopy.viewOptions.showAtomTrace === false) {
        delete propCopy.viewOptions.atomTraceId;
      }
      if (propCopy.modelSampleRate === "default") {
        delete propCopy.modelSampleRate;
      }

      // TODO. Should be able to ask plugins to serialize their data.
      if (model.properties.useQuantumDynamics) {
        propCopy.quantumDynamics = serializeQuantumDynamics();
      }

      removeAtomsArrayIfDefault("marked", metadata.atom.marked.defaultValue);
      removeAtomsArrayIfDefault("visible", metadata.atom.visible.defaultValue);
      removeAtomsArrayIfDefault("draggable", metadata.atom.draggable.defaultValue);

      return propCopy;
    };

    // ------------------------------
    // finish setting up the model
    // ------------------------------

    // Friction parameter temporarily applied to the live-dragged atom.
    model.LIVE_DRAG_FRICTION = 10;

    // ------------------------------
    // Process initialProperties before setting properties on the model
    // ------------------------------

    // Ensure that model, which includes DNA (=> so DNA animation too) has
    // correct, constant dimensions. This is very significant, as if model
    // dimensions are too big or too small, DNA elements can be unreadable. It
    // also ensures that aspect ratio of the model is reasonable for
    // animation.
    // TODO: move this to better place.
    if (initialProperties.DNA) {
      // Overwrite width and height options.
      initialProperties.width = 200;
      initialProperties.height = 5;
      // View options are optional, make sure that they are defined.
      initialProperties.viewOptions = initialProperties.viewOptions || {};
      initialProperties.viewOptions.viewPortX = 0;
      initialProperties.viewOptions.viewPortY = 0;
      initialProperties.viewOptions.viewPortWidth = 5;
      initialProperties.viewOptions.viewPortHeight = 3;
    }

    (function () {
      if (!initialProperties.viewOptions || !initialProperties.viewOptions.textBoxes) {
        return;
      }
      // Temporal workaround to provide text boxes validation.
      // Note that text boxes are handled completely different from other objects
      // like atoms or obstacles. There is much of inconsistency and probably
      // it should be refactored anyway.
      var textBoxes = initialProperties.viewOptions.textBoxes,
          i, len;

      for (i = 0, len = textBoxes.length; i < len; i++) {
        textBoxes[i] = validator.validateCompleteness(metadata.textBox, textBoxes[i]);
      }
    }());

    // TODO. Implement a pattern whereby the pluginController lets each plugins examine the initial
    // properties and extract the relevant plugin properties. *However*, don't do it in a way that
    // requires changing the model JSON schema when functionality is moved out of the main engine
    // and into a plugin, or vice-versa.
    pluginProperties = {
      quantumDynamics: initialProperties.quantumDynamics
    };

    // TODO: Elements are stored and treated different from other objects. This was enforced by
    // createNewAtoms() method which has been removed. Change also editableElements handling.
    editableElements = initialProperties.elements;
    // Create editable elements.
    model.createElements(editableElements);
    // Create elements which specify amino acids also.
    createAminoAcids();

    // This will extend model API to support standard Lab model features. We
    // have to do it know, as this will also set initial properties, so the
    // engine has to be already defined (see custom setters).
    labModelerMixin.mixInto(model);

    // Initialize minX, minY, maxX, maxY from model width and height if they are undefined.
    initializeDimensions(model.properties);

    propertySupport.on("afterInvalidatingChange.read-model-state", readModelState);
    propertySupport.on("afterInvalidatingChangeSequence.tick-history", function () {
      if (tickHistory) tickHistory.invalidateFollowingState();
      dispatch.invalidation();
    });

    // Setup MD2D engine object.
    initializeEngine(model.properties, pluginProperties);

    // Setup genetic engine.
    geneticEngine = new GeneticEngine(model);

    // Finally, if provided, set up the model objects (elements, atoms, bonds, obstacles and the rest).
    // However if these are not provided, client code can create atoms, etc piecemeal.

    // Trigger setter of polarAAEpsilon again when engine is initialized and
    // amino acids crated.
    // TODO: initialize engine before set_properties calls, so properties
    // will be injected to engine automatically.
    model.set({polarAAEpsilon: model.get('polarAAEpsilon')});

    if (initialProperties.atoms)        model.createAtoms(initialProperties.atoms);
    if (initialProperties.radialBonds)  model.createRadialBonds(initialProperties.radialBonds);
    if (initialProperties.angularBonds) model.createAngularBonds(initialProperties.angularBonds);
    if (initialProperties.restraints)   model.createRestraints(initialProperties.restraints);
    if (initialProperties.obstacles)    model.createObstacles(initialProperties.obstacles);
    if (initialProperties.rectangles)    model.createRectangles(initialProperties.rectangles);
    // Basically, this #deserialize method is more or less similar to other #create... methods used
    // above. However, this is the first step to delegate some functionality from modeler to smaller classes.
    if (initialProperties.pairwiseLJProperties)
      engine.pairwiseLJProperties.deserialize(initialProperties.pairwiseLJProperties);

    // Initialize tick history.
    tickHistory = new TickHistory({
      getProperties: function() {
        return propertySupport.historyStateRawValues;
      },
      restoreProperties: propertySupport.setRawValues,
      state: engine.getState()
    }, model, defaultMaxTickHistory);

    // FIXME: ugly workaround - mixin OutputSupport again, this time providing
    // tickHistory, so filtered outputs will use it. We couldn't pass
    // tickHistory directly to LabModelerMixin, as tickHistory depends on
    // propertySupport ...returned by LabModelrMixin. It has to be cleaned up.
    outputSupport = new OutputSupport({
      propertySupport: propertySupport,
      unitsDefinition: unitsDefinition,
      tickHistory: tickHistory
    });
    outputSupport.mixInto(model);

    newStep = true;

    // Define some default output properties.
    model.defineOutput('time', {
      label: "Time",
      unitType: 'time',
      format: 'f'
    }, function() {
      // Output getters are expected to return values in translated units, since authored outputs
      // can only read values already in translated units to start with.
      var value = modelState.time;
      if (unitsTranslation) {
        value = unitsTranslation.translateFromModelUnits(value, 'time');
      }
      return value;
    });

    model.defineOutput('timePerTick', {
      label: "Model time per tick",
      unitType: 'time',
      format: 'f'
    }, function() {
      return model.get('timeStep') * model.get('timeStepsPerTick');
    });

    (function() {
      var displayTimeUnits;

      // Allow units definition to declare a "Display time"; specifically, let MD2D units definition
      // define a "displayValue" section in the time unit that returns ps instead of fs.

      if (unitsDefinition.units.time.displayValue) {
        displayTimeUnits = unitsDefinition.units.time.displayValue;
      } else {
        displayTimeUnits = _.extend({}, unitsDefinition.units.time);
        displayTimeUnits.unitsPerBaseUnit = 1;
      }

      model.defineOutput('displayTime', {
        label: "Time",
        unitName:         displayTimeUnits.name,
        unitPluralName:   displayTimeUnits.pluralName,
        unitAbbreviation: displayTimeUnits.symbol,
        format: '.1f'
      }, function() {
        return model.get('time') * displayTimeUnits.unitsPerBaseUnit;
      });

      model.defineOutput('displayTimePerTick', {
        label: "Model time per tick",
        unitName:         displayTimeUnits.name,
        unitPluralName:   displayTimeUnits.pluralName,
        unitAbbreviation: displayTimeUnits.symbol,
        format: '.3f'
      }, function() {
        return model.get('timePerTick') * displayTimeUnits.unitsPerBaseUnit;
      });
    }());

    model.defineOutput('tickCounter', {
      label: "Tick Counter",
      unitType: '',
      format: '4g'
    }, function() {
      return tickHistory.get('counter');
    });

    model.defineOutput('newStep', {
      label: "New Step",
      unitType: '',
      format: ''
    }, function() {
      return newStep;
    });

    model.defineOutput('kineticEnergy', {
      label: "Kinetic Energy",
      unitType: 'energy',
      format: '.4g'
    }, function() {
      var value = modelState.KE;
      if (unitsTranslation) {
        value = unitsTranslation.translateFromModelUnits(value, 'energy');
      }
      return value;
    });

    model.defineOutput('potentialEnergy', {
      label: "Potential Energy",
      unitType: 'energy',
      format: '.4g'
    }, function() {
      var value = modelState.PE;
      if (unitsTranslation) {
        value = unitsTranslation.translateFromModelUnits(value, 'energy');
      }
      return value;
    });

    model.defineOutput('totalEnergy', {
      label: "Total Energy",
      unitType: 'energy',
      format: '.4g'
    }, function() {
      var value = modelState.KE + modelState.PE;
      if (unitsTranslation) {
        value = unitsTranslation.translateFromModelUnits(value, 'energy');
      }
      return value;
    });

    model.defineOutput('temperature', {
      label: "Temperature",
      unitType: 'temperature',
      format: 'f'
    }, function() {
      var value = modelState.temperature;
      if (unitsTranslation) {
        value = unitsTranslation.translateFromModelUnits(value, 'temperature');
      }
      return value;
    });

    readModelState();
    model.updateAllOutputProperties();

    model.performanceOptimizer = new PerformanceOptimizer(model);

    return model;
  };
});

/*global define*/
/**
 * Views can require this function to get next available tab index.
 */
define('common/views/tab-index',[],function () {
  var tabIndex = 0;

  return function getNextTabIndex() {
    return tabIndex++;
  };
});

/*global $, define: false, d3: false */
// ------------------------------------------------------------
//
//   PTA View Container
//
// ------------------------------------------------------------
define('common/views/svg-container',['require','common/performance','common/views/tab-index','common/console'],function (require) {
  // Dependencies.
  var performance           = require('common/performance'),
      getNextTabIndex       = require('common/views/tab-index'),
      console               = require('common/console');

  return function SVGContainer(model, modelUrl, Renderer, opt) {
        // Public API object to be returned.
    var api,

        // Coordinate system origin. Supported values are 'bottom-left' and 'top-left'.
        origin = opt && opt.origin || 'bottom-left',

        $el,
        node,
        emsize,
        fontSizeInPixels,
        vis1, vis, plot, viewportG,
        cx, cy,
        padding, size, modelSize, viewport,

        // Basic scaling functions for positio, it transforms model units to "pixels".
        // Use it for positions of objects rendered inside the view.
        //
        // This function is exposed in public API. Never ever recreated it, as
        // renderers and sub-renders will loose reference to valid scale
        // function.
        model2px = d3.scale.linear(),

        // Inverted scaling function for position transforming model units to "pixels".
        // Use it for Y coordinates, as Y axis in model coordinate system increases
        // from bottom to top, while but SVG has increases from top to bottom.
        //
        // This function is exposed in public API. Never ever recreated it, as
        // renderers and sub-renders will loose reference to valid scale
        // function.
        model2pxInv = d3.scale.linear(),

        gridContainer,
        brushContainer,

        clickHandler,
        // d3.svg.brush object used to implement select action. It should be
        // updated each time model2px and model2pxInv functions are changed!
        selectBrush,

        dispatch = d3.dispatch("viewportDrag"),

        renderer,

        offsetLeft, offsetTop;

    function getFontSizeInPixels() {
      return parseFloat($el.css('font-size')) || 18;
    }

    // Padding is based on the calculated font-size used for the model view container.
    function updatePadding() {
      fontSizeInPixels = getFontSizeInPixels();
      // Convert value to "em", using 18px as a basic font size.
      // It doesn't have to reflect true 1em value in current context.
      // It just means, that we assume that for 18px font-size,
      // padding and playback have scale 1.
      emsize = fontSizeInPixels / 18;

      padding = {
         "top":    0 * emsize,
         "right":  0 * emsize,
         "bottom": 0 * emsize,
         "left":   0 * emsize
      };

      if (model.get("xunits") || model.get("yunits")) {
        padding.bottom += (fontSizeInPixels * 1.2);
        padding.left +=   (fontSizeInPixels * 1.3);
        padding.top +=    (fontSizeInPixels/2);
        padding.right +=  (fontSizeInPixels/2);
      }

      if (model.get("xlabel") || model.get("ylabel")) {
        padding.bottom += (fontSizeInPixels * 0.8);
        padding.left +=   (fontSizeInPixels * 0.8);
      }
    }

    function scale() {
      var viewPortWidth = model.get("viewPortWidth"),
          viewPortHeight = model.get("viewPortHeight"),
          viewPortZoom = model.get("viewPortZoom") || 1,
          viewPortX = model.get("viewPortX"),
          viewPortY = model.get("viewPortY"),
          aspectRatio,
          width, height;

      // Model size in model units.
      modelSize = {
        "minX": model.get('minX'),
        "minY": model.get('minY'),
        "maxX": model.get('maxX'),
        "maxY": model.get('maxY')
      };

      // Note that viewPort specification can be undefined and then viewport
      // should fit the model.
      viewport = {
        width: viewPortWidth != null ? viewPortWidth : modelSize.maxX - modelSize.minX,
        height: viewPortHeight != null ? viewPortHeight : modelSize.maxY - modelSize.minY,
        x: viewPortX != null ? viewPortX : modelSize.minX,
        y: viewPortY != null ? viewPortY : modelSize.minY
      };

      viewport.scaledWidth  = viewport.width / viewPortZoom;
      viewport.scaledHeight = viewport.height / viewPortZoom;
      if (origin === 'bottom-left') {
        viewport.y += viewport.scaledHeight;
      }

      aspectRatio = viewport.width / viewport.height;

      updatePadding();

      cx = $el.width();
      width = cx - padding.left  - padding.right;
      height = width / aspectRatio;
      cy = height + padding.top  + padding.bottom;
      node.style.height = cy + "px";

      // Plot size in px.
      size = {
        "width":  cx - padding.left - padding.right,
        "height": cy - padding.top  - padding.bottom
      };

      size = {
        "width":  width,
        "height": height
      };

      offsetTop  = node.offsetTop + padding.top;
      offsetLeft = node.offsetLeft + padding.left;

      // Basic model2px scaling function for position.
      model2px
        .domain([0, viewport.width])
        .range([0, size.width]);

      // Inverted model2px scaling function for position (for y-coordinates, domain can be inverted).
      model2pxInv
        .domain([viewport.height, 0])
        .range(origin === 'bottom-left' ? [0, size.height] : [size.height, 0]);

      if (selectBrush) {
        // Update brush to use new scaling functions.
        selectBrush
          .x(model2px)
          .y(model2pxInv);
      }
    }

    function redrawGridLinesAndLabels() {
          // Overwrite default model2px and model2pxInv to display correct units.
      var model2px = d3.scale.linear().domain([viewport.x, viewport.x + viewport.scaledWidth]).range([0, size.width]),
          model2pxInv = d3.scale.linear().domain([viewport.y, viewport.y - viewport.scaledHeight]).range([0, size.height]),
          tx = function(d) { return "translate(" + model2px(d) + ",0)"; },
          ty = function(d) { return "translate(0," + model2pxInv(d) + ")"; },
          stroke = function(d) { return d ? "#ccc" : "#666"; },
          fx = model2px.tickFormat(5),
          fy = model2pxInv.tickFormat(5),
          lengthUnits = model.getUnitDefinition ? model.getUnitDefinition('length') : "",
          xlabel, ylabel;

      if (d3.event && d3.event.transform) {
        d3.event.transform(model2px, model2pxInv);
      }

      // Regenerate x-ticks
      var gx = gridContainer.selectAll("g.x")
          .data(model2px.ticks(5), String)
          .attr("transform", tx)
          .classed("axes", true);

      gx.select("text").text(fx);

      var gxe = gx.enter().insert("g", "a")
          .attr("class", "x")
          .attr("transform", tx);

      if (model.get("gridLines")) {
        gxe.append("line")
            .attr("stroke", stroke)
            .attr("y1", 0)
            .attr("y2", size.height);
      } else {
        gxe.selectAll("line").remove();
      }

      // x-axis units
      if (model.get("xunits")) {
        gxe.append("text")
            .attr("class", "xunits")
            .attr("y", size.height)
            .attr("dy", fontSizeInPixels*0.8 + "px")
            .attr("text-anchor", "middle")
            .text(fx);
      } else {
        gxe.select("text.xunits").remove();
      }

      gx.exit().remove();

      // x-axis label
      xlabel = vis.selectAll("text.xlabel").data(model.get("xlabel") ? [lengthUnits.pluralName] : []);
      xlabel.enter().append("text")
          .attr("class", "axis")
          .attr("class", "xlabel")
          .attr("x", size.width / 2)
          .attr("y", size.height)
          .attr("dy", (fontSizeInPixels * 1.6) + "px")
          .style("text-anchor", "middle");
      xlabel.text(String);
      xlabel.exit().remove();

      // Regenerate y-ticks
      var gy = gridContainer.selectAll("g.y")
          .data(model2pxInv.ticks(5), String)
          .attr("transform", ty)
          .classed("axes", true);

      gy.select("text")
          .text(fy);

      var gye = gy.enter().insert("g", "a")
          .attr("class", "y")
          .attr("transform", ty)
          .attr("background-fill", "#FFEEB6");

      if (model.get("gridLines")) {
        gye.append("line")
            .attr("stroke", stroke)
            .attr("x1", 0)
            .attr("x2", size.width);
      } else {
        gye.selectAll("line").remove();
      }

      // y-axis units
      if (model.get("yunits")) {
        gye.append("text")
            .attr("class", "yunits")
            .attr("x", "-0.3em")
            .attr("dy", fontSizeInPixels/6 + "px")
            .attr("text-anchor", "end")
            .text(fy);
      } else {
        gxe.select("text.yunits").remove();
      }

      gy.exit().remove();

      // y-axis label
      ylabel = vis.selectAll("text.ylabel").data(model.get("ylabel") ? [lengthUnits.pluralName] : []);
      ylabel.enter().append("text")
          .attr("class", "axis")
          .attr("class", "ylabel")
          .style("text-anchor","middle")
          .attr("transform","translate(" + -fontSizeInPixels * 1.6 + " " + size.height / 2 + ") rotate(-90)");
      ylabel.text(String);
      ylabel.exit().remove();
    }

    // Setup background.
    function setupBackground() {
      // Just set the color.
      plot.attr("fill", model.get("backgroundColor") || "rgba(0, 0, 0, 0)");
    }

    function mousedown() {
      setFocus();
    }

    function setFocus() {
      if (model.get("enableKeyboardHandlers")) {
        node.focus();
      }
    }

    function renderContainer() {
      var viewBox;

      // Update cx, cy, size, viewport and modelSize variables.
      scale();

      // Create container, or update properties if it already exists.
      if (vis === undefined) {
        vis1 = d3.select(node).append("svg")
          .attr({
            'xmlns': 'http://www.w3.org/2000/svg',
            'xmlns:xmlns:xlink': 'http://www.w3.org/1999/xlink', // hack: doubling xmlns: so it doesn't disappear once in the DOM
            overflow: 'hidden'
          });

        vis = vis1.append("g").attr("class", "particle-container-vis");

        plot = vis.append("rect")
            .attr("class", "plot");

        if (model.get("enableKeyboardHandlers")) {
          d3.select(node)
            .attr("tabindex", 0)
            .on("mousedown", mousedown);
        }

        gridContainer = vis.append("g").attr("class", "grid-container");
        // Create and arrange "layers" of the final image (g elements). Note
        // that order of their creation is significant.
        // TODO: containers should be initialized by renderers. It's weird
        // that top-level view defines containers for elements that it's
        // unaware of.
        viewportG = vis.append("svg").attr("class", "viewport");
        brushContainer = vis.append("g").attr("class", "brush-container");

      } else {
        // TODO: ?? what g, why is it here?
        vis.selectAll("g.x").remove();
        vis.selectAll("g.y").remove();
      }

      // Set new dimensions of the top-level SVG container.
      vis1
        .attr({
          width: cx,
          height: cy
        })
        // Update style values too, as otherwise SVG isn't clipped correctly e.g. in Safari.
        .style({
          width: cx + "px",
          height: cy + "px"
        });

      viewBox = model2px(viewport.x) + " " +
                model2pxInv(viewport.y) + " " +
                model2px(viewport.scaledWidth) + " " +
                model2px(viewport.scaledHeight);
      viewportG.attr({
        viewBox: viewBox,
        x: 0,
        y: 0,
        width: model2px(viewport.width),
        height: model2px(viewport.height)
      });

      // Update padding, as it can be changed after rescaling.
      vis
        .attr("transform", "translate(" + padding.left + "," + padding.top + ")");

      // Rescale main plot.
      vis.select("rect.plot")
        .attr({
          width: model2px(viewport.width),
          height: model2px(viewport.height),
          x: 0,
          y: 0
        });

      redrawGridLinesAndLabels();
    }

    // Support viewport dragging behavior.
    function viewportDragging() {
      var xs = [],
          ys = [],
          ts = [],
          samples = 8,
          newDrag = false,
          dragOpt = model.properties.viewPortDrag || false,
          vx, vy, t,
          dragBehavior;

      if (dragOpt === false) {
        // This causes that drag behavior will be removed and dragging of
        // other nodes will work again. It's based on the d3 implementation,
        // please see drag() function here:
        // https://github.com/mbostock/d3/blob/master/src/behavior/drag.js
        vis1.on("mousedown.drag", null)
            .on("touchstart.drag", null)
            .classed("draggable", false);
        return;
      }

      dragBehavior = d3.behavior.drag();
      dragBehavior.on("dragstart", function () {
        newDrag = true;
        xs.length = 0;
        ys.length = 0;
        ts.length = 0;
        updateArrays();
      }).on("drag", function () {
        var dx = dragOpt === "y" ? 0 : model2px.invert(d3.event.dx),
            dy = dragOpt === "x" ? 0 : model2px.invert(d3.event.dy);
        model.properties.viewPortX -= dx;
        model.properties.viewPortY += dy;
        dispatch.viewportDrag();
        updateArrays();
      }).on("dragend", function () {
        updateArrays();
        var last = xs.length - 1,
            dt = ts[last] - ts[0];
        // Prevent from division by 0.
        if (dt < 1e-5) return;
        // When time difference between last 'drag' and 'dragend' events is
        // bigger than 100ms assume that there should be no interia (it means
        // that pointer was staying in one place > 100ms just before 'mouseup').
        if (ts[last] - ts[last - 1] > 100) return;
        vx = (xs[last] - xs[0]) / dt;
        vy = (ys[last] - ys[0]) / dt;
        t  = ts[last];
        newDrag = false;
        d3.timer(step);
      });

      vis1.call(dragBehavior).classed("draggable", true);

      function updateArrays() {
        xs.push(model.properties.viewPortX);
        ys.push(model.properties.viewPortY);
        ts.push(performance.now());
        if(xs.length > samples) {
          xs.shift();
          ys.shift();
          ts.shift();
        }
      }

      function step() {
        if (newDrag) return true;

        var now = performance.now(),
            dt = now - t,
            ax = -0.003 * vx,
            ay = -0.003 * vy;

        // Update positions.
        model.properties.viewPortX += vx * dt + 0.5 * ax * dt * dt;
        model.properties.viewPortY += vy * dt + 0.5 * ay * dt * dt;
        dispatch.viewportDrag();
        // Update velocities.
        vx += ax * dt;
        vy += ay * dt;
        // Update last time.
        t = now;

        if (Math.abs(vx) < 1e-5 && Math.abs(vy) < 1e-5) {
          return true;
        }
        return false;
      }
    }

    function removeClickHandlers() {
      var selector;
      for (selector in clickHandler) {
        if (clickHandler.hasOwnProperty(selector)) {
          vis.selectAll(selector).on("click.custom", null);
        }
      }
    }

    function init() {
      // Setup model view state.
      renderContainer();
      viewportDragging();

      clickHandler = {};

      // Register listeners.
      // Redraw container each time when some visual-related property is changed.
      model.addPropertiesListener([ "backgroundColor"], api.repaint);
      model.addPropertiesListener(["gridLines", "xunits", "yunits", "xlabel", "ylabel",
                                   "viewPortX", "viewPortY", "viewPortZoom"],
                                   renderContainer);
      model.addPropertiesListener(["viewPortDrag"],
                                   viewportDragging);
    }

    api = {
      get $el() {
        return $el;
      },
      get node() {
        return node;
      },
      get svg() {
        return vis1;
      },
      get vis() {
        return vis;
      },
      get viewport() {
        return viewportG;
      },
      get model2px() {
        return model2px;
      },
      get model2pxInv() {
        return model2pxInv;
      },
      get setFocus() {
        return setFocus;
      },
      get getFontSizeInPixels() {
        return getFontSizeInPixels;
      },
      get url() {
        return modelUrl;
      },

      repaint: function() {
        setupBackground();
        api.updateClickHandlers();

        if (renderer.repaint) renderer.repaint();
      },
      resize: function() {
        renderContainer();
        api.repaint();

        if (selectBrush) {
          brushContainer.select("g.select-area").call(selectBrush);
        }

        if (renderer.resize) renderer.resize();
      },

      setup: function() {
        if (renderer.setup) renderer.setup();
      },

      update: function() {
        if (renderer.update) renderer.update();
      },

      getHeightForWidth: function (width) {
        var aspectRatio = viewport.width / viewport.height;
        width = width - padding.left  - padding.right;
        return width / aspectRatio + padding.top + padding.bottom;
      },

      bindModel: function(newModel, newModelUrl) {
        modelUrl = newModelUrl || modelUrl;
        model = newModel || model;
        removeClickHandlers();
        api.setSelectHandler(null);
        init();

        if (renderer.bindModel) renderer.bindModel(newModel, newModelUrl);

        api.repaint();
      },

      pos: function() {
        // Add a pos() function so the model renderer can more easily
        // manipulate absolutely positioned dom elements it may create or
        // manage.
        var rect = {
              bottom: 0,
              top:    0,
              height: 0,
              left:   0,
              right:  0,
              width:  0
            };
        if ($el) {
          rect.top = $el.position().top;
          rect.left = $el.position().left;
          rect.width = $el.width();
          rect.height = $el.height();
          rect.bottom = rect.top + rect.height;
          rect.right = rect.left + rect.width;
        }
        return rect;
      },
      on: function(type, listener) {
        dispatch.on(type, listener);
      },
      /**
       * Sets custom click handler.
       *
       * @param {string}   selector Selector string defining clickable objects.
       * @param {Function} handler  Custom click handler. It will be called
       *                            when object is clicked with (x, y, d, i) arguments:
       *                              x - x coordinate in model units,
       *                              y - y coordinate in model units,
       *                              d - data associated with a given object (can be undefined!),
       *                              i - ID of clicked object (usually its value makes sense if d is defined).
       */
      setClickHandler: function (selector, handler) {
        if (typeof handler !== "function") {
          throw new Error("Click handler should be a function.");
        }
        clickHandler[selector] = handler;
        api.updateClickHandlers();
      },
      /**
       * Applies all custom click handlers to objects matching selector
       * Note that this function should be called each time when possibly
       * clickable object is added or repainted!
       */
      updateClickHandlers: function () {
        var selector;

        function getClickHandler (handler) {
          return function (d, i) {
            // Get current coordinates relative to the plot area!
            var coords = d3.mouse(plot.node()),
                x = model2px.invert(coords[0]),
                y = model2pxInv.invert(coords[1]);
            console.log("[view] click at (" + x.toFixed(3) + ", " + y.toFixed(3) + ")");
            handler(x, y, d, i);
          };
        }

        for (selector in clickHandler) {
          if (clickHandler.hasOwnProperty(selector)) {
            // Use 'custom' namespace to don't overwrite other click handlers which
            // can be added by default.
            vis.selectAll(selector).on("click.custom", getClickHandler(clickHandler[selector]));
          }
        }
      },
      /**
       * Sets custom select handler. When you provide function as a handler, select action
       * is enabled and the provided handler executed when select action is finished.
       * To disable select action, pass 'null' as an argument.
       *
       * @param {Function} handler Custom select handler. It will be called
       *                           when select action is finished with (x, y, w, h) arguments:
       *                             x - x coordinate of lower left selection corner (in model units),
       *                             y - y coordinate of lower left selection corner (in model units),
       *                             width  - width of selection rectangle (in model units),
       *                             height - height of selection rectangle (in model units).
       *
       *                            Pass 'null' to disable select action.
       */
      setSelectHandler: function (handler) {
        if (typeof handler !== "function" && handler !== null) {
          throw new Error("Select handler should be a function or null.");
        }
        // Remove previous select handler.
        brushContainer.select("g.select-area").remove();
        if (handler === null) {
          // Previous handler removed, so just return.
          selectBrush = null;
          return;
        }
        selectBrush = d3.svg.brush()
          .x(model2px)
          .y(model2pxInv)
          .on("brushend.select", function() {
            var r = selectBrush.extent(),
                x      = r[0][0],
                y      = r[0][1],
                width  = r[1][0] - x,
                height = r[1][1] - y;

            console.log("[view] selection area (" + x.toFixed(3) + ", " +
              y.toFixed(3) + "), width: " + width + ", height: " + height);

            // Call the user defined callback, passing selected area, as
            // rectangle defined by:
            // x, y, width, height
            // where (x, y) defines its lower left corner in model units.
            handler(x, y, width, height);
            // Clear and hide the brush.
            selectBrush.clear();
            // Redraw brush (which is now empty).
            brushContainer.select("g.select-area").call(selectBrush);
          });
        // Add a new "g" to easily remove it while
        // disabling / reseting select action.
        brushContainer.append("g").classed("select-area", true).call(selectBrush);
      }
    };

    // Initialization.
    // jQuery object with model container.
    $el = $("<div>")
      .attr({
        "id": "model-container",
        "class": "container",
        "tabindex": getNextTabIndex
      })
      // Set initial dimensions.
      .css({
        "width": "50px",
        "height": "50px"
      });
    // DOM element.
    node = $el[0];

    init();
    renderer = new Renderer(api);
    renderer.bindModel(model);

    return api;
  };
});


/*
Simple module which provides context menu for amino acids. It allows
to dynamically change type of amino acids in a convenient way.
It uses jQuery.contextMenu plug-in.

CSS style definition: sass/lab/_context-menu.sass
*/


(function() {

  define('cs!md2d/views/aminoacid-context-menu',['require','cs!md2d/models/aminoacids-helper'],function(require) {
    var HYDROPHILIC_CAT_CLASS, HYDROPHILIC_CLASS, HYDROPHOBIC_CAT_CLASS, HYDROPHOBIC_CLASS, MARKED_CLASS, MENU_CLASS, NEG_CHARGE_CLASS, POS_CHARGE_CLASS, aminoacids, showCategory;
    aminoacids = require('cs!md2d/models/aminoacids-helper');
    MENU_CLASS = "aminoacids-menu";
    HYDROPHOBIC_CLASS = "hydrophobic";
    HYDROPHOBIC_CAT_CLASS = "hydrophobic-category";
    HYDROPHILIC_CLASS = "hydrophilic";
    HYDROPHILIC_CAT_CLASS = "hydrophilic-category";
    POS_CHARGE_CLASS = "pos-charge";
    NEG_CHARGE_CLASS = "neg-charge";
    MARKED_CLASS = "marked";
    showCategory = function(type, animate) {
      var func;
      func = {
        show: animate ? "slideDown" : "show",
        hide: animate ? "slideUp" : "hide"
      };
      if (type === "hydrophobic") {
        $("." + HYDROPHOBIC_CLASS)[func.show]();
        $("." + HYDROPHILIC_CLASS)[func.hide]();
        $("." + HYDROPHOBIC_CAT_CLASS).addClass("expanded");
        return $("." + HYDROPHILIC_CAT_CLASS).removeClass("expanded");
      } else {
        $("." + HYDROPHOBIC_CLASS)[func.hide]();
        $("." + HYDROPHILIC_CLASS)[func.show]();
        $("." + HYDROPHOBIC_CAT_CLASS).removeClass("expanded");
        return $("." + HYDROPHILIC_CAT_CLASS).addClass("expanded");
      }
    };
    return {
      /*
        Register context menu for DOM elements defined by @selector.
        @model, @view are associated model and view, used to set
        properties and redraw view.
      */

      register: function(model, view, selector) {
        $.contextMenu("destroy", selector);
        $.contextMenu({
          selector: selector,
          appendTo: "#responsive-content",
          className: MENU_CLASS,
          animation: {
            show: "show",
            hide: "hide"
          },
          callback: function(key, options) {
            var elemId, marked, props;
            props = d3.select(options.$trigger[0]).datum();
            marked = aminoacids.getAminoAcidByElement(props.element).abbreviation;
            options.items[marked].$node.removeClass(MARKED_CLASS);
            elemId = aminoacids.abbrToElement(key);
            model.setAtomProperties(props.idx, {
              element: elemId
            });
            return view.repaint();
          },
          position: function(opt, x, y) {
            var $win, bottom, height, offset, right, triggerIsFixed, width;
            $win = $(window);
            if (!x && !y) {
              opt.determinePosition.call(this, opt.$menu);
              return;
            } else if (x === "maintain" && y === "maintain") {
              offset = opt.$menu.position();
            } else {
              triggerIsFixed = opt.$trigger.parents().andSelf().filter(function() {
                return $(this).css('position') === "fixed";
              }).length;
              if (triggerIsFixed) {
                y -= $win.scrollTop();
                x -= $win.scrollLeft();
              }
              offset = {
                top: y,
                left: x
              };
            }
            bottom = $win.scrollTop() + $win.height();
            right = $win.scrollLeft() + $win.width();
            /*
                    !!! Workaround for the correct positioning:
                    Use scrollHeight / scrollWidth as these functions return correct height / width
                    in contrast to opt.$menu.height() / opt.$menu.width().
            */

            height = opt.$menu[0].scrollHeight;
            width = opt.$menu[0].scrollWidth;
            if (offset.top + height > bottom) {
              offset.top -= height;
            }
            if (offset.left + width > right) {
              offset.left -= width;
            }
            offset.left += 1;
            return opt.$menu.css(offset);
          },
          events: {
            show: function(options) {
              var $node, key, props;
              props = d3.select(options.$trigger[0]).datum();
              key = aminoacids.getAminoAcidByElement(props.element).abbreviation;
              $node = options.items[key].$node;
              $node.addClass(MARKED_CLASS);
              if ($node.hasClass(HYDROPHOBIC_CLASS)) {
                showCategory("hydrophobic");
              } else {
                showCategory("hydrophilic");
              }
              return true;
            },
            hide: function(options) {
              var key, props;
              props = d3.select(options.$trigger[0]).datum();
              key = aminoacids.getAminoAcidByElement(props.element).abbreviation;
              options.items[key].$node.removeClass(MARKED_CLASS);
              return true;
            }
          },
          items: {
            "Hydrophobic": {
              name: "Hydrophobic",
              className: "" + HYDROPHOBIC_CAT_CLASS,
              callback: function() {
                showCategory("hydrophobic", true);
                return false;
              }
            },
            "Gly": {
              name: "Glycine",
              className: "" + HYDROPHOBIC_CLASS
            },
            "Ala": {
              name: "Alanine",
              className: "" + HYDROPHOBIC_CLASS
            },
            "Val": {
              name: "Valine",
              className: "" + HYDROPHOBIC_CLASS
            },
            "Leu": {
              name: "Leucine",
              className: "" + HYDROPHOBIC_CLASS
            },
            "Ile": {
              name: "Isoleucine",
              className: "" + HYDROPHOBIC_CLASS
            },
            "Phe": {
              name: "Phenylalanine",
              className: "" + HYDROPHOBIC_CLASS
            },
            "Pro": {
              name: "Proline",
              className: "" + HYDROPHOBIC_CLASS
            },
            "Trp": {
              name: "Tryptophan",
              className: "" + HYDROPHOBIC_CLASS
            },
            "Met": {
              name: "Methionine",
              className: "" + HYDROPHOBIC_CLASS
            },
            "Cys": {
              name: "Cysteine",
              className: "" + HYDROPHOBIC_CLASS
            },
            "Tyr": {
              name: "Tyrosine",
              className: "" + HYDROPHOBIC_CLASS
            },
            "Hydrophilic": {
              name: "Hydrophilic",
              className: "" + HYDROPHILIC_CAT_CLASS,
              callback: function() {
                showCategory("hydrophilic", true);
                return false;
              }
            },
            "Asn": {
              name: "Asparagine",
              className: "" + HYDROPHILIC_CLASS
            },
            "Gln": {
              name: "Glutamine",
              className: "" + HYDROPHILIC_CLASS
            },
            "Ser": {
              name: "Serine",
              className: "" + HYDROPHILIC_CLASS
            },
            "Thr": {
              name: "Threonine",
              className: "" + HYDROPHILIC_CLASS
            },
            "Asp": {
              name: "Asparticacid",
              className: "" + HYDROPHILIC_CLASS + " " + NEG_CHARGE_CLASS
            },
            "Glu": {
              name: "Glutamicacid",
              className: "" + HYDROPHILIC_CLASS + " " + NEG_CHARGE_CLASS
            },
            "Lys": {
              name: "Lysine",
              className: "" + HYDROPHILIC_CLASS + " " + POS_CHARGE_CLASS
            },
            "Arg": {
              name: "Arginine",
              className: "" + HYDROPHILIC_CLASS + " " + POS_CHARGE_CLASS
            },
            "His": {
              name: "Histidine",
              className: "" + HYDROPHILIC_CLASS + " " + POS_CHARGE_CLASS
            }
          }
        });
        return showCategory("hydrophobic");
      }
    };
  });

}).call(this);

/*global define, d3 */

define('md2d/views/genetic-elements-renderer',['require','md2d/views/nucleotides'],function (require) {
  var nucleotides          = require('md2d/views/nucleotides'),

      SCALE = 0.007,
      W = {
        "CELLS": 720,
        "DNA1": 661,
        "DNA2": 720,
        "DNA3": 337.4,
        "POLY_UNDER": 426.15,
        "POLY_OVER": 402.525,
        "NUCLEUS": 729.45,
        "RIBO_TOP": 550.7,
        "RIBO_BOTTOM": 509.031,
        "RIBO_UNDER": 550.55,
        "RIBO_OVER": 550.7,
        "TRNA": 117.325,
        "TRNA_NECK": 15.925
      },
      H = {
        "CELLS": 500,
        "DNA1": 550,
        "DNA2": 414.263,
        "DNA3": 89.824,
        "POLY_UNDER": 368.6,
        "POLY_OVER": 368.6,
        "NUCLEUS": 543.199,
        "RIBO_TOP": 250,
        "RIBO_BOTTOM": 147.15,
        "RIBO_UNDER": 311.6,
        "RIBO_OVER": 311.6,
        "TRNA": 67.9,
        "TRNA_NECK": 21.14,
        "A": 31.15
      },

      OBJECT_NAMES = [
        "background",
        "cells", "dna1", "dna2", "dna3",
        "polymeraseUnder", "polymeraseOver",
        "polymeraseUnder", "polymeraseOver",
        "dna", "dnaComp", "mrna", "nucleus",
        "ribosomeBottom", "ribosomeTop",
        "ribosomeUnder", "ribosomeOver",
        "trna", "viewPort"
      ];

  (function () {
    var name;
    for (name in W) {
      if (W.hasOwnProperty(name)) {
        W[name] *= SCALE;
      }
    }
    for (name in H) {
      if (H.hasOwnProperty(name)) {
        H[name] *= SCALE;
      }
    }
  }());

  function getDefs(parent) {
    var defs = parent.select("defs");
    if (defs.empty()) {
      defs = parent.append("defs");
    }
    return defs;
  }

  function appendTranscriptionBg(parent) {
    var defs = getDefs(parent),
        gradient;

    if (defs.select("#transcription-bg").empty()) {
      gradient = defs.append("linearGradient")
        .attr("id", "transcription-bg")
        .attr("x1", "0%")
        .attr("y1", "0%")
        .attr("x2", "0%")
        .attr("y2", "100%");
      gradient.append("stop")
        .attr("stop-color", "#C8DD69")
        .attr("offset", "0%");
      gradient.append("stop")
        .attr("stop-color", "#778B3D")
        .attr("offset", "100%");
    }
  }

  function GeneticElementsRenderer(svg, model2px, model2pxInv, model) {

    function scaleFunc(d) {
      return "scale(" + d.scale + ")";
    }
    function opacityFunc(d) {
      return d.opacity;
    }
    function translateFuncInv(d) {
      var x = d.translateX || 0,
          y = d.translateY || 0;
      return "translate(" + model2px(x) + " " + model2pxInv(y) + ")";
    }
    function translateScaleFuncInv(d) {
      return translateFuncInv(d) + " " + scaleFunc(d);
    }
    // Returns optimal (minimal) boundaries of the DNA or mRNA view array.
    // They are based on the current vieport position, size and knowledge
    // about single nucleotide size.
    function getOptBoundaries(dna) {
      var shift = dna ? model.geneticEngine().PRECODING_LEN : 0,
          lowIdx = Math.floor(model.properties.viewPortX / nucleotides.WIDTH) - 2,
          highIdx = Math.ceil((model.properties.viewPortX + model.properties.viewPortWidth) / nucleotides.WIDTH) + 4;
      return [Math.max(0, lowIdx + shift), highIdx + shift];
    }

    return {
      cells: function (parent, data) {
        var cells = parent.select(".background-layer").selectAll(".cells").data(data.cells);
        cells.enter().append("image").attr({
          "class": "cells",
          "x": model2px(W.CELLS * -0.567),
          "y": model2px(H.CELLS * -0.445),
          "width": model2px(W.CELLS),
          "height": model2px(H.CELLS),
          "preserveAspectRatio": "none",
          "xlink:href": "resources/dna/Cells.svg",
          "transform": translateScaleFuncInv
        }).style("opacity", opacityFunc);
        d3.transition(cells)
          .attr("transform", translateScaleFuncInv)
          .style("opacity", opacityFunc);
        d3.transition(cells.exit()).remove();
      },

      dna1: function (parent, data) {
        var dna1 = parent.select(".dna-layer").selectAll(".dna1").data(data.dna1);
        dna1.enter().append("image").attr({
          "class": "dna1",
          "x": model2px(W.DNA1 * -0.5),
          "y": model2px(H.DNA1 * -0.5),
          "width": model2px(W.DNA1),
          "height": model2px(H.DNA1),
          "preserveAspectRatio": "none",
          "xlink:href": "resources/dna/DNA_InsideNucleus_1.svg",
          "transform": translateScaleFuncInv
        }).style("opacity", opacityFunc);
        d3.transition(dna1)
          .attr("transform", translateScaleFuncInv)
          .style("opacity", opacityFunc);
        d3.transition(dna1.exit()).remove();
      },

      dna2: function (parent, data) {
        var dna2 = parent.select(".dna-layer").selectAll(".dna2").data(data.dna2);
        dna2.enter().append("image").attr({
          "class": "dna2",
          "x": model2px(W.DNA2 * -0.5),
          "y": model2px(H.DNA2 * -0.404),
          "width": model2px(W.DNA2),
          "height": model2px(H.DNA2),
          "preserveAspectRatio": "none",
          "xlink:href": "resources/dna/DNA_InsideNucleus_2.svg",
          "transform": translateScaleFuncInv
        }).style("opacity", opacityFunc);
        d3.transition(dna2)
          .attr("transform", translateScaleFuncInv)
          .style("opacity", opacityFunc);
        d3.transition(dna2.exit()).remove();
      },

      dna3: function (parent, data) {
        var dna3units = 14,
            dna3, dna3Enter;
        dna3 = parent.select(".dna-layer").selectAll(".dna3").data(data.dna3);
        dna3Enter = dna3.enter().append("g").attr({
          "class": "dna3 main-dna",
          "transform": translateScaleFuncInv
        }).style("opacity", opacityFunc);
        dna3Enter.selectAll("dna3-unit").data(new Array(dna3units)).enter().append("image").attr({
          "class": "dna3-unit",
          "x": function (d, i) { return (i - dna3units * 0.5) * model2px(W.DNA3) * 0.98; },
          "y": model2px(H.DNA3 * -0.5),
          "width": model2px(W.DNA3),
          "height": model2px(H.DNA3),
          "preserveAspectRatio": "none",
          "xlink:href": "resources/dna/DoubleHelix_Unit.svg"
        });
        d3.transition(dna3)
          .attr("transform", translateScaleFuncInv)
          .style("opacity", opacityFunc);
        d3.transition(dna3.exit()).remove();
      },

      dna: function (parent, data, enterExitOnly) {
        var viewModel  = model.geneticEngine().viewModel,
            boundaries = getOptBoundaries(true),
            bonds      = data.dna[0] ? data.dna[0].bonds : 0,
            n          = nucleotides(),
            dna        = parent.select(".dna-layer").selectAll(".dna");

        // Configure nucleotides.
        n.model2px(model2px)
         .sequence(viewModel.DNA.slice(boundaries[0], boundaries[1]))
         .glow(model.get("DNAMutations"))
         .bonds(bonds);

        if (enterExitOnly) {
          dna.call(n.enterExitOnly(true));
          return;
        }

        dna = dna.data(data.dna);

        // DNA enter:
        dna.enter().append("g").attr({
          "class": "dna",
          "transform": translateFuncInv
        });
        // DNA update:
        dna.call(n);
        d3.transition(dna).attr("transform", translateFuncInv);
        // DNA exit:
        d3.transition(dna.exit()).remove();
      },

      dnaComp: function (parent, data, enterExitOnly) {
        var viewModel  = model.geneticEngine().viewModel,
            boundaries = getOptBoundaries(true),
            bonds      = data.dnaComp[0] ? data.dnaComp[0].bonds : 0,
            n          = nucleotides(),
            dnaComp    = parent.select(".dna-layer").selectAll(".dna-comp");

        // Configure nucleotides.
        n.model2px(model2px)
         .sequence(viewModel.DNAComp.slice(boundaries[0], boundaries[1]))
         .direction(2)
         .glow(model.get("DNAMutations"))
         .bonds(bonds);

        if (enterExitOnly) {
          dnaComp.call(n.enterExitOnly(true));
          return;
        }

        dnaComp = dnaComp.data(data.dnaComp);

        // DNA Comp enter:
        dnaComp.enter().append("g").attr({
          "class": "dna-comp",
          "transform": translateFuncInv
        });
        // DNA Comp update:
        dnaComp.call(n);
        d3.transition(dnaComp).attr("transform", translateFuncInv);
        // DNA Comp exit:
        d3.transition(dnaComp.exit()).remove();
      },

      mrna: function (parent, data, enterExitOnly) {
        var geneticEngine = model.geneticEngine(),
            mrnaSequence  = geneticEngine.viewModel.mRNA,
            boundaries    = getOptBoundaries(),
            stopCodons    = geneticEngine.stopCodonsHash(),
            bonds         = data.mrna[0] ? data.mrna[0].bonds : 0,
            dir           = data.mrna[0] ? data.mrna[0].direction : 1,
            n             = nucleotides(),
            mrna          = parent.select(".dna-layer").selectAll(".mrna");

        // Configure nucleotides.
        n.model2px(model2px)
         .sequence(mrnaSequence.slice(boundaries[0], boundaries[1]))
         .backbone("RNA")
         .direction(dir)
         .bonds(bonds)
         .stopCodonsHash(stopCodons);

        if (enterExitOnly) {
          mrna.call(n.enterExitOnly(true));
          return;
        }

        mrna = mrna.data(data.mrna);

        // mRNA enter:
        mrna.enter().append("g").attr({
          "class": "mrna",
          "transform": translateFuncInv
        });
        // mRNA update:
        mrna.call(n);
        d3.transition(mrna).attr("transform", translateFuncInv);
        // mRNA exit:
        d3.transition(mrna.exit()).remove();
      },

      polymeraseUnder: function (parent, data) {
        var polyUnder = parent.select(".under-dna-layer").selectAll(".polymerase-under").data(data.polymeraseUnder);
        polyUnder.enter().append("image").attr({
          "class": "polymerase-under",
          "x": model2px(W.POLY_UNDER * -0.5),
          "y": model2px(H.POLY_UNDER * -0.5),
          "width": model2px(W.POLY_UNDER),
          "height": model2px(H.POLY_UNDER),
          "preserveAspectRatio": "none",
          "xlink:href": "resources/dna/Polymerase_Under.svg",
          "transform": translateScaleFuncInv
        }).style("opacity", opacityFunc);
        d3.transition(polyUnder)
          .attr("transform", translateScaleFuncInv)
          .style("opacity", opacityFunc);
        d3.transition(polyUnder.exit()).remove();
      },

      polymeraseOver: function (parent, data) {
        var polyOver = parent.select(".over-dna-layer").selectAll(".polymerase-over").data(data.polymeraseOver);
        polyOver.enter().append("image").attr({
          "class": "polymerase-over",
          "x": model2px(W.POLY_OVER * -0.5),
          "y": model2px(H.POLY_OVER * -0.5),
          "width": model2px(W.POLY_OVER),
          "height": model2px(H.POLY_OVER),
          "preserveAspectRatio": "none",
          "xlink:href": "resources/dna/Polymerase_Over.svg",
          "transform": translateScaleFuncInv
        }).style("opacity", opacityFunc);
        d3.transition(polyOver)
          .attr("transform", translateScaleFuncInv)
          .style("opacity", opacityFunc);
        d3.transition(polyOver.exit()).remove();
      },

      nucleus: function (parent, data) {
        var nucleus = parent.select(".background-layer").selectAll(".nucleus").data(data.nucleus);
        nucleus.enter().append("image").attr({
          "class": "nucleus",
          "x": model2px(W.NUCLEUS * -0.5),
          "y": model2px(H.NUCLEUS * -0.5),
          "width": model2px(W.NUCLEUS),
          "height": model2px(H.NUCLEUS),
          "preserveAspectRatio": "none",
          "xlink:href": "resources/dna/BG_Nucleus.svg",
          "transform": translateFuncInv
        }).style("opacity", opacityFunc);
        d3.transition(nucleus)
          .attr("transform", translateFuncInv)
          .style("opacity", opacityFunc);
        d3.transition(nucleus.exit()).remove();
      },

      ribosomeBottom: function (parent, data) {
        var selection = parent.select(".over-dna-layer").selectAll(".ribosome-bottom").data(data.ribosomeBottom);
        selection.enter().append("image").attr({
          "class": "ribosome-bottom",
          "x": model2px(W.RIBO_BOTTOM * -0.5),
          "y": model2px(H.RIBO_BOTTOM * -0.5),
          "width": model2px(W.RIBO_BOTTOM),
          "height": model2px(H.RIBO_BOTTOM),
          "preserveAspectRatio": "none",
          "xlink:href": "resources/dna/Ribosome_bottom1.svg",
          "transform": translateFuncInv
        }).style("opacity", 0);
        d3.transition(selection)
          .attr("transform", translateFuncInv)
          .style("opacity", opacityFunc);
        d3.transition(selection.exit())
          .style("opacity", 0)
          .remove();
      },

      ribosomeTop: function (parent, data) {
        var selection = parent.select(".over-dna-layer").selectAll(".ribosome-top").data(data.ribosomeTop);
        selection.enter().append("image").attr({
          "class": "ribosome-top",
          "x": model2px(W.RIBO_TOP * -0.5),
          "y": model2px(H.RIBO_TOP * -0.5),
          "width": model2px(W.RIBO_TOP),
          "height": model2px(H.RIBO_TOP),
          "preserveAspectRatio": "none",
          "xlink:href": "resources/dna/Ribosome_top1.svg",
          "transform": translateFuncInv
        }).style("opacity", 0);
        d3.transition(selection)
          .attr("transform", translateFuncInv)
          .style("opacity", opacityFunc);
        d3.transition(selection.exit())
          .style("opacity", 0)
          .remove();
      },

      ribosomeUnder: function (parent, data) {
        var selection = parent.select(".under-dna-layer").selectAll(".ribosome-under").data(data.ribosomeUnder);
        selection.enter().append("image").attr({
          "class": "ribosome-under",
          "x": model2px(W.RIBO_UNDER * -0.5),
          "y": model2px(H.RIBO_UNDER * -0.5),
          "width": model2px(W.RIBO_UNDER),
          "height": model2px(H.RIBO_UNDER),
          "preserveAspectRatio": "none",
          "xlink:href": "resources/dna/Ribosome_under.png",
          "transform": translateFuncInv
        }).style({
          "opacity": opacityFunc
        });
        d3.transition(selection)
          .attr("transform", translateFuncInv)
          .style("opacity", opacityFunc);
        d3.transition(selection.exit()).remove();
      },

      ribosomeOver: function (parent, data) {
        var selection = parent.select(".over-dna-layer").selectAll(".ribosome-over").data(data.ribosomeOver);
        selection.enter().append("image").attr({
          "class": "ribosome-over",
          "x": model2px(W.RIBO_OVER * -0.5),
          "y": model2px(H.RIBO_OVER * -0.5),
          "width": model2px(W.RIBO_OVER),
          "height": model2px(H.RIBO_OVER),
          "preserveAspectRatio": "none",
          "xlink:href": "resources/dna/Ribosome_over.png",
          "transform": translateFuncInv
        }).style("opacity", opacityFunc);
        d3.transition(selection)
          .attr("transform", translateFuncInv)
          .style("opacity", opacityFunc);
        d3.transition(selection.exit()).remove();
      },

      trna: function (parent, data) {
        var geneticEngine = model.geneticEngine(),

            codonWidth = 3 * nucleotides.WIDTH,
            offset = (codonWidth - W.TRNA) * 0.55,

            selection, enter, update, exit;

        selection = parent.select(".top-layer").selectAll(".trna")
                      .data(data.trna, function (d) { return d.index; });
        // The most outer container can be used to set easily position offset.
        // While the inner g elements provides translation for "ideal" tRNA position
        // close to the mRNA and optional rotation.
        enter = selection.enter().append("g").attr({
          "class": "trna",
          "display": function (d) { return d.index < 0 ? "none" : "inline"; },
          "transform": function (d, i) {
            return "translate(" + model2px(nucleotides.HEIGHT * 2) + ", " + model2px(-2.78) + ") " +
                    translateFuncInv(d, i) + " rotate(30)";
          }
        }).style("opacity", opacityFunc);

        enter.append("g")
          .attr("transform", "translate(0, " + model2px(-H.A) + ")")
          .call(nucleotides()
                  .model2px(model2px)
                  .sequence(function (d) { return geneticEngine.codonComplement(d.index); })
                  .backbone(false)
                  .randomEnter(false));

        enter.append("image").attr({
          "class": "trna-neck",
          "x": model2px(0.52 * (codonWidth - W.TRNA_NECK)),
          "y": model2px(-H.TRNA_NECK -H.TRNA * 0.95 - H.A * 0.92),
          "width": model2px(W.TRNA_NECK),
          "height": model2px(H.TRNA_NECK),
          "preserveAspectRatio": "none",
          "xlink:href": "resources/dna/tRNA_neck.png"
        });
        enter.append("image").attr({
          "class": "trna-base",
          "x": model2px(offset),
          "y": model2px(-H.TRNA - H.A * 0.92),
          "width": model2px(W.TRNA),
          "height": model2px(H.TRNA),
          "preserveAspectRatio": "none",
          "xlink:href": "resources/dna/tRNA_base.png"
        });

        update = d3.transition(selection)
          .attr("transform", translateFuncInv)
          .style("opacity", opacityFunc);
        update.select(".trna-neck").style("opacity", function (d) { return d.neck; });

        exit = d3.transition(selection.exit())
          .attr("transform", function (d, i) {
            return "translate(" + model2px(nucleotides.HEIGHT * -5) + ", " + model2px(nucleotides.HEIGHT * -4) + ") " +
                    translateFuncInv(d, i) + " rotate(-30)";
          })
          .style("opacity", 0);
        exit.selectAll(".bonds").style("opacity", 0);
        exit.remove();
      },

      viewPort: function (parent, data) {
        var position = data.viewPort[0].position,
            ease     = data.viewPort[0].ease,
            drag     = data.viewPort[0].drag,
            viewport = d3.transition(svg.select(".viewport"));

        // This is a bit hacky. In fact we use d3 transitions to modify model,
        // not the SVG element! It could be implemented also as a MD2D modeler
        // transition (see atom transitions), but this approach fits well our
        // needs and we reuse a lot of nice d3.transition features. We could
        // also consider removing atom transitions completely and use similar
        // approach for them. As this is just one exception, leave it for now,
        // but in the future it could be useful to chose only one approach
        // (d3.transitions vs custom transitions handled by MD2D modeler).

        // Update dragging behavior. Limit dragging to X axis.
        model.set("viewPortDrag", drag ? "x" : false);
        // Duck test whether viewportUpdate is a transition or selection.
        // See D3 API Reference - d3.transition(selection) returns transition
        // only when called in the context of other transition. Otherwise it
        // returns selection.
        if (viewport.duration) {
          // Transition!
          viewport.ease(ease);
          viewport.tween("model-update", function () {
            var i = d3.interpolate(Number(model.properties.viewPortX), position * nucleotides.WIDTH);
            return function (t) {
              var newVal = i(t);
              if (Math.abs(model.properties.viewPortX - newVal) > 1e-3) {
                model.properties.viewPortX = newVal;
              }
            };
          });
        } else {
          // Selection! Immediate update of the model.
          model.set("viewPortX", position * nucleotides.WIDTH);
        }
      },

      background: function (parent, data) {
        appendTranscriptionBg(parent);
        d3.transition(svg.select(".plot")).attr("fill", data.background[0].color);
      }
    };
  }

  GeneticElementsRenderer.W = W;
  GeneticElementsRenderer.H = H;
  GeneticElementsRenderer.OBJECT_NAMES = OBJECT_NAMES;

  return GeneticElementsRenderer;
});

/*global define, $ */

define('common/views/state-manager',[],function () {
  return function StateManager(names) {
    var api,
        states = [],
        stateByName = {};

    api = {
      newState: function (stateName, stateDef) {
        var state = $.extend(true, {}, stateDef);
        names.forEach(function (n) {
          if (typeof state[n] === "undefined") {
            state[n] = [];
          }
        });
        states.push(state);
        stateByName[stateName] = state;
      },
      extendLastState: function (stateName, stateDef) {
        var prevState = states[states.length - 1],
            state = {};

        names.forEach(function (n) {
          state[n] = [];
          if (typeof stateDef[n] !== "undefined") {
            // Array expected!
            stateDef[n].forEach(function (objDef, idx) {
              state[n].push($.extend(true, {}, prevState[n][idx], objDef));
            });
          }
        });
        states.push(state);
        stateByName[stateName] = state;
      },
      getState: function (name) {
        var orgState = stateByName[name],
            state = $.extend(true, {}, orgState),
            objName;
        for (objName in state) {
          if (state.hasOwnProperty(objName)) {
            state[objName].forEach(function (d, i) {
              var value;
              for (value in d) {
                if (typeof d[value] === "function") {
                  // Very important - evaluate function from original state
                  // object, not from copy! It can be important where two
                  // functions call each other. It should still work.
                  d[value] = orgState[objName][i][value]();
                }
              }
            });
          }
        }
        return state;
      }
    };
    return api;
  };
});

/*global define */

define('md2d/views/genetic-anim-states',['require','md2d/views/nucleotides','md2d/views/genetic-elements-renderer','common/views/state-manager'],function (require) {
  var nucleotides             = require('md2d/views/nucleotides'),
      GeneticElementsRenderer = require('md2d/views/genetic-elements-renderer'),
      StateManager            = require('common/views/state-manager'),

      H = GeneticElementsRenderer.H,
      OBJECT_NAMES = GeneticElementsRenderer.OBJECT_NAMES;

  /**
   * Returns StateManager with definitions of DNA / genetic animations states.
   */
  return function geneticAnimStates(model) {
    var stateMgr       = new StateManager(OBJECT_NAMES),
        geneticEngine  = model.geneticEngine(),
        // Viewport dimensions are immutable, so save them once.
        viewPortWidth  = model.get("viewPortWidth"),
        viewPortHeight = model.get("viewPortHeight"),
        vx = viewPortWidth * 0.5,
        vy = viewPortHeight * 0.5,

        lastStep;

    function getStep() {
      var state = geneticEngine.state();
      if (state.name === "translation-end") {
        return model.geneticEngine().lastTranslationStep();
      }
      lastStep = !isNaN(state.step) ? state.step : lastStep;
      return lastStep;
    }
    function ribosomeX() {
      return (1.65 + Math.max(0, getStep() - 2) * 3) * nucleotides.WIDTH;
    }
    function trnaX() {
      return this.index() * 3 * nucleotides.WIDTH;
    }

    stateMgr.newState("intro-cells", {
      cells: [{
        translateX: vx + 0.33,
        translateY: vy,
        scale: 1
      }],
      dna1: [{
        translateX: vx + 0.33,
        translateY: vy,
        scale: 0.13,
        opacity: 0
      }],
      viewPort: [{
        position: 0,
        ease: "cubic-in-out",
        drag: false
      }],
      background: [{
        color: "#8492ef"
      }]
    });
    stateMgr.extendLastState("intro-zoom1", {
      cells: [{
        translateX: vx,
        scale: 6
      }],
      dna1: [{
        translateX: vx,
        scale: 0.78,
        opacity: 5
      }],
      dna2: [{
        translateX: vx,
        translateY: vy,
        scale: 0.5,
        opacity: 0
      }],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("intro-zoom2", {
      cells: [{
        scale: 24
      }],
      dna1: [{
        scale: 3.12,
        opacity: 0
      }],
      dna2: [{
        scale: 2,
        opacity: 1
      }],
      dna3: [{
        translateX: vx,
        translateY: vy,
        scale: 0.2,
        opacity: 0
      }],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("intro-zoom3-s0", {
      cells: [{}],
      dna2: [{
        scale: 3.8,
        opacity: 0
      }],
      dna3: [{
        scale: 0.4,
        opacity: 1
      }],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("intro-zoom3", {
      cells: [{}],
      dna3: [{
        scale: 0.6
      }],
      polymeraseUnder: [{
        scale: 0.2,
        translateX: -2,
        translateY: 4,
        opacity: 1
      }],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("intro-polymerase-s0", {
      cells: [{}],
      dna3: [{}],
      polymeraseUnder: [{
        scale: 0.8,
        translateX: vx,
        translateY: vy,
        opacity: 1
      }],
      polymeraseOver: [{
        translateX: vx,
        translateY: vy,
        scale: 0.8,
        opacity: 0
      }],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("intro-polymerase", {
      cells: [{}],
      dna3: [{}],
      polymeraseUnder: [{
        scale: 1,
      }],
      polymeraseOver: [{
        scale: 1,
        opacity: 1
      }],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("dna-s0", {
      cells: [{
        opacity: 0
      }],
      dna3: [{
        scale: 1.5
      }],
      polymeraseUnder: [{
        scale: 2.5
      }],
      polymeraseOver: [{
        scale: 2.5
      }],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("dna", {
      polymeraseUnder: [{
        opacity: 0
      }],
      polymeraseOver: [{
        opacity: 0
      }],
      dna3: [{
        opacity: 0
      }],
      dna: [{
        translateX: -model.geneticEngine().PRECODING_LEN * nucleotides.WIDTH,
        translateY: viewPortHeight / 2 + nucleotides.HEIGHT,
        bonds: 1
      }],
      dnaComp: [{
        translateX: -model.geneticEngine().PRECODING_LEN * nucleotides.WIDTH,
        translateY: viewPortHeight / 2 - nucleotides.HEIGHT,
        bonds: 1
      }],
      viewPort: [{
        position: -2,
        drag: true
      }],
      background: [{
        color: "url(#transcription-bg)"
      }]
    });
    stateMgr.extendLastState("transcription", {
      dna: [{
        translateY: viewPortHeight / 2 + 2.5 * nucleotides.HEIGHT,
        bonds: 0
      }],
      dnaComp: [{
        translateY: viewPortHeight / 2 - 2.5 * nucleotides.HEIGHT,
        bonds: function () {
          var limit = getStep() + model.geneticEngine().PRECODING_LEN;
          return function (d) {
            return d.region === "c" && d.idx < limit ? 1 : 0;
          };
        }
      }],
      mrna: [{
        translateY: viewPortHeight / 2 - 0.5 * nucleotides.HEIGHT,
        bonds: 1,
        direction: 1
      }],
      viewPort: [{
        position: function () {
          return Math.max(0, Math.min(model.get("DNA").length - 10, getStep() - 6)) - 2;
        },
        ease: "linear"
      }],
      background: [{}]
    });
    stateMgr.extendLastState("transcription-end", {
      dna: [{}],
      dnaComp: [{
        bonds: function () {
          return function (d) {
            return d.region === "c" ? 1 : 0;
          };
        }
      }],
      mrna: [{}],
      polymeraseUnder: [{
        translateX: function () { return model.get("DNA").length * nucleotides.WIDTH; },
        translateY: 0.5 * viewPortHeight,
        scale: 3.5,
        opacity: 0
      }],
      polymeraseOver: [{
        translateX: function () { return model.get("DNA").length * nucleotides.WIDTH; },
        translateY: 0.5 * viewPortHeight,
        scale: 3.5,
        opacity: 0
      }],
      viewPort: [{
        position: function () { return Math.max(0, model.get("DNA").length - 10) - 2; }
      }],
      background: [{}]
    });
    stateMgr.extendLastState("after-transcription", {
      dna: [{}],
      dnaComp: [{}],
      mrna: [{}],
      polymeraseUnder: [{
        opacity: 1
      }],
      polymeraseOver: [{
        opacity: 1
      }],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("before-translation-s0", {
      dna: [{}],
      dnaComp: [{}],
      mrna: [{}],
      polymeraseUnder: [{
        scale: 1.4
      }],
      polymeraseOver: [{
        scale: 1.4,
        opacity: 0
      }],
      viewPort: [{}],
      background: [{
        color: "#8492ef"
      }]
    });
    stateMgr.extendLastState("before-translation-s1", {
      dna: [{}],
      dnaComp: [{}],
      mrna: [{}],
      polymeraseUnder: [{
        translateX: function () { return model.get("viewPortX") + 0.5 * viewPortWidth + 5; }, // + 5!
        translateY: 0.5 * viewPortHeight - 2,
        scale: 0.7
      }],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("before-translation-s2", {
      dna: [{}],
      dnaComp: [{}],
      mrna: [{}],
      nucleus: [{
        translateX: 0.5 * viewPortWidth - 2 * nucleotides.WIDTH,
        translateY: 0.5 * viewPortHeight
      }],
      viewPort: [{
        position: -2,
        ease: "cubic-in-out"
      }],
      background: [{}]
    });
    stateMgr.extendLastState("before-translation-s3", {
      dna: [{
        translateY: 4 * nucleotides.HEIGHT
      }],
      dnaComp: [{
        translateY: 2 * nucleotides.HEIGHT,
        bonds: 0
      }],
      mrna: [{
        bonds: 0
      }],
      nucleus: [{
        translateY: 0
      }],
      viewPort: [{}],
      background: [{
        color: function() { return model.get("backgroundColor"); }
      }]
    });
    stateMgr.extendLastState("before-translation-s4", {
      dna: [{
        translateY: -1 * nucleotides.HEIGHT
      }],
      dnaComp: [{
        translateY: -3 * nucleotides.HEIGHT,
      }],
      mrna: [{
        translateY: 2.5 * nucleotides.HEIGHT
      }],
      nucleus: [{
        translateY: H.NUCLEUS * -0.5
      }],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("before-translation", {
      mrna: [{
        translateY: 1.5 * nucleotides.HEIGHT,
        direction: 2,
        bonds: 0
      }],
      ribosomeBottom: [{
        translateX: -3,
        translateY: vy,
        opacity: 0
      }],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("translation-s0", {
      mrna: [{}],
      ribosomeBottom: [{
        translateX: ribosomeX,
        translateY: 1.75 * nucleotides.HEIGHT,
        opacity: 1
      }],
      ribosomeTop: [{
        translateX: -3,
        translateY: 6,
        opacity: 0
      }],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("translation-s1", {
      mrna: [{}],
      ribosomeBottom: [{}],
      ribosomeTop: [{
        translateX: ribosomeX,
        translateY: 4.52 * nucleotides.HEIGHT,
        opacity: 1
      }],
      ribosomeUnder: [{
        translateX: ribosomeX,
        translateY: 3.7 * nucleotides.HEIGHT,
        opacity: 0
      }],
      ribosomeOver: [{
        translateX: ribosomeX,
        translateY: 3.7 * nucleotides.HEIGHT,
        opacity: 0
      }],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("translation", {
      mrna: [{
        bonds: function () {
          var step = getStep();
          return function (d) {
            return d.idx < 3 * (step - 2) || d.idx >= 3 * step ? 0 : 1;
          };
        }
      }],
      ribosomeUnder: [{
        opacity: 1
      }],
      ribosomeOver: [{
        opacity: 1
      }],
      trna: [
        {
          index: function () { return getStep() - 2; },
          translateX: trnaX,
          translateY: 2.5 * nucleotides.HEIGHT,
          neck: 0
        },
        {
          index: function () { return getStep() - 1; },
          translateX: trnaX,
          translateY: 2.5 * nucleotides.HEIGHT,
          neck: 1
        }
      ],
      viewPort: [{
        position: function () { return Math.max(0, 3 * (getStep() - 3)) - 2; },
        ease: "linear"
      }],
      background: [{}]
    });
    stateMgr.extendLastState("translation-step0", {
      mrna: [{
        bonds: function () {
          var step = getStep();
          return function (d) {
            return d.idx < 3 * (step - 3) || d.idx >= 3 * step ? 0 : 1;
          };
        }
      }],
      ribosomeUnder: [{}],
      ribosomeOver: [{}],
      trna: [
        {
          index: function () { return getStep() - 3; },
        },
        {
          index: function () { return getStep() - 2; },
        },
        {
          index: function () { return getStep() - 1; },
          translateX: trnaX,
          translateY: 2.5 * nucleotides.HEIGHT,
          neck: 1
        }
      ],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("translation-step1", {
      mrna: [{}],
      ribosomeUnder: [{}],
      ribosomeOver: [{}],
      trna: [
        {},
        {
          neck: 0
        },
        {}
      ],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("translation-end-s0", {
      mrna: [{}],
      ribosomeUnder: [{}],
      ribosomeOver: [{}],
      trna: [
        {
          index: function () { return getStep() - 2; }
        },
        {
          index: function () { return getStep() - 1; },
          neck: 0
        }
      ],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("translation-end-s1", {
      mrna: [{
        bonds: function () {
          var step = getStep();
          return function (d) {
            return d.idx < 3 * (step - 1) || d.idx >= 3 * step ? 0 : 1;
          };
        }
      }],
      ribosomeUnder: [{}],
      ribosomeOver: [{}],
      trna: [{
        index: function () { return getStep() - 1; },
      }],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("translation-end-s2", {
      mrna: [{
        bonds: 0
      }],
      ribosomeUnder: [{}],
      ribosomeOver: [{}],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("translation-end-s3", {
      mrna: [{}],
      ribosomeBottom: [{
        translateX: ribosomeX,
        translateY: 1.75 * nucleotides.HEIGHT,
        opacity: 1
      }],
      ribosomeTop: [{
        translateX: ribosomeX,
        translateY: 4.52 * nucleotides.HEIGHT,
        opacity: 1
      }],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("translation-end-s4", {
      mrna: [{}],
      ribosomeBottom: [{
        translateY: 1.75 * nucleotides.HEIGHT - 0.3,
      }],
      ribosomeTop: [{
        translateY: 4.52 * nucleotides.HEIGHT + 0.5,
      }],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("translation-end-s5", {
      mrna: [{}],
      ribosomeBottom: [{
        translateX: function () { return ribosomeX() + 8; },
        translateY: 1.75 * nucleotides.HEIGHT - 0.5,
      }],
      ribosomeTop: [{
        translateX: function () { return ribosomeX() + 8; },
        translateY: 4.52 * nucleotides.HEIGHT + 5,
      }],
      viewPort: [{}],
      background: [{}]
    });
    stateMgr.extendLastState("translation-end", {
      mrna: [{}],
      viewPort: [{}],
      background: [{}]
    });

    return stateMgr;
  };
});


/*
Simple module which provides mutations context menu for DNA nucleotides.

CSS style definition: sass/lab/_context-menu.sass
*/


(function() {
  var __hasProp = {}.hasOwnProperty;

  define('cs!md2d/views/mutations-context-menu',['require'],function(require) {
    return {
      /*
        Registers context menu for DOM elements defined by @selector.
        @model should be an instance of Modeler class (MD2D Modeler).
        @DNAComplement indicates whether this menu is registered for
        DNA or DNA complementary strand.
      */

      register: function(selector, model, DNAComplement) {
        var clickedNucleoType, onMenuHide, onMenuShow;
        clickedNucleoType = null;
        onMenuShow = function(options) {
          var item, key, subsItems;
          clickedNucleoType = d3.select(options.$trigger[0]).datum().type;
          subsItems = options.items["Substitution"].items;
          for (key in subsItems) {
            if (!__hasProp.call(subsItems, key)) continue;
            item = subsItems[key];
            key = key.split(":")[1];
            item.$node.addClass("" + clickedNucleoType + "-to-" + key);
          }
          d3.select(options.$trigger[0]).classed("glowing", true);
          return true;
        };
        onMenuHide = function(options) {
          var item, key, subsItems;
          subsItems = options.items["Substitution"].items;
          for (key in subsItems) {
            if (!__hasProp.call(subsItems, key)) continue;
            item = subsItems[key];
            key = key.split(":")[1];
            item.$node.removeClass("" + clickedNucleoType + "-to-" + key);
          }
          d3.select(options.$trigger[0]).classed("glowing", false);
          return true;
        };
        $.contextMenu("destroy", selector);
        $.contextMenu({
          selector: selector,
          appendTo: "#responsive-content",
          className: "mutations-menu",
          trigger: "left",
          events: {
            show: onMenuShow,
            hide: onMenuHide
          },
          callback: function(key, options) {
            var d;
            key = key.split(":");
            d = d3.select(options.$trigger[0]).datum();
            switch (key[0]) {
              case "substitute":
                return model.geneticEngine().mutate(d.idx, key[1], DNAComplement);
              case "insert":
                return model.geneticEngine().insert(d.idx, key[1], DNAComplement);
              case "delete":
                return model.geneticEngine()["delete"](d.idx);
            }
          },
          items: {
            "Substitution": {
              name: "Substitution mutation",
              className: "substitution-submenu",
              items: {
                "substitute:A": {
                  name: ""
                },
                "substitute:T": {
                  name: ""
                },
                "substitute:G": {
                  name: ""
                },
                "substitute:C": {
                  name: ""
                }
              }
            },
            "Insertion": {
              name: "Insertion mutation",
              className: "insertion-submenu",
              items: {
                "insert:A": {
                  name: "Insert",
                  className: "A"
                },
                "insert:T": {
                  name: "Insert",
                  className: "T"
                },
                "insert:G": {
                  name: "Insert",
                  className: "G"
                },
                "insert:C": {
                  name: "Insert",
                  className: "C"
                }
              }
            },
            "delete": {
              name: "Deletion mutation"
            }
          }
        });
      }
    };
  });

}).call(this);

/*global define, d3 */

define('md2d/views/genetic-renderer',['require','md2d/views/nucleotides','md2d/views/genetic-elements-renderer','md2d/views/genetic-anim-states','cs!md2d/views/mutations-context-menu'],function (require) {
  var nucleotides             = require('md2d/views/nucleotides'),
      GeneticElementsRenderer = require('md2d/views/genetic-elements-renderer'),
      GeneticAnimStates       = require('md2d/views/genetic-anim-states'),
      mutationsContextMenu    = require('cs!md2d/views/mutations-context-menu'),

      OBJECT_NAMES = GeneticElementsRenderer.OBJECT_NAMES;

  function GeneticRenderer(modelView, model) {
    var api,
        svg = modelView.svg,
        model2px = modelView.model2px,
        model2pxInv = modelView.model2pxInv,
        viewportG = svg.select(".viewport"),

        g = null,
        currentTrans = null,
        state = null,
        prevAnimState = null,
        prevAnimStep = null,
        suppressViewport = false,
        transitionInProgress = false,
        animStateInProgress = null,

        stateMgr = new GeneticAnimStates(model),
        objectRenderer = new GeneticElementsRenderer(svg, model2px, model2pxInv, model),

        transitionFunction;

    function init() {
      // Redraw DNA / mRNA when DNA state is changed.
      model.geneticEngine().on("change", render);
      // Play animation when there is a "transition" event.
      model.geneticEngine().on("transition", transition);

      // When DNAMutations is changed, cleanup & render again.
      model.addPropertiesListener(["DNAMutations"], setup);

      // When viewPortX is changed render DNA and mRNA again. Also center
      // protein while in 'translation-end' state.
      model.addPropertiesListener(["viewPortX"], function() {
        if (!g || !model.get("DNA")) return;

        // state.name values are subset of all animation states. We define
        // more animation states than we publish for author / users
        // (animations with -s0, -s1, (...) suffixes).
        var data = stateMgr.getState(animStateInProgress || state.name);

        objectRenderer.mrna(g, data, true);
        objectRenderer.dna(g, data, true);
        objectRenderer.dnaComp(g, data, true);

        if (!transitionInProgress &&
            state.name === "translation-end" &&
            model.getNumberOfAtoms() > 0) {
          model.geneticEngine().centerProtein();
        }
      });

      // Register mutation menus for DNA and DNA complement. Note that
      // jQuery.contextMenu uses event delegation, so it's fully enough to
      // register this menu only once, even before these elements exists.
      mutationsContextMenu.register('[class~="dna"] [class~="clickable-nucleo"]', model, false);
      mutationsContextMenu.register('[class~="dna-comp"] [class~="clickable-nucleo"]', model, true);
    }

    /**
     * Setups genetic renderer. It will be called when new parent view is created
     * or reseted.
     *
     * @private
     */
    function setup() {
      state = model.geneticEngine().state();

      // Cleanup.
      cancelTransitions();
      viewportG.selectAll("g.genetics").remove();
      g = null;

      if (!model.get("DNA")) {
        // When DNA is not defined (=== "", undefined or null) genetic
        // renderer has nothing to do.
        return;
      }

      // Create a new container.
      g = viewportG.insert("g", ".image-container-below").attr("class", "genetics");
      g.append("g").attr("class", "background-layer");
      g.append("g").attr("class", "under-dna-layer");
      g.append("g").attr("class", "dna-layer");
      g.append("g").attr("class", "over-dna-layer");
      g.append("g").attr("class", "top-layer");

      render();
    }

    /**
     * Renders DNA-related graphics using "DNA" and "DNAState"
     * options of the model.
     */
    function render(suppressViewportUpdate) {
      suppressViewport = suppressViewportUpdate;

      // Update DNA state.
      state = model.geneticEngine().state();

      cancelTransitions();

      // Force rendering of all objects when render was called before previous
      // transition ended. This means that we can be somewhere between states
      // and it's impossible to detect which objects should be rendered using
      // previous and current animation state.
      renderState(g, state.name, null, transitionInProgress);

      transitionInProgress = false;
    }

    /**
     * Renders animation state. It updates all objects from previous and new state.
     *
     * You can pass d3.selection or d3.transition as "parent" argument to decide whether
     * new state should be rendered immediately or using transition.
     *
     * @private
     * @param {d3.selection OR d3.transition} parent d3.selection or d3.transition object.
     * @param {String} animState  animation state name.
     * @param {function} onStartCallback callback executed at the beginning of transition
     *                                   or immediately if parent isn't a transition (optional).
     * @param {boolean} forceAll forces re-rendering of all scene objects (optional).
     */
    function renderState(parent, animState, onStartCallback, forceAll) {
      var data = stateMgr.getState(animState),
          prevAnimStateData = prevAnimState ? stateMgr.getState(prevAnimState) : null;

      // TODO: make it simpler.
      function shouldRenderObj(name) {
        var inData     = !!data[name].length,
            inPrevData = !!(prevAnimStateData && prevAnimStateData[name].length);

        if (suppressViewport && name === "viewPort") {
          // Viewport update can be disabled using special variable.
          return false;
        } else if (forceAll || inData || inPrevData) {
          // Render all objects from current and previous states.
          return true;
        }
        return false;
      }

      function render() {
        parent.each(function() {
          var parent = d3.select(this);
          OBJECT_NAMES.forEach(function (name) {
            if (shouldRenderObj(name)) {
              objectRenderer[name](parent, data);
            }
          });
        });
        if (onStartCallback) onStartCallback(parent);
      }

      if (parent.duration) {
        // Transition.
        parent.each("start.transition-name", function () {
          animStateInProgress = animState;
          render();
        });
        parent.each("end.transition-name", function () {
          animStateInProgress = null;
        });
      } else {
        render();
      }

      prevAnimState = animState;
      prevAnimStep = state.step || 0; // when undefined or NaN
    }

    /**
     * Returns a new, chained transition.
     * This transition will be executed when previous one ends.
     *
     * @private
     * @return {d3 transtion} d3 transtion object.
     */
    function nextTrans() {
      var newTrans;
      // TODO: this first check is a workaround.
      // Ideal scenario would be to call always:
      // currentTrans[name] = currentTrans[name].transition();
      // but it seems to fail when transition has already ended.
      if (currentTrans && currentTrans.node().__transition__) {
        // Some transition is currently in progress, chain a new transition.
        newTrans = currentTrans.transition();
      } else {
        // All transitions ended, just create a new one.
        newTrans = g.transition();
      }
      currentTrans = newTrans;
      return newTrans;
    }

    /**
     * Trick to cancel all current transitions. It isn't possible explicitly
     * so we have to start new, fake transitions, which will cancel previous
     * ones. Note that some transitions can be applied to elements that live
     * outside g.genetics element, e.g. viewport and background. So, it isn't
     * enough to use d3.selectAll("g.genetics *").
     *
     * @private
     */
    function cancelTransitions() {
      var g = svg.select("g.genetics");
      if (!g.empty() && g.node().__transition__) {
        svg.selectAll("g.genetics, g.genetics *").transition().delay(0);
        svg.select(".plot").transition().delay(0); // background changes
        viewportG.transition().delay(0);           // viewport scrolling
        currentTrans = null;
        animStateInProgress = null;
      }
    }

    /**
     * Triggers animation state transition.
     */
    function transition(transitionName, suppressViewportUpdate) {
      transitionInProgress = true;
      suppressViewport = suppressViewportUpdate;

      // Update DNA state.
      state = model.geneticEngine().state();

      if (Number(transitionName.split(":")[1]) > 0) {
        // e.g. translation:5 or transcription:7
        // We have one common transition function for all "transcription:1" to
        // "transcription:N" transitions called "transcription", as well as
        // one common transition function for all "translation:1" to
        // "translation:N" transitions called "translation".
        transitionName = transitionName.split(":")[0];
      }

      transitionFunction[transitionName]();

      currentTrans.each("end.trans-end", function() {
        transitionInProgress = false;
        // Notify engine that transition has ended.
        model.geneticEngine().transitionEnded();
      });
    }

    /**
     * Definition of all transition functions.
     * @private
     * @type {Object}
     */
    transitionFunction = {
      "dna-updated": function dnaUpdated() {
        // Special state - render current animation state again,
        // as model was updated.
        var t = nextTrans().ease("cubic-in-out").duration(800);
        renderState(t, state.name, null, true);
      },

      "intro-zoom1": function introZoom1() {
        var t = nextTrans().ease("cubic").duration(3000);
        renderState(t, "intro-zoom1");
      },

      "intro-zoom2": function introZoom2() {
        var t = nextTrans().ease("linear").duration(3000);
        renderState(t, "intro-zoom2");
      },

      "intro-zoom3": function introZoom3() {
        var t = nextTrans().ease("linear").duration(2000);
        renderState(t, "intro-zoom3-s0");

        t = nextTrans().ease("quad-out").duration(3300);
        renderState(t, "intro-zoom3");
      },

      "intro-polymerase": function introPolymerase() {
        var t = nextTrans().ease("quad-out").duration(3000);
        renderState(t, "intro-polymerase-s0");

        t = nextTrans().ease("cubic-in-out").duration(1000);
        renderState(t, "intro-polymerase");
      },

      "dna": function dna() {
        var t = nextTrans().duration(2000);
        renderState(t, "dna-s0");


        t = nextTrans().duration(1000);
        renderState(t, "dna", function (t) {
          // Make some transitions almost immediate.
          t.selectAll(".nucleotide").duration(5);
          t.selectAll(".plot").duration(5);
        });
      },

      "transcription:0": function transcription0() {
        var t = nextTrans().duration(1500);
        renderState(t, "transcription", function(t) {
          // Reselect bonds transition, change duration to 250.
          t.selectAll(".bonds").duration(250);
        });
      },

      "transcription": function transcription() {
        var t = nextTrans().duration(500);
        renderState(t, "transcription", function (t) {
          // Reselect bonds transition, change duration to ease to cubic.
          t.selectAll(".bonds").ease("cubic");
        });
      },

      "transcription-end": function transcriptionEnd() {
        var t = nextTrans().duration(500);
        renderState(t, "transcription-end", function (t) {
          // Reselect bonds transition, change duration to ease to cubic.
          t.selectAll(".bonds").ease("cubic");
        });
      },

      "after-transcription": function afterTranscription() {
        var t = nextTrans().ease("cubic-in-out").duration(700);
        renderState(t, "after-transcription");
      },

      "before-translation": function beforeTranslation() {
        var t = nextTrans().ease("cubic-in-out").duration(1000);
        renderState(t, "before-translation-s0", function (t) {
          t.selectAll(".plot").duration(1);
        });

        t = nextTrans().ease("cubic-in-out").duration(1500);
        renderState(t, "before-translation-s1");

        t = nextTrans().ease("cubic-in-out").duration(1500);
        renderState(t, "before-translation-s2");

        t = nextTrans().ease("cubic").duration(1000);
        renderState(t, "before-translation-s3", function (t) {
          t.selectAll(".bonds").duration(250);
          t.selectAll(".plot").duration(1);
        });

        t = nextTrans().ease("cubic-out").duration(1000);
        renderState(t, "before-translation-s4");

        t = nextTrans().ease("cubic-out").duration(500);
        renderState(t, "before-translation");
      },

      "translation:0": function translation0() {
        var t = nextTrans().ease("cubic-in-out").duration(1000);
        renderState(t, "translation-s0");

        t = nextTrans().ease("cubic-in-out").duration(1000);
        renderState(t, "translation-s1");

        t = nextTrans().ease("cubic-in-out").duration(500);
        renderState(t, "translation");
      },

      "translation": function translation() {
        var geneticEngine = model.geneticEngine(),
            codonIdx = state.step - 1,
            newAADuration = 1000,
            shiftDuration = 500,
            t;

        t = nextTrans().duration(newAADuration);
        renderState(t, "translation-step0", function (t) {
          t.selectAll(".bonds").ease("cubic");
          geneticEngine.translationStepStarted(codonIdx, 1.45 + codonIdx * 3 * nucleotides.WIDTH, 3.95,
              0.53 + codonIdx * 3 * nucleotides.WIDTH, 1.57, newAADuration);
        });

        t = nextTrans().duration(shiftDuration);
        renderState(t, "translation-step1", function (t) {
          t.selectAll(".trna-neck").duration(150);
          geneticEngine.shiftAminoAcids(codonIdx, 2 * nucleotides.WIDTH, shiftDuration);
        });
        t.each("end", function () {
          geneticEngine.connectAminoAcid(codonIdx);
        });

        // This will remove 3rd tRNA.
        if (codonIdx > 0) {
          t = nextTrans().duration(900);
          renderState(t, "translation", function (t) {
            t.selectAll(".bonds").duration(150);
          });
        }
      },

      "translation-end": function translationEnd() {
        var geneticEngine = model.geneticEngine(),
            aaCount = model.getNumberOfAtoms(),
            t;

        if (aaCount >= 1) {
          t = nextTrans().duration(150);
          renderState(t, "translation-end-s0");
          t.each("end.anim", function () {
            geneticEngine.translationCompleted();
          });

          t = nextTrans().duration(800);
          renderState(t, "translation-end-s1", function (t) {
            t.selectAll(".bonds").duration(150);
          });

          t = nextTrans().duration(800);
          renderState(t, "translation-end-s2", function (t) {
            t.selectAll(".bonds").duration(150);
          });
        }

        t = nextTrans().duration(500);
        renderState(t, "translation-end-s3");

        t = nextTrans().duration(300);
        renderState(t, "translation-end-s4");

        t = nextTrans().duration(1000);
        renderState(t, "translation-end-s5");

        t = nextTrans().duration(700);
        renderState(t, "translation-end", function () {
          geneticEngine.centerProtein(700);
        });
      }
    };

    api = {
      setup: setup,
      render: render
    };

    init();
    return api;
  }

  return GeneticRenderer;
});


/*
  A simple function to wrap a string of text into an SVG text node of a given width
  by creating tspans and adding words to them until the computedTextLength of the
  tspan is greater than the desired width. Returns the number of lines.

  If no wrapping is desired, use maxWidth=-1
*/


(function() {

  define('cs!common/layout/wrap-svg-text',['require'],function(require) {
    var svgUrl, wrapSVGText;
    svgUrl = "http://www.w3.org/2000/svg";
    return wrapSVGText = window.wrapSVGText = function(text, svgTextNode, maxWidth, x, dy) {
      var computedTextLength, curLineLength, dashArray, dashes, i, lastWord, line, newlinemode, numLines, result, tempText, textNode, tspanNode, widestWidth, width, word, words, _i, _len;
      dashes = /-/gi;
      if (text.search("\n") > 0) {
        words = text.split("\n");
        newlinemode = true;
        dashArray = [];
      } else {
        words = text.split(/[\s-]/);
        newlinemode = false;
        dashArray = (function() {
          var _results;
          _results = [];
          while (result = dashes.exec(text)) {
            _results.push(result.index);
          }
          return _results;
        })();
      }
      curLineLength = 0;
      computedTextLength = 0;
      numLines = 1;
      widestWidth = 0;
      for (i = _i = 0, _len = words.length; _i < _len; i = ++_i) {
        word = words[i];
        curLineLength += word.length + 1;
        if (i === 0 || newlinemode || maxWidth > 0 && computedTextLength > maxWidth) {
          if (i > 0) {
            if (newlinemode) {
              widestWidth = Math.max(tspanNode.getComputedTextLength(), widestWidth);
              numLines++;
            } else {
              tempText = tspanNode.firstChild.nodeValue;
              if (tempText.length > words[i - 1].length + 1) {
                lastWord = tempText.slice(tempText.length - words[i - 1].length - 1);
                tspanNode.firstChild.nodeValue = tempText.slice(0, tempText.length - words[i - 1].length - 1);
              } else if (tempText.length === words[i - 1].length + 1) {
                tspanNode.firstChild.nodeValue = tempText.slice(0, tempText.length - 1);
              }
              widestWidth = Math.max(tspanNode.getComputedTextLength(), widestWidth);
              numLines++;
            }
          }
          tspanNode = document.createElementNS(svgUrl, "tspan");
          tspanNode.setAttributeNS(null, "x", x);
          tspanNode.setAttributeNS(null, "dy", i === 0 ? 0 : dy);
          textNode = document.createTextNode(line);
          tspanNode.appendChild(textNode);
          svgTextNode.appendChild(tspanNode);
          if (~dashArray.indexOf(curLineLength - 1)) {
            line = word + "-";
          } else {
            line = word + " ";
          }
          if (i && lastWord) {
            line = lastWord + line;
          }
        } else {
          if (~dashArray.indexOf(curLineLength - 1)) {
            line += word + "-";
          } else {
            line += word + " ";
          }
        }
        tspanNode.firstChild.nodeValue = line;
        computedTextLength = tspanNode.getComputedTextLength();
        if (newlinemode) {
          widestWidth = Math.max(tspanNode.getComputedTextLength(), widestWidth);
        }
        if (!newlinemode) {
          if (i && i === words.length - 1 && maxWidth > 0 && computedTextLength > maxWidth) {
            tempText = tspanNode.firstChild.nodeValue;
            tspanNode.firstChild.nodeValue = tempText.slice(0, tempText.length - words[i].length - 1);
            tspanNode = document.createElementNS(svgUrl, "tspan");
            tspanNode.setAttributeNS(null, "x", x);
            tspanNode.setAttributeNS(null, "dy", dy);
            textNode = document.createTextNode(words[i]);
            tspanNode.appendChild(textNode);
            svgTextNode.appendChild(tspanNode);
            numLines++;
          }
        }
      }
      if (widestWidth === 0) {
        widestWidth = svgTextNode.childNodes[0].getComputedTextLength();
      }
      if (maxWidth > widestWidth) {
        width = maxWidth;
      } else {
        width = widestWidth;
      }
      return {
        lines: numLines,
        width: width,
        textWidth: widestWidth
      };
    };
  });

}).call(this);

/*global define: false */

define('common/views/gradients',[],function () {
  return {
    /**
     * Creates a new radial gradient or updates existing one.
     *
     * @param  {[type]} id
     * @param  {[type]} lightColor
     * @param  {[type]} medColor
     * @param  {[type]} darkColor
     * @param  {[type]} container SVG container which will be used to store gradients definitions.
     * @return {string}           Gradient URL string, e.g. "url(#green-gradient)"
     */
    createRadialGradient: function (id, lightColor, medColor, darkColor, container) {
      var gradientUrl,
          defs,
          gradient;
      defs = container.select("defs");
      if (defs.empty()) {
        // Store gradients in 'defs' element.
        defs = container.append("defs");
      }

      gradient = defs.select("#" + id);

      if (gradient.empty()) {
        // Create a new gradient.
        gradient = defs.append("radialGradient")
          .attr("id", id)
          .attr("cx", "50%")
          .attr("cy", "47%")
          .attr("r", "53%")
          .attr("fx", "35%")
          .attr("fy", "30%");
      } else {
        gradient.selectAll("stop").remove()
      }

      gradient.append("stop")
        .attr("stop-color", lightColor)
        .attr("offset", "0%");
      gradient.append("stop")
        .attr("stop-color", medColor)
        .attr("offset", "40%");
      gradient.append("stop")
        .attr("stop-color", darkColor)
        .attr("offset", "80%");
      gradient.append("stop")
        .attr("stop-color", medColor)
        .attr("offset", "100%");

      gradientUrl = "url(#" + id + ")";
      // Store main color (for now - dark color) of the gradient.
      // Useful for radial bonds. Keys are URLs for convenience.
      this.mainColorOfGradient[gradientUrl] = darkColor;
      return gradientUrl;
    },

    /**
     * Hash which defines the main color of a given gradient.
     * Note that for convenience, keys are in forms of URLs (e.g. url(#some-gradient)).
     * e.g. useful for MD2D radial bonds, which can adjust their color to gradient.
     */
    mainColorOfGradient: {}
  };
});

/*global define: false, d3: false */

/**
 * Tiny module providing useful functions for color manipulation.
 */
define('common/views/color',[],function () {

  function parseColor(color) {
    // d3.rgb is handy, however it cannor parse RGBA colors. Use it regexp to
    // parse rgba if it's necessary. Note that alpha channel will be ignored!
    var rgba = color.match(/rgba\(([0-9]+),([0-9]+),([0-9]+),([0-9]+)\)/i);
    if (rgba !== null) {
      return d3.rgb(rgba[1], rgba[2], rgba[3]);
    } else {
      return d3.rgb(color);
    }
  }

  return {
    /**
     * Returns color contrasting to specified background color (black or white).
     * Note that if background color specifies alpha channel (e.g. rgba(0,0,0,0.5)),
     * it will be ignored!
     * @param  {string} bg Web-compatible color definition (e.g. "red", "#ff0012", "#000").
     * @return {string} Contrasting color - "#000" or "#fff".
     */
    contrastingColor: function (bg) {
      bg = parseColor(bg);
      // Calculate luminance in YIQ color space.
      // This ensures that color will be visible on background.
      // This simple algorithm is described here:
      // http://www.w3.org/TR/AERT#color-contrast
      return (bg.r * 299 + bg.g * 587 + bg.b * 114) / 1000 >= 128 ? '#000' : '#fff';
    }
  };
});

/*global $, define: false, d3: false, Image */
// ------------------------------------------------------------
//
//   MD2D View Renderer
//
// ------------------------------------------------------------
define('md2d/views/renderer',['require','lab.config','common/alert','common/console','common/benchmark/benchmark','cs!md2d/views/aminoacid-context-menu','md2d/views/genetic-renderer','cs!common/layout/wrap-svg-text','common/views/gradients','common/views/color'],function (require) {
  // Dependencies.
  var labConfig           = require('lab.config'),
      alert               = require('common/alert'),
      console             = require('common/console'),
      benchmark           = require('common/benchmark/benchmark'),
      amniacidContextMenu = require('cs!md2d/views/aminoacid-context-menu'),
      GeneticRenderer     = require('md2d/views/genetic-renderer'),
      wrapSVGText         = require('cs!common/layout/wrap-svg-text'),
      gradients           = require('common/views/gradients'),
      color               = require('common/views/color'),

      RADIAL_BOND_TYPES = {
        STANDARD_STICK  : 101,
        LONG_SPRING     : 102,
        BOND_SOLID_LINE : 103,
        GHOST           : 104,
        UNICOLOR_STICK  : 105,
        SHORT_SPRING    : 106,
        DOUBLE_BOND     : 107,
        TRIPLE_BOND     : 108,
        DISULPHIDE_BOND : 109
      };

  return function MD2DView(modelView, model) {
        // Public API object to be returned.
    var api = {},

        // The model function getAtoms() returns a 2 dimensional array
        // of particle indices and properties that is updated every model tick.
        // This array is not garbage-collected so the view can be assured that
        // the latest modelAtoms will be in this array when the view is executing
        modelAtoms,
        modelElements,
        modelWidth,
        modelHeight,
        aspectRatio,

        // Basic scaling functions for position, it transforms model units to "pixels".
        // Use it for positions of objects rendered inside the view.
        model2px,

        // Inverted scaling function for position transforming model units to "pixels".
        // Use it for Y coordinates, as Y axis in model coordinate system increases
        // from bottom to top, while but SVG has increases from top to bottom
        model2pxInv,

        // "Containers" - SVG g elements used to position layers of the final visualization.
        fieldVisualization      = modelView.viewport.append("g").attr("class", "field-visualization"),
        rectangleContainerBelow = modelView.viewport.append("g").attr("class", "rectangle-container-below"),
        imageContainerBelow     = modelView.viewport.append("g").attr("class", "image-container-below"),
        textContainerBelow      = modelView.viewport.append("g").attr("class", "text-container-below"),
        radialBondsContainer    = modelView.viewport.append("g").attr("class", "radial-bonds-container"),
        VDWLinesContainer       = modelView.viewport.append("g").attr("class", "vdw-lines-container"),
        mainContainer           = modelView.viewport.append("g").attr("class", "main-container"),
        rectangleContainerTop   = modelView.viewport.append("g").attr("class", "rectangle-container-top"),
        imageContainerTop       = modelView.viewport.append("g").attr("class", "image-container-top"),
        textContainerTop        = modelView.viewport.append("g").attr("class", "text-container-top"),
        iconContainer           = modelView.vis.append("g").attr("class", "icon-container"),

        dragOrigin,

        // Renderers specific for MD2D
        // TODO: for now only DNA is rendered in a separate class, try to create
        // new renderers in separate files for clarity and easier testing.
        geneticRenderer,

        gradientNameForElement = [
          "url(#elem0-grad)",
          "url(#elem1-grad)",
          "url(#elem2-grad)",
          "url(#elem3-grad)"
        ],
        // Set of gradients used for Kinetic Energy Shading.
        gradientNameForKELevel = [],
        // Number of gradients used for Kinetic Energy Shading.
        KE_SHADING_STEPS = 25,
        // Set of gradients used for Charge Energy Shading.
        gradientNameForPositiveChargeLevel = [],
        gradientNameForNegativeChargeLevel = [],
        // Number of gradients used for Charge Shading (for both positive and negative charges).
        CHARGE_SHADING_STEPS = 25,
        // Array which defines a gradient assigned to a given particle.
        gradientNameForParticle = [],

        atomTooltipOn = false,

        particle, label, labelEnter,
        atomToolTip, atomToolTipPre,

        fontSizeInPixels,
        textBoxFontSizeInPixels,

        modelTimeFormatter = d3.format("5.1f"),
        timePrefix = "",
        timeSuffix = "",

        radialBonds,
        radialBondResults,
        obstacle,
        obstacles,
        mockObstaclesArray = [],
        rectangles,
        rectangleTop,
        rectangleBelow,
        mockRectanglesTop= [],
        mockRectanglesBelow = [],
        radialBond1, radialBond2,
        vdwPairs = [],
        vdwLines,
        chargeShadingMode,
        keShadingMode,
        useQuantumDynamics,
        drawVdwLines,
        drawVelocityVectors,
        drawElectricForceField,
        velocityVectorColor,
        velocityVectorWidth,
        velocityVectorLength,
        drawForceVectors,
        forceVectorColor,
        forceVectorWidth,
        forceVectorLength,
        velVector,
        forceVector,
        efVector,
        imageProp,
        imageMapping,
        modelImagePath,
        imageSizes = [],
        textBoxes,
        imagePath,
        drawAtomTrace,
        atomTraceId,
        atomTraceColor,
        atomTrace,
        atomTracePath,

        VELOCITY_STR = "velocity",
        FORCE_STR    = "force",

        browser = benchmark.what_browser(),

        // pre-calculations
        halfPi = Math.PI/2,

        // this is a hack put in place to temporarily deal with a IE 10 bug which
        // does not update line markers when svg lines are moved
        // see https://connect.microsoft.com/IE/feedback/details/781964/
        hideLineMarkers = browser.browser === "MSIE" && browser.version >= "10.0";


    function modelTimeLabel() {
      return timePrefix + modelTimeFormatter(model.get('displayTime')) + timeSuffix;
    }

    function setAtomPosition(i, xpos, ypos, checkPosition, moveMolecule) {
      return model.setAtomProperties(i, {x: xpos, y: ypos}, checkPosition, moveMolecule);
    }

    function getObstacleColor(i) {
      return "rgb(" +
        obstacles.colorR[i] + "," +
        obstacles.colorG[i] + "," +
        obstacles.colorB[i] + ")";
    }

    // Pass in the signed 24-bit Integer used for Java MW elementColors
    // See: https://github.com/mbostock/d3/wiki/Colors
    function createElementColorGradient(id, signedInt, mainContainer) {
      var colorstr = (signedInt + Math.pow(2, 24)).toString(16),
          color,
          medColor,
          lightColor,
          darkColor,
          i;

      for (i = colorstr.length; i < 6; i++) {
        colorstr = String(0) + colorstr;
      }
      color      = d3.rgb("#" + colorstr);
      medColor   = color.toString();
      lightColor = color.brighter(1).toString();
      darkColor  = color.darker(1).toString();
      return gradients.createRadialGradient(id, lightColor, medColor, darkColor, mainContainer);
    }

    /**
     * Setups set of gradient which can be changed by the user.
     * They should be recreated during each reset / repaint operation.
     * @private
     */
    function setupDynamicGradients() {
      var i, color, lightColor, medColor, darkColor;

      for (i= 0; i < 4; i++) {
        // Use names defined in gradientNameForElement array!
        createElementColorGradient("elem" + i + "-grad", modelElements.color[i], mainContainer);
      }

      // "Marked" particle gradient.
      medColor   = model.get("markColor");
      // Mark color defined in JSON defines medium color of a gradient.
      color      = d3.rgb(medColor);
      lightColor = color.brighter(1).toString();
      darkColor  = color.darker(1).toString();
      gradients.createRadialGradient("mark-grad", lightColor, medColor, darkColor, mainContainer);
    }

    /**
     * Creates set of gradient which cannot be changed, they are constant
     * for each possible model. So, it is enough to setup them just once.
     * @private
     */
    function createImmutableGradients() {
          // Scale used for Kinetic Energy Shading gradients.
      var medColorScale = d3.scale.linear()
            .interpolate(d3.interpolateRgb)
            .range(["#F2F2F2", "#FF8080"]),
          // Scale used for Kinetic Energy Shading gradients.
          darkColorScale = d3.scale.linear()
            .interpolate(d3.interpolateRgb)
            .range(["#A4A4A4", "#FF2020"]),
          gradientName,
          gradientUrl,
          KELevel,
          i;

      // Kinetic Energy Shading gradients
      for (i = 0; i < KE_SHADING_STEPS; i++) {
        gradientName = "ke-shading-" + i;
        KELevel = i / KE_SHADING_STEPS;
        gradientUrl = gradients.createRadialGradient(gradientName, "#FFFFFF", medColorScale(KELevel),
          darkColorScale(KELevel), mainContainer);
        gradientNameForKELevel[i] = gradientUrl;
      }

      // Scales used for Charge Shading gradients.
      // Originally Positive:(ffefff,9abeff,767fbf) and Negative:(dfffff,fdadad,e95e5e)

      gradients.createRadialGradient("neutral-grad","#FFFFFF","#f2f2f2","#A4A4A4",mainContainer);

      var posLightColorScale = d3.scale.linear()
        .interpolate(d3.interpolateRgb)
        .range(["#FFFFFF", "#ffefff"]),
      posMedColorScale = d3.scale.linear()
        .interpolate(d3.interpolateRgb)
        .range(["#f2f2f2", "#9090FF"]),
      posDarkColorScale = d3.scale.linear()
        .interpolate(d3.interpolateRgb)
        .range(["#A4A4A4", "#3030FF"]),
      negLightColorScale = d3.scale.linear()
        .interpolate(d3.interpolateRgb)
        .range(["#FFFFFF", "#dfffff"]),
      negMedColorScale = d3.scale.linear()
        .interpolate(d3.interpolateRgb)
        .range(["#f2f2f2", "#FF8080"]),
      negDarkColorScale = d3.scale.linear()
        .interpolate(d3.interpolateRgb)
        .range(["#A4A4A4", "#FF2020"]),
      ChargeLevel;

      // Charge Shading gradients
      for (i = 1; i < CHARGE_SHADING_STEPS; i++) {
        gradientName = "pos-charge-shading-" + i;
        ChargeLevel = i / CHARGE_SHADING_STEPS;
        gradientUrl = gradients.createRadialGradient(gradientName,
          posLightColorScale(ChargeLevel),
          posMedColorScale(ChargeLevel),
            posDarkColorScale(ChargeLevel), mainContainer);
        gradientNameForPositiveChargeLevel[i] = gradientUrl;

        gradientName = "neg-charge-shading-" + i;
        ChargeLevel = i / CHARGE_SHADING_STEPS;
        gradientUrl = gradients.createRadialGradient(gradientName,
          negLightColorScale(ChargeLevel),
          negMedColorScale(ChargeLevel),
            negDarkColorScale(ChargeLevel), mainContainer);
        gradientNameForNegativeChargeLevel[i] = gradientUrl;
      }

      // Colored gradients, used for amino acids.
      gradients.createRadialGradient("green-grad", "#dfffef", "#75a643", "#2a7216", mainContainer);
      gradients.createRadialGradient("orange-grad", "#F0E6D1", "#E0A21B", "#AD7F1C", mainContainer);
    }

    function createVectorArrowHeads(color, name) {
      var defs,
          id = "Triangle-"+name,
          arrowHead;
      defs = mainContainer.select("defs");
      if (defs.empty()) {
        defs = mainContainer.append("defs");
      }
      arrowHead = defs.select("#" + id);
      if (arrowHead.empty()) {
        arrowHead = defs.append("marker")
          .attr("id", "Triangle-"+name)
          .attr("viewBox", "0 0 10 10")
          .attr("refX", "0")
          .attr("refY", "5")
          .attr("markerUnits", "strokeWidth")
          .attr("markerWidth", "4")
          .attr("markerHeight", "3")
          .attr("orient", "auto")
          .attr("stroke", color)
          .attr("fill", color);
        arrowHead.append("path")
            .attr("d", "M 0 0 L 10 5 L 0 10 z");
      }
    }

    function createExcitationGlow() {
      var defs,
          glow;

      defs = mainContainer.select("defs");
      if (defs.empty()) {
        defs = mainContainer.append("defs");
      }
      glow = defs.select("#glow");
      if (glow.empty()) {
        glow = defs.append("filter")
          .attr("id", "glow")
          .attr("x", "-1")
          .attr("y", "-1")
          .attr("width", "400%")
          .attr("height", "400%");
        glow.append("feMorphology")
          .attr("result", "bigger")
          .attr("in", "SourceGraphic")
          .attr("operator", "dilate")
          .attr("radius", "6");
        glow.append("feGaussianBlur")
          .attr("result", "blurOut")
          .attr("in", "bigger")
          .attr("stdDeviation", "10");
        glow.append("feBlend")
          .attr("in", "SourceGraphic")
          .attr("in2", "blurOut")
          .attr("mode", "normal");
      }
    }

    // Returns gradient appropriate for a given atom.
    // d - atom data.
    function getParticleGradient(d) {
        var ke, keIndex, charge, chargeIndex, chargeColor,
          aminoAcidColorScheme = model.get("aminoAcidColorScheme");

        if (d.marked) {
          return "url(#mark-grad)";
        }

        if (keShadingMode) {
          ke  = model.getAtomKineticEnergy(d.idx),
          // Convert Kinetic Energy to [0, 1] range
          // using empirically tested transformations.
          // K.E. shading should be similar to the classic MW K.E. shading.
          keIndex = Math.min(5 * ke, 1);

          return gradientNameForKELevel[Math.round(keIndex * (KE_SHADING_STEPS - 1))];
        }

        if (chargeShadingMode || aminoAcidColorScheme==="charge" || aminoAcidColorScheme==="chargeAndHydro") {
          charge = d.charge;
          chargeIndex = Math.round(Math.min(Math.abs(charge) / 3, 1) * (CHARGE_SHADING_STEPS - 1));
          chargeColor = chargeIndex === 0 ? "url(#neutral-grad)" : (charge >= 0 ? gradientNameForPositiveChargeLevel : gradientNameForNegativeChargeLevel)[chargeIndex];
        }

        if (chargeShadingMode || aminoAcidColorScheme==="charge" || aminoAcidColorScheme==="chargeAndHydro" && chargeIndex !== 0) {
          return chargeColor;
        }

        if (!d.isAminoAcid()) {
          return gradientNameForElement[d.element % 4];
        }
        // Particle represents amino acid.
        // Note that if charge shading were on, the charge color would have been returned above
        switch (aminoAcidColorScheme) {
          case "none":
          case "charge":
            return "url(#neutral-grad)";
          case "hydrophobicity":
          case "chargeAndHydro":
            return d.hydrophobicity > 0 ? "url(#orange-grad)" : "url(#green-grad)";
          default:
            throw new Error("ModelContainer: unknown amino acid color scheme.");
        }
    }

    // Returns first color appropriate for a given radial bond (color next to atom1).
    // d - radial bond data.
    function getBondAtom1Color(d) {
      if (isSpringBond(d)) {
        return "#888";
      } else {
        return gradients.mainColorOfGradient[gradientNameForParticle[d.atom1]];
      }
    }

    // Returns second color appropriate for a given radial bond (color next to atom2).
    // d - radial bond data.
    function getBondAtom2Color(d) {
      if (isSpringBond(d)) {
        return "#888";
      } else {
        return gradients.mainColorOfGradient[gradientNameForParticle[d.atom2]];
      }
    }

    // Create key images which can be shown in the
    // upper left corner in different situations.
    // IMPORTANT: The height attribute must be set,
    // it will allow to properly calculate images
    // placement in drawSymbolImages() function.
    function createSymbolImages() {
      var xMargin = "1%",
          fSize = Math.max(fontSizeInPixels, 12);

      // only add these images if they don't already exist
      if (iconContainer.select("#heat-bath").empty()) {
        // Heat bath key image.
        iconContainer.append("image")
            .attr({
              "id": "heat-bath",
              "x": xMargin,
              "width": fSize*2,
              "height": fSize*2,
              "preserveAspectRatio": "xMinYMin",
              "xlink:href": "resources/upstatement/heatbath.svg",
              "class": "opaque-on-hover"
            })
            .append("title")
            .text("Heatbath active");
      }
      if (iconContainer.select("#ke-gradient").empty()) {
        // Kinetic Energy Shading gradient image.
        iconContainer.append("image")
            .attr({
              "id": "ke-gradient",
              "x": "0",
              "width": fSize*2.2,
              "height": fSize*6,
              "preserveAspectRatio": "xMinYMin",
              "xlink:href": "resources/upstatement/ke-gradient.svg",
              "class": "opaque-on-hover"
            })
            .append("title")
            .text("Kinetic energy gradient");
      }
    }

    // Draw key images in the upper left corner.
    // Place them in one row, dynamically calculate
    // y position.
    function drawSymbolImages() {
        var heatBath = model.get('temperatureControl'),
            imageSelect, imageHeight,
            // Variables used for calculating proper y positions.
            yPos = 0,
            yMargin = 1,
            fSize = Math.max(fontSizeInPixels, 12);

        // Heat bath symbol.
        if (heatBath) {
            yPos += yMargin;
            imageSelect = iconContainer.select("#heat-bath")
              .attr({
                "y": yPos,
                "width": fSize*2,
                "height": fSize*2
              })
              .style("display", "");

            imageHeight = parseInt(imageSelect.attr("height"), 10);
            yPos += imageHeight;
        } else {
            iconContainer.select("#heat-bath").style("display","none");
        }

        // Kinetic Energy shading gradient.
        // Put it under heat bath symbol.
        if (keShadingMode) {
            yPos += yMargin;
            iconContainer.select("#ke-gradient")
              .attr({
                "y": yPos,
                "width": fSize*2.2,
                "height": fSize*6
              })
              .style("display", "");
        } else {
            iconContainer.select("#ke-gradient").style("display", "none");
        }
    }

    function updateParticleRadius() {
      mainContainer.selectAll("circle").data(modelAtoms).attr("r",  function(d) { return model2px(d.radius); });
    }

    /**
      Call this wherever a d3 selection is being used to add circles for atoms
    */

    function particleEnterExit() {
      particle.enter().append("circle")
          .attr({
            "class": function (d) { return d.isAminoAcid() ? "draggable atom amino-acid" : "atom draggable"; },
            "r":  function(d) { return model2px(d.radius); },
            "cx": function(d) { return model2px(d.x); },
            "cy": function(d) { return model2pxInv(d.y); },
            "fill-opacity": function(d) { return d.visible ? 1 : 0; },
            "fill": function (d, i) { return gradientNameForParticle[i]; },
            "filter": function (d) { if (d.excitation) {return "url(#glow)";} return null; }
          })
          .on("mousedown", moleculeMouseDown)
          .on("mouseover", moleculeMouseOver)
          .on("mouseout", moleculeMouseOut)
          .call(d3.behavior.drag()
            .on("dragstart", nodeDragStart)
            .on("drag", nodeDrag)
            .on("dragend", nodeDragEnd)
          );

      particle.exit().remove();
    }

    function vectorEnter(vector, pathFunc, widthFunc, color, name) {
      vector.enter().append("path")
        .attr({
          "class": "vector-"+name,
          "marker-end": hideLineMarkers ? "" : "url(#Triangle-"+name+")",
          "d": pathFunc,
          "stroke-width": widthFunc,
          "stroke": color,
          "fill": "none"
        });
    }

    function atomTraceEnter() {
      atomTrace.enter().append("path")
        .attr({
          "class": "atomTrace",
          "d": getAtomTracePath,
          "stroke-width": model2px(0.01),
          "stroke": atomTraceColor,
          "fill": "none",
          "stroke-dasharray": "6, 6"
        });
    }

    function obstacleEnter() {
      var obstacleGroup = obstacle.enter().append("g");

      obstacleGroup
        .attr("class", "obstacle")
        .attr("transform",
          function (d, i) {
            return "translate(" + model2px(obstacles.x[i]) + " " + model2pxInv(obstacles.y[i] + obstacles.height[i]) + ")";
          }
        );
      obstacleGroup.append("rect")
        .attr({
          "class": "obstacle-shape",
          "x": 0,
          "y": 0,
          "width": function(d, i) {return model2px(obstacles.width[i]); },
          "height": function(d, i) {return model2px(obstacles.height[i]); },
          "fill": function(d, i) { return obstacles.visible[i] ? getObstacleColor(i) : "rgba(128,128,128, 0)"; },
          "stroke-width": function(d, i) { return obstacles.visible[i] ? 0.2 : 0.0; },
          "stroke": function(d, i) { return obstacles.visible[i] ? getObstacleColor(i) : "rgba(128,128,128, 0)"; }
        });

      // Append external force markers.
      obstacleGroup.each(function (d, i) {
        // Fast path, if no forces are defined.
        if (!obstacles.externalAx[i] && !obstacles.externalAy[i])
          return;

        // Note that arrows indicating obstacle external force use
        // the same options for styling like arrows indicating atom force.
        // Only their length is fixed.
        var obstacleGroupEl = d3.select(this),
            obsHeight = obstacles.height[i],
            obsWidth = obstacles.width[i],
            obsAx = obstacles.externalAx[i],
            obsAy = obstacles.externalAy[i],
            // Use fixed length of force vectors (in nm).
            vecLen = 0.06,
            space = 0.06,
            step, coords;

        // Set arrows indicating horizontal force.
        if (obsAx) {
          // Make sure that arrows keep constant distance between both ends of an obstacle.
          step = (obsHeight - 2 * space) / Math.round((obsHeight - 2 * space) / 0.2);
          coords = d3.range(space, obsHeight, step);
          obstacleGroupEl.selectAll("path.obstacle-force-hor").data(coords).enter().append("path")
            .attr({
              "class": "obstacle-force-hor",
              "d": function (d) {
                if (obsAx < 0)
                  return "M " + model2px(obsWidth + vecLen + space) +
                              "," + model2px(d) +
                              " L " + model2px(obsWidth + space) +
                              "," + model2px(d);
                else
                  return "M " + model2px(-vecLen - space) +
                              "," + model2px(d) +
                              " L " + model2px(-space) +
                              "," + model2px(d);
              }
            });
        }
        // Later set arrows indicating vertical force.
        if (obsAy) {
          // Make sure that arrows keep constant distance between both ends of an obstacle.
          step = (obsWidth - 2 * space) / Math.round((obsWidth - 2 * space) / 0.2);
          coords = d3.range(space, obsWidth, step);
          obstacleGroupEl.selectAll("path.obstacle-force-vert").data(coords).enter().append("path")
            .attr({
              "class": "obstacle-force-vert",
              "d": function (d) {
                if (obsAy < 0)
                  return "M " + model2px(d) +
                              "," + model2px(-vecLen - space) +
                              " L " + model2px(d) +
                              "," + model2px(-space);
                else
                  return "M " + model2px(d) +
                              "," + model2px(obsHeight + vecLen + space) +
                              " L " + model2px(d) +
                              "," + model2px(obsHeight + space);
              }
            });
        }
        // Finally, set common attributes and stying for both vertical and horizontal forces.
        obstacleGroupEl.selectAll("path.obstacle-force-hor, path.obstacle-force-vert")
          .attr({
            "marker-end": hideLineMarkers ? "" : "url(#Triangle-"+ FORCE_STR +")",
            "stroke-width": model2px(forceVectorWidth),
            "stroke": forceVectorColor,
            "fill": "none"
          });
      });
    }

    function rectangleEnter() {
      var layers = [rectangleTop, rectangleBelow], i;
      for(i = 0; i < layers.length; i++){
          var rectangleGroup = layers[i].enter().append("g");
        rectangleGroup
          .attr("class", "rectangle")
          .attr("transform",
            function (d) {
              return "translate(" + model2px(rectangles.x[d]) + " " + model2pxInv(rectangles.y[d] + rectangles.height[d]) + ")";
            }
          );
        rectangleGroup.append("rect")
          .attr({
            "class": "rectangle-shape",
            "x": 0,
            "y": 0,
            "width": function(d) {return model2px(rectangles.width[d]); },
            "height": function(d) {return model2px(rectangles.height[d]); },
            "fill": function(d) { return rectangles.visible[d] ? rectangles.color[d] : "rgba(128,128,128, 0)"; },
            "stroke-width": function(d) { return rectangles.lineWeight[d]; },
            "stroke-dasharray": function(d) { return rectangles.lineDashes[d]; },
            "stroke": function(d) { return rectangles.visible[d] ? rectangles.lineColor[d] : "rgba(128,128,128, 0)"; }
          });
       }
    }

    function radialBondEnter() {
      radialBond1.enter().append("path")
          .attr({
            "d": function (d) { return findPoints(d,1); },
            "stroke-width": function (d) {
              if (isSpringBond(d)) {
                return springStrokeWidth(d);
              } else {
                return model2px(Math.min(modelAtoms[d.atom1].radius, modelAtoms[d.atom2].radius)) * 0.75;
              }
            },
            "stroke": getBondAtom1Color,
            "fill": "none"
          })
          .classed("radialbond1", true)
          .classed("disulphideBond", function (d) {
            return d.type === RADIAL_BOND_TYPES.DISULPHIDE_BOND;
          });

      radialBond2.enter().append("path")
          .attr({
            "d": function (d) { return findPoints(d,2); },
            "stroke-width": function (d) {
              if (isSpringBond(d)) {
                return springStrokeWidth(d);
              } else {
                return model2px(Math.min(modelAtoms[d.atom1].radius, modelAtoms[d.atom2].radius)) * 0.75;
              }
            },
            "stroke": getBondAtom2Color,
            "fill": "none"
          })
          .classed("radialbond2", true)
          .classed("disulphideBond", function (d) {
            return d.type === RADIAL_BOND_TYPES.DISULPHIDE_BOND;
          });

    }

    function findPoints(d, num) {
      var pointX, pointY,
          j,
          dx, dy,
          x1, x2,
          y1, y2,
          radius_x1, radius_x2, radiusFactorX,
          radius_y1, radius_y2, radiusFactorY,
          path,
          costheta,
          sintheta,
          length,
          strength,
          numTurns,
          springDiameter,
          cosThetaDiameter,
          sinThetaDiameter,
          cosThetaSpikes,
          sinThetaSpikes;

      x1 = model2px(d.x1);
      y1 = model2pxInv(d.y1);
      x2 = model2px(d.x2);
      y2 = model2pxInv(d.y2);
      dx = x2 - x1;
      dy = y2 - y1;

      strength = d.strength;
      length = Math.sqrt(dx*dx + dy*dy) / model2px(0.01);

      numTurns = Math.floor(d.length * 24);
      springDiameter = length / numTurns;

      costheta = dx / length;
      sintheta = dy / length;
      cosThetaDiameter = costheta * springDiameter;
      sinThetaDiameter = sintheta * springDiameter;
      cosThetaSpikes = costheta * numTurns;
      sinThetaSpikes = sintheta * numTurns;

      radius_x1 = model2px(modelAtoms[d.atom1].radius) * costheta;
      radius_x2 = model2px(modelAtoms[d.atom2].radius) * costheta;
      radius_y1 = model2px(modelAtoms[d.atom1].radius) * sintheta;
      radius_y2 = model2px(modelAtoms[d.atom2].radius) * sintheta;
      radiusFactorX = radius_x1 - radius_x2;
      radiusFactorY = radius_y1 - radius_y2;

      if (isSpringBond(d)) {
        path = "M "+x1+","+y1+" " ;
        for (j = 0; j < numTurns; j++) {
          if (j % 2 === 0) {
            pointX = x1 + (j + 0.5) * cosThetaDiameter - 0.5 * sinThetaSpikes;
            pointY = y1 + (j + 0.5) * sinThetaDiameter + 0.5 * cosThetaSpikes;
          }
          else {
            pointX = x1 + (j + 0.5) * cosThetaDiameter + 0.5 * sinThetaSpikes;
            pointY = y1 + (j + 0.5) * sinThetaDiameter - 0.5 * cosThetaSpikes;
          }
          path += " L "+pointX+","+pointY;
        }
        return path += " L "+x2+","+y2;
      } else {
        if (num === 1) {
          return "M "+x1+","+y1+" L "+((x2+x1+radiusFactorX)/2)+" , "+((y2+y1+radiusFactorY)/2);
        } else {
          return "M "+((x2+x1+radiusFactorX)/2)+" , "+((y2+y1+radiusFactorY)/2)+" L "+x2+","+y2;
        }
      }
    }

    function isSpringBond(d){
      return d.type === RADIAL_BOND_TYPES.SHORT_SPRING;
    }

    function springStrokeWidth() {
      return 1.25;
      // The following code is intended to use a thicker stroke-width when
      // the spring constant is larger ... but to work properly in models with
      // both MD2D and MKS units schemes the model would need to supply
      // an apprpriately scaled default spring constant.
      // For example in the Spring and Mass Interactive which uses an MKS unit
      // scheme the spring constant is varied between 0.001 and 0.003 ... while in
      // the Comparing Dipole atom-pulling Interactive that uses an MD2D unit
      // scheme the spring constant is 10.
      // return (1 + Math.log(1+d.strength*1000)) * 0.25;
    }

    function vdwLinesEnter() {
      var strokeWidth = model2px(0.02),
          strokeDasharray = model2px(0.03) + " " + model2px(0.02);
      // update existing lines
      vdwLines.attr({
        "x1": function(d) { return model2px(modelAtoms[d[0]].x); },
        "y1": function(d) { return model2pxInv(modelAtoms[d[0]].y); },
        "x2": function(d) { return model2px(modelAtoms[d[1]].x); },
        "y2": function(d) { return model2pxInv(modelAtoms[d[1]].y); }
      });

      // append new lines
      vdwLines.enter().append('line')
        .attr({
          "class": "attractionforce",
          "x1": function(d) { return model2px(modelAtoms[d[0]].x); },
          "y1": function(d) { return model2pxInv(modelAtoms[d[0]].y); },
          "x2": function(d) { return model2px(modelAtoms[d[1]].x); },
          "y2": function(d) { return model2pxInv(modelAtoms[d[1]].y); }
        })
        .style({
          "stroke-width": strokeWidth,
          "stroke-dasharray": strokeDasharray
        });

      // remove old lines
      vdwLines.exit().remove();
    }

    function getImagePath(imgProp) {
      return imagePath + (imageMapping[imgProp.imageUri] || imgProp.imageUri);
    }

    function drawImageAttachment() {
      var img = [],
          imglayer,
          container,
          i,
          positionOrder,
          positionOrderTop = [],
          positionOrderBelow = [];

      imageContainerTop.selectAll("image").remove();
      imageContainerBelow.selectAll("image").remove();

      if (!imageProp) return;

      for (i = 0; i < imageProp.length; i++) {
        img[i] = new Image();
        img[i].src = getImagePath(imageProp[i]);
        img[i].onload = (function(i) {
          return function() {
            imglayer = imageProp[i].imageLayer;
            positionOrder = imglayer === 1 ? positionOrderTop : positionOrderBelow;
            positionOrder.push({
              i: i,
              zOrder: (!!imageProp[i].imageLayerPosition) ? imageProp[i].imageLayerPosition : 0
            });
            positionOrder.sort(function(a,b) { return d3.ascending(a["zOrder"],b["zOrder"]); });
            // In Classic MW model size is defined in 0.1A.
            // Model unit (0.1A) - pixel ratio is always 1. The same applies
            // to images. We can assume that their pixel dimensions are
            // in 0.1A also. So convert them to nm (* 0.01).
            imageSizes[i] = [0.01 * img[i].width, 0.01 * img[i].height];
            container = imglayer === 1 ? imageContainerTop : imageContainerBelow;
            container.selectAll("image").remove();
            container.selectAll("image")
              .data(positionOrder, function(d){ return d["i"]; })
              .enter().append("image")
                .attr("x", function(d){ return getImageCoords(d["i"])[0]; } )
                .attr("y", function(d){ return getImageCoords(d["i"])[1]; } )
                .attr("class", function(d){ return "image_attach" + d["i"] + " draggable"; })
                .attr("xlink:href", function(d){ return img[d["i"]].src; })
                .attr("width", function(d){return model2px( imageSizes[d["i"]][0]); })
                .attr("height", function(d){return model2px( imageSizes[d["i"]][1]); })
                .attr("pointer-events", "none");
          };
        })(i);
      }
    }

    function getTextBoxCoords(d) {
      var x, y, hostX, hostY, textX, textY, frameX, frameY, calloutX, calloutY,
          pixelScale = textBoxFontSizeInPixels * d.fontScale;

      x = d.x;
      y = d.y;

      if (d.hostType) {
        if (d.hostType === "Atom") {
          hostX = modelAtoms[d.hostIndex].x;
          hostY = modelAtoms[d.hostIndex].y;
        } else {
          hostX = obstacles.x[d.hostIndex] + (obstacles.width[d.hostIndex] / 2);
          hostY = obstacles.y[d.hostIndex] + (obstacles.height[d.hostIndex] / 2);
        }
      }

      if (d.hostType && !d.calloutPoint) {
        x = hostX;
        y = hostY;
      }

      if (d.calloutPoint) {
        if (!d.hostType) {
          calloutX = d.calloutPoint[0];
          calloutY = d.calloutPoint[1];
        } else {
          calloutX = hostX;
          calloutY = hostY;
        }
      }

      frameX = model2px(x);
      frameY = model2pxInv(y);

      textX = frameX + pixelScale*0.75;
      textY = frameY + pixelScale*1.2;

      calloutX = model2px(calloutX);
      calloutY = model2pxInv(calloutY);

      return [textX, textY, frameX, frameY, calloutX, calloutY];
    }

    function getCalloutPath(location, frame, fullWidth, fullHeight, fontSize) {
      var calloutLocation = [
            parseFloat(location[0]),
            parseFloat(location[1])
          ],
          center = [
            parseFloat(frame.getAttribute("x")) + (fullWidth / 2),
            parseFloat(frame.getAttribute("y")) + (fullHeight / 2)
          ],
          angle = halfPi - Math.atan((calloutLocation[0] - center[0]) / (calloutLocation[1] - center[1])),
          baseSize = Math.min(fontSize, fullHeight/2),

          dcx = Math.sin(angle) * baseSize,
          dcy = Math.cos(angle) * baseSize;

      return (center[0]+dcx) + ", " + (center[1]-dcy) + " " + (center[0]-dcx) + ", " + (center[1]+dcy) + " " + calloutLocation;
    }

    function updateTextBoxes() {
      var layers = [textContainerTop, textContainerBelow],
          updateText;

      updateText = function (layerNum) {
        var layer = layers[layerNum - 1],
            layerTextBoxes = textBoxes.filter(function (t) {
              return t.layer === layerNum;
            });

        layer.selectAll("g.textBoxWrapper rect")
          .data(layerTextBoxes.filter( function(d) { return d.frame; } ))
          .attr({
            "x": function(d) { return getTextBoxCoords(d)[2]; },
            "y": function(d) { return getTextBoxCoords(d)[3]; },
            "transform": function(d) {
              var rotate = d.rotate,
                  pos = getTextBoxCoords(d);
              return "rotate("+rotate+" "+pos[0]+" "+pos[1]+")";
            }
          });

        layer.selectAll("g.textBoxWrapper text")
          .data(layerTextBoxes)
          .attr({
            "y": function(d) {
              $(this).find("tspan").attr("x", getTextBoxCoords(d)[0]);
              return getTextBoxCoords(d)[1];
            }
          });

        layer.selectAll("g.textBoxWrapper polygon")
          .data(layerTextBoxes.filter( function(d) { return d.calloutPoint; } ))
          .attr({
            "callout-location-data": function(d) {
              var pos = getTextBoxCoords(d);
              return pos[4] + ", " + pos[5];
            }
          });
      };

      updateText(1);
      updateText(2);

      // update callouts
      $(".textBox").each( function() {
        var $parentNode = $(this.parentNode),
            callout     = $parentNode.find("polygon"),
            frame       = $parentNode.find("rect")[0],
            fontSize, width, height, calloutLocation;

        if (!frame || callout.length === 0) return;

        fontSize  = parseFloat(this.getAttributeNS(null, "font-size"));
        width  = frame.getAttribute("width");
        height = frame.getAttribute("height");
        calloutLocation = callout.attr("callout-location-data").split(", ");

        callout.attr("points", getCalloutPath(calloutLocation, frame, width, height, fontSize) );
      });
    }

    function drawTextBoxes() {
      var size, layers, appendTextBoxes;

      textBoxes = model.get('textBoxes');

      size = [ model.get('width'), model.get('height') ];

      layers = [textContainerTop, textContainerBelow];

      // Append to either top or bottom layer depending on item's layer #.
      appendTextBoxes = function (layerNum) {
        var layer = layers[layerNum - 1],
            text, layerTextBoxes, selection;

        layer.selectAll("g.textBoxWrapper").remove();

        layerTextBoxes = textBoxes.filter(function(t) { return t.layer === layerNum; });

        selection = layer.selectAll("g.textBoxWrapper")
          .data(layerTextBoxes);
        text = selection.enter().append("svg:g")
          .attr("class", "textBoxWrapper");

        text.filter(function (d) { return d.calloutPoint; })
          .append("polygon")
          .attr({
            "points": "0,0 0,0 0,0",
            "style": function(d) {
              var backgroundColor = d.backgroundColor,
                  strokeWidth = d.strokeWidthEms * fontSizeInPixels,
                  strokeOpacity = d.strokeOpacity;
              return "fill:"+backgroundColor+";opacity:1.0;fill-opacity:1;stroke:#000000;stroke-width:"+(strokeWidth*2)+";stroke-opacity:"+strokeOpacity;
            },
            "callout-location-data": function(d) {
              var pos = getTextBoxCoords(d);
              return pos[4] + ", " + pos[5];
            }
          });

        text.filter(function (d) { return d.frame; })
          .append("rect")
          .attr({
            "class": function(d, i) { return "textBoxFrame text-"+i; },
            "id": function(d, i) { return "text-"+i; },
            "transform": function(d) {
              var rotate = d.rotate,
                  pos = getTextBoxCoords(d);
              return "rotate("+rotate+" "+pos[0]+" "+pos[1]+")";
            },
            "style": function(d) {
              var backgroundColor = d.backgroundColor,
                  strokeWidth = d.strokeWidthEms * fontSizeInPixels,
                  strokeOpacity = d.strokeOpacity;
              return "fill:"+backgroundColor+";opacity:1.0;fill-opacity:1;stroke:#000000;stroke-width:"+strokeWidth+";stroke-opacity:"+strokeOpacity;
            },
            "width": 0,
            "height": 0,
            "rx": function(d) { return d.frame === "rounded rectangle" ? textBoxFontSizeInPixels/2.5  : 0; },
            "ry": function(d) { return d.frame === "rounded rectangle" ? textBoxFontSizeInPixels/2 : 0; },
            "x":  function(d) { return getTextBoxCoords(d)[2]; },
            "y":  function(d) { return getTextBoxCoords(d)[3]; }
          });

        text.filter(function (d) { return d.calloutPoint; })
          .append("polygon")
          .attr({
            "points": "0,0 0,0 0,0",
            "style": function(d) {
              var backgroundColor = d.backgroundColor;
              return "fill:"+backgroundColor+";opacity:1.0;fill-opacity:1;stroke:#000000;stroke-width:0;";
            }
          });

        text.append("text")
          .attr({
            "class": function() { return "textBox" + (AUTHORING ? " draggable" : ""); },
            "transform": function(d) {
              var rotate = d.rotate,
                  pos = getTextBoxCoords(d);
              return "rotate("+rotate+" "+pos[0]+" "+pos[1]+")";
            },
            "x-data": function(d) { return getTextBoxCoords(d)[0]; },
            "y": function(d)      { return getTextBoxCoords(d)[1]; },
            "width-data": function(d) { return d.width; },
            "height-data": function(d) { return d.height; },
            "width":  model2px(size[0]),
            "height": model2px(size[1]),
            "xml:space": "preserve",
            "font-family": "'" + labConfig.fontface + "', sans-serif",
            "font-size": function(d) {
              return d.fontScale * textBoxFontSizeInPixels + "px";
            },
            "fill": function(d) { return d.color || "black"; },
            "text-data": function(d) { return d.text; },
            "text-anchor": function(d) {
              var align = d.textAlign || "left";
              if (align === "center") align = "middle";
              return align;
            },
            "has-host": function(d) { return !!d.hostType; }
          })
          .call(d3.behavior.drag()
            .on("drag", textDrag)
            .on("dragend", function(d) {
              // simple output to console for now, eventually should just get
              // serialized back to interactive (or model?) JSON on author save
              console.log('"x": '+d.x+",");
              console.log('"y": '+d.y+",");
            })
          );
        selection.exit().remove();
      };

      appendTextBoxes(1);
      appendTextBoxes(2);

      // wrap text, set callouts
      $(".textBox").each( function() {
        var text      = this.getAttributeNS(null, "text-data"),
            x         = this.getAttributeNS(null, "x-data"),
            width     = this.getAttributeNS(null, "width-data"),
            height    = this.getAttributeNS(null, "height-data"),
            fontSize  = parseFloat(this.getAttributeNS(null, "font-size")),
            transform = this.getAttributeNS(null, "transform"),
            hasHost   = this.getAttributeNS(null, "has-host"),
            textAlign = this.getAttributeNS(null, "text-anchor"),
            $parentNode = $(this.parentNode),
            horizontalPadding, verticalPadding,
            result, fullWidth, fullHeight, frame, dy, tx, ty,
            callout, calloutLocation;

        dy = fontSize*1.2;
        horizontalPadding = +fontSize*1.5;
        verticalPadding = fontSize/1.8;

        if (width === '') {
          width = -1;
        } else {
          width = model2px(width);
        }

        if (height === '') {
          height = -1;
        } else {
          height = model2px(height);
        }

        while (this.firstChild) {     // clear element first
          this.removeChild(this.firstChild);
        }

        result = wrapSVGText(text, this, width, x, dy);

        if ($parentNode.find("rect").length > 0) {
          frame = $parentNode.find("rect")[0];
          fullWidth = result.width + horizontalPadding;
          frame.setAttributeNS(null, "width", fullWidth);
          if (height > 0) {
            fullHeight = height;
          } else {
            fullHeight = (result.lines * dy) + verticalPadding;
          }
          frame.setAttributeNS(null, "height", fullHeight);
        }

        // if we have a callout
        callout = $parentNode.find("polygon");
        if (frame && callout.length > 0) {
          calloutLocation = callout.attr("callout-location-data").split(", ");
          callout.attr("points", getCalloutPath(calloutLocation, frame, fullWidth, fullHeight, fontSize) );
        }

        // center all hosted labels simply by tweaking the g.transform
        if (textAlign === "middle") {
          tx = result.width / 2;
          if (height > 0) {
            ty = height / 2 - verticalPadding * 1.5 - (result.lines-1) * dy / 2;
          } else {
            ty = 0;
          }
          transform = transform + " translate("+tx+","+ty+")";
          $(this).attr("transform", transform);
        }
        if (hasHost === "true" && callout.length === 0) {
          tx = result.width / -2 - horizontalPadding/2;
          ty = result.lines * dy / -2 - verticalPadding/2;
          $parentNode.attr("transform", "translate("+tx+","+ty+")");
        }
      });
    }

    function setupColorsOfParticles() {
      var i, len;

      chargeShadingMode = model.get("chargeShading");
      keShadingMode = model.get("keShading");

      gradientNameForParticle.length = modelAtoms.length;
      for (i = 0, len = modelAtoms.length; i < len; i++)
        gradientNameForParticle[i] = getParticleGradient(modelAtoms[i]);
    }

    function setupParticles() {
      var showChargeSymbols = model.get("showChargeSymbols"),
          useThreeLetterCode = model.get("useThreeLetterCode");

      setupColorsOfParticles();

      mainContainer.selectAll("circle").remove();
      mainContainer.selectAll("g.label").remove();

      particle = mainContainer.selectAll("circle").data(modelAtoms);
      updateParticleRadius();

      particleEnterExit();

      label = mainContainer.selectAll("g.label")
          .data(modelAtoms);

      labelEnter = label.enter().append("g")
          .attr("class", "label")
          .attr("transform", function(d) {
            return "translate(" + model2px(d.x) + "," + model2pxInv(d.y) + ")";
          });

      labelEnter.each(function (d) {
        var selection = d3.select(this),
            txtValue, txtSelection;
        // Append appropriate label. For now:
        // If 'atomNumbers' option is enabled, use indices.
        // If not and there is available 'label'/'symbol' property, use one of them
        // (check 'useThreeLetterCode' option to decide which one).
        // If not and 'showChargeSymbols' option is enabled, use charge symbols.
        if (model.get("atomNumbers")) {
          selection.append("text")
            .text(d.idx)
            .style("font-size", model2px(1.4 * d.radius) + "px");
        }
        else if (useThreeLetterCode && d.label) {
          // Add shadow - a white stroke, which increases readability.
          selection.append("text")
            .text(d.label)
            .attr("class", "shadow")
            .style("font-size", model2px(d.radius) + "px");
          selection.append("text")
            .text(d.label)
            .style("font-size", model2px(d.radius) + "px");
        }
        else if (!useThreeLetterCode && d.symbol) {
          // Add shadow - a white stroke, which increases readability.
          selection.append("text")
            .text(d.symbol)
            .attr("class", "shadow")
            .style("font-size", model2px(1.4 * d.radius) + "px");
          selection.append("text")
            .text(d.symbol)
            .style("font-size", model2px(1.4 * d.radius) + "px");
        }
        else if (showChargeSymbols) {
          if (d.charge > 0){
            txtValue = "+";
          } else if (d.charge < 0){
            txtValue = "-";
          } else {
            return;
          }
          selection.append("text")
            .text(txtValue)
            .style("font-size", model2px(1.6 * d.radius) + "px");
        }
        // Set common attributes for labels (+ shadows).
        txtSelection = selection.selectAll("text");
        // Check if node exists and if so, set appropriate attributes.
        if (txtSelection.node()) {
          txtSelection
            .attr("pointer-events", "none")
            .style({
              "font-weight": "bold",
              "opacity": 0.7
            });
          txtSelection
            .attr({
              // Center labels, use real width and height.
              // Note that this attrs should be set *after* all previous styling options.
              // .node() will return first node in selection. It's OK - both texts
              // (label and its shadow) have the same dimension.
              "x": -txtSelection.node().getBBox().width / 2,
              "y": "0.31em"
            });
        }
        // Set common attributes for shadows.
        selection.select("text.shadow")
          .style({
            "stroke": "#fff",
            "stroke-width": 0.15 * model2px(d.radius),
            "stroke-opacity": 0.7
          });
      });
    }

    function setupObstacles() {
      obstacles = model.get_obstacles();
      mainContainer.selectAll("g.obstacle").remove();
      if (obstacles) {
        mockObstaclesArray.length = obstacles.x.length;
        obstacle = mainContainer.selectAll("g.obstacle").data(mockObstaclesArray);
        obstacleEnter();
      }
    }

    function setupRectangles() {
      rectangles = model.get_rectangles();
      rectangleContainerTop.selectAll(".rectangle").remove();
      rectangleContainerBelow.selectAll(".rectangle").remove();
      if (rectangles) {
        mockRectanglesTop=[];
        mockRectanglesBelow=[];
        for(var i = 0; i < rectangles.x.length ; i++){
          if(rectangles.layer[i]===1){
            mockRectanglesTop.push(i);
          }
          else{
            mockRectanglesBelow.push(i);
          }
        }
        rectangleTop = rectangleContainerTop.selectAll(".rectangle").data(mockRectanglesTop);
        rectangleBelow = rectangleContainerBelow.selectAll(".rectangle").data(mockRectanglesBelow);
        rectangleEnter();
      }
    }

    function setupRadialBonds() {
      radialBondsContainer.selectAll("path.radialbond1").remove();
      radialBondsContainer.selectAll("path.radialbond2").remove();
      radialBonds = model.get_radial_bonds();
      radialBondResults = model.get_radial_bond_results();
      if (radialBondResults) {
        radialBond1 = radialBondsContainer.selectAll("path.radialbond1").data(radialBondResults);
        radialBond2 = radialBondsContainer.selectAll("path.radialbond2").data(radialBondResults);
        radialBondEnter();
      }
    }

    function setupVdwPairs() {
      VDWLinesContainer.selectAll("line.attractionforce").remove();
      updateVdwPairsArray();
      drawVdwLines = model.get("showVDWLines");
      if (drawVdwLines) {
        vdwLines = VDWLinesContainer.selectAll("line.attractionforce").data(vdwPairs);
        vdwLinesEnter();
      }
    }

    // The vdw hash returned by md2d consists of typed arrays of length N*N-1/2
    // To make these d3-friendly we turn them into an array of atom pairs, only
    // as long as we need.
    function updateVdwPairsArray() {
      var vdwHash = model.get_vdw_pairs();
      for (var i = 0; i < vdwHash.count; i++) {
        vdwPairs[i] = [vdwHash.atom1[i], vdwHash.atom2[i]];
      }
      // if vdwPairs was longer at the previous tick, trim the end
      vdwPairs.splice(vdwHash.count);
    }

    function setupVectors() {
      mainContainer.selectAll("path.vector-"+VELOCITY_STR).remove();
      mainContainer.selectAll("path.vector-"+FORCE_STR).remove();

      drawVelocityVectors = model.get("showVelocityVectors");
      drawForceVectors    = model.get("showForceVectors");
      if (drawVelocityVectors) {
        velVector = mainContainer.selectAll("path.vector-"+VELOCITY_STR).data(modelAtoms);
        vectorEnter(velVector, getVelVectorPath, getVelVectorWidth, velocityVectorColor, VELOCITY_STR);
      }
      if (drawForceVectors) {
        forceVector = mainContainer.selectAll("path.vector-"+FORCE_STR).data(modelAtoms);
        vectorEnter(forceVector, getForceVectorPath, getForceVectorWidth, forceVectorColor, FORCE_STR);
      }
    }

    function setupElectricField() {
      var density = model.get("electricFieldDensity"),
          col, size;
      drawElectricForceField = density > 0;
      // Do full enter-update-remove cycle to reuse DOM elements.
      efVector = fieldVisualization.selectAll(".vector-electric-field").data(model.getElectricField());
      efVector.exit().remove();
      if (drawElectricForceField) {
        // Enter.
        efVector.enter()
          .append("g")
            .attr("class", "vector-electric-field")
          .append("g")
            .attr("class", "rot-g")
          .append("svg")
            .attr("viewBox", "-5 -12 10 12")
          .append("path")
            .attr("d", "M0,0 L0,-8 L1,-8 L0,-10 L-1,-8, L0,-8");
        // Update.
        col = color.contrastingColor(model.get("backgroundColor"));
        efVector
            .attr("transform", function (d) {
              return "translate(" + model2px(d.x) + ", " + model2pxInv(d.y) + ")";
            })
            .style("fill", col)
            .style("stroke", col);
        // Size update.
        size = Math.sqrt(30 / density);
        efVector.select("svg")
            .attr("x", (-0.5 * size) + "em")
            .attr("y", (-size) + "em")
            .attr("width", size + "em")
            .attr("height", size + "em");
        // Cache selection + update rotation.
        efVector = efVector.select(".rot-g");
        updateElectricForceField();
      }
    }

    function updateElectricForceField() {
      var rad2deg = 180 / Math.PI;
      efVector
          .attr("transform", function(d) {
            return "rotate(" + (Math.atan2(d.fx, d.fy) * rad2deg) + ")";
          })
          .style("opacity", function(d) {
            return Math.min(1, Math.pow(d.fx * d.fx + d.fy * d.fy, .2) * .3);
          });
    }

    function setupAtomTrace() {
      mainContainer.selectAll("path.atomTrace").remove();
      atomTracePath = "";

      drawAtomTrace = model.get("showAtomTrace");
      atomTraceId = model.get("atomTraceId");
      if (drawAtomTrace) {
        atomTrace = mainContainer.selectAll("path.atomTrace").data([modelAtoms[atomTraceId]]);
        atomTraceEnter();
      }
    }

    function updateVdwPairs() {
      // Get new set of pairs from model.
      updateVdwPairsArray();

      vdwLines = VDWLinesContainer.selectAll("line.attractionforce").data(vdwPairs);
      vdwLinesEnter();
    }

    function moleculeMouseOver(d, i) {
      if (model.get("enableAtomTooltips") && (atomTooltipOn === false)) {
        renderAtomTooltip(i);
      }
    }

    function moleculeMouseDown(d, i) {
      modelView.node.focus();
      if (model.get("enableAtomTooltips")) {
        if (atomTooltipOn !== false) {
          atomToolTip.style("opacity", 1e-6);
          atomToolTip.style("display", "none");
          atomTooltipOn = false;
        } else {
          if (d3.event.shiftKey) {
            atomTooltipOn = i;
          } else {
            atomTooltipOn = false;
          }
          renderAtomTooltip(i);
        }
      }
    }

    function renderAtomTooltip(i) {
      var pos = modelView.pos(),
          left = pos.left + model2px(modelAtoms[i].x),
          top  = pos.top +  model2pxInv(modelAtoms[i].y);

      atomToolTip
            .style("opacity", 1.0)
            .style("display", "inline")
            .style("background", "rgba(100%, 100%, 100%, 0.7)")
            .style("left", left + "px")
            .style("top",  top + "px")
            .style("zIndex", 100)
            .transition().duration(250);

      atomToolTipPre.text(
          "atom: " + i + "\n" +
          "time: " + modelTimeLabel() + "\n" +
          "speed: " + d3.format("+6.3e")(modelAtoms[i].speed) + "\n" +
          "vx:    " + d3.format("+6.3e")(modelAtoms[i].vx)    + "\n" +
          "vy:    " + d3.format("+6.3e")(modelAtoms[i].vy)    + "\n" +
          "ax:    " + d3.format("+6.3e")(modelAtoms[i].ax)    + "\n" +
          "ay:    " + d3.format("+6.3e")(modelAtoms[i].ay)    + "\n"
        );
    }

    function moleculeMouseOut() {
      if (!atomTooltipOn && atomTooltipOn !== 0) {
        atomToolTip.style("opacity", 1e-6).style("zIndex" -1);
      }
    }

    // TODO: this function name seems to be inappropriate to
    // its content.
    function updateParticles() {
      particle.attr({
        "cx": function(d) { return model2px(d.x); },
        "cy": function(d) { return model2pxInv(d.y); }
      });

      if (keShadingMode || chargeShadingMode) {
        // When Kinetic Energy Shading or Charge Shading is enabled, update style of atoms
        // during each frame.
        setupColorsOfParticles();
        // Update particles "fill" attribute. Array of colors is already updated.
        particle.attr("fill", function (d, i) { return gradientNameForParticle[i]; });
      }

      if (useQuantumDynamics) {
        particle.attr("filter", function (d) { if (d.excitation) {return "url(#glow)";} return null; });
      }

      label.attr("transform", function (d) {
        return "translate(" + model2px(d.x) + "," + model2pxInv(d.y) + ")";
      });

      if (atomTooltipOn === 0 || atomTooltipOn > 0) {
        renderAtomTooltip(atomTooltipOn);
      }
    }

    function getVelVectorPath(d) {
      var x_pos = model2px(d.x),
          y_pos = model2pxInv(d.y),
          path = "M "+x_pos+","+y_pos,
          scale = velocityVectorLength * 100;
      return path + " L "+(x_pos + model2px(d.vx*scale))+","+(y_pos - model2px(d.vy*scale));
    }

    function getForceVectorPath(d) {
      var x_pos = model2px(d.x),
          y_pos = model2pxInv(d.y),
          mass  = d.mass,
          scale = forceVectorLength * 100,
          path  = "M "+x_pos+","+y_pos;
      return path + " L "+(x_pos + model2px(d.ax*mass*scale))+","+(y_pos - model2px(d.ay*mass*scale));
    }

    function getVelVectorWidth(d) {
      return Math.abs(d.vx) + Math.abs(d.vy) > 1e-6 ? model2px(velocityVectorWidth) : 0;
    }

    function getForceVectorWidth(d) {
      return Math.abs(d.ax) + Math.abs(d.ay) > 1e-8 ? model2px(forceVectorWidth) : 0;
    }

    function updateVectors(vector, pathFunc, widthFunc) {
      vector.attr({
         "d": pathFunc,
         "stroke-width": widthFunc
      });
    }

    function getAtomTracePath(d) {
      // until we implement buffered array model output properties,
      // we just keep the path history in the path string
      var dx = Math.floor(model2px(d.x) * 100) / 100,
          dy = Math.floor(model2pxInv(d.y) * 100) / 100,
          lIndex, sIndex;
      if (!atomTracePath) {
        atomTracePath = "M"+dx+","+dy+"L";
        return "M "+dx+","+dy;
      } else {
        atomTracePath += dx+","+dy + " ";
      }

      // fake buffered array functionality by knocking out the first
      // element of the string when we get too big
      if (atomTracePath.length > 4000) {
        lIndex = atomTracePath.indexOf("L");
        sIndex = atomTracePath.indexOf(" ");
        atomTracePath = "M" + atomTracePath.slice(lIndex+1, sIndex) + "L" + atomTracePath.slice(sIndex+1);
      }
      return atomTracePath;
    }

    function updateAtomTrace() {
      atomTrace.attr({
        "d": getAtomTracePath
      });
    }

    function updateRadialBonds() {
      radialBond1.attr("d", function (d) { return findPoints(d, 1); });
      radialBond2.attr("d", function (d) { return findPoints(d, 2); });

      if (keShadingMode || chargeShadingMode) {
        // Update also radial bonds color when keShading or chargeShading is on.
        radialBond1.attr("stroke", getBondAtom1Color);
        radialBond2.attr("stroke", getBondAtom2Color);
      }
    }

    function getImageCoords(i) {
      var props = imageProp[i],
          x, y, img_width, img_height;
      if (props.imageHostType) {
        if (props.imageHostType === "Atom") {
          x = modelAtoms[props.imageHostIndex].x;
          y = modelAtoms[props.imageHostIndex].y;
        } else if (props.imageHostType === "RectangularObstacle") {
          x = obstacles.x[props.imageHostIndex] + (obstacles.width[props.imageHostIndex] / 2);
          y = obstacles.y[props.imageHostIndex] + (obstacles.height[props.imageHostIndex] / 2);
        }
        img_width = imageSizes[i][0];
        img_height = imageSizes[i][1];
        x = x - img_width / 2;
        y = y + img_height / 2;
      } else {
        x = props.imageX;
        y = props.imageY;
      }
      return [model2px(x), model2pxInv(y)];
    }

    function updateImageAttachment(){
      var numImages, imglayer, container, coords, i;
      numImages= imageProp.length;
      for(i = 0; i < numImages; i++) {
        if (!imageSizes || !imageSizes[i]) continue;
        coords = getImageCoords(i);
        imglayer = imageProp[i].imageLayer;
        container = imglayer === 1 ? imageContainerTop : imageContainerBelow;
        container.selectAll("image.image_attach"+i)
          .attr("x", coords[0])
          .attr("y", coords[1]);
      }
    }

    function nodeDragStart(d, i) {
      if (model.isStopped()) {
        // cache the *original* atom position so we can go back to it if drag is disallowed
        dragOrigin = [d.x, d.y];
      }
      else if ( d.draggable ) {
        model.liveDragStart(i);
      }
    }

    /**
      Given x, y, and a bounding box (object with keys top, left, bottom, and right relative to
      (x, y), returns an (x, y) constrained to keep the bounding box within the molecule container.
    */
    function dragBoundingBox(x, y, bbox) {
      if (bbox.left + x < 0)                x = 0 - bbox.left;
      if (bbox.right + x > modelWidth) x = modelWidth - bbox.right;
      if (bbox.bottom + y < 0)              y = 0 - bbox.bottom;
      if (bbox.top + y > modelHeight)  y = modelHeight - bbox.top;

      return { x: x, y: y };
    }

    function clip(value, min, max) {
      if (value < min) return min;
      if (value > max) return max;
      return value;
    }

    /**
      Given x, y, make sure that x and y are clipped to remain within the model container's
      boundaries
    */
    function dragPoint(x, y) {
      return { x: clip(x, 0, modelWidth), y: clip(y, 0, modelHeight) };
    }

    function nodeDrag(d, i) {
      var dragX = model2px.invert(d3.event.x),
          dragY = model2pxInv.invert(d3.event.y),
          drag;

      if (model.isStopped()) {
        drag = dragBoundingBox(dragX, dragY, model.getMoleculeBoundingBox(i));
        setAtomPosition(i, drag.x, drag.y, false, true);
        update();
      }
      else if ( d.draggable ) {
        drag = dragPoint(dragX, dragY);
        model.liveDrag(drag.x, drag.y);
      }
    }

    function textDrag(d) {
      var dragDx = model2px.invert(d3.event.dx),
          dragDy = model2px.invert(d3.event.dy);

      if (!(AUTHORING && model.isStopped())) {
      // for now we don't have user-draggable textBoxes
        return;
      }
      else {
        d.x = d.x + dragDx;
        d.y = d.y - dragDy;
        updateTextBoxes();
      }
    }

    function nodeDragEnd(d, i) {
      if (model.isStopped()) {

        if (!setAtomPosition(i, d.x, d.y, true, true)) {
          alert("You can't drop the atom there");     // should be changed to a nice Lab alert box
          setAtomPosition(i, dragOrigin[0], dragOrigin[1], false, true);
        }
        update();
      }
      else if (d.draggable) {
        // here we just assume we are removing the one and only spring force.
        // This assumption will have to change if we can have more than one.
        model.liveDragEnd();
      }
    }

    function setupToolTips() {
      var mc = d3.select("#model-container");
      if ( atomToolTip === undefined && !mc.empty()) {
        atomToolTip = mc.append("div")
            .attr("class", "tooltip")
            .style("opacity", 1e-6);
        atomToolTipPre = atomToolTip.append("pre");
      }
    }

    function setupFirefoxWarning() {
      var $firefoxWarningPane,
          pos,
          top,
          left,
          b = benchmark.what_browser();   // we need to recalc this for FF, for some reason

      if (b.browser === "Firefox" && b.version >= "18" && b.version < "23") {
        $firefoxWarningPane = $("#firefox-warning-pane");
        pos = modelView.pos();
        top  = pos.bottom - $firefoxWarningPane.height();
        left = pos.right - $firefoxWarningPane.width();
        $firefoxWarningPane.css({
          display: "inline",
          top: top -5,
          left: left - 15,
          'z-index': 100
        });
      }
    }

    function setupRendererOptions() {
      imageProp = model.get("images");
      imageMapping = model.get("imageMapping");
      modelImagePath = model.get('imagePath');
      if (modelImagePath) {
        imagePath = labConfig.actualRoot + modelImagePath;
      }
      else if (modelView.url) {
        imagePath = labConfig.actualRoot + modelView.url.slice(0, modelView.url.lastIndexOf("/") + 1);
      }

      velocityVectorColor = model.get("velocityVectors").color;
      velocityVectorWidth  = model.get("velocityVectors").width;
      velocityVectorLength = model.get("velocityVectors").length;

      forceVectorColor = model.get("forceVectors").color;
      forceVectorWidth  = model.get("forceVectors").width;
      forceVectorLength = model.get("forceVectors").length;

      atomTraceColor = model.get("atomTraceColor");

      createVectorArrowHeads(velocityVectorColor, VELOCITY_STR);
      createVectorArrowHeads(forceVectorColor, FORCE_STR);

      useQuantumDynamics = model.properties.useQuantumDynamics;
      if (useQuantumDynamics) {
        createExcitationGlow();
      }

      createSymbolImages();
      createImmutableGradients();

      // Register additional controls, context menus etc.
      // Note that special selector for class is used. Typical class selectors
      // (e.g. '.amino-acid') cause problems when interacting with SVG nodes.
      amniacidContextMenu.register(model, api, '[class~="amino-acid"]');

      // Initialize renderers.
      geneticRenderer = new GeneticRenderer(modelView, model);
    }

    function photonPath(d) {
      var lineData = [],
          nPoints = 40,
          line = d3.svg.line()
            .x(function(d) { return model2px(0.5 / nPoints * d.x); })
            .y(function(d) { return model2px(0.1 * d.y); }),

          t = d.angularFrequency * 2 * Math.PI / nPoints,
          i;

      // Reference implementation: https://github.com/concord-consortium/mw/blob/6e2f2d4630323b8e993fcfb531a3e7cb06644fef/src/org/concord/mw2d/models/Photon.java#L74-L79
      for (i = 0; i < nPoints; i++) {
        lineData.push({
          x: i - nPoints/2,
          y: Math.sin(i * t) / (1 + 0.01 * (i - 0.5 * nPoints) * (i - 0.5 * nPoints))
        });
      }

      return line(lineData);
    }

    function enterAndUpdatePhotons() {
      var photonData = model.getPhotons(),
          photons = mainContainer.selectAll(".photon").data(photonData);

      photons.enter().append("path")
        .attr({
          "class": "photon",
          "d": photonPath,
          "stroke-width": 1,
          "stroke": "black",
          "fill-opacity": 0
        });

      photons.exit().remove();

      photons.attr("transform", function(d) {
        var angle = -180 * Math.atan2(d.vy, d.vx) / Math.PI;
        return "translate(" + model2px(d.x) + ", " + model2pxInv(d.y) + ") " +
               "rotate(" + angle + ")";
      });

    }

    //
    // *** Main Renderer functions ***
    //

    //
    // MD2D Renderer: init
    //
    function init() {
      timeSuffix = " (" + model.getPropertyDescription('displayTime').getUnitAbbreviation() + ")";

      model2px = modelView.model2px;
      model2pxInv = modelView.model2pxInv;

      fontSizeInPixels = modelView.getFontSizeInPixels();
      textBoxFontSizeInPixels = fontSizeInPixels * 0.9;

      modelAtoms  = model.getAtoms();
      modelElements = model.get_elements();
      modelWidth    = model.get('width');
      modelHeight   = model.get('height');
      aspectRatio   = modelWidth / modelHeight;

      setupRendererOptions();

      // Subscribe for model events.
      model.addPropertiesListener(["temperatureControl"], drawSymbolImages);

      function redrawClickableObjects (redrawOperation) {
        return function () {
          redrawOperation();
          // All objects where repainted (probably removed and added again), so
          // it's necessary to apply click handlers again.
          modelView.updateClickHandlers();
        };
      }

      // Redraw container each time when some visual-related property is changed.
      model.addPropertiesListener([
        "keShading", "chargeShading", "showChargeSymbols", "useThreeLetterCode",
        "showVDWLines", "VDWLinesCutoff",
        "showVelocityVectors", "showForceVectors",
        "showAtomTrace", "atomTraceId", "aminoAcidColorScheme",
        "backgroundColor", "markColor"],
          redrawClickableObjects(repaint));
      model.addPropertiesListener("electricFieldDensity", setupElectricField);

      model.on('addAtom', redrawClickableObjects(setupParticles));
      model.on('removeAtom', redrawClickableObjects(repaint));
      model.on('addRadialBond', redrawClickableObjects(setupRadialBonds));
      model.on('removeRadialBond', redrawClickableObjects(setupRadialBonds));
      model.on('textBoxesChanged', redrawClickableObjects(drawTextBoxes));

      setupFirefoxWarning();
    }

    // Call when model is reset or reloaded.
    function bindModel(newModel) {
      model = newModel;
      init();
    }

    //
    // MD2D Renderer: repaint
    //
    // Call when container being rendered into changes size, in that case
    // pass in new D3 scales for model2px transformations.
    //
    // Also call when the number of objects changes such that the container
    // must be setup again.
    //
    function repaint(m2px, m2pxInv) {
      if (arguments.length) {
        model2px = m2px;
        model2pxInv = m2pxInv;
      }
      fontSizeInPixels = modelView.getFontSizeInPixels();
      textBoxFontSizeInPixels = fontSizeInPixels * 0.9;

      setupDynamicGradients();
      setupObstacles();
      setupVdwPairs();
      setupParticles();
      // Always setup radial bonds *after* particles to use correct atoms
      // color table.
      setupRectangles();
      //Rectangles are ON TOP of particles
      setupRadialBonds();
      geneticRenderer.setup();
      setupVectors();
      setupElectricField();
      setupAtomTrace();
      drawImageAttachment();
      drawTextBoxes();
      setupToolTips();
      drawSymbolImages();
      setupFirefoxWarning();
      if (useQuantumDynamics) {
        enterAndUpdatePhotons();
      }
    }

    //
    // MD2D Renderer: update
    //
    // Call to update visualization when model result state changes.
    // Normally called on every model tick.
    //
    function update() {
      console.time('view update');
      if (obstacles) {
        obstacle.attr("transform", function (d, i) {
          return "translate(" + model2px(obstacles.x[i]) + " " + model2pxInv(obstacles.y[i] + obstacles.height[i]) + ")";
        });
      }

      if (rectangles) {
        rectangleTop.attr("transform", function (d) {
          return "translate(" + model2px(rectangles.x[d]) + " " + model2pxInv(rectangles.y[d] + rectangles.height[d]) + ")";
        });
        rectangleBelow.attr("transform", function (d) {
          return "translate(" + model2px(rectangles.x[d]) + " " + model2pxInv(rectangles.y[d] + rectangles.height[d]) + ")";
        });
      }

      if (drawVdwLines) {
        updateVdwPairs();
      }

      updateParticles();

      if (radialBondResults) {
        // Always update radial bonds *after* particles, as particles can
        // change their color and radial bonds should reflect that too (=> use
        // updated colors array).
        updateRadialBonds();
      }
      if (drawVelocityVectors) {
        updateVectors(velVector, getVelVectorPath, getVelVectorWidth);
      }
      if (drawForceVectors) {
        updateVectors(forceVector, getForceVectorPath, getForceVectorWidth);
      }
      if (drawElectricForceField) {
        updateElectricForceField();
      }
      if (drawAtomTrace) {
        updateAtomTrace();
      }
      if(imageProp && imageProp.length !== 0) {
        updateImageAttachment();
      }
      if (textBoxes && textBoxes.length > 0) {
        updateTextBoxes();
      }
      if (useQuantumDynamics) {
        enterAndUpdatePhotons();
      }
      console.timeEnd('view update');
    }

    //
    // Public API to instantiated Renderer
    //
    api = {
      // Expose private methods.
      update: update,
      repaint: repaint,
      bindModel: bindModel,
      model2px: modelView.model2px,
      model2pxInv: modelView.model2pxInv
    };

    return api;
  };
});

/*global define: false */

define('md2d/views/view',['require','common/views/svg-container','md2d/views/renderer'],function (require) {
  var SVGContainer = require("common/views/svg-container"),
      Renderer     = require("md2d/views/renderer");

  return function (model, modelUrl) {
    return new SVGContainer(model, modelUrl, Renderer);
  };

});

/*global $, define, model */

define('md2d/views/dna-edit-dialog',[],function () {

  return function DNAEditDialog() {
    var api,
        $dialogDiv,
        $dnaTextInput,
        $errorMsg,
        $submitButton,

        init = function() {
          // Basic dialog elements.
          $dialogDiv = $('<div></div>');
          $dnaTextInput = $('<input type="text" id="dna-sequence-input" size="55"></input>');
          $dnaTextInput.appendTo($dialogDiv);
          $errorMsg = $('<p class="error"></p>');
          $errorMsg.appendTo($dialogDiv);

          // jQuery UI Dialog.
          $dialogDiv.dialog({
            dialogClass: "dna-edit-dialog",
            // Ensure that font is being scaled dynamically.
            appendTo: "#responsive-content",
            title: "DNA Code on Sense Strand",
            autoOpen: false,
            width: "35em",
            buttons: {
              "Apply": function () {
                model.set({
                  DNA: $dnaTextInput.val()
                });
                $(this).dialog("close");
              }
            }
          });

          // Dynamic validation on input.
          $submitButton = $(".dna-edit-dialog button:contains('Apply')");
          $dnaTextInput.on("input", function () {
            try {
              model.getPropertyValidateFunc("DNA")($dnaTextInput.val());
              $submitButton.button("enable");
              $errorMsg.text("");
            } catch (e) {
              $submitButton.button("disable");
              $errorMsg.text(e.message);
            }
          });
        };

    api = {
      open: function () {
        // Clear previous errors.
        $errorMsg.text("");
        $submitButton.removeAttr("disabled");
        // Set current value of DNA code.
        $dnaTextInput.val(model.get("DNA"));
        $dialogDiv.dialog("open");
      }
    };

    init();

    return api;
  };
});

/*global define, model */

define('md2d/controllers/scripting-api',['require','common/alert','md2d/views/dna-edit-dialog'],function (require) {

  var alert = require('common/alert'),
      DNAEditDialog = require('md2d/views/dna-edit-dialog');

  /**
    Define the model-specific MD2D scripting API used by 'action' scripts on interactive elements.

    The universal Interactive scripting API is extended with the properties of the
    object below which will be exposed to the interactive's 'action' scripts as if
    they were local vars. All other names (including all globals, but excluding
    Javascript builtins) will be unavailable in the script context; and scripts
    are run in strict mode so they don't accidentally expose or read globals.

    @param: api
  */
  return function MD2DScriptingAPI (api) {

    var dnaEditDialog = new DNAEditDialog(),
        // whether we are currently processing a batch command, suppresses repaint
        inBatch = false;

    return {
      /* Returns number of atoms in the system. */
      getNumberOfAtoms: function getNumberOfAtoms(f) {
        return model.getNumberOfAtoms(f);
      },

      /* Returns number of obstacles in the system. */
      getNumberOfObstacles: function getNumberOfObstacles() {
        return model.getNumberOfObstacles();
      },

      /* Returns number of elements in the system. */
      getNumberOfElements: function getNumberOfElements() {
        return model.getNumberOfElements();
      },

      /* Returns number of radial bonds in the system. */
      getNumberOfRadialBonds: function getNumberOfRadialBonds() {
        return model.getNumberOfRadialBonds();
      },

      /* Returns number of angular bonds in the system. */
      getNumberOfAngularBonds: function getNumberOfAngularBonds() {
        return model.getNumberOfAngularBonds();
      },

      addAtom: function addAtom(props, options) {
        if (options && options.suppressRepaint) {
          // Translate suppressRepaint option to
          // option understable by modeler.
          // supresRepaint is a conveniance option for
          // Scripting API users.
          options.suppressEvent = true;
        }
        return model.addAtom(props, options);
      },

      /*
        Removes atom 'i'.
      */
      removeAtom: function removeAtom(i, options) {
        if (options && options.suppressRepaint) {
          // Translate suppressRepaint option to
          // option understable by modeler.
          // supresRepaint is a conveniance option for
          // Scripting API users.
          options.suppressEvent = true;
          delete options.suppressRepaint;
        }
        try {
          model.removeAtom(i, options);
        } catch (e) {
          if (!options || !options.silent)
            throw e;
        }
      },

      /*
        Removes radial bond 'i'.
      */
      removeRadialBond: function removeRadialBond(i, options) {
        try {
          model.removeRadialBond(i);
        } catch (e) {
          if (!options || !options.silent)
            throw e;
        }

        api.repaintIfReady();
      },

      /*
        Removes angular bond 'i'.
      */
      removeAngularBond: function removeAngularBond(i, options) {
        try {
          model.removeAngularBond(i);
        } catch (e) {
          if (!options || !options.silent)
            throw e;
        }

        api.repaintIfReady();
      },

      addRandomAtom: function addRandomAtom() {
        return model.addRandomAtom.apply(model, arguments);
      },

      adjustTemperature: function adjustTemperature(fraction) {
        model.set({targetTemperature: fraction * model.get('targetTemperature')});
      },

      /**
       Scales the velocity of a group of atoms to the desired temperature T
       */
      setTemperatureOfAtoms: function setTemperatureOfAtoms(atomIndices, T) {
        model.setTemperatureOfAtoms(atomIndices,T);
      },

      getTemperatureOfAtoms: function getTemperatureOfAtoms(atomIndices) {
        return model.getTemperatureOfAtoms(atomIndices);
      },

      limitHighTemperature: function limitHighTemperature(t) {
        if (model.get('targetTemperature') > t) model.set({targetTemperature: t});
      },

      /** returns a list of integers corresponding to atoms in the system */
      randomAtoms: function randomAtoms(n) {
        var numAtoms = model.getNumberOfAtoms();

        if (n === null) n = 1 + api.randomInteger(numAtoms-1);

        if (!api.isInteger(n)) throw new Error("randomAtoms: number of atoms requested, " + n + ", is not an integer.");
        if (n < 0) throw new Error("randomAtoms: number of atoms requested, " + n + ", was less be greater than zero.");

        if (n > numAtoms) n = numAtoms;
        return api.choose(n, numAtoms);
      },

      /**
       * Returns array of atom indices within circular area,
       * optionally specifying an element of interest.
       * e.g. atomsWithinCircle(1, 1, 0.5) returns all atoms within 0.5 nm of position (1nm, 1nm).
       * @param  {number} x       X coordinate of the circle center.
       * @param  {number} y       Y coordinate of the circle center.
       * @param  {number} w       Radius of the circle.
       * @param  {number} element Optional ID of the desired element type.
       * @return {Array}          Array of atoms indices within a given area.
       */
      atomsWithinCircle: function(x, y, r, element) {
        var result = [],
            props, dist, i, len;

        for (i = 0, len = model.getNumberOfAtoms(); i < len; i++) {
          props = model.getAtomProperties(i);
          if (typeof element !== 'undefined' && props.element !== element) continue;
          dist = Math.sqrt(Math.pow(x - props.x, 2) + Math.pow(y - props.y, 2));
          if (dist <= r) {
            result.push(i);
          }
        }
        return result;
      },

      /**
       * Returns array of atom indices within rectangular area,
       * optionally specifying an element of interest.
       * e.g. atomsWithinRect(1, 1, 0.2, 0.3) returns all atoms within a rectangle of width 0.2nm
       * by height 0.3nm, with the bottom-left corner specified by the postion (1nm, 1nm).
       * @param  {number} x       X coordinate of the bottom-left rectangle corner.
       * @param  {number} y       Y coordinate of the bottom-left rectangle corner.
       * @param  {number} w       Width of the rectangle.
       * @param  {number} h       Height of the rectangle.
       * @param  {number} element Optional ID of the desired element type.
       * @return {Array}          Array of atoms indices within a given area.
       */
      atomsWithinRect: function(x, y, w, h, element) {
        var result = [],
            props, dist, inX, inY, i, len;

        for (i = 0, len = model.getNumberOfAtoms(); i < len; i++) {
          props = model.getAtomProperties(i);
          if (typeof element !== 'undefined' && props.element !== element) continue;
          if (typeof h === 'undefined') {
            dist = Math.sqrt(Math.pow(x - props.x, 2) + Math.pow(y - props.y, 2));
            if (dist <= w) {
              result.push(i);
            }
          } else {
            inX = ((props.x >= x) && (props.x <= (x + w)));
            inY = ((props.y >= y) && (props.y <= (y + h)));
            if (inX && inY) {
              result.push(i);
            }
          }
        }
        return result;
      },

      /**
       * Returns an array of atom indices within triangular area,
       * optionally specifying an element ID of interest.
       *
       * @param  {number} ax      X coordinate of 1st triangle vertex.
       * @param  {number} ay      Y coordinate of 1st triangle vertex.
       * @param  {number} bx      X coordinate of 2nd triangle vertex.
       * @param  {number} by      Y coordinate of 2nd triangle vertex.
       * @param  {number} cx      X coordinate of 3rd triangle vertex.
       * @param  {number} cy      Y coordinate of 3rd triangle vertex.
       * @param  {number} element Optional ID of the desired element type.
       * @return {Array}          Array of atoms indices within a given area.
       */
      atomsWithinTriangle: function(ax, ay, bx, by, cx, cy, element) {
        var result = [],
            props, i, len;

        function isInTriangle(px, py) {
          // See: http://www.blackpawn.com/texts/pointinpoly/default.html
          var v0 = [cx - ax, cy - ay],
              v1 = [bx - ax, by - ay],
              v2 = [px - ax, py - ay],

              dot00 = (v0[0] * v0[0]) + (v0[1] * v0[1]),
              dot01 = (v0[0] * v1[0]) + (v0[1] * v1[1]),
              dot02 = (v0[0] * v2[0]) + (v0[1] * v2[1]),
              dot11 = (v1[0] * v1[0]) + (v1[1] * v1[1]),
              dot12 = (v1[0] * v2[0]) + (v1[1] * v2[1]),

              invDenom = 1 / (dot00 * dot11 - dot01 * dot01),

              u = (dot11 * dot02 - dot01 * dot12) * invDenom,
              v = (dot00 * dot12 - dot01 * dot02) * invDenom;

          return ((u >= 0) && (v >= 0) && (u + v < 1));
        }

        for (i = 0, len = model.getNumberOfAtoms(); i < len; i++) {
          props = model.getAtomProperties(i);
          if (typeof element !== 'undefined' && props.element !== element) continue;
          if (isInTriangle(props.x, props.y)) {
            result.push(i);
          }
        }
        return result;
      },

      /**
        Accepts atom indices as arguments, or an array containing atom indices.
        Unmarks all atoms, then marks the requested atom indices.
        Repaints the screen to make the marks visible.
      */
      markAtoms: function markAtoms(indices) {
        var i,
            len;

        if (arguments.length === 0) return;

        // allow passing a list of arguments instead of an array of atom indices
        if (!api.isArray(arguments[0])) {
          indices = arguments;
        }

        api.unmarkAllAtoms();

        // mark the requested atoms
        for (i = 0, len = indices.length; i < len; i++) {
          model.setAtomProperties(indices[i], {marked: 1});
        }

        api.repaintIfReady();
      },

      unmarkAllAtoms: function unmarkAllAtoms() {
        for (var i = 0, len = model.getNumberOfAtoms(); i < len; i++) {
          model.setAtomProperties(i, {marked: 0});
        }
        api.repaintIfReady();
      },

      traceAtom: function traceAtom(i) {
        if (i === null) return;

        model.set({atomTraceId: i});
        model.set({showAtomTrace: true});
      },

      untraceAtom: function untraceAtom() {
        model.set({showAtomTrace: false});
      },

      /**
        Sets individual atom properties using human-readable hash.
        e.g. setAtomProperties(5, {x: 1, y: 0.5, charge: 1})
      */
      setAtomProperties: function setAtomProperties(i, props, checkLocation, moveMolecule, options) {
        model.setAtomProperties(i, props, checkLocation, moveMolecule);
        api.repaintIfReady(options);
      },

      /**
       * Returns atom transition object. It can be used to smoothly change
       * atom properties over specified time. It's similar to D3 transitions.
       *
       * Atom transition object provides following methods:
       *  id(id)          - sets ID of the atom (required!).
       *  duration(d)     - sets duration in ms (required!).
       *  prop(name, val) - sets property name and its final value (required!).
       *  delay(d)        - sets delay in ms (default is 0).
       *  ease(name)      - sets easing function (default is "cubic-in-out").
       *                    Please see:
       *                    https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_ease
       *
       * e.g.
       *  atomTransition().id(0).duration(1000).ease("linear").prop("x", 10);
       *
       * This will change "x" property of the atom with ID=0
       * to value 10 over 1000ms using linear easing function.
       *
       * @return {AtomTransition} AtomTransition instance.
       */
      atomTransition: function atomTransition() {
        return model.atomTransition();
      },

      /**
        Returns atom properties as a human-readable hash.
        e.g. getAtomProperties(5) --> {x: 1, y: 0.5, charge: 1, ... }
      */
      getAtomProperties: function getAtomProperties(i) {
        return model.getAtomProperties(i);
      },

      /**
        Returns an array consisting of radial bonds indices for the atom
        e.g. getRadialBondsForAtom(5) --> [2]
      */
      getRadialBondsForAtom: function getRadialBondsForAtom(i) {
        return model.getRadialBondsForAtom(i);
      },

      /**
        Returns an array consisting of the angular bonds indices for the atom
        e.g. getAngularBondsForAtom(5) --> [6, 8]
      */
      getAngularBondsForAtom: function getAngularBondsForAtom(i) {
        return model.getAngularBondsForAtom(i);
      },

      /**
        Returns all atoms in the same molecule as atom i
        (not including i itself)
      */
      getMoleculeAtoms: function getMoleculeAtoms(i) {
        return model.getMoleculeAtoms(i);
      },

      setElementProperties: function setElementProperties(i, props) {
        model.setElementProperties(i, props);
        api.repaintIfReady();
      },

      /**
        Sets custom pairwise LJ properties (epsilon or sigma), which will
        be used instead of the mean values of appropriate element properties.
        i, j - IDs of the elements which should have custom pairwise LJ properties.
        props - object containing sigma, epsilon or both.
        e.g. setPairwiseLJProperties(0, 1, {epsilon: -0.2})
      */
      setPairwiseLJProperties: function setPairwiseLJProperties(i, j, props) {
        model.getPairwiseLJProperties().set(i, j, props);
      },

      getElementProperties: function getElementProperties(i) {
        return model.getElementProperties(i);
      },

      /**
        Adds an obstacle using human-readable hash of properties.
        e.g. addObstacle({x: 1, y: 0.5, width: 1, height: 1})
      */
      addObstacle: function addObstacle(props, options) {
        try {
          model.addObstacle(props);
        } catch (e) {
          if (!options || !options.silent)
            throw e;
        }
        api.repaintIfReady();
      },

      /**
        Sets individual obstacle properties using human-readable hash.
        e.g. setObstacleProperties(0, {x: 1, y: 0.5, externalAx: 0.00001})
      */
      setObstacleProperties: function setObstacleProperties(i, props) {
        model.setObstacleProperties(i, props);
        api.repaintIfReady();
      },
      
      /**
        Returns obstacle properties as a human-readable hash.
        e.g. getObstacleProperties(0) --> {x: 1, y: 0.5, externalAx: 0.00001, ... }
      */
      getObstacleProperties: function getObstacleProperties(i) {
        return model.getObstacleProperties(i);
      },

      /**
        Removes obstacle 'i'.
      */
      removeObstacle: function removeObstacle(i, options) {
        try {
          model.removeObstacle(i);
        } catch (e) {
          if (!options || !options.silent)
            throw e;
        }

        api.repaintIfReady();
      },

      setRectangleProperties: function setRectangleProperties(i, props) {
        model.setRectangleProperties(i, props);
        api.repaintIfReady();
      },

      getRectangleProperties: function getRectangleProperties(i) {
        return model.getRectangleProperties(i);
      },

      getAtomsWithinRectangle: function getAtomsInsideRectangle(i) {
        var props=model.getRectangleProperties(i);
        return this.atomsWithinRect(props.x,props.y,props.width,props.height)
      },
      
      removeRectangle: function removeRectangle(i, options) {
        try {
          model.removeRectangle(i);
        } catch (e) {
          if (!options || !options.silent)
            throw e;
        }
        api.repaintIfReady();
      },

      setRadialBondProperties: function setRadialBondProperties(i, props) {
        model.setRadialBondProperties(i, props);
        api.repaintIfReady();
      },

      getRadialBondProperties: function getRadialBondProperties(i) {
        return model.getRadialBondProperties(i);
      },

      setAngularBondProperties: function setAngularBondProperties(i, props) {
        model.setAngularBondProperties(i, props);
        api.repaintIfReady();
      },

      getAngularBondProperties: function getAngularBondProperties(i) {
        return model.getAngularBondProperties(i);
      },

      /**
        Opens DNA properties dialog, which allows to set DNA code.
      */
      openDNADialog: function showDNADialog() {
        dnaEditDialog.open();
      },

      /**
       * Jumps to the next DNA state.
       *
       * Note that jumping between translation states is not supported!
       * Please use animateToNextDNAState if you need to change state
       * from translation:x to translation:x+1.
       */
      jumpToNextDNAState: function jumpToNextDNAState() {
        model.geneticEngine().jumpToNextState();
      },

      /**
       * Jumps to the next DNA state.
       *
       * Note that jumping between translation states is not supported!
       * When current state is translation:x, where x > 0, this functions
       * will cause jump to translation:0 state.
       */
      jumpToPrevDNAState: function jumpToPrevDNAState() {
        model.geneticEngine().jumpToPrevState();
      },

      /**
       * Tests whether *current* DNA state is before state
       * passed as an argument.
       * @param {String} state DNA state name, e.g. "translation:5".
       * @return {boolean}     true if current state is before 'state',
       *                       false otherwise.
       */
      DNAStateBefore: function DNAStateBefore(state) {
        return model.geneticEngine().stateBefore(state);
      },

      /**
       * Tests whether *current* DNA state is after state
       * passed as an argument.
       * @param {String} state DNA state name, e.g. "translation:5".
       * @return {boolean}     true if current state is after 'state',
       *                       false otherwise.
       */
      DNAStateAfter: function DNAStateAfter(state) {
        return model.geneticEngine().stateAfter(state);
      },

      /**
       * Triggers animation to the next DNA state.
       *
       * Note that this is the only possible way to change state
       * from translation:x to translation:x+1. Jumping between
       * translation states is not supported!
       */
      animateToNextDNAState: function animateToNextDNAState() {
        model.geneticEngine().transitionToNextState();
      },

      /**
       * Triggers animation to the given DNA state.
       * If current DNA state is after the desired state,
       * nothing happens.
       * e.g.
       * get('DNAState'); // transcription:0
       * animateToDNAState("transcription-end") // triggers animation
       * However:
       * get('DNAState'); // translation-end
       * animateToDNAState("transcription-end") // nothing happens
       *
       * @param  {string} stateName name of the state.
       */
      animateToDNAState: function animateToDNAState(stateName) {
        model.geneticEngine().transitionTo(stateName);
      },

      /**
       * Stops current DNA animation.
       */
      stopDNAAnimation: function stopDNAAnimation() {
        // Jumping to previous state will cancel current animation
        // and cleanup transitions queue.
        model.geneticEngine().stopTransition();
      },

      /**
       * Triggers only one step of DNA transcription.
       * This method also accepts optional parameter - expected nucleotide.
       * When it's available, transcription step will be performed only
       * when passed nucleotide code matches nucleotide, which should
       * be actually joined to mRNA in this transcription step. When
       * expected nucleotide code is wrong, this method does nothing.
       *
       * e.g.
       * transcribeDNAStep("A") will perform transcription step only
       * if "A" nucleotide should be added to mRNA in this step.
       *
       * @param {string} expectedNucleotide code of the expected nucleotide ("U", "C", "A" or "G").
       */
      transcribeDNAStep: function transcribeDNAStep(expectedNucleotide) {
        var ge = model.geneticEngine();
        if (ge.stateBefore("dna") || ge.stateAfter("transcription-end")) {
          // Jump to beginning of DNA transcription if current state is before
          // or after transcrption process (so, state is different from:
          // "dna", "transcription:0", ..., "transcription-end").
          model.set("DNAState", "dna");
          ge.transitionTo("transcription:0");
          ge.transcribeStep(expectedNucleotide);
        } else if (model.get("DNAState") !== "transcription-end") {
          // Proceed to the next step.
          ge.transcribeStep(expectedNucleotide);
        }
      },

      /**
       * Triggers only one step of DNA translation.
       */
      translateDNAStep: function translateDNAStep() {
        var ge = model.geneticEngine();
        if (ge.stateBefore("translation:0") || ge.stateAfter("translation-end")) {
          // Animate directly to the translation:0, merge a few shorter
          // animations.
          model.set("DNAState", "translation:0");
          ge.transitionTo("translation:1");
        } else if (model.get("DNAState") !== "translation-end") {
          // Proceed to the next step.
          ge.transitionToNextState();
        }
      },

     /**
      * Generates a random protein. It removes all existing atoms before.
      *
      * @param  {[type]} expectedLength controls the maximum (and expected) number of amino acids of
      *                                 the resulting protein. When expected length is too big
      *                                 (due to limited area of the model), protein will be truncated
      *                                 and warning shown.
      */
      generateRandomProtein: function (expectedLength) {
        var realLength = model.geneticEngine().generateProtein(undefined, expectedLength);

        if (realLength !== expectedLength) {
          throw new Error("Generated protein was truncated due to limited area of the model. Only" +
            realLength + " amino acids were generated.");
        }
      },

      /**
        Sets solvent. You can use three predefined solvents: "water", "oil" or "vacuum".
        This is only a convenience method. The same effect can be achieved by manual setting
        of 'solventForceFactor', 'dielectricConstant' and 'backgroundColor' properties.
      */
      setSolvent: function setSolvent(type) {
        model.setSolvent(type);
      },

      pe: function pe() {
        return model.get('potentialEnergy');
      },

      ke: function ke() {
        return model.get('kineticEnergy');
      },

      atomsKe: function atomsKe(atomsList) {
        var sum = 0, i;
        for (i = 0; i < atomsList.length; i++) {
          sum += model.getAtomKineticEnergy(atomsList[i]);
        }
        return sum;
      },

      minimizeEnergy: function minimizeEnergy() {
        model.minimizeEnergy();
        api.repaintIfReady();
      },

      addTextBox: function(props) {
        model.addTextBox(props);
      },

      removeTextBox: function(i) {
        model.removeTextBox(i);
      },

      setTextBoxProperties: function(i, props) {
        model.setTextBoxProperties(i, props);
      },

      repaintIfReady: function(options) {
        if (!(inBatch || options && options.suppressRepaint)) {
          api.repaint();
        }
      },

      batch: function(func) {
        inBatch = true;

        model.startBatch();
        func();
        model.endBatch();

        inBatch = false;

        // call repaint manually
        api.repaintIfReady();
      }

    };

  };
});

/*global define, model, Lab, d3 */

define('md2d/benchmarks/benchmarks',[],function () {

  return function Benchmarks(controller) {

    var benchmarks = [
      {
        name: "commit",
        numeric: false,
        run: function(done) {
          var link = "<a href='"+Lab.version.repo.commit.url+"' class='opens-in-new-window' target='_blank'>"+Lab.version.repo.commit.short_sha+"</a>";
          if (Lab.version.repo.dirty) {
            link += " <i>dirty</i>";
          }
          done(link);
        }
      },
      {
        name: "atoms",
        numeric: true,
        run: function(done) {
          done(model.getNumberOfAtoms());
        }
      },
      {
        name: "temperature",
        numeric: true,
        formatter: d3.format("5.1f"),
        run: function(done) {
          done(model.get("temperature"));
        }
      },
      {
        name: "just graphics (steps/s)",
        numeric: true,
        formatter: d3.format("5.1f"),
        run: function(done) {
          var elapsed, start, i;
          model.stop();
          start = +Date.now();
          i = 0;
          while (i++ < 100) {
            controller.modelContainer.update();
          }
          elapsed = Date.now() - start;
          done(100/elapsed*1000);
        }
      },
      {
        name: "model (steps/s)",
        numeric: true,
        formatter: d3.format("5.1f"),
        run: function(done) {
          var start, elapsed;
          model.stop();
          start = +Date.now();
          model.suppressEvents(function () {
            var i = 0;
            while (i++ < 100) {
              model.tick();
            }
          });
          elapsed = Date.now() - start;
          done(100/elapsed*1000);
        }
      },
      {
        name: "model+graphics (steps/s)",
        numeric: true,
        formatter: d3.format("5.1f"),
        run: function(done) {
          var start, elapsed, i;
          model.stop();
          start = +Date.now();
          i = 0;
          while (i++ < 100) {
            model.tick();
          }
          elapsed = Date.now() - start;
          done(100/elapsed*1000);
        }
      },
      {
        name: "fps",
        numeric: true,
        formatter: d3.format("5.1f"),
        run: function(done) {
          // warmup
          model.start();
          setTimeout(function() {
            model.stop();
            var startCounter = model.stepCounter();
            setTimeout(function() {
              // actual fps calculation
              model.start();
              setTimeout(function() {
                model.stop();
                done( (model.stepCounter() - startCounter) / 2 );
              }, 2000);
            }, 100);
          }, 1000);
        }
      },
      {
        name: "interactive",
        numeric: false,
        run: function(done) {
          done(window.location.pathname + window.location.hash);
        }
      }
    ];

    return benchmarks;

  };
});

/*global
  define
*/
/*jslint onevar: true*/
define('md2d/controllers/controller',['require','common/controllers/model-controller','md2d/models/modeler','md2d/views/view','md2d/controllers/scripting-api','md2d/benchmarks/benchmarks'],function (require) {
  // Dependencies.
  var ModelController   = require("common/controllers/model-controller"),
      Model             = require('md2d/models/modeler'),
      ModelContainer    = require('md2d/views/view'),
      ScriptingAPI      = require('md2d/controllers/scripting-api'),
      Benchmarks        = require('md2d/benchmarks/benchmarks');

  return function (modelUrl, modelOptions, interactiveController) {
    return new ModelController(modelUrl, modelOptions, interactiveController,
                               Model, ModelContainer, ScriptingAPI, Benchmarks);
  };
});

/*global define: true */
/** Provides a few simple helper functions for converting related unit types.

    This sub-module doesn't do unit conversion between compound unit types (e.g., knowing that kg*m/s^2 = N)
    only simple scaling between units measuring the same type of quantity.
*/

// Prefer the "per" formulation to the "in" formulation.
//
// If KILOGRAMS_PER_AMU is 1.660540e-27 we know the math is:
// "1 amu * 1.660540e-27 kg/amu = 1.660540e-27 kg"
// (Whereas the "in" forumulation might be slighty more error prone:
// given 1 amu and 6.022e-26 kg in an amu, how do you get kg again?)

// These you might have to look up...

// Module can be used both in Node.js environment and in Web browser
// using RequireJS. RequireJS Optimizer will strip out this if statement.


define('solar-system/models/engine/constants/units',['require','exports','module'],function (require, exports, module) {

  var SECONDS_PER_DAY           = 86400,
      METERS_PER_AU             = 149597870700,
      KILOGRAMS_PER_EARTH_MASS  = 5.97219e24,
      EARTH_MASS_PER_SOLAR_MASS = 332946,

      types = {
        TIME:         "time",
        LENGTH:       "length",
        MASS:         "mass",
        ENERGY:       "energy",
        POWER:        "power",
        FORCE:        "force",
        VELOCITY:     "velocity",
        ACCELERATION: "acceleration",
        GRAVITATIONAL_CONSTANT: "Gravitational Constant",

        // unused as of yet
        AREA: "area",
        VOLUME: "volume",
        PRESSURE: "pressure"
      },

    unit,
    ratio,
    convert;

  /**
    In each of these units, the reference type we actually use has value 1, and conversion
    ratios for the others are listed.
  */
  exports.unit = unit = {

    DAY:         { name: "Day",         value: 1,                             type: types.TIME },
    SECOND:      { name: "second",      value: SECONDS_PER_DAY,               type: types.TIME },

    AU:          { name: "au",          value: 1,                             type: types.LENGTH },
    METER:       { name: "meter",       value: METERS_PER_AU,               type: types.LENGTH },


    EARTH_MASS:  { name: "Earth Mass",  value: 1,                             type: types.MASS },
    KILOGRAM:    { name: "kilogram",    value: KILOGRAMS_PER_EARTH_MASS,  type: types.MASS },
    SOLAR_MASS:  { name: "Solar Mass",  value: EARTH_MASS_PER_SOLAR_MASS, type: types.MASS },

    JOULE: {
      name: "Joule",
      value: (1/KILOGRAMS_PER_EARTH_MASS) *
             (1/METERS_PER_AU) * (1/METERS_PER_AU) /
             ((1/SECONDS_PER_DAY) * (1/SECONDS_PER_DAY)),
      type: types.ENERGY
    },

    WATT: {
      name: "Watt",
      value: (1/KILOGRAMS_PER_EARTH_MASS) *
             (1/METERS_PER_AU) * (1/METERS_PER_AU) /
             ((1/SECONDS_PER_DAY) * (1/SECONDS_PER_DAY) * (1/SECONDS_PER_DAY)),
      type: types.POWER
    },

    NEWTON: {
      name: "Newton",
      value: 1,
      type: types.FORCE
    },

    METERS_PER_SECOND: {
      name: "meters per second",
      value: (1 / METERS_PER_AU) * SECONDS_PER_DAY,
      type: types.VELOCITY
    },

    METERS_PER_SECOND_PER_SECOND: {
      name: "meters per second per second",
      value: (1/METERS_PER_AU) * SECONDS_PER_DAY * SECONDS_PER_DAY,
      type: types.ACCELERATION
    },

    METERS_CUBED_PER_KILOGRAMS_TIMES_TIME_SQUARED: {
      name: "meters cubed per kilograms times second squared",
      value: (1/METERS_PER_AU) * (1/METERS_PER_AU) * (1/METERS_PER_AU) /
             ((1/KILOGRAMS_PER_EARTH_MASS) * SECONDS_PER_DAY * SECONDS_PER_DAY),
      type: types.ACCELERATION
    },

    ASTRONOMICAL_FORCE: {
      name: " in Astronomical units (Earth Mass, AU, Day)",
      value: 1 * KILOGRAMS_PER_EARTH_MASS,
      type: types.GRAVITATIONAL_CONSTANT
    },

    SI_GC: {
      name: "gravitational constant of proprtionality in SI units (kg, m, s)",
      value: 1,
      type: types.GRAVITATIONAL_CONSTANT
    },

    ASTRONOMICAL_GC: {
      name: "gravitational constant of proprtionality in Astronomical units (Earth Mass, AU, Day)",
      value: 1 *
             KILOGRAMS_PER_EARTH_MASS * SECONDS_PER_DAY * SECONDS_PER_DAY /
             (METERS_PER_AU * METERS_PER_AU * METERS_PER_AU),
      type: types.GRAVITATIONAL_CONSTANT
    }

  };


  /** Provide ratios for conversion of one unit to an equivalent unit type.

     Usage:
       constants.ratio(unit.SECOND, { per: unit.DAY })  => 86400
       constants.ratio(unit.METER, { per: unit.AU }) => 6.684587122268445e-12

  */
  exports.ratio = ratio = function(from, to) {
    var checkCompatibility = function(fromUnit, toUnit) {
      if (fromUnit.type !== toUnit.type) {
        throw new Error("Attempt to convert incompatible type '" + fromUnit.name + "'' to '" + toUnit.name + "'");
      }
    };

    if (to.per) {
      checkCompatibility(from, to.per);
      return from.value / to.per.value;
    } else if (to.as) {
      checkCompatibility(from, to.as);
      return to.as.value / from.value;
    } else {
      throw new Error("units.ratio() received arguments it couldn't understand.");
    }
  };

  /** Scale 'val' to a different unit of the same type.

    Usage:
      constants.convert(1, {from: unit.DAY, to: unit.SECOND}) => 86400
      constants.convert(1, {from: unit.AU, to: unit.METER}) => 6.684587122268445e-12
      constants.convert(1, {from: unit.EARTH_MASS, to: unit.KILOGRAM}) => 5.97219e+24
      constants.convert(1, {from: unit. EARTH_MASS, to: unit.SOLAR_MASS}) => 332946

  */
  exports.convert = convert = function(val, fromTo) {
    var from = fromTo && fromTo.from,
        to   = fromTo && fromTo.to;

    if (!from) {
      throw new Error("units.convert() did not receive a \"from\" argument");
    }
    if (!to) {
      throw new Error("units.convert() did not receive a \"to\" argument");
    }

    return val * ratio(to, { per: from });
  };
});

/*global define: true */
/*jslint loopfunc: true */

/** A list of physical constants. To access any given constant, require() this module
    and call the 'as' method of the desired constant to get the constant in the desired unit.

    This module also provides a few helper functions for unit conversion.

    Usage:
      var constants = require('./constants'),

          AU_IN_METERS = constants.ASTRONOMICAL_UNIT_DISTANCE.as(constants.unit.METER),

          SOLAR_LUMINOSITY = constants.SOLAR_LUMINOSITY.as(constants.unit.WATT)

          ASTRONOMICAL_GRAVITATIONAL_CONSTANT = constants.GRAVITATIONAL_CONSTANT.as(constants.unit.ASTRONOMICAL_GC)

*/

// Module can be used both in Node.js environment and in Web browser
// using RequireJS. RequireJS Optimizer will strip out this if statement.


define('solar-system/models/engine/constants/index',['require','exports','module','./units'],function (require, exports, module) {

  var units = require('./units'),
      unit  = units.unit,
      ratio = units.ratio,
      convert = units.convert,

      constants = {

        SOLAR_LUMINOSITY: {
          value: 3.839e26,
          unit: unit.WATT
        },

        ASTRONOMICAL_UNIT_DISTANCE: {
          value: 149597870691,
          unit: unit.METER
        },

        GRAVITATIONAL_CONSTANT: {
          value: 6.67384e-11,
          unit: unit.SI_GC
        }
      },

      constantName, constant;

  // Exports

  exports.unit = unit;
  exports.ratio = ratio;
  exports.convert = convert;

  // Require explicitness about units by publishing constants as a set of objects with only an 'as' property,
  // which will return the constant in the specified unit.

  for (constantName in constants) {
    if (constants.hasOwnProperty(constantName)) {
      constant = constants[constantName];

      exports[constantName] = (function(constant) {
        return {
          as: function(toUnit) {
            return units.convert(constant.value, { from: constant.unit, to: toUnit });
          }
        };
      }(constant));
    }
  }
});

/*global define: true */
/*jslint eqnull: true, boss: true, loopfunc: true*/

define('solar-system/models/engine/solar-system',['require','exports','module','arrays','common/array-types','./constants/index','common/console','common/models/engines/clone-restore-wrapper'],function (require, exports, module) {

  var arrays                 = require('arrays'),
      arrayTypes             = require('common/array-types'),
      constants              = require('./constants/index'),
      unit                   = constants.unit,
      console                = require('common/console'),
      CloneRestoreWrapper    = require('common/models/engines/clone-restore-wrapper'),

      GRAVITATIONAL_CONSTANT = constants.GRAVITATIONAL_CONSTANT.as(constants.unit.ASTRONOMICAL_GC);

  exports.createEngine = function() {

    var // the object to be returned
        engine,

        // If a numeric value include gravitational field in force calculations,
        // otherwise value should be false
        gravitationalConstant = GRAVITATIONAL_CONSTANT,

        // Whether system dimensions have been set. This is only allowed to happen once.
        sizeHasBeenInitialized = false,

        // System dimensions as [x, y]. Default value can be changed until turles are created.
        size = [50, 50],

        // System dimensions as minX, minYm, maxX, maxY. Default value can be changed until turles are created.
        minX = -25,
        minY = -25,
        maxX =  25,
        maxY =  25,

        // The current model time in ticks.
        time = 0,

        // The current integration time step
        dt,

        // Square of integration time step.
        dt_sq,

        // ####################################################################
        //                      Body Properties

        // Individual property arrays for the bodies, indexed by body number
        radius, x, y, vx, vy, px, py, ax, ay, mass, speed,

        // An object that contains references to the above body-property arrays
        bodies,

        // The number of bodies in the system.
        N = 0,

        // booleans indicating whether the body world wraps
        horizontalWrapping,
        verticalWrapping,

        // Initializes basic data structures.
        initialize = function () {
          createBodiesArray(0);
        },

        /**
          Extend all arrays in arrayContainer to `newLength`. Here, arrayContainer is expected to be `bodies`
          `elements`, `radialBonds`, etc. arrayContainer might be an array or an object.
          TODO: this is just interim solution, in the future only objects will be expected.
        */
        extendArrays = function(arrayContainer, newLength) {
          var i, len;
          if (Array.isArray(arrayContainer)) {
            // Array of arrays.
            for (i = 0, len = arrayContainer.length; i < len; i++) {
              if (arrays.isArray(arrayContainer[i]))
                arrayContainer[i] = arrays.extend(arrayContainer[i], newLength);
            }
          } else {
            // Object with arrays defined as properties.
            for (i in arrayContainer) {
              if(arrayContainer.hasOwnProperty(i)) {
                if (arrays.isArray(arrayContainer[i]))
                  arrayContainer[i] = arrays.extend(arrayContainer[i], newLength);
              }
            }
          }
        },

        /**
          Set up "shortcut" references, e.g., x = bodies.x
        */
        assignShortcutReferences = {

          bodies: function() {
            radius         = bodies.radius;
            x              = bodies.x;
            y              = bodies.y;
            vx             = bodies.vx;
            vy             = bodies.vy;
            px             = bodies.px;
            py             = bodies.py;
            ax             = bodies.ax;
            ay             = bodies.ay;
            mass           = bodies.mass;
            speed          = bodies.speed;
            pinned         = bodies.pinned;
          }

        },


        createBodiesArray = function(num) {
          bodies  = engine.bodies  = {};

          // TODO. DRY this up by letting the property list say what type each array is
          bodies.radius         = arrays.create(num, 0, arrayTypes.float);
          bodies.x              = arrays.create(num, 0, arrayTypes.float);
          bodies.y              = arrays.create(num, 0, arrayTypes.float);
          bodies.vx             = arrays.create(num, 0, arrayTypes.float);
          bodies.vy             = arrays.create(num, 0, arrayTypes.float);
          bodies.px             = arrays.create(num, 0, arrayTypes.float);
          bodies.py             = arrays.create(num, 0, arrayTypes.float);
          bodies.ax             = arrays.create(num, 0, arrayTypes.float);
          bodies.ay             = arrays.create(num, 0, arrayTypes.float);
          bodies.mass           = arrays.create(num, 0, arrayTypes.floatType);
          bodies.speed          = arrays.create(num, 0, arrayTypes.float);
          bodies.pinned         = arrays.create(num, 0, arrayTypes.uint8);

          // For the sake of clarity, manage all bodies properties in one
          // place (engine). In the future, think about separation of engine
          // properties and view-oriented properties like these:
          bodies.marked         = arrays.create(num, 0, arrayTypes.uint8);
          bodies.visible        = arrays.create(num, 0, arrayTypes.uint8);

          assignShortcutReferences.bodies();
        },

        // Constrain Body i to the area between the walls by simulating perfectly elastic collisions with the walls.
        // Note this may change the linear and angular momentum.
        bounceBodyOffWalls = function(i) {
          var r = radius[i],
              leftwall = minX + r,
              bottomwall = minY + r,
              rightwall = maxX - r,
              topwall = maxY - r,
              width = size[0],
              height = size[1];

          if (horizontalWrapping) {
            // wrap around vertical walls
            if (x[i] + radius[i] < leftwall) {
              x[i] += width;
            } else if (x[i] - radius[i] > rightwall) {
              x[i] -= width;
            }
          } else {
            // Bounce off vertical walls.
            if (x[i] < leftwall) {
              while (x[i] < leftwall - width) {
                x[i] += width;
              }
              x[i]  = leftwall + (leftwall - x[i]);
              vx[i] *= -1;
              px[i] *= -1;
            } else if (x[i] > rightwall) {
              while (x[i] > rightwall + width) {
                x[i] -= width;
              }
              x[i]  = rightwall - (x[i] - rightwall);
              vx[i] *= -1;
              px[i] *= -1;
            }
          }

          if (verticalWrapping) {
            // wrap around horizontal walls
            if (y[i] + radius[i] < bottomwall) {
              y[i] += height;
            } else if (y[i] - radius[i] > topwall) {
              y[i] -= height;
            }
          } else {
            // Bounce off horizontal walls
            if (y[i] < bottomwall) {
              while (y[i] < bottomwall - height) {
                y[i] += height;
              }
              y[i]  = bottomwall + (bottomwall - y[i]);
              vy[i] *= -1;
              py[i] *= -1;
            } else if (y[i] > topwall) {
              while (y[i] > topwall + height) {
                y[i] -= height;
              }
              y[i]  = topwall - (y[i] - topwall);
              vy[i] *= -1;
              py[i] *= -1;
            }
          }
        },

        // Accumulate acceleration into a(t + dt) from all possible interactions, fields
        // and forces connected with bodies.
        updateBodiesAccelerations = function () {
          var i, inverseMass;

          if (N === 0) return;

          // Zero out a(t) for accumulation of forces into a(t + dt).
          for (i = 0; i < N; i++) {
            ax[i] = ay[i] = 0;
          }

          updateGravitationalAccelerations();

        },


        updateGravitationalAccelerations = function() {
          var i, j, dx, dy, rSq, gf, gfx, gfy;

          i = -1; while (++i < N) {
            m1 = mass[i];
            j = i; while (++j < N) {
              dx = x[j] - x[i];
              dy = y[j] - y[i];
              rSq = dx * dx + dy * dy;
              l = Math.sqrt(rSq);
              m2 = mass[j];
              gf = gravitationalConstant * m1 * m2 / rSq;
              gfx = dx / l * gf;
              gfy = dy / l * gf;
              ax[i] += gfx / m1;
              ay[i] += gfy / m1;
              ax[j] -= gfx / m2;
              ay[j] -= gfy / m2;
            }
          }
        },

        // Half of the update of v(t + dt) and p(t + dt) using a. During a single integration loop,
        // call once when a = a(t) and once when a = a(t+dt).
        halfUpdateVelocity = function() {
          var i, m;
          for (i = 0; i < N; i++) {
            m = mass[i];
            vx[i] += 0.5 * ax[i] * dt;
            px[i] = m * vx[i];
            vy[i] += 0.5 * ay[i] * dt;
            py[i] = m * vy[i];
          }
        },

        // Calculate r(t + dt, i) from v(t + 0.5 * dt).
        updateBodiesPosition = function() {
          var width100  = size[0] * 100,
              height100 = size[1] * 100,
              xPrev, yPrev, i;

          for (i = 0; i < N; i++) {
            xPrev = x[i];
            yPrev = y[i];

            x[i] += vx[i] * dt;
            y[i] += vy[i] * dt;

            // Bounce off walls.
            bounceBodyOffWalls(i);
          }
        },

        // Removes velocity and acceleration from pinned Bodies.
        pinBodies = function() {
          var i;

          for (i = 0; i < N; i++) {
            if (pinned[i]) {
              vx[i] = vy[i] = ax[i] = ay[i] = 0;
            }
          }
        },

        // Update speed using velocities.
        updateBodiesSpeed = function() {
          var i;

          for (i = 0; i < N; i++) {
            speed[i] = Math.sqrt(vx[i] * vx[i] + vy[i] * vy[i]);
          }
        };

        // ####################################################################
        // ####################################################################

    engine = {

      // Our timekeeping is really a convenience for users of this lib, so let them reset time at will
      setTime: function(t) {
        time = t;
      },

      setDimensions: function(v) {
        if (sizeHasBeenInitialized) {
          throw new Error("The SolarSystem model's size has already been set, and cannot be reset.");
        }
        minX = v[0];
        minY = v[1];
        maxX = v[2];
        maxY = v[3];
        size = [maxX - minX, maxY - minY];
        sizeHasBeenInitialized = true;
      },

      getDimensions: function() {
        return [minX, maxX, minY, maxY];
      },

      setHorizontalWrapping: function(v) {
        horizontalWrapping = !!v;
      },

      setVerticalWrapping: function(v) {
        verticalWrapping = !!v;
      },

      setGravitationalConstant: function(gc) {
        if (typeof gc === "number" && gc !== 0) {
          gravitationalConstant = gc;
        } else {
          gravitationalConstant = GRAVITATIONAL_CONSTANT;
        }
      },

      setBodyProperties: function (i, props) {
        var key, idx, rest, j;

        // Set all properties from props hash.
        for (key in props) {
          if (props.hasOwnProperty(key)) {
            bodies[key][i] = props[key];
          }
        }

        // Update properties which depend on other properties.
        speed[i] = Math.sqrt(vx[i] * vx[i] + vy[i] * vy[i]);
      },

      /**
        The canonical method for adding an body to the collections of bodies.

        If there isn't enough room in the 'bodies' array, it (somewhat inefficiently)
        extends the length of the typed arrays by ten to have room for more bodies.

        @returns the index of the new body
      */
      addBody: function(props) {
        if (N + 1 > bodies.x.length) {
          extendArrays(bodies, N + 10);
          assignShortcutReferences.bodies();
        }

        // Set acceleration of new body to zero.
        props.ax = props.ay = 0;

        // Increase number of bodies.
        N++;

        // Set provided properties of new body.
        engine.setBodyProperties(N - 1, props);

      },

      removeBody: function(idx) {
        var i, len, prop,
            l, list, lists;

        if (idx >= N) {
          throw new Error("Body " + idx + " doesn't exist, so it can't be removed.");
        }

        // Shift bodies properties and zero last element.
        // It can be optimized by just replacing the last
        // body with body 'i', however this approach
        // preserves more expectable bodies indexing.
        for (i = idx; i < N; i++) {
          for (prop in bodies) {
            if (bodies.hasOwnProperty(prop)) {
              if (i === N - 1)
                bodies[prop][i] = 0;
              else
                bodies[prop][i] = bodies[prop][i + 1];
            }
          }
        }

        // Update number of bodies!
        N--;

        // Update accelerations of bodies.
        updateParticlesAccelerations();
      },

      setupBodiesRandomly: function(options) {

        var
            nrows = Math.floor(Math.sqrt(N)),
            ncols = Math.ceil(N/nrows),

            i, r, c, rowSpacing, colSpacing,
            vMagnitude, vDirection, props;

        colSpacing = size[0] / (1 + ncols);
        rowSpacing = size[1] / (1 + nrows);

        // Arrange bodies in a lattice.
        i = -1;

        for (r = 1; r <= nrows; r++) {
          for (c = 1; c <= ncols; c++) {
            i++;
            if (i === N) break;
            vMagnitude = math.normal(1, 1/4);
            vDirection = 2 * Math.random() * Math.PI;

            props = {
              x:       c * colSpacing,
              y:       r * rowSpacing,
              mass:    Math.random() * 5,
              vx:      vMagnitude * Math.cos(vDirection),
              vy:      vMagnitude * Math.sin(vDirection)
            };
            props.radius = radiusFromMass(props.mass);
            engine.setBodyProperties(i, props);
          }
        }
      },

      radiusFromMass: function(m) {
        var density = 1000,
            volume = m/density,
            r;
        r = Math.pow(volume/(4/3*Math.PI), 1/3);
        return r
      },

      // Velocity Verlet integration scheme.
      // See: http://en.wikipedia.org/wiki/Verlet_integration#Velocity_Verlet
      // The current implementation is:
      // 1. Calculate: v(t + 0.5 * dt) = v(t) + 0.5 * a(t) * dt
      // 2. Calculate: r(t + dt) = r(t) + v(t + 0.5 * dt) * dt
      // 3. Derive a(t + dt) from the interaction potential using r(t + dt)
      // 4. Calculate: v(t + dt) = v(t + 0.5 * dt) + 0.5 * a(t + dt) * dt
      integrate: function(duration, _dt) {
        var steps, iloop, tStart = time;

        // How much time to integrate over, in fs.
        if (duration === undefined)  duration = 100;

        // The length of an integration timestep, in fs.
        if (_dt === undefined) _dt = 0.1;

        dt = _dt;        // dt is a closure variable that helpers need access to
        dt_sq = dt * dt; // the squared time step is also needed by some helpers.

        // Calculate accelerations a(t), where t = 0.
        // Later this is not necessary, as a(t + dt) from
        // previous step is used as a(t) in the current step.
        if (time === 0) {
          updateBodiesAccelerations();
        }

        // Number of steps.
        steps = Math.floor(duration / dt);

        for (iloop = 1; iloop <= steps; iloop++) {
          time = tStart + iloop * dt;

          // Calculate v(t + 0.5 * dt) using v(t) and a(t).
          halfUpdateVelocity();

          // Clearing the acceleration here from pinned bodies will cause the acceleration
          // to be zero for both halfUpdateVelocity methods and updateBodyPosition, freezing the body.
          pinBodies();

          // Update r(t + dt) using v(t + 0.5 * dt).
          updateBodiesPosition();

          // Accumulate accelerations into a(t + dt) from all possible interactions, fields
          // and forces connected with atoms.
          updateBodiesAccelerations();

          // Calculate v(t + dt) using v(t + 0.5 * dt) and a(t + dt).
          halfUpdateVelocity();

          // Now that we have velocity v(t + dt), update speed.
          updateBodiesSpeed();

        } // end of integration loop

      },


      getNumberOfBodies: function() {
        return N;
      },

      /**
        Compute the model state and store into the passed-in 'state' object.
        (Avoids GC hit of throwaway object creation.)
      */
      // TODO: [refactoring] divide this function into smaller chunks?
      computeOutputState: function(state) {
        var i, j,
            i1, i2, i3,
            el1, el2,
            dx, dy,
            dxij, dyij, dxkj, dykj,
            cosTheta, theta,
            r_sq, rij, rkj,
            k, dr, angleDiff,
            gravPEInMWUnits,
            // Total kinetic energy, in MW units.
            KEinMWUnits,
            // Potential energy, in eV.
            PE;

        // State to be read by the rest of the system:
        state.time           = time;
      },

      // ######################################################################
      //                State definition of the engine

      // Return array of objects defining state of the engine.
      // Each object in this list should implement following interface:
      // * .clone()        - returning complete state of that object.
      // * .restore(state) - restoring state of the object, using 'state'
      //                     as input (returned by clone()).
      getState: function() {
        return [
          // Use wrapper providing clone-restore interface to save the hashes-of-arrays
          // that represent model state.
          new CloneRestoreWrapper(bodies),

          // Save time value.
          // Create one-line wrapper to provide required interface.
          {
            clone: function () {
              return time;
            },
            restore: function(state) {
              engine.setTime(state);
            }
          }
        ];
      }
    };

    // Initialization
    initialize();

    // Finally, return Public API.
    return engine;
  };
});

/*global define: false */

define('solar-system/models/metadata',[],function() {

  return {
    mainProperties: {
      type: {
        defaultValue: "solar-system",
        immutable: true
      },
      imagePath: {
        defaultValue: "",
        immutable: true
      },
      minX: {
        defaultValue: -25,
        immutable: true
      },
      maxX: {
        defaultValue: 25,
        immutable: true
      },
      minY: {
        defaultValue: -25,
        immutable: true
      },
      maxY: {
        defaultValue: 25,
        immutable: true
      },
      width: {
        defaultValue: 50
      },
      height: {
        defaultValue: 50
      },
      unitsScheme: {
        defaultValue: "solar-system"
      },
      modelSampleRate: {
        defaultValue: "default"
      },
      timeStep: {
        defaultValue: 0.1,
        storeInTickHistory: true
      },
      timeStepsPerTick: {
        defaultValue: 50,
        storeInTickHistory: true
      },
      horizontalWrapping: {
        defaultValue: false
      },
      verticalWrapping: {
        defaultValue: false
      },
    },

    viewOptions: {
      viewPortWidth: {
        unitType: "length",
        immutable: true
      },
      viewPortHeight: {
        unitType: "length",
        immutable: true
      },
      viewPortZoom: {
        defaultValue: 1
      },
      viewPortX: {
        unitType: "length"
      },
      viewPortY: {
        unitType: "length"
      },
      viewPortDrag: {
        // Supported values:
        // - true  -> dragging is enabled.
        // - "x"   -> dragging is limited only to X axis.
        // - "y"   -> dragging is limited only yo Y axis.
        // - false -> dragging is disabled.
        defaultValue: false
      },
      showClock: {
        defaultValue: true,
        storeInTickHistory: true
      },
      showBodyTrace: {
        defaultValue: false,
        storeInTickHistory: true
      },
      bodyTraceId: {
        defaultValue: 0,
        storeInTickHistory: true
      },
      backgroundColor: {
        defaultValue: "#eeeeee"
      },
      bodyTraceColor: {
        defaultValue: "#ee8833"
      },
      markColor: {
        defaultValue: "#f8b500"
      },
      images: {
        defaultValue: []
      },
      imageMapping: {
        defaultValue: {}
      },
      textBoxes: {
        defaultValue: []
      },
      fitToParent: {
        defaultValue: false
      },
      xlabel: {
        defaultValue: false
      },
      ylabel: {
        defaultValue: false
      },
      xunits: {
        defaultValue: false
      },
      yunits: {
        defaultValue: false
      },
      controlButtons: {
        defaultValue: "play"
      },
      gridLines: {
        defaultValue: false
      },
      planetNumbers: {
        defaultValue: false
      },
      enableBodyTooltips: {
        defaultValue: false
      },
      enableKeyboardHandlers: {
        defaultValue: true
      },
      planetTraceColor: {
        defaultValue: "#6913c5"
      }
    },

    body: {
      // Required properties:
      x: {
        required: true
      },
      y: {
        required: true
      },
      vx: {
        defaultValue: 0
      },
      vy: {
        defaultValue: 0
      },
      ax: {
        defaultValue: 0,
        serialize: false
      },
      ay: {
        defaultValue: 0,
        serialize: false
      },
      mass: {
        defaultValue: 1
      },
      radius: {
      },
      pinned: {
        defaultValue: false
      },
      visible: {
        defaultValue: 1
      },
      marked: {
        defaultValue: 0
      },
      // Read-only values, can be set only by engine:
      px: {
        readOnly: true,
        serialize: false
      },
      py: {
        readOnly: true,
        serialize: false
      },
      speed: {
        readOnly: true,
        serialize: false
      }
    },

    textBox: {
      text: {
        defaultValue: ""
      },
      x: {
        defaultValue: 0,
        unitType: "length"
      },
      y: {
        defaultValue: 0,
        unitType: "length"
      },
      anchor: {
        defaultValue: "lower-left"
      },
      layer: {
        defaultValue: 1
      },
      width: {},
      height: {},
      frame: {},
      color: {},
      backgroundColor: {
        defaultValue: "white"
      },
      strokeWidthEms: {
        defaultValue: 0.03
      },
      strokeOpacity: {
        defaultValue: 1.0
      },
      rotate: {
        defaultValue: 0
      },
      fontScale: {
        defaultValue: 1
      },
      hostType: {},
      hostIndex: {},
      textAlign: {}
    }
  };
});

/*global define: false */

// Definitions of the default Solar System units. Every model property exposed by
// solar-system/models/modeler.js is in one of the unit types below.

// This particular set of definitions is for reference and for generating the correct labels on
// output properties; it's not used for computation. Unit conversions that need to happen during
// calculations in the solar-system engine itself are "baked in" using a engines constants and
// units module 'solar-system/models/engine/constants/index.js')

// Additionally, since we don't yet offer user-facing methods which do unit conversions (e.g.,
// allowing a property setter to accept an argument containing a value and a unit) there is no
// need for quantitative information in this definition.

define('solar-system/models/unit-definitions/solar-system',[],function() {
  return {
    name: "solar-system",
    translated: false,
    units: {

      length: {
        name: "Astronomical Unit",
        pluralName: "Astronomical Units",
        symbol: "AU"
      },

      mass: {
        name: "Earth Mass",
        pluralName: "Earth Masses",
        symbol: "M"
      },

      time: {
        name: "day",
        pluralName: "days",
        symbol: "D",
        displayValue: {
          unitsPerBaseUnit: 1,
          name: "day",
          pluralName: "days",
          symbol: "D"
        }
      },

      velocity: {
        name: "Astronomical Unit per day",
        pluralName: "Astronomical Units per day",
        symbol: "AU/D"
      },

      acceleration: {
        name: "Astronomical Unit per day squared",
        pluralName: "Astronomical Units per day squared",
        symbol: "AU/D"
      },

      momentum: {
        name: "Earth Mass Astronomical Unit per day",
        pluralName: "Earth Mass Astronomical Units per day",
        symbol: "MAU/D"
      },

      force: {
        name: "Earth Mass Astronomical Unit per day squared",
        pluralName: "Earth Mass Astronomical Units per day squared",
        symbol: "MAU/D"
      },

      energy: {
        name: "joules",
        pluralName: "joules",
        symbol: "J"
      },

      temperature: {
        // Not "degrees Kelvin", just "Kelvin".
        name: "Kelvin",
        // Not "Kelvins", just "Kelvin".
        pluralName: "Kelvin",
        symbol: "K"
      },

      angle: {
        name: "radian",
        pluralName: "radians",
        symbol: "rad"
      }
    }
  };
});

/*global define*/

define('solar-system/models/unit-definitions/index',['require','solar-system/models/unit-definitions/solar-system','underscore'],function(require) {
  var defs = {
        solarSystem: require('solar-system/models/unit-definitions/solar-system')
      },
      _ = require('underscore');

  return {
    get: function(name) {
      var ret;
      if (name === 'solar-system') return defs.solarSystem;

      // For any unit type not in defs[name].units (e.g., temperature does not need to be redefined
      // in MKS), fall back to the SolarSystem unit definition.
      ret = _.extend({}, defs[name]);
      ret.units = _.extend({}, defs.solarSystem.units, defs[name].units);
      return ret;
    }
  };
});

/*global define: false, d3: false, $: false */
/*jslint onevar: true devel:true eqnull: true boss: true */

define('solar-system/models/modeler',['require','arrays','common/console','solar-system/models/engine/solar-system','solar-system/models/metadata','common/models/tick-history','common/property-support','common/serialize','common/validator','solar-system/models/engine/constants/units','common/property-description','solar-system/models/unit-definitions/index','underscore'],function(require) {
  // Dependencies.
  var arrays               = require('arrays'),
      console              = require('common/console'),
      solarSystem          = require('solar-system/models/engine/solar-system'),
      metadata             = require('solar-system/models/metadata'),
      TickHistory          = require('common/models/tick-history'),
      PropertySupport      = require('common/property-support'),
      serialize            = require('common/serialize'),
      validator            = require('common/validator'),
      units                = require('solar-system/models/engine/constants/units'),
      PropertyDescription  = require('common/property-description'),
      unitDefinitions      = require('solar-system/models/unit-definitions/index'),
      _ = require('underscore');

  return function Model(initialProperties) {

    // all models created with this constructor will be of type: "solar-system"
    this.constructor.type = "solar-system";

    var model = {},
        dispatch = d3.dispatch("tick", "play", "stop", "reset", "stepForward", "stepBack",
            "seek", "addBody", "removeBody", "invalidation", "textBoxesChanged"),

        propertySupport = new PropertySupport({
          types: ["output", "parameter", "mainProperty", "viewOption"]
        }),

        defaultMaxTickHistory = 1000,
        stopped = true,
        restart = false,
        newStep = false,

        lastSampleTime,
        sampleTimes = [],

        modelOutputState,
        tickHistory,

        // SolarSystem engine.
        engine,

        // ######################### Main Data Structures #####################
        // They are initialized at the end of this function. These data strucutres
        // are mainly managed by the engine.

        // A hash of arrays consisting of arrays of planet property values
        bodies,

        // ####################################################################

        // A two dimensional array consisting of planet index numbers and planet
        // property values - in effect transposed from the planet property arrays.
        results,

        // If this is true, output properties will not be recalculated on changes
        suppressInvalidatingChangeHooks = false,

        // Invalidating change hooks might between others
        invalidatingChangeHookNestingLevel = 0,

        // The subset of outputName list, containing list of outputs which are filtered
        // by one of the built-in filters (like running average filter).
        filteredOutputNames = [],

        // Function adding new sample for filtered outputs. Other properties of filtered output
        // are stored in outputsByName object, as filtered output is just extension of normal output.
        filteredOutputsByName = {},

        // The set of units currently in effect. (Determined by the 'unitsScheme' property of the
        // model; default value is 'md2d')
        unitsDefinition,

        // Set method mixed in to model by propertySupport; model.set needs to be augmented with
        // physics-based invalidation concerns.
        baseSet,

        // The initial "main" propeties, validated and filtered from the initialProperties array
        mainProperties,

        // The initial viewOptions, validated and filtered from the initialProperties
        viewOptions;

    function defineBuiltinProperty(type, key, setter) {
      var metadataForType,
          descriptor,
          unitType;

      if (type === 'mainProperty') {
        metadataForType = metadata.mainProperties;
      } else if (type === 'viewOption') {
        metadataForType = metadata.viewOptions;
      } else {
        throw new Error(type + " is not a supported built-in property type");
      }

      descriptor = {
        type: type,
        writable: validator.propertyIsWritable(metadataForType[key]),
        set: setter,
        includeInHistoryState: !!metadataForType[key].storeInTickHistory,
        validate: function(value) {
          return validator.validateSingleProperty(metadataForType[key], key, value, false);
        }
      };

      propertySupport.defineProperty(key, descriptor);
    }

    function tick(elapsedTime, dontDispatchTickEvent) {
      var timeStep = model.get('timeStep'),
          t, sampleTime;

      // timeStepsPerTick is defined as the model integration time period
      console.time('integration');
      engine.integrate(model.get('timeStepsPerTick') * timeStep, timeStep);
      console.timeEnd('integration');
      console.time('reading model state');
      updateAllOutputProperties();
      console.timeEnd('reading model state');

      console.time('tick history push');
      tickHistory.push();
      console.timeEnd('tick history push');

      newStep = true;

      if (!dontDispatchTickEvent) {
        dispatch.tick();
      }

      return stopped;
    }

    // Returns the "raw" (untranslated) version of property 'name'. Used to provide privileged
    // access to internal representation of properties to, e.g., TickHistory.
    function getRawPropertyValue(name) {
      return properties[name];
    }

    // Returns a copy of 'obj' with value replaced by fn(key, value) for every (key, value) pair.
    // (Underscore doesn't do this: https://github.com/documentcloud/underscore/issues/220)
    function mapValues(obj, fn) {
      obj = _.extend({}, obj);
      for (var k in obj) {
        if (obj.hasOwnProperty(k)) obj[k] = fn(k, obj[k]);
      }
      return obj;
    }

    /**
      Call this method after moving to a different model time (e.g., after stepping the model
      forward or back, seeking to a different time, or on model initialization) to update all output
      properties and notify their listeners. This method is more efficient for that case than
      updateOutputPropertiesAfterChange because it can assume that all output properties are
      invalidated by the model step. It therefore does not need to calculate any output property
      values; it allows them to be evaluated lazily instead. Property values are calculated when and
      if listeners request them. This method also guarantees that all properties have their updated
      value when they are requested by any listener.

      Technically, this method first updates the 'results' array and macrostate variables, then
      invalidates any  cached output-property values, and finally notifies all output-property
      listeners.

      Note that this method and updateOutputPropertiesAfterChange are the only methods which can
      flush the cached value of an output property. Therefore, be sure to not to make changes
      which would invalidate a cached value without also calling one of these two methods.
    */
    function updateAllOutputProperties() {
      readModelState();
      propertySupport.deleteComputedPropertyCachedValues();

      // Update all filtered outputs.
      // Note that this have to be performed after invalidation of all outputs
      // (as filtered output can filter another output), but before notifying
      // listeners (as we want to provide current, valid value).
      filteredOutputNames.forEach(function(name) {
        filteredOutputsByName[name].addSample();
      });

      propertySupport.notifyAllComputedProperties();
    }

    // FIXME
    //
    // Instead of requiring balanced calls to "PreHooks" and "PostHooks", we should instead accept a
    // callback containing actions to perform in between the pre and post actions. That would be a
    // better way of ensuring that pre and post hooks are always balanced.

    /**
      ALWAYS CALL THIS FUNCTION before any change to model state outside a model step
      (i.e., outside a tick, seek, stepForward, stepBack)

      Note:  Changes to view-only property changes that cannot change model physics might reasonably
      by considered non-invalidating changes that don't require calling this hook.
    */
    function invalidatingChangePreHook() {
      if (suppressInvalidatingChangeHooks) return;
      invalidatingChangeHookNestingLevel++;

      if (invalidatingChangeHookNestingLevel === 0) {
        // If we're beginning a series of (possibly-nested) invalidating changes, store computed
        // property values so they can be compared when we finish the invalidating changes.
        propertySupport.storeComputedProperties();
        propertySupport.deleteComputedPropertyCachedValues();
        propertySupport.enableCaching = false;
      }
      invalidatingChangeHookNestingLevel++;
    }

    /**
      ALWAYS CALL THIS FUNCTION after any change to model state outside a model step.
    */
    function invalidatingChangePostHook() {
      if (suppressInvalidatingChangeHooks) return;
      invalidatingChangeHookNestingLevel--;

      if (invalidatingChangeHookNestingLevel === 0) {
        propertySupport.enableCaching = true;
      }

      // Make sure that computed properties which depend on engine state are valid
      if (engine) {
        readModelState();
      }

      // Non-filtered outputs will be valid at this point (caching is disabl;ed, so they're
      // recomputed every time.) This ensures that filtered outputs that depend on non-filtered
      // outputs are also valid:
      filteredOutputNames.forEach(function(name) {
        filteredOutputsByName[name].addSample();
      });

      if (invalidatingChangeHookNestingLevel === 0) {
        // Once we've finished the cycle of invalidating changes, go ahead and notify observers of
        // computed properties that changed.
        propertySupport.enableCaching = true;
        propertySupport.notifyChangedComputedProperties();

        if (tickHistory) tickHistory.invalidateFollowingState();
        dispatch.invalidation();
      }
    }

    /**
      Executes the closure 'extract' which extracts from the tick history, then dispatches
      addAtom/removeAtom, etc, events as needed.

      This prevents unneessary creation and removal of atoms.
    */
    var runAndDispatchObjectNumberChanges = (function() {
      var objects = [{
        getNum: 'getNumberOfBodies',
        addEvent: 'addBody',
        removeEvent: 'removeBody'
      }];

      return function (extract) {
        var i, o, newNum;
        for (i = 0; i < objects.length; i++) {
          o = objects[i];
          o.num = engine[o.getNum]();
        }

        extract();

        for (i = 0; i < objects.length; i++) {
          o = objects[i];
          newNum = engine[o.getNum]();
          if (newNum > o.num) {
            dispatch[o.addEvent]();
          } else if (newNum < o.num) {
            dispatch[o.removeEvent]();
          }
        }
      };
    })();

    /**
      This method is called to refresh the results array and macrostate variables (KE, PE,
      temperature) whenever an engine integration occurs or the model state is otherwise changed.

      Normally, you should call the methods updateOutputPropertiesAfterChange or
      updateAllOutputProperties rather than calling this method. Calling this method directly does
      not cause output-property listeners to be notified, and calling it prematurely will confuse
      the detection of changed properties.
    */
    function readModelState() {
      var i, prop, n;

      engine.computeOutputState(modelOutputState);

      resizeResultsArray();

      // Transpose 'bodies' object into 'results' for easier consumption by view code
      for (i = 0, n = model.get_num_bodies(); i < n; i++) {
        for (prop in bodies) {
          if (bodies.hasOwnProperty(prop)) {
            results[i][prop] = bodies[prop][i];
          }
        }
      }
    }

    /**
      Ensure that the 'results' array of arrays is defined and contains one typed array per atom
      for containing the atom properties.
    */
    function resizeResultsArray() {
      var i, len;

      // TODO: refactor whole approach to creation of objects from flat arrays.

      if (!results) results = [];

      for (i = results.length, len = model.get_num_bodies(); i < len; i++) {
        if (!results[i]) {
          results[i] = {
            idx: i
          };
        }
      }

      // Also make sure to truncate the results array if it got shorter (i.e., atoms were removed)
      results.length = len;
    }

    // ------------------------------------------------------------
    //
    // Public functions
    //
    // ------------------------------------------------------------

    // Adds model.properties, model.set, model.get, model.addObserver, model.removeObserver...
    propertySupport.mixInto(model);

    baseSet = model.set;

    model.set = function(key, value) {
      if (engine) invalidatingChangePreHook();
      baseSet(key, value);
      if (engine) invalidatingChangePostHook();
    };

    /**
      Add a listener callback that will be notified when any of the properties in the passed-in
      array of properties is changed. (The argument `properties` can also be a string, if only a
      single name needs to be passed.) This is a simple way for views to update themselves in
      response to property changes.
    */
    model.addPropertiesListener = function(properties, callback) {
      if (typeof properties === 'string') {
        model.addObserver(properties, callback);
      } else {
        properties.forEach(function(property) {
          model.addObserver(property, callback);
        });
      }
    };

    /**
      Add an "output" property to the model. Output properties are expected to change at every
      model tick, and may also be changed indirectly, outside of a model tick, by a change to model
      properties or the atom, element, etc. properties.

      `key` should be the name of the output. The property value will be accessed by
      `model.get(<key>);`

      `description` should be a hash of metadata about the property.

      `getter` should be a no-arg function which calculates the property value. These values are not
      translated after getter returns because we expect that most output getters are authored
      scripts, which operate entirely with already-translated units. Therefore, getters defined
      internally in modeler.js needs to make sure to translate any "md2d units" values out of the
      md2d-unit domain.
    */
    model.defineOutput = function(key, descriptionHash, getter) {
      propertySupport.defineProperty(key, {
        type: 'output',
        writable: false,
        get: getter,
        includeInHistoryState: false,
        description: new PropertyDescription(unitsDefinition, descriptionHash)
      });
    };

    /**
      Add an "filtered output" property to the model. This is special kind of output property, which
      is filtered by one of the built-in filters based on time (like running average). Note that filtered
      outputs do not specify calculate function - instead, they specify property which should filtered.
      It can be another output, model parameter or custom parameter.

      Filtered output properties are extension of typical output properties. They share all features of
      output properties, so they are expected to change at every model tick, and may also be changed indirectly,
      outside of a model tick, by a change to the model parameters or to the configuration of atoms and other
      objects in the model.

      `name` should be the name of the parameter. The property value will be accessed by
      `model.get(<name>);`

      `description` should be a hash of metadata about the property. Right now, these metadata are not
      used. However, example metadata include the label and units name to be used when graphing
      this property.

      `property` should be name of the basic property which should be filtered.

      `type` should be type of filter, defined as string. For now only "RunningAverage" is supported.

      `period` should be number defining length of time period used for calculating filtered value. It should
      be specified in femtoseconds.

    */
    model.defineFilteredOutput = function(name, description, property, type, period) {
      // Filter object.
      var filter, initialValue;

      if (type === "RunningAverage") {
        filter = new RunningAverageFilter(period);
      } else {
        throw new Error("FilteredOutput: unknown filter type " + type + ".");
      }

      initialValue = model.get(property);
      if (initialValue === undefined || isNaN(Number(initialValue))) {
        throw new Error("FilteredOutput: property is not a valid numeric value or it is undefined.");
      }

      // Add initial sample.
      filter.addSample(model.get('time'), initialValue);

      filteredOutputNames.push(name);
      // filteredOutputsByName stores properties which are unique for filtered output.
      // Other properties like description or calculate function are stored in outputsByName hash.
      filteredOutputsByName[name] = {
        addSample: function () {
          filter.addSample(model.get('time'), model.get(property));
        }
      };

      // Create simple adapter implementing TickHistoryCompatible Interface
      // and register it in tick history.
      tickHistory.registerExternalObject({
        push: function () {
          // Push is empty, as we store samples during each tick anyway.
        },
        extract: function (idx) {
          filter.setCurrentStep(idx);
        },
        invalidate: function (idx) {
          filter.invalidate(idx);
        },
        setHistoryLength: function (length) {
          filter.setMaxBufferLength(length);
        }
      });

      // Extend description to contain information about filter.
      description.property = property;
      description.type = type;
      description.period = period;

      // Filtered output is still an output.
      // Reuse existing, well tested logic for caching, observing etc.
      model.defineOutput(name, description, function () {
        return filter.calculate();
      });
    };

    /**
      Define a property of the model to be treated as a custom parameter. Custom parameters are
      (generally, user-defined) read/write properties that trigger a setter action when set, and
      whose values are automatically persisted in the tick history.

      Because custom parameters are not intended to be interpreted by the engine, but instead simply
      *represent* states of the model that are otherwise fully specified by the engine state and
      other properties of the model, and because the setter function might not limit itself to a
      purely functional mapping from parameter value to model properties, but might perform any
      arbitrary stateful change, (stopping the model, etc.), the setter is NOT called when custom
      parameters are updated by the tick history.
    */
    model.defineParameter = function(key, descriptionHash, setter) {
      var descriptor = {
            type: 'parameter',
            includeInHistoryState: true,
            invokeSetterAfterBulkRestore: false,
            description: new PropertyDescription(unitsDefinition, descriptionHash)
          };

      // In practice, some parameters are meant only to be observed, and have no setter
      if (setter) {
        descriptor.set = function(value) {
          setter.call(model, value);
        };
      }
      propertySupport.defineProperty(key, descriptor);
    };

    /**
      Current seek position
    */
    model.stepCounter = function() {
      return tickHistory.get("counter");
    };

    /**
      Current position of first value in tick history, normally this will be 0.
      This will be greater than 0 if maximum size of tick history has been exceeded.
    */
    model.stepStartCounter = function() {
      return tickHistory.get("startCounter");
    };

    /** Total number of ticks that have been run & are stored, regardless of seek
        position
    */
    model.steps = function() {
      return tickHistory.get("length");
    };

    model.isNewStep = function() {
      return newStep;
    };

    model.seek = function(location) {
      if (!arguments.length) { location = 0; }
      if (!model.isStopped()) {
        model.stop();
      }
      newStep = false;
      runAndDispatchObjectNumberChanges(function() {
        tickHistory.seekExtract(location);
        updateAllOutputProperties();
        dispatch.seek();
      });
      return tickHistory.get("counter");
    };

    model.stepBack = function(num) {
      if (!arguments.length) { num = 1; }
      if (!model.isStopped()) {
        model.stop();
      }
      newStep = false;
      runAndDispatchObjectNumberChanges(function() {
        var i, index;
        i=-1; while(++i < num) {
          index = tickHistory.get("index");
          if (index > 0) {
            tickHistory.decrementExtract();
            updateAllOutputProperties();
            dispatch.stepBack();
          }
        }
      });
      return tickHistory.get("counter");
    };

    model.stepForward = function(num) {
      if (!arguments.length) { num = 1; }
      if (!model.isStopped()) {
        model.stop();
      }
      runAndDispatchObjectNumberChanges(function() {
        var i, index, size;
        i=-1; while(++i < num) {
          index = tickHistory.get("index");
          size = tickHistory.get("length");
          if (index < size-1) {
            tickHistory.incrementExtract();
            updateAllOutputProperties();
            dispatch.stepForward();
          } else {
            tick();
          }
        }
      });
      return tickHistory.get("counter");
    };

    /**
      Initialize width and height from minX, minYm, maxX, maxY
    */
    model.initializeDimensions = function () {
      model.set({ width: model.get('maxX') - model.get('minX') });
      model.set({ height: model.get('maxY') - model.get('minY') });
    };

    /**
      Creates a new solarSystem engine and leaves it in 'engine'.
    */
    model.initializeEngine = function () {
      engine = solarSystem.createEngine();

      engine.setDimensions([model.get('minX'), model.get('minY'), model.get('maxX'), model.get('maxY')]);
      engine.setHorizontalWrapping(model.get('horizontalWrapping'));
      engine.setVerticalWrapping(model.get('verticalWrapping'));

      window.state = modelOutputState = {};

      // Copy reference to basic properties.
      bodies = engine.bodies;
    };

    /**
      Creates a new set of bodies.

      @config: either the number of bodies (for a random setup) or
               a hash specifying the x,y,vx,vy properties of the bodies
      When random setup is used, the option 'relax' determines whether the model is requested to
      relax to a steady-state temperature (and in effect gets thermalized). If false, the bodies are
      left in whatever grid the engine's initialization leaves them in.
    */
    model.createBodies = function(config) {
          // Options for addBody method.
      var options = {
            // Do not check the position of planet, assume that it's valid.
            supressCheck: true,
            // Deserialization process, invalidating change hooks will be called manually.
            deserialization: true
          },
          i, num, prop, planetProps;

      // Call the hook manually, as addBody won't do it due to
      // deserialization option set to true.
      invalidatingChangePreHook();

      if (typeof config === 'number') {
        num = config;
      } else if (config.num !== undefined) {
        num = config.num;
      } else if (config.x) {
        num = config.x.length;
      }

      // TODO: this branching based on x, y isn't very clear.
      if (config.x && config.y) {
        // config is hash of arrays (as specified in JSON model).
        // So, for each index, create object containing properties of
        // planet 'i'. Later, use these properties to add planet
        // using basic addBody method.
        for (i = 0; i < num; i++) {
          planetProps = {};
          for (prop in config) {
            if (config.hasOwnProperty(prop)) {
              planetProps[prop] = config[prop][i];
            }
          }
          if (!planetProps.radius) {
            planetProps.radius = engine.radiusFromMass(config.mass[i]);
          }
          model.addBody(planetProps, options);
        }
      } else {
        for (i = 0; i < num; i++) {
          // Provide only required values.
          planetProps = {x: 0, y: 0};
          model.addBody(planetProps, options);
        }
        // This function rearrange all bodies randomly.
        engine.setupBodiesRandomly();
      }

      // Call the hook manually, as addBody won't do it due to
      // deserialization option set to true.
      invalidatingChangePostHook();

      // Listeners should consider resetting the bodies a 'reset' event
      dispatch.reset();

      // return model, for chaining (if used)
      return model;
    };

    model.reset = function() {
      engine.setTime(0);
      tickHistory.restoreInitialState();
      dispatch.reset();
    };


    /**
      Attempts to add a body to a random location.
    */
    model.addRandomBody = function() {
      var width = model.get('width'),
          height = model.get('height'),
          minX = model.get('minX'),
          minY = model.get('minY'),
          props = {},
          radius,
          mass;

      mass = Math.random() * 10;
      radius = engine.radiusFromMass(mass);
      props = {
        x:       minX + Math.random() * width - 2*radius,
        y:       minY + Math.random() * height - 2*radius,
        vx:      (Math.random() - 0.5) / 100,
        vy:      (Math.random() - 0.5) / 100,
        mass:    mass,
        radius:  radius
      };
      model.addBody(props);
      return false;
    },

    /**
      Adds a new body defined by properties.
      Intended to be exposed as a script API method also.

      Adjusts (x,y) if needed so that the whole body is within the walls of the container.

      Returns false and does not add the planet if the potential energy change of adding an *uncharged*
      planet of the specified element to the specified location would be positive (i.e, if the planet
      intrudes into the repulsive region of another planet.)

      Otherwise, returns true.

      silent = true disables this check.
    */
    model.addBody = function(props, options) {
      var minX = model.get('minX'),
          minY = model.get('minY'),
          maxX = model.get('maxX'),
          maxY = model.get('maxY');

      options = options || {};

      // Validate properties, provide default values.
      props = validator.validateCompleteness(metadata.body, props);

      // As a convenience to script authors, bump the body within bounds
      // radius = engine.getRadiusOfElement(props.element);
      // if (props.x < (minX + radius)) props.x = minX + radius;
      // if (props.x > (maxX - radius)) props.x = maxX - radius;
      // if (props.y < (minY + radius)) props.y = minY + radius;
      // if (props.y > (maxY - radius)) props.y = maxY - radius;

      // When bodies are being deserialized, the deserializing function
      // should handle change hooks due to performance reasons.
      if (!options.deserialization)
        invalidatingChangePreHook();
      engine.addBody(props);
      if (!options.deserialization)
        invalidatingChangePostHook();

      if (!options.supressEvent) {
        dispatch.addBody();
      }

      return true;
    },

    model.removeBody = function(i, options) {

      options = options || {};

      invalidatingChangePreHook();
      engine.removeBody(i);
      // Enforce modeler to recalculate results array.
      results.length = 0;
      invalidatingChangePostHook();

      if (!options.supressEvent) {
        // Notify listeners that bodies is removed.
        dispatch.removeplanet();
      }
    },

    /**
        A generic method to set properties on a single existing planet.

        Example: setplanetProperties(3, {x: 5, y: 8, px: 0.5, charge: -1})

        This can optionally check the new location of the planet to see if it would
        overlap with another another planet (i.e. if it would increase the PE).

        This can also optionally apply the same dx, dy to any bodies in the same
        molecule (if x and y are being changed), and check the location of all
        the bonded bodies together.
      */
    model.setBodyProperties = function(i, props, checkLocation, moveMolecule) {
      var dx, dy,
          new_x, new_y,
          j, jj;

      // Validate properties.
      props = validator.validate(metadata.body, props);


      if (checkLocation) {
        var x  = typeof props.x === "number" ? props.x : bodies.x[i],
            y  = typeof props.y === "number" ? props.y : bodies.y[i];

        if (!engine.canPlaceplanet(el, x, y, i)) {
          return false;
        }
      }

      invalidatingChangePreHook();
      engine.setBodyProperties(i, props);
      invalidatingChangePostHook();
      return true;
    };

    model.getBodyProperties = function(i) {
      var planetMetaData = metadata.body,
          props = {},
          propName;
      for (propName in planetMetaData) {
        if (planetMetaData.hasOwnProperty(propName)) {
          props[propName] = bodies[propName][i];
        }
      }
      return props;
    };

    model.addTextBox = function(props) {
      props = validator.validateCompleteness(metadata.textBox, props);
      model.get('textBoxes').push(props);
      dispatch.textBoxesChanged();
    };

    model.removeTextBox = function(i) {
      var text = model.get('textBoxes');
      if (i >=0 && i < text.length) {
        model.set('textBoxes', text.slice(0,i).concat(text.slice(i+1)));
        dispatch.textBoxesChanged();
      } else {
        throw new Error("Text box \"" + i + "\" does not exist, so it cannot be removed.");
      }
    };

    model.setTextBoxProperties = function(i, props) {
      var textBox = model.get('textBoxes')[i],
          prop;

      if (textBox) {
        props = validator.validate(metadata.textBox, props);
        for (prop in props) {
          if (props.hasOwnProperty(prop)) {
            textBox[prop] = props[prop];
          }
        }
        dispatch.textBoxesChanged();
      } else {
        throw new Error("Text box \"" + i + "\" does not exist, so it cannot have properties set.");
      }
    };

    model.isStopped = function() {
      return stopped;
    };

    model.get_bodies = function() {
      return bodies;
    };

    model.get_results = function() {
      return results;
    };

    model.get_num_bodies = function() {
      return engine.getNumberOfBodies();
    };

    model.on = function(type, listener) {
      dispatch.on(type, listener);
      return model;
    };

    model.tickInPlace = function() {
      dispatch.tick();
      return model;
    };

    model.tick = function(num, opts) {
      if (!arguments.length) num = 1;

      var dontDispatchTickEvent = opts && opts.dontDispatchTickEvent || false,
          i = -1;

      while(++i < num) {
        tick(null, dontDispatchTickEvent);
      }
      return model;
    };

    model.start = function() {
      return model.resume();
    };

    /**
      Restart the model (call model.resume()) after the next tick completes.

      This is useful for changing the modelSampleRate interactively.
    */
    model.restart = function() {
      restart = true;
    };

    model.resume = function() {

      console.time('gap between frames');
      model.timer(function timerTick(elapsedTime) {
        console.timeEnd('gap between frames');
        // Cancel the timer and refuse to to step the model, if the model is stopped.
        // This is necessary because there is no direct way to cancel a d3 timer.
        // See: https://github.com/mbostock/d3/wiki/Transitions#wiki-d3_timer)
        if (stopped) return true;

        if (restart) {
          setTimeout(model.resume, 0);
          return true;
        }

        tick(elapsedTime, false);

        console.time('gap between frames');
        return false;
      });

      restart = false;
      if (stopped) {
        stopped = false;
        dispatch.play();
      }

      return model;
    };

    /**
      Repeatedly calls `f` at an interval defined by the modelSampleRate property, until f returns
      true. (This is the same signature as d3.timer.)

      If modelSampleRate === 'default', try to run at the "requestAnimationFrame rate"
      (i.e., using d3.timer(), after running f, also request to run f at the next animation frame)

      If modelSampleRate !== 'default', instead uses setInterval to schedule regular calls of f with
      period (1000 / sampleRate) ms, corresponding to sampleRate calls/s
    */
    model.timer = function(f) {
      var intervalID,
          sampleRate = model.get("modelSampleRate");

      if (sampleRate === 'default') {
        // use requestAnimationFrame via d3.timer
        d3.timer(f);
      } else {
        // set an interval to run the model more slowly.
        intervalID = window.setInterval(function() {
          if ( f() ) {
            window.clearInterval(intervalID);
          }
        }, 1000/sampleRate);
      }
    };

    model.stop = function() {
      stopped = true;
      dispatch.stop();
      return model;
    };

    /**
      Return a unitDefinition in the current unitScheme for a quantity
      such as 'length', 'mass', etc.
    */
    model.getUnitDefinition = function(name) {
      return unitsDefinition.units[name];
    };

    // FIXME: Broken!! Includes property setter methods, does not include radialBonds, etc.
    model.serialize = function() {
      var propCopy = {},
          ljProps, i, len,

          removebodiesArrayIfDefault = function(name, defaultVal) {
            if (propCopy.bodies[name].every(function(i) {
              return i === defaultVal;
            })) {
              delete propCopy.bodies[name];
            }
          };

      propCopy = serialize(metadata.mainProperties, properties);
      propCopy.viewOptions = serialize(metadata.viewOptions, properties);
      propCopy.bodies = serialize(metadata.body, bodies, engine.getNumberOfBodies());

      // Remove bodyTraceId when body tracing is disabled.
      if (propCopy.viewOptions.showBodyTrace === false) {
        delete propCopy.viewOptions.bodyTraceId;
      }

      removebodiesArrayIfDefault("marked", metadata.body.marked.defaultValue);
      removebodiesArrayIfDefault("visible", metadata.body.visible.defaultValue);

      return propCopy;
    };

    // ------------------------------
    // finish setting up the model
    // ------------------------------

    (function () {
      if (!initialProperties.viewOptions || !initialProperties.viewOptions.textBoxes) {
        return;
      }
      // Temporal workaround to provide text boxes validation.
      // Note that text boxes are handled completely different from other objects
      // like atoms or obstacles. There is much of inconsistency and probably
      // it should be refactored anyway.
      var textBoxes = initialProperties.viewOptions.textBoxes,
          i, len;

      for (i = 0, len = textBoxes.length; i < len; i++) {
        textBoxes[i] = validator.validateCompleteness(metadata.textBox, textBoxes[i]);
      }
    }());
    viewOptions = validator.validateCompleteness(metadata.viewOptions, initialProperties.viewOptions || {});

    // Set the regular, main properties. Note that validation process will return hash without all
    // properties which are not defined in meta model as mainProperties (like atoms, obstacles,
    // viewOptions etc).
    mainProperties = validator.validateCompleteness(metadata.mainProperties, initialProperties);

    // Set up units scheme.
    unitsDefinition = unitDefinitions.get(mainProperties.unitsScheme);

    // ------------------------------
    // Define toplevel properties of the model
    // ------------------------------

    // Add all the mainProperties, with custom setters defined below
    (function() {
      var customSetters = {
        modelSampleRate: function() {
          if (!stopped) model.restart();
        }
      };

      Object.keys(metadata.mainProperties).forEach(function(key) {
        defineBuiltinProperty('mainProperty', key, customSetters[key]);
      });
      propertySupport.setRawValues(mainProperties);
    })();

    // Define and set the model view options. None of these have custom setters.
    Object.keys(metadata.viewOptions).forEach(function(key) {
      defineBuiltinProperty('viewOption', key);
    });
    propertySupport.setRawValues(viewOptions);

    // Initialize minX, minYm, maxX, maxY from model width and height
    // if they are undefined.
    model.initializeDimensions();

    // Setup engine object.
    model.initializeEngine();

    // Finally, if provided, set up the model objects (bodies).
    // However if these are not provided, client code can create bodies, etc piecemeal.

    if (initialProperties.bodies) {
      model.createBodies(initialProperties.bodies);
    }

    // Initialize tick history.
    tickHistory = new TickHistory({
      getProperties: function() {
        return propertySupport.historyStateRawValues;
      },
      restoreProperties: propertySupport.setRawValues,
      state: engine.getState()
    }, model, defaultMaxTickHistory);

    newStep = true;

    // set up types of all properties before any third-party calls to set/get
    mainPropertyUnitTypes = {};
    _.each(metadata.mainProperties, function(value, key) {
      if (value.unitType) {
        mainPropertyUnitTypes[key] = {
          unitType: value.unitType
        };
      }
    });

    // Define some default output properties.
    model.defineOutput('time', {
      label: "Time",
      unitType: 'time',
      format: 'f'
    }, function() {
      return modelOutputState.time;
    });

    model.defineOutput('timePerTick', {
      label: "Model time per tick",
      unitType: 'time',
      format: 'f'
    }, function() {
      return model.get('timeStep') * model.get('timeStepsPerTick');
    });

    (function() {
      var displayTimeUnits;

      // Allow units definition to declare a "Display time"; specifically, let MD2D units definition
      // define a "displayValue" section in the time unit that returns ps instead of fs.

      if (unitsDefinition.units.time.displayValue) {
        displayTimeUnits = unitsDefinition.units.time.displayValue;
      } else {
        displayTimeUnits = _.extend({}, unitsDefinition.units.time);
        displayTimeUnits.unitsPerBaseUnit = 1;
      }

      model.defineOutput('displayTime', {
        label: "Time",
        unitName:         displayTimeUnits.name,
        unitPluralName:   displayTimeUnits.pluralName,
        unitAbbreviation: displayTimeUnits.symbol,
        format: '.1f'
      }, function() {
        return model.get('time') * displayTimeUnits.unitsPerBaseUnit;
      });

      model.defineOutput('displayTimePerTick', {
        label: "Model time per tick",
        unitName:         displayTimeUnits.name,
        unitPluralName:   displayTimeUnits.pluralName,
        unitAbbreviation: displayTimeUnits.symbol,
        format: '.3f'
      }, function() {
        return model.get('timePerTick') * displayTimeUnits.unitsPerBaseUnit;
      });
    }());

    model.defineOutput('tickCounter', {
      label: "Tick Counter",
      unitType: '',
      format: '4g'
    }, function() {
      return tickHistory.get("counter");
    });

    model.defineOutput('newStep', {
      label: "New Step",
      unitType: '',
      format: ''
    }, function() {
      return newStep;
    });

    updateAllOutputProperties();

    return model;
  };
});

/*global $ alert ACTUAL_ROOT model_player define: false, d3: false */
// ------------------------------------------------------------
//
//   SolarSystem View Renderer
//
// ------------------------------------------------------------
define('solar-system/views/renderer',['require','lab.config','common/console','cs!common/layout/wrap-svg-text','common/views/gradients'],function (require) {
  // Dependencies.
  var labConfig             = require('lab.config'),
      console               = require('common/console'),
      wrapSVGText           = require('cs!common/layout/wrap-svg-text'),
      gradients             = require('common/views/gradients');

  return function SolarSystemView(SVGContainer, model) {
    // Public API object to be returned.
    var api = {},

        modelWidth,
        modelHeight,
        modelMinX2,
        modelMinY2,
        modelMaxX2,
        modelMaxY2,
        aspectRatio,

        // Basic scaling functions for position, it transforms model units to "pixels".
        // Use it for positions of objects rendered inside the view.
        model2px,

        // Inverted scaling function for position transforming model units to "pixels".
        // Use it for Y coordinates, as Y axis in model coordinate system increases
        // from bottom to top, while but SVG has increases from top to bottom
        model2pxInv,

        // The model function get_results() returns a 2 dimensional array
        // of particle indices and properties that is updated every model tick.
        // This array is not garbage-collected so the view can be assured that
        // the latest results will be in this array when the view is executing
        modelResults,

        // "Containers" - SVG g elements used to position layers of the final visualization.
        imageContainerBelow  = SVGContainer.viewport.append("g").attr("class", "image-container-below"),
        textContainerBelow   = SVGContainer.viewport.append("g").attr("class", "text-container-below"),
        mainContainer        = SVGContainer.viewport.append("g").attr("class", "main-container"),
        imageContainerTop    = SVGContainer.viewport.append("g").attr("class", "image-container-top"),
        textContainerTop     = SVGContainer.viewport.append("g").attr("class", "text-container-top"),

        // Array which defines a gradient assigned to a given astromonicalBody.
        gradientNameForBody = [],

        astromonicalBodyTooltipOn,

        astromonicalBody,
        label, labelEnter,
        astromonicalBodyDiv, astromonicalBodyDivPre,

        fontSizeInPixels,
        textBoxFontSizeInPixels,

        imageProp,
        imageMapping,
        modelImagePath,
        imageSizes = [],
        textBoxes,
        imagePath,

        drawBodyTrace,
        bodyTraceId,
        bodyTraceColor,
        bodyTrace,
        bodyTracePath,
        bodyTraceMaxLength = 35500,
        traceBodyStrokeWidth;

    /**
     * Setups set of gradient which can be changed by the user.
     * They should be recreated during each reset / repaint operation.
     * @private
     */
    function setupDynamicGradients() {
      var i, color, lightColor, medColor, darkColor;

      // "Marked" particle gradient.
      medColor   = model.get("markColor");
      // Mark color defined in JSON defines medium color of a gradient.
      color      = d3.rgb(medColor);
      lightColor = color.brighter(1).toString();
      darkColor  = color.darker(1).toString();
      gradients.createRadialGradient("mark-grad", lightColor, medColor, darkColor, mainContainer);
      gradients.createRadialGradient("neutral-grad", "#FFFFFF", "#f2f2f2", "#A4A4A4", mainContainer);
    }

    // Returns gradient appropriate for a given astromonicalBody.
    // d - astromonicalBody data.
    function getBodyGradient(d) {
      if (d.marked) {
        return "url(#mark-grad)";
      } else {
        return "url(#neutral-grad)";
      }
    }

    function updateBodyRadius() {
      mainContainer.selectAll("circle").data(modelResults).attr("r",  function(d) { return model2px(d.radius); });
    }

    function setupColorsOfBodies() {
      var i, len;

      gradientNameForBody.length = modelResults.length;
      for (i = 0, len = modelResults.length; i < len; i++)
        gradientNameForBody[i] = getBodyGradient(modelResults[i]);
    }

    function setupBodies() {

      mainContainer.selectAll("circle").remove();
      mainContainer.selectAll("g.label").remove();

      astromonicalBody = mainContainer.selectAll("circle").data(modelResults);

      astromonicalBodyEnter();

      label = mainContainer.selectAll("g.label")
          .data(modelResults);

      labelEnter = label.enter().append("g")
          .attr("class", "label")
          .attr("transform", function(d) {
            return "translate(" + model2px(d.x) + "," + model2pxInv(d.y) + ")";
          });

      labelEnter.each(function (d) {
        var selection = d3.select(this),
            txtValue, txtSelection;
        // Append appropriate label. For now:
        // If 'astromonicalBodyNumbers' option is enabled, use indices.
        // If not and there is available 'label'/'symbol' property, use one of them
        if (model.get("astromonicalBodyNumbers")) {
          selection.append("text")
            .text(d.idx)
            .style("font-size", model2px(1.4 * d.radius) + "px");
        }
        // Set common attributes for labels (+ shadows).
        txtSelection = selection.selectAll("text");
        // Check if node exists and if so, set appropriate attributes.
        if (txtSelection.node()) {
          txtSelection
            .attr("pointer-events", "none")
            .style({
              "font-weight": "bold",
              "opacity": 0.7
            });
          txtSelection
            .attr({
              // Center labels, use real width and height.
              // Note that this attrs should be set *after* all previous styling options.
              // .node() will return first node in selection. It's OK - both texts
              // (label and its shadow) have the same dimension.
              "x": -txtSelection.node().getComputedTextLength() / 2,
              "y": "0.31em"//bBox.height / 4
            });
        }
        // Set common attributes for shadows.
        selection.select("text.shadow")
          .style({
            "stroke": "#fff",
            "stroke-width": 0.15 * model2px(d.radius),
            "stroke-opacity": 0.7
          });
      });
    }

    function setupBodyTrace() {
      mainContainer.selectAll("path.bodyTrace").remove();
      bodyTracePath = "";

      drawBodyTrace = model.get("showBodyTrace");
      bodyTraceId = model.get("bodyTraceId");
      if (drawBodyTrace) {
        bodyTrace = mainContainer.selectAll("path.bodyTrace").data([modelResults[bodyTraceId]]);
        bodyTraceEnter();
      }
    }

    /**
      Call this wherever a d3 selection is being used to add circles for astromonicalBodys
    */

    function astromonicalBodyEnter() {
      astromonicalBody.enter().append("circle")
          .attr({
            "r":  function(d) {
              return model2px(d.radius); },
            "cx": function(d) {
              return model2px(d.x); },
            "cy": function(d) {
              return model2pxInv(d.y); },
            "fill-opacity": function(d) {
              return d.visible; },
            "fill": function (d, i) {
              return gradientNameForBody[i]; }
          })
          .on("mousedown", astromonicalBodyMouseDown)
          .on("mouseover", astromonicalBodyMouseOver)
          .on("mouseout", astromonicalBodyMouseOut);
    }

    function astromonicalBodyUpdate() {
      astromonicalBody.attr({
        "r":  function(d) {
          return model2px(d.radius); },
        "cx": function(d) {
          return model2px(d.x); },
        "cy": function(d) {
          return model2pxInv(d.y); }
      });

      if (astromonicalBodyTooltipOn === 0 || astromonicalBodyTooltipOn > 0) {
        renderBodyTooltip(astromonicalBodyTooltipOn);
      }
    }

    function astromonicalBodyMouseOver(d, i) {
      if (model.get("enableBodyTooltips")) {
        renderBodyTooltip(i);
      }
    }

    function astromonicalBodyMouseDown(d, i) {
      SVGContainer.node.focus();
      if (model.get("enableBodyTooltips")) {
        if (astromonicalBodyTooltipOn !== false) {
          astromonicalBodyDiv.style("opacity", 1e-6);
          astromonicalBodyDiv.style("display", "none");
          astromonicalBodyTooltipOn = false;
        } else {
          if (d3.event.shiftKey) {
            astromonicalBodyTooltipOn = i;
          } else {
            astromonicalBodyTooltipOn = false;
          }
          renderBodyTooltip(i);
        }
      }
    }

    function updateBodyTrace() {
      bodyTrace.attr({
        "d": getBodyTracePath
      });
    }

    function bodyTraceEnter() {
      bodyTrace.enter().append("path")
        .attr({
          "class": "bodyTrace",
          "d": getBodyTracePath,
          "stroke-width": traceBodyStrokeWidth,
          "stroke": bodyTraceColor,
          "fill": "none"
        });
    }

    function getBodyTracePath(d) {
      // until we implement buffered array model output properties,
      // we just keep the path history in the path string
      var dx = Math.floor(model2px(d.x) * 100) / 100,
          dy = Math.floor(model2pxInv(d.y) * 100) / 100,
          lIndex, sIndex;
      if (!bodyTracePath) {
        bodyTracePath = "M"+dx+","+dy+"L";
        return "M "+dx+","+dy;
      } else {
        bodyTracePath += dx+","+dy + " ";
      }

      // fake buffered array functionality by knocking out the first
      // element of the string when we get too big
      if (bodyTracePath.length > bodyTraceMaxLength) {
        lIndex = bodyTracePath.indexOf("L");
        sIndex = bodyTracePath.indexOf(" ");
        bodyTracePath = "M" + bodyTracePath.slice(lIndex+1, sIndex) + "L" + bodyTracePath.slice(sIndex+1);
      }
      return bodyTracePath;
    }

    function renderBodyTooltip(i) {
      astromonicalBodyDiv
            .style("opacity", 1.0)
            .style("display", "inline")
            .style("background", "rgba(100%, 100%, 100%, 0.7)")
            .style("left", model2px(modelResults[i].x) + 60 + "px")
            .style("top",  model2pxInv(modelResults[i].y) + 30 + "px")
            .style("zIndex", 100)
            .transition().duration(250);

      astromonicalBodyDivPre.text(
          "astromonicalBody: " + i + "\n" +
          "time: " + modelTimeLabel() + "\n" +
          "speed: " + d3.format("+6.3e")(modelResults[i].speed) + "\n" +
          "vx:    " + d3.format("+6.3e")(modelResults[i].vx)    + "\n" +
          "vy:    " + d3.format("+6.3e")(modelResults[i].vy)    + "\n" +
          "ax:    " + d3.format("+6.3e")(modelResults[i].ax)    + "\n" +
          "ay:    " + d3.format("+6.3e")(modelResults[i].ay)    + "\n"
        );
    }

    function astromonicalBodyMouseOut() {
      if (!astromonicalBodyTooltipOn && astromonicalBodyTooltipOn !== 0) {
        astromonicalBodyDiv.style("opacity", 1e-6).style("zIndex" -1);
      }
    }

    function setupTooTips() {
      if ( astromonicalBodyDiv === undefined) {
        astromonicalBodyDiv = d3.select("body").append("div")
            .attr("class", "tooltip")
            .style("opacity", 1e-6);
        astromonicalBodyDivPre = astromonicalBodyDiv.append("pre");
      }
    }

    //
    // *** Main Renderer functions ***
    //

    function setupRendererOptions() {
      imageProp = model.get("images");
      imageMapping = model.get("imageMapping");
      modelImagePath = model.get('imagePath');
      if (modelImagePath) {
        imagePath = labConfig.actualRoot + modelImagePath;
      }
      else if (SVGContainer.url) {
        imagePath = labConfig.actualRoot + SVGContainer.url.slice(0, SVGContainer.url.lastIndexOf("/") + 1);
      }

      bodyTraceColor = model.get("bodyTraceColor");
    }

    //
    // SolarSystem Renderer: init
    //
    // Called when Renderer is created.
    //
    function init() {
      model2px = SVGContainer.model2px;
      model2pxInv = SVGContainer.model2pxInv;

      fontSizeInPixels = SVGContainer.getFontSizeInPixels();
      textBoxFontSizeInPixels = fontSizeInPixels * 0.9;
      traceBodyStrokeWidth = fontSizeInPixels/12;

      modelResults  = model.get_results();
      modelWidth    = model.get('width');
      modelHeight   = model.get('height');
      aspectRatio   = modelWidth / modelHeight;

      setupRendererOptions();

      modelMinX = model.get('minX');
      modelMinY = model.get('minY');
      modelMaxX = model.get('maxX');
      modelMaxY = model.get('maxY');

      setupTooTips();

      function redrawClickableObjects (redrawOperation) {
        return function () {
          redrawOperation();
          // All objects where repainted (probably removed and added again), so
          // it's necessary to apply click handlers again.
          SVGContainer.updateClickHandlers();
        };
      }

      // Redraw container each time when some visual-related property is changed.
      model.addPropertiesListener([
        "showBodyTrace", "bodyTraceId",
        "backgroundColor", "markColor"],
          redrawClickableObjects(repaint));

      // Redraw container each time when some visual-related property is changed.
      model.on('addBody', redrawClickableObjects(repaint));
      model.on('removeBody', redrawClickableObjects(repaint));
    }

    // Call when model is reset or reloaded.
    function bindModel(newModel) {
      model = newModel;
      init();
    }

    //
    // SolarSystem Renderer: repaint
    //
    // Call when container being rendered into changes size, in that case
    // pass in new D3 scales for model2px transformations.
    //
    // Also call when the number of objects changes such that the container
    // must be setup again.
    //
    function repaint(m2px, m2pxInv) {
      if (arguments.length) {
        model2px = m2px;
        model2pxInv = m2pxInv;
      }
      fontSizeInPixels = SVGContainer.getFontSizeInPixels();
      textBoxFontSizeInPixels = fontSizeInPixels * 0.9;

      setupDynamicGradients();
      setupBodyTrace();
      setupColorsOfBodies();
      setupBodies();
    }

    //
    // SolarSystem Renderer: update
    //
    // Call to update visualization when model result state changes.
    // Normally called on every model tick.
    //
    function update() {
      console.time('view update');

      astromonicalBodyUpdate();

      if (drawBodyTrace) {
        updateBodyTrace();
      }

      console.timeEnd('view update');
    }


    //
    // Public API to instantiated Renderer
    //
    api = {
      // Expose private methods.
      update: update,
      repaint: repaint,
      bindModel: bindModel,
      model2px: SVGContainer.model2px,
      model2pxInv: SVGContainer.model2pxInv
    };

    return api;
  };
});

/*global define: false */

define('solar-system/views/view',['require','common/views/svg-container','solar-system/views/renderer'],function (require) {
  var SVGContainer = require("common/views/svg-container"),
      Renderer     = require("solar-system/views/renderer");

  return function (model, modelUrl) {
    return new SVGContainer(model, modelUrl, Renderer);
  };
});

/*global define model */

define('solar-system/controllers/scripting-api',['require'],function (require) {

  /**
    Define the model-specific SolarSystem scripting API used by 'action' scripts on interactive elements.

    The universal Interactive scripting API is extended with the properties of the
    object below which will be exposed to the interactive's 'action' scripts as if
    they were local vars. All other names (including all globals, but excluding
    Javascript builtins) will be unavailable in the script context; and scripts
    are run in strict mode so they don't accidentally expose or read globals.

    @param: api
  */


  return function SolarSystemScriptingAPI (api) {

    return {
      /* Returns number of bodies in the system. */
      getNumberOfBodies: function getNumberOfBodies() {
        return model.get_num_bodies();
      },

      addBody: function addBody(props, options) {
        if (options && options.supressRepaint) {
          // Translate supressRepaint option to
          // option understable by modeler.
          // supresRepaint is a conveniance option for
          // Scripting API users.
          options.supressEvent = true;
        }
        return model.addBody(props, options);
      },

      /*
        Removes planet 'i'.
      */
      removeBody: function removeBody(i, options) {
        if (options && options.supressRepaint) {
          // Translate supressRepaint option to
          // option understable by modeler.
          // supresRepaint is a conveniance option for
          // Scripting API users.
          options.supressEvent = true;
          delete options.supressRepaint;
        }
        try {
          model.removeBody(i, options);
        } catch (e) {
          if (!options || !options.silent)
            throw e;
        }
      },

      addRandomBody: function addRandomBody() {
        return model.addRandomBody.apply(model, arguments);
      },

      /** returns a list of integers corresponding to bodies in the system */
      randomBodies: function randomBodies(n) {
        var numBodies = model.get_num_bodies();

        if (n === null) n = 1 + api.randomInteger(numBodies-1);

        if (!api.isInteger(n)) throw new Error("randomBodies: number of bodies requested, " + n + ", is not an integer.");
        if (n < 0) throw new Error("randomBodies: number of bodies requested, " + n + ", was less be greater than zero.");

        if (n > numBodies) n = numBodies;
        return api.choose(n, numBodies);
      },

      /**
        Accepts planet indices as arguments, or an array containing planet indices.
        Unmarks all bodies, then marks the requested planet indices.
        Repaints the screen to make the marks visible.
      */
      markBodies: function markBodies() {
        var i,
            len;

        if (arguments.length === 0) return;

        // allow passing an array instead of a list of planet indices
        if (api.isArray(arguments[0])) {
          return markBodies.apply(null, arguments[0]);
        }

        api.unmarkAllBodies();

        // mark the requested bodies
        for (i = 0, len = arguments.length; i < len; i++) {
          model.setBodyProperties(arguments[i], {marked: 1});
        }
        api.repaint();
      },

      unmarkAllBodies: function unmarkAllBodies() {
        for (var i = 0, len = model.get_num_bodies(); i < len; i++) {
          model.setBodyProperties(i, {marked: 0});
        }
        api.repaint();
      },

      traceBody: function traceBody(i) {
        if (i === null) return;

        model.set({bodyTraceId: i});
        model.set({showBodyTrace: true});
      },

      untraceBody: function untraceBody() {
        model.set({showBodyTrace: false});
      },

      /**
        Sets individual planet properties using human-readable hash.
        e.g. setBodyProperties(5, {x: 1, y: 0.5, charge: 1})
      */
      setBodyProperties: function setBodyProperties(i, props, checkLocation, moveBody, options) {
        model.setBodyProperties(i, props, checkLocation, moveBody);
        if (!(options && options.supressRepaint)) {
          api.repaint();
        }
      },

      /**
        Returns planet properties as a human-readable hash.
        e.g. getBodyProperties(5) --> {x: 1, y: 0.5, charge: 1, ... }
      */
      getBodyProperties: function getBodyProperties(i) {
        return model.getBodyProperties(i);
      },

      addTextBox: function(props) {
        model.addTextBox(props);
      },

      removeTextBox: function(i) {
        model.removeTextBox(i);
      },

      setTextBoxProperties: function(i, props) {
        model.setTextBoxProperties(i, props);
      }

    };

  };
});

/*global define model */

define('solar-system/benchmarks/benchmarks',['require'],function (require) {

  return function Benchmarks(controller) {

    var benchmarks = [
      {
        name: "commit",
        numeric: false,
        run: function(done) {
          var link = "<a href='"+Lab.version.repo.commit.url+"' class='opens-in-new-window' target='_blank'>"+Lab.version.repo.commit.short_sha+"</a>";
          if (Lab.version.repo.dirty) {
            link += " <i>dirty</i>";
          }
          done(link);
        }
      },
      {
        name: "bodies",
        numeric: true,
        run: function(done) {
          done(model.get_num_bodies());
        }
      },
      {
        name: "just graphics (steps/s)",
        numeric: true,
        formatter: d3.format("5.1f"),
        run: function(done) {
          var elapsed, start, i;

          model.stop();
          start = +Date.now();
          i = -1;
          while (i++ < 100) {
            controller.modelContainer.update();
          }
          elapsed = Date.now() - start;
          done(100/elapsed*1000);
        }
      },
      {
        name: "model (steps/s)",
        numeric: true,
        formatter: d3.format("5.1f"),
        run: function(done) {
          var elapsed, start, i;

          model.stop();
          start = +Date.now();
          i = -1;
          while (i++ < 100) {
            // advance model 1 tick, but don't paint the display
            model.tick(1, { dontDispatchTickEvent: true });
          }
          elapsed = Date.now() - start;
          done(100/elapsed*1000);
        }
      },
      {
        name: "model+graphics (steps/s)",
        numeric: true,
        formatter: d3.format("5.1f"),
        run: function(done) {
          var start, elapsed, i;

          model.stop();
          start = +Date.now();
          i = -1;
          while (i++ < 100) {
            model.tick();
          }
          elapsed = Date.now() - start;
          done(100/elapsed*1000);
        }
      },
      {
        name: "fps",
        numeric: true,
        formatter: d3.format("5.1f"),
        run: function(done) {
          // warmup
          model.start();
          setTimeout(function() {
            model.stop();
            var start = model.get('time');
            setTimeout(function() {
              // actual fps calculation
              model.start();
              setTimeout(function() {
                model.stop();
                var elapsedModelTime = model.get('time') - start;
                done( elapsedModelTime / (model.get('timeStepsPerTick') * model.get('timeStep')) / 2 );
              }, 2000);
            }, 100);
          }, 1000);
        }
      },
      {
        name: "interactive",
        numeric: false,
        run: function(done) {
          done(window.location.pathname + window.location.hash);
        }
      }
    ];

    return benchmarks;

  }

});

/*global
  define
*/
/*jslint onevar: true*/
define('solar-system/controllers/controller',['require','common/controllers/model-controller','solar-system/models/modeler','solar-system/views/view','solar-system/controllers/scripting-api','solar-system/benchmarks/benchmarks'],function (require) {
  // Dependencies.
  var ModelController   = require("common/controllers/model-controller"),
      Model             = require('solar-system/models/modeler'),
      ModelContainer    = require('solar-system/views/view'),
      ScriptingAPI      = require('solar-system/controllers/scripting-api'),
      Benchmarks        = require('solar-system/benchmarks/benchmarks');

  return function (modelUrl, modelOptions, interactiveController) {
    return new ModelController(modelUrl, modelOptions, interactiveController,
                                     Model, ModelContainer, ScriptingAPI, Benchmarks);
  }
});

/*global define: false */

define('signal-generator/metadata',[],function() {

  return {
    mainProperties: {
      type: {
        defaultValue: "signal-generator",
        immutable: true
      },
      frequency: {
        defaultValue: 1,
        unitType: "frequency",
        propertyChangeInvalidates: true
      },
      modelSampleRate: {
        defaultValue: 60,
        propertyChangeInvalidates: true
      },
      timeScale: {
        defaultValue: 1,
        unitType: "time",
        propertyChangeInvalidates: true
      }
    },
    viewOptions: {
      showClock: {
        defaultValue: true,
        propertyChangeInvalidates: false
      },
      controlButtons: {
        defaultValue: "play_reset",
        propertyChangeInvalidates: false
      }
    }
  };
});

/*global define: false */

define('signal-generator/modeler',['require','common/lab-modeler-mixin','common/validator','signal-generator/metadata'],function(require) {

  var LabModelerMixin         = require('common/lab-modeler-mixin'),
      validator               = require('common/validator'),
      metadata                = require('signal-generator/metadata'),

      unitsDefinition = {
        units: {
          time: {
            name: "second",
            pluralName: "seconds",
            symbol: "s"
          },
          frequency: {
            name: "Hertz",
            pluralName: "Hertz",
            symbol: "Hz"
          },
          angle: {
            name: "radian",
            pluralName: "radians",
            symbol: "rad"
          }
        }
      };

  return function Model(initialProperties) {
    var customSetters = {
          // Ensure that phase + (time * angular frequency) remains unchanged when the frequency changes.
          // This makes for continuous signals.
          frequency: function (newFrequency) {
            if (lastFrequency !== undefined) {
              phase = constrain(phase + 2 * Math.PI * (lastFrequency - newFrequency) * model.properties.time);
            }
            lastFrequency = newFrequency;
          }
        },

        labModelerMixin = new LabModelerMixin({
          metadata: metadata,
          setters: customSetters,
          unitsDefinition: unitsDefinition,
          initialProperties: initialProperties
        }),
        dispatch = labModelerMixin.dispatchSupport,

        lastFrequency,
        phase = 0,
        time = 0,
        stepCounter = 0,
        model;

    function constrain(angle) {
      return angle - 2 * Math.PI * Math.floor(angle / (2 * Math.PI));
    }

    model = {

      tick: function () {
        var intervalLength = 1000 / model.properties.modelSampleRate;

        stepCounter++;
        time += (0.001 * intervalLength * model.properties.timeScale);

        model.updateAllOutputProperties();

        dispatch.tick();
      },

      stepCounter: function() {
        return stepCounter;
      }
    };

    labModelerMixin.mixInto(model);
    dispatch.addEventTypes("tick");

    model.defineOutput('time', {
      label: "Time",
      unitType: 'time',
      format: '.2f'
    }, function() {
      return time;
    });

    model.defineOutput('displayTime', {
      label: "Time",
      unitType: 'time',
      format: '.2f'
    }, function() {
      return time;
    });

    model.defineOutput('signalValue', {
      label: "Signal Value",
      format: '.2f'
    }, function() {
      return Math.cos(model.properties.angle);
    });

    model.defineOutput('angle', {
      label: "Angle",
      unitType: 'angle',
      format: '.2f'
    }, function() {
      var angle = phase + 2 * Math.PI * model.properties.frequency * model.properties.time;
      return constrain(angle);
    });

    return model;
  };
});

/*global define: false $: false */

/**
  For use with models that do not need an associated view, but which (at least for now) are required
  by the common ModelController to have a ModelContainer which has an $el property and which
  responds to certain methods.
*/

define('common/views/null-model-view',[],function() {
  return function() {
    return  {
      $el: $("<div id='model-container' class='container'/>"),
      getHeightForWidth: function() { return 0; },
      resize: function() {},
      bindModel: function() {},
      setup: function() {},
      update: function() {}
    };
  };
});

/*global define $ */

define('signal-generator/controller',['require','common/controllers/model-controller','signal-generator/modeler','common/views/null-model-view'],function (require) {
  // Dependencies.
  var ModelController   = require('common/controllers/model-controller'),
      Model             = require('signal-generator/modeler'),
      ModelContainer    = require('common/views/null-model-view'),
      ScriptingAPI      = function() {},
      Benchmarks        = function() {};

  return function (modelUrl, modelOptions, interactiveController) {
    return new ModelController(modelUrl, modelOptions, interactiveController,
                               Model, ModelContainer, ScriptingAPI, Benchmarks);
  };
});

/*global define: false */

define('sensor/metadata',[],function() {

  return {
    mainProperties: {
      type: {
        defaultValue: "sensor",
        immutable: true
      },
      sensorType: {
        defaultValue: 'goMotion'
      },
      samplesPerSecond: {
        readOnly: true
      }
    },
    viewOptions: {
      showClock: {
        defaultValue: true,
        propertyChangeInvalidates: false
      },
      controlButtons: {
        defaultValue: "play_reset",
        propertyChangeInvalidates: false
      }
    }
  };
});

/*global define: false*/

define('sensor/units-definition',[],function() {
  return {
    units: {
      time: {
        name: "second",
        pluralName: "seconds",
        symbol: "s"
      },
      distance: {
        name: "meter",
        pluralName: "meters",
        symbol: "m"
      }
    }
  };
});

/*global define: false*/

/**

  mini-class.js

  Minimalist classical-OO style inheritance for JavaScript.
  Adapted from CoffeeScript and SproutCore.

  Richard Klancer, 7-23-2012
*/
define('common/mini-class',[],function() {

  function mixin(dest, src) {
    var hasProp = {}.hasOwnProperty,
        key;

    for (key in src) {
      if (hasProp.call(src, key)) dest[key] = src[key];
    }
  }

  //
  // Remember that "classes" are just constructor functions that create objects, and that the
  // constructor function property called `prototype` is used to define the prototype object
  // (aka the __proto__ property) which will be assigned to instances created by the constructor.
  // Properties added to the prototype object of a constructor effectively become the instance
  // properties/methods of objects created with that constructor, and properties of the prototype
  // of the prototype are effectively "superclass" instance properties/methods.
  //
  // See http://javascriptweblog.wordpress.com/2010/06/07/understanding-javascript-prototypes/
  //

  /**
    Assuming Child, Parent are classes (i.e., constructor functions):
      1. Copies the properties of the Parent constructor to the Child constructor (These can be
         considered "class properties"/methods, shared among all instances of a class.)
      2. Adds Parent's prototype to Child's prototype chain.
      3. Adds Parent's prototype to the '__super__' property of Child.
  */
  function extend(Child, Parent) {

    // First, copy direct properties of the constructor object ("class properties") from Parent to
    // Child.
    mixin(Child, Parent);

    // First step in extending the prototype chain: make a throwaway constructor, whose prototype
    // property is the same as the Parent constructor's prototype property. Objects created by
    // calling `new PrototypeConstructor()` will have the *same* prototype object as objects created
    // by calling `new Parent()`.
    function PrototypeConstructor() {
      this.constructor = Child;
    }
    PrototypeConstructor.prototype = Parent.prototype;

    // Now use PrototypeConstructor to extend the prototype chain by one link.
    // That is, use PrototypeConstructor to make a new *object* whose prototype object
    // (__proto__ property) is Parent.prototype, and assign the object to the Child constructor's
    // prototype property. This way, objects created by calling "new Child()"
    // will have a prototype object whose prototype object in turn is Parent.prototype.
    Child.prototype = new PrototypeConstructor();

    // Assign the prototype used by objects created by Parent to the __super__ property of Child.
    // (This property can be accessed within a Child instance as `this.constructor.__super__`.)
    // This allows a Child instance to look "up" the prototype chain to find instances properties
    // defined in Parent that are overridden in Child (i.e., defined on Child.prototype)
    Child.__super__ = Parent.prototype;
  }

  /**
    Defines a "class" whose instances will have the properties defined in `prototypeProperties`:
      1. Creates a new constructor, which accepts a list of properties to be copied directly onto
         the instance returned by the constructor.
      2. Adds the properties in `prototypeProperties` to the prototype object shared by instances
         created by the constructor.
  */
  function defineClass(prototypeProperties) {
    function NewConstructor(instanceProperties) {
       mixin(this, instanceProperties);
    }
    mixin(NewConstructor.prototype, prototypeProperties);
    return NewConstructor;
  }

  /**
    Given ParentClass, return a new class which is ParentClass extended by childPrototypeProperties
  */
  function extendClass(ParentClass, childPrototypeProperties) {
    function ChildConstructor(instanceProperties) {
      mixin(this, instanceProperties);
    }
    // Extend ParentClass first so childPrototypeProperties override anything defined in ParentClass
    extend(ChildConstructor, ParentClass);
    mixin(ChildConstructor.prototype, childPrototypeProperties);
    return ChildConstructor;
  }

  return {
    defineClass: defineClass,
    extendClass: extendClass,
    mixin: mixin
  };

});

/*global define: false*/

define('sensor/applet/mini-event-emitter',[],function() {
  /**
    Basic event-emitter functionality to mixin to other classes.

    TODO: needs explicit tests (is currently *implicitly* tested by sensor-applet_spec).
  */
  return {

    on: function(evt, cb) {
      if (!this._ee_listeners) this._ee_listeners = {};
      if (!this._ee_listeners[evt]) this._ee_listeners[evt] = [];

      this._ee_listeners[evt].push(cb);
    },

    emit: function(evt) {
      var args = arguments.length > 1 ? [].splice.call(arguments, 1) : [];

      if (this._ee_listeners && this._ee_listeners[evt]) {
        for (var i = 0, len = this._ee_listeners[evt].length; i < len; i++) {
          this._ee_listeners[evt][i].apply(null, args);
        }
      }
    },

    removeListener: function(evt, listener) {
      if (this._ee_listeners && this._ee_listeners[evt]) {
        for (var i = 0, len = this._ee_listeners[evt].length; i < len; i++) {
          if (this._ee_listeners[evt][i] === listener) {
            this._ee_listeners[evt].splice(i, 1);
          }
        }
      }
    },

    removeListeners: function(evt) {
      if (!evt) {
        this._ee_listeners = {};
      } else {
        if (this._ee_listeners) this._ee_listeners[evt] = [];
      }
    }
  };

});

/*global define: false */

define('sensor/applet/errors',['require','common/inherit'],function(require) {

  var inherit = require('common/inherit');

  function errorConstructor(message) {
    Error.call(this); //super constructor
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor); //super helper method to include stack trace in error object
    }

    this.name = this.constructor.name; //set our functions name as error name.
    this.message = message; //set the error message
  }

  function JavaLoadError() {
    errorConstructor.apply(this, Array.prototype.slice.apply(arguments));
  }
  inherit(JavaLoadError, Error);

  function AppletInitializationError() {
    errorConstructor.apply(this, Array.prototype.slice.apply(arguments));
  }
  inherit(AppletInitializationError, Error);

  function SensorConnectionError() {
    errorConstructor.apply(this, Array.prototype.slice.apply(arguments));
  }
  inherit(SensorConnectionError, Error);

  // temporary check:
  window.JavaLoadError = JavaLoadError;

  return {
    JavaLoadError: JavaLoadError,
    AppletInitializationError: AppletInitializationError,
    SensorConnectionError: SensorConnectionError
  };

});

/*global define: false $:false */
/*jshint unused: false*/

define('sensor/applet/sensor-applet',['require','common/mini-class','./mini-event-emitter','./errors','lab.config'],function(require) {

  var miniClass = require('common/mini-class'),
      EventEmitter = require('./mini-event-emitter'),
      errors = require('./errors'),
      labConfig = require('lab.config'),
      SensorApplet;

  function waitForTestFunction(test, intervalLength, maxAttempts, done, fail) {
    var attempts = 0,
        timer;

    timer = window.setInterval(function() {
      attempts++;
      if (test()) {
        window.clearInterval(timer);
        done();
      } else {
        if (attempts > maxAttempts) {
          window.clearInterval(timer);
          fail();
        }
      }
    }, intervalLength);
  }

  /**
    events:
      data
      deviceUnplugged
      sensorUnplugged

    states:
      not appended
      test applet appended
      appended
      applet ready
      stopped
      started
  */
  SensorApplet = miniClass.defineClass({

    _state: 'not appended',
    _isInAppletCallback: false,

    testAppletReadyInterval: 100,

    getCodebase: function() {
      return labConfig.actualRoot + "jnlp";
    },

    getTestAppletHTML: function() {
      return [
       '<applet ',
         'id="',       this.appletId,         '-test-applet" ',
         'class="applet test-sensor-applet" ',
         'code="org.concord.sensor.applet.DetectionApplet" ',
         'codebase="', this.getCodebase(), '" ',
         'width="150px" ',
         'height="150px" ',
         'MAYSCRIPT="true" ',
       '>',
          '<param name="MAYSCRIPT" value="true" />',
        '</applet>'
      ].join('');
    },

    getState: function() {
      return this._state;
    },

    getIsInAppletCallback: function() {
      return this._isInAppletCallback;
    },

    startAppletCallback: function() {
      if (this.getIsInAppletCallback()) {
        throw new Error("SensorApplet.startAppletCallback was called without previous endAppletCallback call");
      }
      this._isInAppletCallback = true;
    },

    endAppletCallback: function() {
      if (!this.getIsInAppletCallback()) {
        throw new Error("SensorApplet.endAppletCallback was called without previous startAppletCallback call");
      }
      this._isInAppletCallback = false;
    },

    /**
      Append the applet to the DOM, and call callback when either:

        (1) The applet is configured and ready, with the correct device attached (it is ready to
            start collecting data immediately). The SensorApplet instance will be in the 'stopped'
            state.

        or:

        (2) An error occurs in the initialization process. An error object will be passed as the
            first argument to the callback (Node.js style).

        Currently, we detect three kinds of errors:

          * The Java plugin does not appear to be working (we time out waiting for a callback from
            our test applet). In this case, application code may want to remove the applet and try
            calling 'append' again later.

          * The sensor applet was appended, but never initializes (we time out waiting for its
            methods to become callable from Javascript).  In this case, application code may want to
            remove the applet and try calling 'append' again later.

          * The sensor applet reports that the wrong sensor type is attached. In this case,
            the applet is known to be loaded, and the application code may want to notify the user,
            and call 'initializeSensor' when the user indicates the sensor is plugged in. If
            initializeSensor returns true, the applet is ready to collect data.

        We don't yet handle the case that the test applet initializes correctly but never calls the
        'sensorsReady' callback. If that happens, 'callback' will never be invoked.
    */
    append: function(callback) {
      if (this.getState() !== 'not appended') {
        throw new Error("Can't call append() when sensor applet has left 'not appended' state");
      }
      this._appendTestAppletHTML();
      this._appendCallback = callback;
    },

    _appendTestAppletHTML: function() {
      $('body').append( this.getTestAppletHTML() );
      this.testAppletInstance = $('#'+this.appletId + "-test-applet")[0];
      this._state = 'test applet appended';
      this._waitForTestAppletReady();
    },

    _waitForTestAppletReady: function() {
      // TODO: require Function.prototype.bind shim? Or ignore b/c we require Safari >= 5.1?
      var self = this;

      function testFunction() {
        try {
          return self.testAppletInstance.areYouLoaded();
        } catch(e) {
          return false;
        }
      }

      function done() {
        self._appendHTML( self.getHTML() );
        self._state = 'appended';
        self._waitForAppletReady();
      }

      function fail() {
        self._appendCallback(new errors.JavaLoadError("Timed out waiting for test applet to respond."));
      }

      waitForTestFunction(testFunction, this.testAppletReadyInterval, 10, done, fail);
    },

    _waitForAppletReady: function() {
      var self = this;

      function testFunction() {
        return self.testAppletReady();
      }

      function done() {
        $(self.testAppletInstance).remove();
        if (self.getState() === 'appended') {
          self._state = 'applet ready';
        }
        if (!self.isSensorConnected()) {
          self._appendCallback(new errors.SensorConnectionError("Device reported the requested sensor type was not attached."));
        }
        self.initializeSensor();
        // now, do nothing. We just wait for the callback from the sensor applet to sensorIsReady.
      }

      function fail() {
        self._appendCallback(new errors.AppletInitializationError("Timed out waiting for sensor applet to be ready."));
      }

      waitForTestFunction(testFunction, this.testAppletReadyInterval, 10, done, fail);
    },

    sensorIsReady: function() {
      var self = this;
      this._state = 'stopped';
      setTimeout(function() {
        self._appendCallback(null);
        self._appendCallback = null;
      }, 10);
    },

    start: function() {
      if (this.getState() === 'stopped') {
        this._state = 'started';
        this._startSensor();
      }
    },

    stop: function() {
      if (this.getState() === 'started') {
        this._state = 'stopped';
        this._stopSensor();
      }
    },

    remove: function() {
      var self = this;

      function remove() {
        if (self.getState() !== 'not appended') {
          self._removeApplet();
          self._state = 'not appended';
        }
      }

      if (this.getIsInAppletCallback()) {
        window.setTimeout(function() { remove(); }, 10);
      }
      else {
        remove();
      }
    },

    _appendHTML: function(html) {
      $('body').append(html);
      this.appletInstance = $('#'+this.appletId)[0];
    },

    _removeApplet: function() {
      $('#'+this.appletId).remove();
    },

    getHTML: function() {
      throw new Error("Override this method!");
    },

    testAppletReady: function() {
      throw new Error("Override this method!");
    },

    _startSensor: function() {
      throw new Error("Override this method!");
    },

    _stopSensor: function () {
      throw new Error("Override this method!");
    }

  });

  miniClass.mixin(SensorApplet.prototype, EventEmitter);

  return SensorApplet;
});

/*global define: false */

define('sensor/applet/vernier-sensor-applet',['require','common/mini-class','./sensor-applet'],function(require) {

  var miniClass    = require('common/mini-class'),
      SensorApplet = require('./sensor-applet');

  return miniClass.extendClass(SensorApplet, {

    // Before appending the applet, set this value with the path to an object that will receive applet callbacks.
    listenerPath: '',

    // Before appending the applet, set this to the sensor type
    // supported values are:
    //   "temperature"
    //   "light"
    //   "force 5n"
    //   "force 50n"
    //   "co2"
    //   "o2"
    //   "ph"
    //   "distance"
    measurementType: '',

    // supported values are:
    //  "labquest"
    //  "golink"
    deviceType: '',

    appletId:     'sensor-applet',
    classNames:   'applet sensor-applet',

    jarUrls:     ['com/sun/jna/jna.jar',
                  'org/concord/sensor/sensor.jar',
                  'org/concord/sensor/sensor-vernier/sensor-vernier.jar',
                  'org/concord/sensor/sensor-applets/sensor-applets.jar'],

    deviceSpecificJarUrls: [],

    code:         'org.concord.sensor.applet.SensorApplet',

    getHTML: function() {
      var allJarUrls = this.jarUrls.concat(this.deviceSpecificJarUrls);

      return [
       '<applet ',
         'id="',       this.appletId,         '" ',
         'class="',    this.classNames,       '" ',
         'archive="',  allJarUrls.join(', '), '" ',
         'code="',     this.code,             '" ',
         'codebase="', this.getCodebase(), '" ',
         'width="1px" ',
         'height="1px" ',
         'MAYSCRIPT="true" ',
       '>',
          '<param name="MAYSCRIPT" value="true" />',
        '</applet>'
      ].join('');
    },

    testAppletReady: function() {
      try {
        // We only care to see if this throws or not. (In some versions of IE, it's not possible
        // to 'probe' for the mere existence of this.appletInstance.getSensorRequest by testing
        // it for truthiness, because Java methods can be invoked but not included in expressions.)
        this.appletInstance.getSensorRequest(this.measurementType);
      } catch(e) {
        return false;
      }
      return true;
    },

    /**
      Returns true if the correct device type is connected.

      NOTE: This will throw if the applet hasn't been initialized yet (which occurs asynchronously
      after the <applet> tag is appended to the DOM).
    */
    isSensorConnected: function() {
      return this.appletInstance.isInterfaceConnected(this.deviceType);
    },

    /**
      Try to initialize the sensor for the correct device and measurement type (e.g., goio,
      distance). Returns true on success.

      NOTE: This will throw if the applet hasn't been initialized yet (which occurs asynchronously
      after the <applet> tag is appended to the DOM).
    */
    initializeSensor: function() {
      var req;

      if (!this.isSensorConnected()) {
        return false;
      }

      req = this.appletInstance.getSensorRequest(this.measurementType);
      return this.appletInstance.initSensorInterface(this.listenerPath, this.deviceType, [req]);
    },

    // In some browsers, calling an applet method from within a callback triggered by
    // an applet seems to cause problems (lock up the browser). Therefore, make sure
    // not to call the applet's stopCollecting, startCollecting methods within an applet
    // callback.

    _stopSensor: function() {
      var self = this;

      if (this.getIsInAppletCallback()) {
        window.setTimeout(function() { self.appletInstance.stopCollecting(); }, 10);
      }
      else {
        this.appletInstance.stopCollecting();
      }
    },

    _startSensor: function() {
      var self = this;

      if (this.getIsInAppletCallback()) {
        window.setTimeout(function() { self.appletInstance.startCollecting(); }, 10);
      }
      else {
        this.appletInstance.startCollecting();
      }
    },

    // applet callbacks

    sensorsReady: function() {
      this.startAppletCallback();
      this.sensorIsReady();
      this.endAppletCallback();
    },

    dataReceived: function(type, count, data) {
      data = data || [];
      this.startAppletCallback();
      for (var i = 0, len = data.length; i < len; i++) {
        this.emit('data', data[i]);
      }
      this.endAppletCallback();
    },

    deviceUnplugged: function() {
      var self = this;
      this.startAppletCallback();
      window.setTimeout(function() { self.emit('deviceUnplugged'); }, 10);
      this.endAppletCallback();
    },

    sensorUnplugged: function() {
      var self = this;
      this.startAppletCallback();
      window.setTimeout(function() { self.emit('sensorUnplugged'); }, 10);
      this.endAppletCallback();
    }
  });
});

/*global define: false*/

define('sensor/applet/applet-classes',['require','common/mini-class','./vernier-sensor-applet'],function(require) {

  var miniClass           = require('common/mini-class'),
      VernierSensorApplet = require('./vernier-sensor-applet');

  return {
    goio: miniClass.extendClass(VernierSensorApplet, {
      deviceType:            'golink',
      deviceSpecificJarUrls: ['org/concord/sensor/goio-jna/goio-jna.jar']
    }),

    labquest: miniClass.extendClass(VernierSensorApplet, {
      deviceType:            'labquest',
      deviceSpecificJarUrls: ['org/concord/sensor/labquest-jna/labquest-jna.jar']
    })
  };
});

/*global define: false*/

define('sensor/applet/sensor-definitions',[],function() {
  return {
    goMotion: {
      appletClass: 'goio',
      measurementType: 'distance',

      // fully specified, readable name of the sensor: e.g., "GoIO pH Sensor"
      sensorName: "GoMotion",

      // readable name of the interface device the sensor connects to, e..g, "GoIO"
      deviceName: "GoMotion",

      samplesPerSecond: 20,
      tareable: true
    }
  };
});

/*global define: false, d3: false $: true */

define('sensor/modeler',['require','common/property-support','common/property-description','cs!common/running-average-filter','common/validator','./metadata','./units-definition','./applet/applet-classes','./applet/errors','./applet/sensor-definitions','common/controllers/basic-dialog'],function(require) {

  var PropertySupport      = require('common/property-support'),
      PropertyDescription  = require('common/property-description'),
      RunningAverageFilter = require('cs!common/running-average-filter'),
      validator            = require('common/validator'),
      metadata             = require('./metadata'),
      unitsDefinition      = require('./units-definition'),
      appletClasses        = require('./applet/applet-classes'),
      appletErrors         = require('./applet/errors'),
      sensorDefinitions    = require('./applet/sensor-definitions'),
      BasicDialog          = require('common/controllers/basic-dialog');

  function simpleAlert(message, buttons) {
    var dialog = new BasicDialog({
          width: "60%",
          buttons: buttons
        });

    dialog.setContent(message);
    dialog.open();
  }

  return function Model(initialProperties) {
    var propertySupport = new PropertySupport({
          types: ['mainProperty', 'viewOption', 'parameter', 'output']
        }),

        viewOptions,
        mainProperties,
        isStopped = true,
        dispatch = d3.dispatch('play', 'stop', 'tick', 'reset', 'stepForward', 'stepBack', 'seek', 'invalidation'),
        sensorType,
        applet,
        didStop = false,
        sensorIsReady = false,
        samplesPerSecond,
        time = 0,
        sensorReading,
        stepCounter = 0,
        invalidatingChangeNestingLevel = 0,
        filteredOutputs = [],
        customSetters,
        model;

    //
    // The following function is essentially copied from MD2D modeler, and should moved to a common
    // module
    //
    function defineBuiltinProperty(key, type, setter) {
      var metadataForType,
          descriptor,
          propertyChangeInvalidates,
          unitType;

      if (type === 'mainProperty') {
        metadataForType = metadata.mainProperties;
      } else if (type === 'viewOption') {
        metadataForType = metadata.viewOptions;
      } else {
        throw new Error(type + " is not a supported built-in property type");
      }

      propertyChangeInvalidates = validator.propertyChangeInvalidates(metadataForType[key]);

      descriptor = {
        type: type,
        writable: validator.propertyIsWritable(metadataForType[key]),
        set: setter,
        includeInHistoryState: !!metadataForType[key].storeInTickHistory,
        validate: function(value) {
          return validator.validateSingleProperty(metadataForType[key], key, value, false);
        },
        beforeSetCallback: propertyChangeInvalidates ? invalidatingChangePreHook : undefined,
        afterSetCallback: propertyChangeInvalidates ? invalidatingChangePostHook : undefined
      };

      unitType = metadataForType[key].unitType;
      if (unitType) {
        descriptor.description = new PropertyDescription(unitsDefinition, { unitType: unitType });
      }

      propertySupport.defineProperty(key, descriptor);
    }

    function invalidatingChangePreHook() {
      if (invalidatingChangeNestingLevel === 0) {
        propertySupport.storeComputedProperties();
        propertySupport.deleteComputedPropertyCachedValues();
        propertySupport.enableCaching = false;
      }
      invalidatingChangeNestingLevel++;
    }

    function invalidatingChangePostHook() {
      invalidatingChangeNestingLevel--;
      updateFilteredOutputs();
      if (invalidatingChangeNestingLevel === 0) {
        propertySupport.enableCaching = true;
        propertySupport.notifyChangedComputedProperties();
      }
    }

    function makeInvalidatingChange(closure) {
      invalidatingChangePreHook();
      closure();
      invalidatingChangePostHook();
    }

    function updateFilteredOutputs() {
      filteredOutputs.forEach(function(output) {
        output.addSample();
      });
    }

    function removeApplet() {
      applet.removeListeners('data');
      applet.removeListeners('deviceUnplugged');
      applet.removeListeners('sensorUnplugged');

      applet.remove();
      makeInvalidatingChange(function() {
        sensorIsReady = false;
      });
    }

    function appendApplet() {
      applet.on('data', appletDataCallback);
      applet.on('deviceUnplugged', function() { handleUnplugged('device'); });
      applet.on('sensorUnplugged', function() { handleUnplugged('sensor'); });

      applet.append(function(error) {
        if (error) {
          if (error instanceof appletErrors.JavaLoadError) {
            handleLoadingFailure("It appears that Java applets cannot run in your browser. If you are able to fix this, reload the page to use the sensor");
          } else if (error instanceof appletErrors.AppletInitializationError) {
            handleLoadingFailure("The sensor applet appears not to be loading. If you are able to fix this, reload the page to use the sensor");
          } else if (error instanceof appletErrors.SensorConnectionError) {
            handleSensorConnectionError();
          } else {
            handleLoadingFailure("There was an unexpected error when connecting to the sensor.");
          }
          return;
        }

        makeInvalidatingChange(function() {
          sensorIsReady = true;
        });
      });
    }

    function handleSensorConnectionError() {
      removeApplet();
      simpleAlert("The " + model.properties.sensorName + " does not appear to be attached. Try re-attaching it, and then click \"Try Again\".", {
        "Try Again" : function() {
          $(this).dialog("close");
          // This is a workaround: currently, the applet itself does not appear to respond to its
          // initialization methods if the sensor was not connected when the applet started up.
          appendApplet();
        },
        Cancel: function() {
          $(this).dialog("close");
        }
      });
    }

    function handleLoadingFailure(message) {
      removeApplet();
      simpleAlert(message, {
        OK: function() {
          $(this).dialog("close");
        }
      });
    }

    function handleUnplugged(what) {
      removeApplet();
      model.stop();
      simpleAlert("The " + model.properties[what+'Name'] + " was unplugged. Try plugging it back in, and then click \"Try Again\".", {
        "Try Again": function() {
          $(this).dialog("close");
          appendApplet();
        },
        Cancel: function() {
          $(this).dialog("close");
        }
      });
    }

    function setSensorType(_sensorType) {
      var AppletClass;

      if (sensorType === _sensorType) {
        return;
      }
      sensorType = _sensorType;

      if (applet) {
        removeApplet();
      }

      samplesPerSecond = sensorDefinitions[sensorType].samplesPerSecond;
      AppletClass = appletClasses[sensorDefinitions[sensorType].appletClass];

      applet = window.Lab.sensor[sensorType] = new AppletClass({
        listenerPath: 'Lab.sensor.' + sensorType,
        measurementType: sensorDefinitions[sensorType].measurementType,
        appletId: sensorType+'-sensor'
      });

      appendApplet();
    }

    function appletDataCallback(d) {
      stepCounter++;

      time += (1 / samplesPerSecond);

      // Whaaa? Accessing 'window' seems to prevent a strange bug in which Safari 6.0 stops updating
      // time after 3.7s. Hard to debug because accessing console, window, or Web Inspector makes
      // the problem go away!
      window.__bizarreSafariFix = 1;

      sensorReading = d;

      propertySupport.deleteComputedPropertyCachedValues();
      propertySupport.notifyAllComputedProperties();
      updateFilteredOutputs();

      dispatch.tick();
    }

    model = {

      on: function(type, listener) {
        dispatch.on(type, listener);
      },

      start: function() {
        if (!model.properties.isPlayable) {
          return;
        }

        isStopped = false;
        if (applet) {
          applet.start();
        }
        dispatch.play();
      },

      stop: function() {
        isStopped = true;
        if (applet) {
          applet.stop();
        }
        dispatch.stop();

        // Needed in order to recompute isPlaying. FIXME: need a better paradigm for standard
        // MVC style properties that don't flow from model physics.
        makeInvalidatingChange(function() {
          didStop = true;
        });
      },

      isStopped: function() {
        return isStopped;
      },

      stepCounter: function() {
        return stepCounter;
      },

      //
      // The following are essentially copied from MD2D modeler, and should moved to a common module
      //

      addPropertiesListener: function(properties, callback) {
        if (typeof properties === 'string') {
          model.addObserver(properties, callback);
        } else {
          properties.forEach(function(property) {
            model.addObserver(property, callback);
          });
        }
      },

      defineParameter: function(key, descriptionHash, setter) {
        var descriptor = {
              type: 'parameter',
              includeInHistoryState: true,
              invokeSetterAfterBulkRestore: false,
              description: new PropertyDescription(unitsDefinition, descriptionHash),
              beforeSetCallback: invalidatingChangePreHook,
              afterSetCallback: invalidatingChangePostHook
            };

        // In practice, some parameters are meant only to be observed, and have no setter
        if (setter) {
          descriptor.set = function(value) {
            setter.call(model, value);
          };
        }
        propertySupport.defineProperty(key, descriptor);
      },

      defineOutput: function(key, descriptionHash, getter) {
        propertySupport.defineProperty(key, {
          type: 'output',
          writable: false,
          get: getter,
          includeInHistoryState: false,
          description: new PropertyDescription(unitsDefinition, descriptionHash)
        });
      },

      defineFilteredOutput: function(key, description, filteredPropertyKey, type, period) {
        var filter, initialValue;

        if (type === "RunningAverage") {
          filter = new RunningAverageFilter(period);
        } else {
          throw new Error("FilteredOutput: unknown filter type " + type + ".");
        }

        // Add initial sample
        initialValue = model.properties[key];
        if (initialValue === undefined || isNaN(Number(initialValue))) {
          throw new Error("FilteredOutput: property is not a valid numeric value or it is undefined.");
        }
        filter.addSample(model.properties.time, initialValue);

        filteredOutputs.push({
          addSample: function() {
            filter.addSample(model.properties.time, model.properties[filteredPropertyKey]);
          }
        });

        // Extend description to contain information about filter
        description.property = filteredPropertyKey;
        description.type = type;
        description.period = period;

        model.defineOutput(key, description, function () {
          return filter.calculate();
        });
      }
    };

    // Need to define a globally-accessible 'listenerPath' for the sensor to evaluate
    if (window.Lab === undefined) {
      window.Lab = {};
    }
    window.Lab.sensor = {};

    propertySupport.mixInto(model);

    customSetters = {
      sensorType: setSensorType
    };

    mainProperties = validator.validateCompleteness(metadata.mainProperties, initialProperties);
    Object.keys(mainProperties).forEach(function(key) {
      defineBuiltinProperty(key, 'mainProperty', customSetters[key]);
    });
    propertySupport.setRawValues(mainProperties);

    viewOptions = validator.validateCompleteness(metadata.viewOptions, initialProperties.viewOptions || {});
    Object.keys(viewOptions).forEach(function(key) {
      defineBuiltinProperty(key, 'viewOption');
    });
    propertySupport.setRawValues(viewOptions);

    model.defineOutput('time', {
      label: "Time",
      unitType: 'time',
      format: '.2f'
    }, function() {
      return time;
    });

    model.defineOutput('displayTime', {
      label: "Time",
      unitType: 'time',
      format: '.2f'
    }, function() {
      return time;
    });

    model.defineOutput('sensorReading', {
      label: "Sensor Reading",
      format: '.2f'
    }, function() {
      return sensorReading;
    });

    // TODO. Need a better way for the model to be able to have a property which it can set the
    // value of at arbitrary times, but which is read-only to client code. Outputs aren't quite
    // the right solution because the invalidation stuff is really about time and physics-based
    // invalidation.

    model.defineOutput('sensorName', {
      label: "Sensor Name"
    }, function() {
      return sensorDefinitions[sensorType].sensorName;
    });

    model.defineOutput('deviceName', {
      label: "Sensor Interface Device Name"
    }, function() {
      return sensorDefinitions[sensorType].deviceName;
    });

    // TODO. We need a way to make "model-writable" read only properties. custom getters could
    model.defineOutput('isPlayable', {
      label: "Playable"
    }, function() {
      return !didStop && sensorIsReady;
    });

    // Kick things off by doing this explicitly:
    setSensorType(model.properties.sensorType);

    return model;
  };
});

/*global define $ */

define('sensor/controller',['require','common/controllers/model-controller','sensor/modeler','common/views/null-model-view'],function (require) {
  // Dependencies.
  var ModelController   = require('common/controllers/model-controller'),
      Model             = require('sensor/modeler'),
      ModelContainer    = require('common/views/null-model-view'),
      ScriptingAPI      = function() {},
      Benchmarks        = function() {};

  return function (modelUrl, modelOptions, interactiveController) {
    return new ModelController(modelUrl, modelOptions, interactiveController,
                               Model, ModelContainer, ScriptingAPI, Benchmarks);
  };
});

/*jslint indent: 2, browser: true, newcap: true */
/*globals define: false*/

// Basic constants used by Energy2D module

define('energy2d/models/constants',['require','exports','module'],function (require, exports, module) {
  'use strict';
  // Air's thermal conductivity = 0.025 W/(m*K)
  exports.AIR_THERMAL_CONDUCTIVITY = 0.025;
  // Air's specific heat = 1012 J/(kg*K)
  exports.AIR_SPECIFIC_HEAT = 1012;
  // Air's density = 1.204 kg/m^3 at 25 C
  exports.AIR_DENSITY = 1.204;
  // By default, air's kinematic viscosity = 1.568 x 10^-5 m^2/s at 27 C is
  // used. It can be set to zero for inviscid fluid.
  exports.AIR_VISCOSITY = 0.00001568;
  // Stefan's constant unit J/(s*m^2*K^-4)
  exports.STEFAN_CONSTANT = 0.0000000567;
});

/*global define: false */

define('energy2d/metadata',['require','energy2d/models/constants'],function(require) {
  var constants = require('energy2d/models/constants');

  return {
    mainProperties: {
      type: {
        defaultValue: "energy2d",
        immutable: true
      },
      use_WebGL: {
        defaultValue: false
      },
      grid_width: {
        defaultValue: 100,
        immutable: true
      },
      grid_height: {
        defaultValue: 100,
        immutable: true
      },
      model_width: {
        defaultValue: 10,
        immutable: true
      },
      model_height: {
        defaultValue: 10,
        immutable: true
      },
      timeStep: {
        defaultValue: 1
      },
      timeStepsPerTick: {
        defaultValue: 4
      },
      ticksPerGPUSync: {
        defaultValue: 30
      },
      convective: {
        defaultValue: true
      },
      background_temperature: {
        defaultValue: 0
      },
      background_conductivity: {
        defaultValue: constants.AIR_THERMAL_CONDUCTIVITY
      },
      background_specific_heat: {
        defaultValue: constants.AIR_SPECIFIC_HEAT
      },
      background_density: {
        defaultValue: constants.AIR_DENSITY
      },
      background_viscosity: {
        defaultValue: constants.AIR_VISCOSITY
      },
      thermal_buoyancy: {
        defaultValue: 0.00025
      },
      buoyancy_approximation: {
        defaultValue: 1
      },
      boundary: {
        defaultValue: {
          type: "temperature",
          upper: 0,
          lower: 0,
          left: 0,
          right: 0
        }
      },
      sunny: {
        defaultValue: false
      },
      sun_angle: {
        defaultValue: 1.5707964
      },
      solar_power_density: {
        defaultValue: 2000
      },
      solar_ray_count: {
        defaultValue: 24
      },
      solar_ray_speed: {
        defaultValue: 0.1
      },
      photon_emission_interval: {
        defaultValue: 20
      }
    },

    viewOptions: {
      showClock: {
        defaultValue: true,
        propertyChangeInvalidates: false
      },
      controlButtons: {
        defaultValue: "play_reset",
        propertyChangeInvalidates: false
      },
      color_palette_type: {
        defaultValue: 0
      },
      velocity: {
        defaultValue: false
      },
      minimum_temperature: {
        defaultValue: 0
      },
      maximum_temperature: {
        defaultValue: 40.0
      },
      enableKeyboardHandlers: {
        defaultValue: true
      }
    },

    part: {
      shapeType: {
        // Available options: "rectangle", "ellipse", "ring" or "polygon".
        required: true,
        immutable: true
      },
      x: {
        defaultValue: 0
      },
      y: {
        defaultValue: 0
      },
      width: {},
      height: {},
      a: {},
      b: {},
      inner: {},
      outer: {},
      vertices: {},

      // Special shortcut properties which let user access polygon properties
      // faster and more convenient. They can be used both to get and set
      // value. They are not serialized.
      raw_x_coords: {
        serialize: false
      },
      raw_y_coords: {
        serialize: false
      },

      thermal_conductivity: {
        defaultValue: 1
      },
      specific_heat: {
        defaultValue: 1300
      },
      density: {
        defaultValue: 25
      },
      transmission: {
        defaultValue: 0
      },
      reflection: {
        defaultValue: 0
      },
      absorption: {
        defaultValue: 1
      },
      emissivity: {
        defaultValue: 0
      },
      temperature: {
        defaultValue: 0
      },
      constant_temperature: {
        defaultValue: false
      },
      power: {
        defaultValue: 0
      },
      wind_speed: {
        defaultValue: 0
      },
      wind_angle: {
        defaultValue: 0
      },
      visible: {
        defaultValue: true
      },
      filled: {
        defaultValue: true
      },
      color: {
        // Auto color means that part will use color matching its power or temperature
        // (when it has constant temperature) or gray color otherwise.
        defaultValue: "auto"
      },
      label: {
        defaultValue: ""
      },
      texture: {
        defaultValue: false
      },
      draggable: {
        defaultValue: true
      }
    },

    sensor: {
      type: {
        required: true,
        immutable: true
      },
      x: {
        required: true,
        unitType: "length"
      },
      y: {
        required: true,
        unitType: "length"
      },
      angle: {
        // Optional, defined only for heat flux sensors.
        immutable: true
      },
      label: {
        defaultValue: ""
      },
      value: {
        readOnly: true,
        serialize: false
      }
    }
  };
});

/*global define: false*/

define('energy2d/models/physics-solvers/heat-solver',['require','exports','module','arrays'],function (require, exports) {
  'use strict';
  var
    arrays = require('arrays'),

    RELAXATION_STEPS = 5;

  exports.makeHeatSolver = function (model) {
    var
      // Basic simulation parameters.
      props = model.getModelOptions(),
      nx = props.grid_width,
      ny = props.grid_height,

      relaxationSteps = RELAXATION_STEPS,

      // Simulation arrays provided by model.
      conductivity = model.getConductivityArray(),
      capacity     = model.getCapacityArray(),
      density      = model.getDensityArray(),
      u            = model.getUVelocityArray(),
      v            = model.getVVelocityArray(),
      tb           = model.getBoundaryTemperatureArray(),
      fluidity     = model.getFluidityArray(),

      // Internal array that stores the previous temperature results.
      t0 = arrays.create(nx * ny, 0, model.getArrayType()),

      // Convenience variables.
      nx1 = nx - 1,
      ny1 = ny - 1,
      nx2 = nx - 2,
      ny2 = ny - 2,

      deltaX = props.model_width / props.grid_width,
      deltaY = props.model_height / props.grid_height,

      //
      // Private methods
      //

      applyBoundary  = function (t) {
        var
          boundary = props.boundary,
          vN = boundary.upper,
          vS = boundary.lower,
          vW = boundary.left,
          vE = boundary.right,
          i, j, inx, inx_ny1;

        if (boundary.type === "temperature") {
          for (i = 0; i < nx; i += 1) {
            inx = i * nx;
            t[inx] = vN;
            t[inx + ny1] = vS;
          }
          for (j = 0; j <  ny; j += 1) {
            t[j] = vW;
            t[nx1 * nx + j] = vE;
          }
        } else if (boundary.type === "flux") {
          for (i = 0; i < nx; i += 1) {
            inx = i * nx;
            inx_ny1 = inx + ny1;
            t[inx] = t[inx + 1] + vN * deltaY / conductivity[inx];
            t[inx_ny1] = t[inx + ny2] - vS * deltaY / conductivity[inx_ny1];
          }
          for (j = 0; j < ny; j += 1) {
            t[j] = t[nx + j] - vW * deltaX / conductivity[j];
            t[nx1 * nx + j] = t[nx2 * nx + j] + vE * deltaX / conductivity[nx1 * nx + j];
          }
        }
      },

      macCormack  = function (t) {
        var
          timeStep = props.timeStep,
          tx = 0.5 * timeStep / deltaX,
          ty = 0.5 * timeStep / deltaY,
          i, j, inx, jinx, jinx_plus_nx, jinx_minus_nx, jinx_plus_1, jinx_minus_1;

        for (i = 1; i < nx1; i += 1) {
          inx = i * nx;
          for (j = 1; j < ny1; j += 1) {
            jinx = inx + j;
            jinx_minus_nx = jinx - nx;
            jinx_plus_nx = jinx + nx;
            jinx_minus_1 = jinx - 1;
            jinx_plus_1 = jinx + 1;
            if (fluidity[jinx]) {
              t0[jinx] = t[jinx]
                - tx * (u[jinx_plus_nx] * t[jinx_plus_nx] - u[jinx_minus_nx] * t[jinx_minus_nx])
                - ty * (v[jinx_plus_1] * t[jinx_plus_1] - v[jinx_minus_1] * t[jinx_minus_1]);
            }
          }
        }
        applyBoundary(t0);

        for (i = 1; i < nx1; i += 1) {
          inx = i * nx;
          for (j = 1; j < ny1; j += 1) {
            jinx = inx + j;
            if (fluidity[jinx]) {
              jinx_minus_nx = jinx - nx;
              jinx_plus_nx = jinx + nx;
              jinx_minus_1 = jinx - 1;
              jinx_plus_1 = jinx + 1;

              t[jinx] = 0.5 * (t[jinx] + t0[jinx]) - 0.5 * tx * u[jinx]
                * (t0[jinx_plus_nx] - t0[jinx_minus_nx]) - 0.5 * ty * v[jinx]
                * (t0[jinx_plus_1] - t0[jinx_minus_1]);
            }
          }
        }
        applyBoundary(t);
      };

    return {
      solve: function (convective, t, q) {
        var
          timeStep = props.timeStep,
          hx = 0.5 / (deltaX * deltaX),
          hy = 0.5 / (deltaY * deltaY),
          invTimeStep = 1.0 / timeStep,
          rij, sij, axij, bxij, ayij, byij,
          k, i, j, inx, jinx, jinx_plus_nx, jinx_minus_nx, jinx_plus_1, jinx_minus_1;

        arrays.copy(t, t0);

        for (k = 0; k < relaxationSteps; k += 1) {
          for (i = 1; i < nx1; i += 1) {
            inx = i * nx;
            for (j = 1; j < ny1; j += 1) {
              jinx = inx + j;
              if (isNaN(tb[jinx])) {
                jinx_minus_nx = jinx - nx;
                jinx_plus_nx = jinx + nx;
                jinx_minus_1 = jinx - 1;
                jinx_plus_1 = jinx + 1;

                sij = capacity[jinx] * density[jinx] * invTimeStep;
                rij = conductivity[jinx];
                axij = hx * (rij + conductivity[jinx_minus_nx]);
                bxij = hx * (rij + conductivity[jinx_plus_nx]);
                ayij = hy * (rij + conductivity[jinx_minus_1]);
                byij = hy * (rij + conductivity[jinx_plus_1]);
                t[jinx] = (t0[jinx] * sij + q[jinx] + axij * t[jinx_minus_nx] + bxij
                          * t[jinx_plus_nx] + ayij * t[jinx_minus_1] + byij * t[jinx_plus_1])
                          / (sij + axij + bxij + ayij + byij);
              } else {
                t[jinx] = tb[jinx];
              }
            }
          }
          applyBoundary(t);
        }
        if (convective) {
          // advect(t)
          macCormack(t);
        }
      }
    };
  };
});

/*global define: false*/

// WebGL Context Manager module.
//
// It provides access to one, global WebGL context.
// All clients interested in WebGL context should call:
// getWebGLContext() function. If WebGL is not available,
// an appropriate error will be thrown.
define('energy2d/gpu/context',[],function () {
  'use strict';
  // The internal `gl` variable holds the current WebGL context.
  var gl;

  return {
    getWebGLContext: function () {
      if (!gl) {
        var canvas = document.createElement('canvas');
        try {
          gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
        } catch (e) {}
        if (!gl) {
          throw new Error('GL: WebGL not supported.');
        }
      }
      return gl;
    },

    get error() {
      if (!gl) return "WebGL unavailable";
      var error = gl.getError();
      return error === gl.NO_ERROR ? undefined : error;
    }
  };
});

/*jslint indent: 2, browser: true, newcap: true, es5: true */
/*globals define: false, Float32Array: false, Uint16Array: false, console: false*/

define('energy2d/gpu/shader',['require','common/console','energy2d/gpu/context'],function (require) {
  'use strict';
  var
    // Dependencies.
    console = require('common/console'),
    context = require('energy2d/gpu/context'),

    // The internal `gl` variable holds the current WebGL context.
    gl,

    // Local, private helper functions.
    regexMap = function (regex, text, callback) {
      var result;
      while ((result = regex.exec(text)) !== null) {
        callback(result);
      }
    },
    isArray = function (obj) {
      var str = Object.prototype.toString.call(obj);
      return str === '[object Array]' || str === '[object Float32Array]';
    },
    isNumber = function (obj) {
      var str = Object.prototype.toString.call(obj);
      return str === '[object Number]' || str === '[object Boolean]';
    },
    // Class to be exported.
    Shader;

  // Compiles a shader program using the provided vertex and fragment shaders.
  Shader = function (vertexSource, fragmentSource) {
    var
      // Headers are prepended to the sources to provide some automatic functionality.
      vertexHeader =
      '\
      attribute vec4 gl_Vertex;\
      attribute vec4 gl_TexCoord;\
      attribute vec3 gl_Normal;\
      attribute vec4 gl_Color;\
      ',
      fragmentHeader =
      '\
      precision highp float;\
      ',

      // The `gl_` prefix must be substituted for something else to avoid compile
      // errors, since it's a reserved prefix. This prefixes all reserved names with
      // `_`. The header is inserted after any extensions, since those must come
      // first.
      fix = function (header, source) {
        var replaced = {}, match;
        match = /^((\s*\/\/.*\n|\s*#extension.*\n)+)[^]*$/.exec(source);
        source = match ? match[1] + header + source.substr(match[1].length) : header + source;
        regexMap(/\bgl_\w+\b/g, header, function (result) {
          if (replaced[result] === undefined) {
            source = source.replace(new RegExp('\\b' + result + '\\b', 'g'), '_' + result);
            replaced[result] = true;
          }
        });
        return source;
      },

      isSampler = {};

    gl = context.getWebGLContext();

    vertexSource = fix(vertexHeader, vertexSource);
    fragmentSource = fix(fragmentHeader, fragmentSource);

    // Compile and link errors are thrown as strings.
    function compileSource(type, source) {
      var shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        throw new Error('Shader: compile error.\n' + gl.getShaderInfoLog(shader) +
                        '\nSource:\n' + source);
      }
      return shader;
    }

    this.program = gl.createProgram();
    gl.attachShader(this.program, compileSource(gl.VERTEX_SHADER, vertexSource));
    gl.attachShader(this.program, compileSource(gl.FRAGMENT_SHADER, fragmentSource));
    gl.linkProgram(this.program);
    if (!gl.getProgramParameter(this.program, gl.LINK_STATUS)) {
      throw new Error('Shader: link error.\n' + gl.getProgramInfoLog(this.program) +
                      '\nSource:\n' + vertexSource + '\n\n' + fragmentSource);
    }
    this.attributes = {};
    this.uniformLocations = {};

    // Sampler uniforms need to be uploaded using `gl.uniform1i()` instead of `gl.uniform1f()`.
    // To do this automatically, we detect and remember all uniform samplers in the source code.
    regexMap(/uniform\s+sampler(1D|2D|3D|Cube)\s+(\w+)\s*;/g, vertexSource + fragmentSource, function (groups) {
      isSampler[groups[2]] = 1;
    });
    this.isSampler = isSampler;
  };

  // Set a uniform for each property of `uniforms`. The correct `gl.uniform*()` method is
  // inferred from the value types and from the stored uniform sampler flags.
  Shader.prototype.uniforms = function (uniforms) {
    var name, location, value;

    gl.useProgram(this.program);

    for (name in uniforms) {
      if (uniforms.hasOwnProperty(name)) {
        if (this.uniformLocations[name] === undefined) {
          this.uniformLocations[name] = gl.getUniformLocation(this.program, name);
        }
        location = this.uniformLocations[name];
        if (location === null) {
          console.warn('Shader: name ' + name + ' does not correspond to an active uniform variable.');
          continue;
        }
        value = uniforms[name];
        if (isArray(value)) {
          switch (value.length) {
          case 1: gl.uniform1fv(location, new Float32Array(value)); break;
          case 2: gl.uniform2fv(location, new Float32Array(value)); break;
          case 3: gl.uniform3fv(location, new Float32Array(value)); break;
          case 4: gl.uniform4fv(location, new Float32Array(value)); break;
          // Matrices are automatically transposed, since WebGL uses column-major
          // indices instead of row-major indices.
          case 9: gl.uniformMatrix3fv(location, false, new Float32Array([
            value[0], value[3], value[6],
            value[1], value[4], value[7],
            value[2], value[5], value[8]
          ])); break;
          case 16: gl.uniformMatrix4fv(location, false, new Float32Array([
            value[0], value[4], value[8], value[12],
            value[1], value[5], value[9], value[13],
            value[2], value[6], value[10], value[14],
            value[3], value[7], value[11], value[15]
          ])); break;
          default: throw new Error('Shader: don\'t know how to load uniform "' + name + '" of length ' + value.length);
          }
        } else if (isNumber(value)) {
          (this.isSampler[name] ? gl.uniform1i : gl.uniform1f).call(gl, location, value);
        } else {
          throw new Error('Shader: attempted to set uniform "' + name + '" to invalid value ' + value);
        }
      }
    }

    return this;
  };

  // Sets all uniform matrix attributes, binds all relevant buffers, and draws the
  // mesh geometry as indexed triangles or indexed lines. Set `mode` to `gl.LINES`
  // (and either add indices to `lines` or call `computeWireframe()`) to draw the
  // mesh in wireframe.
  Shader.prototype.draw = function (mesh, mode) {
    gl.useProgram(this.program);

    this.drawBuffers(mesh.vertexBuffers,
      mesh.indexBuffers[mode === gl.LINES ? 'lines' : 'triangles'],
      arguments.length < 2 ? gl.TRIANGLES : mode);
  };

  // Sets all uniform matrix attributes, binds all relevant buffers, and draws the
  // indexed mesh geometry. The `vertexBuffers` argument is a map from attribute
  // names to `Buffer` objects of type `gl.ARRAY_BUFFER`, `indexBuffer` is a `Buffer`
  // object of type `gl.ELEMENT_ARRAY_BUFFER`, and `mode` is a WebGL primitive mode
  // like `gl.TRIANGLES` or `gl.LINES`. This method automatically creates and caches
  // vertex attribute pointers for attributes as needed.
  Shader.prototype.drawBuffers = function (vertexBuffers, indexBuffer, mode) {
    // Create and enable attribute pointers as necessary.
    var length = 0, attribute, buffer, location;

    for (attribute in vertexBuffers) {
      if (vertexBuffers.hasOwnProperty(attribute)) {
        buffer = vertexBuffers[attribute];
        if (this.attributes[attribute] === undefined) {
          this.attributes[attribute] = gl.getAttribLocation(this.program, attribute.replace(/^gl_/, '_gl_'));
        }
        location = this.attributes[attribute];
        if (location === -1 || !buffer.buffer) {
          continue;
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, buffer.buffer);
        gl.enableVertexAttribArray(location);
        gl.vertexAttribPointer(location, buffer.buffer.spacing, gl.FLOAT, false, 0, 0);
        length = buffer.buffer.length / buffer.buffer.spacing;
      }
    }

    // Disable unused attribute pointers.
    for (attribute in this.attributes) {
      if (this.attributes.hasOwnProperty(attribute)) {
        if (vertexBuffers[attribute] === undefined) {
          gl.disableVertexAttribArray(this.attributes[attribute]);
        }
      }
    }

    // Draw the geometry.
    if (length && (!indexBuffer || indexBuffer.buffer)) {
      if (indexBuffer) {
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer.buffer);
        gl.drawElements(mode, indexBuffer.buffer.length, gl.UNSIGNED_SHORT, 0);
      } else {
        gl.drawArrays(mode, 0, length);
      }
    }
  };

  // Export constructor function.
  return Shader;
});

/*jslint indent: 2, browser: true, newcap: true */
/*globals define: false*/

// Simple wrapper around WebGL textures that supports render-to-texture.
//
// The arguments `width` and `height` give the size of the texture in texels.
// WebGL texture dimensions must be powers of two unless `filter` is set to
// either `gl.NEAREST` or `gl.REPEAT` and `wrap` is set to `gl.CLAMP_TO_EDGE`
// (which they are by default).
//
// Texture parameters can be passed in via the `options` argument.
// Example usage:
//
//     var t = new Texture(256, 256, {
//       // Defaults to gl.LINEAR, set both at once with "filter"
//       mag_filter: gl.NEAREST,
//       min_filter: gl.LINEAR,
//
//       // Defaults to gl.CLAMP_TO_EDGE, set both at once with "wrap"
//       wrap_s: gl.REPEAT,
//       wrap_t: gl.REPEAT,
//
//       format: gl.RGB, // Defaults to gl.RGBA
//       type: gl.FLOAT  // Defaults to gl.UNSIGNED_BYTE
//     });

define('energy2d/gpu/texture',['require','energy2d/gpu/context'],function (require) {
  'use strict';
  var
    // Dependencies.
    context = require('energy2d/gpu/context'),

    // WebGL context.
    gl,

    // Class to be exported.
    Texture;

  Texture = function (width, height, options) {
    gl = context.getWebGLContext();
    options = options || {};
    // Basic texture params.
    this.id = gl.createTexture();
    this.width = width;
    this.height = height;
    this.format = options.format || gl.RGBA;
    this.type = options.type || gl.UNSIGNED_BYTE;
    // Number of texture unit which contains this texture (if any).
    this.tex_unit = null;
    // Render target params.
    this.fbo = null;

    // Set parameters.
    gl.bindTexture(gl.TEXTURE_2D, this.id);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, options.mag_filter || options.filter || gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, options.min_filter || options.filter || gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, options.wrap || options.wrap_s || gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, options.wrap || options.wrap_t || gl.CLAMP_TO_EDGE);
    gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, null);
  };

  // Set texture as render target.
  // After this call user can render to texture.
  Texture.prototype.setAsRenderTarget = function () {
    if (this.fbo === null) {
      // FBO initialization during first call.
      this.fbo = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.id, 0);
      gl.viewport(0, 0, this.width, this.height);
    } else {
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
      gl.viewport(0, 0, this.width, this.height);
    }
  };

  // Bind this texture to the given texture unit (0-7, defaults to 0).
  Texture.prototype.bind = function (unit) {
    this.tex_unit = unit || 0;
    gl.activeTexture(gl.TEXTURE0 + this.tex_unit);
    gl.bindTexture(gl.TEXTURE_2D, this.id);
  };

  // Unbind this texture.
  Texture.prototype.unbind = function (unit) {
    if (this.tex_unit === null) {
      return;
    }
    gl.activeTexture(gl.TEXTURE0 + this.tex_unit);
    gl.bindTexture(gl.TEXTURE_2D, null);
    this.tex_unit = null;
  };

  // Render all draw calls in `callback` to this texture. It also temporarily
  // changes the viewport to the size of the texture.
  Texture.prototype.drawTo = function (callback) {
    if (this.fbo === null) {
      throw new Error("Texture: call setupAsRenderTarget() method first.");
    }
    gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
    gl.viewport(0, 0, this.width, this.height);

    callback();

    gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  };

  // Switch this texture with 'other', useful for the ping-pong rendering
  // technique used in multi-stage rendering.
  // Textures should have identical dimensions, types and in general - parameters.
  // Only ID, FBO and active texture unit values are swapped.
  Texture.prototype.swapWith = function (other) {
    var temp;
    // Swap ID.
    temp = other.id;
    other.id = this.id;
    this.id = temp;
    // Swap active texture unit.
    temp = other.tex_unit;
    other.tex_unit = this.tex_unit;
    this.tex_unit = temp;
    // Swap FBO.
    temp = other.fbo;
    other.fbo = this.fbo;
    this.fbo = temp;
  };

  // Export constructor function.
  return Texture;
});

/*jslint indent: 2, browser: true, newcap: true, es5: true */
/*globals define: false, Float32Array: false, Uint16Array: false*/

// Represents a collection of vertex buffers and index buffers. Each vertex
// buffer maps to one attribute in GLSL and has a corresponding property set
// on the Mesh instance. There is one vertex buffer by default: `vertices`,
// which maps to `gl_Vertex`. The `coords`, `normals`, and `colors` vertex
// buffers map to `gl_TexCoord`, `gl_Normal`, and `gl_Color` respectively,
// and can be enabled by setting the corresponding options to true. There are
// two index buffers, `triangles` and `lines`, which are used for rendering
// `gl.TRIANGLES` and `gl.LINES`, respectively. Only `triangles` is enabled by
// default, although `computeWireframe()` will add a normal buffer if it wasn't
// initially enabled.

define('energy2d/gpu/mesh',['require','energy2d/gpu/context'],function (require) {
  'use strict';
  var
    // Dependencies.
    context = require('energy2d/gpu/context'),

    // The internal `gl` variable holds the current WebGL context.
    gl,

    // Internal, private class.
    Buffer,
    // Class to be exported.
    Mesh;

  // Provides a simple method of uploading data to a GPU buffer. Example usage:
  //
  //     var vertices = new GL.Buffer(gl.ARRAY_BUFFER, Float32Array);
  //     var indices = new GL.Buffer(gl.ELEMENT_ARRAY_BUFFER, Uint16Array);
  //     vertices.data = [[0, 0, 0], [1, 0, 0], [0, 1, 0], [1, 1, 0]];
  //     indices.data = [[0, 1, 2], [2, 1, 3]];
  //     vertices.compile();
  //     indices.compile();
  Buffer = function (target, type) {
    gl = context.getWebGLContext();
    this.buffer = null;
    this.target = target;
    this.type = type;
    this.data = [];
  };

  // Upload the contents of `data` to the GPU in preparation for rendering. The
  // data must be a list of lists where each inner list has the same length. For
  // example, each element of data for vertex normals would be a list of length three.
  // This will remember the data length and element length for later use by shaders.
  // The type can be either `gl.STATIC_DRAW` or `gl.DYNAMIC_DRAW`, and defaults to
  // `gl.STATIC_DRAW`.
  //
  // This could have used `[].concat.apply([], this.data)` to flatten
  // the array but Google Chrome has a maximum number of arguments so the
  // concatenations are chunked to avoid that limit.
  Buffer.prototype.compile = function (type) {
    var data = [], i, chunk, spacing;
    for (i = 0, chunk = 10000; i < this.data.length; i += chunk) {
      data = Array.prototype.concat.apply(data, this.data.slice(i, i + chunk));
    }
    spacing = this.data.length ? data.length / this.data.length : 0;
    if (spacing !== Math.round(spacing)) {
      throw new Error('Mesh: buffer elements not of consistent size, average size is ' + spacing);
    }
    this.buffer = this.buffer || gl.createBuffer();
    this.buffer.length = data.length;
    this.buffer.spacing = spacing;
    gl.bindBuffer(this.target, this.buffer);
    gl.bufferData(this.target, new this.type(data), type || gl.STATIC_DRAW);
  };

  Mesh = function (options) {
    gl = context.getWebGLContext();
    options = options || {};
    this.vertexBuffers = {};
    this.indexBuffers = {};
    this.addVertexBuffer('vertices', 'gl_Vertex');
    if (options.coords) {
      this.addVertexBuffer('coords', 'gl_TexCoord');
    }
    if (options.normals) {
      this.addVertexBuffer('normals', 'gl_Normal');
    }
    if (options.colors) {
      this.addVertexBuffer('colors', 'gl_Color');
    }
    if (options.lines === undefined || options.triangles) {
      this.addIndexBuffer('triangles');
    }
    if (options.lines) {
      this.addIndexBuffer('lines');
    }
  };

  // Add a new vertex buffer with a list as a property called `name` on this object
  // and map it to the attribute called `attribute` in all shaders that draw this mesh.
  Mesh.prototype.addVertexBuffer = function (name, attribute) {
    var buffer = this.vertexBuffers[attribute] = new Buffer(gl.ARRAY_BUFFER, Float32Array);
    buffer.name = name;
    this[name] = [];
  };

  // Add a new index buffer with a list as a property called `name` on this object.
  Mesh.prototype.addIndexBuffer = function (name) {
    var buffer = this.indexBuffers[name] = new Buffer(gl.ELEMENT_ARRAY_BUFFER, Uint16Array);
    this[name] = [];
  };

  // Upload all attached buffers to the GPU in preparation for rendering. This
  // doesn't need to be called every frame, only needs to be done when the data
  // changes.
  Mesh.prototype.compile = function () {
    var attribute, name, buffer;
    for (attribute in this.vertexBuffers) {
      if (this.vertexBuffers.hasOwnProperty(attribute)) {
        buffer = this.vertexBuffers[attribute];
        buffer.data = this[buffer.name];
        buffer.compile();
      }
    }

    for (name in this.indexBuffers) {
      if (this.indexBuffers.hasOwnProperty(name)) {
        buffer = this.indexBuffers[name];
        buffer.data = this[name];
        buffer.compile();
      }
    }
  };

  // Generates a square 2x2 mesh the xy plane centered at the origin. The
  // `options` argument specifies options to pass to the mesh constructor.
  // Additional options include `detailX` and `detailY`, which set the tesselation
  // in x and y, and `detail`, which sets both `detailX` and `detailY` at once.
  // Two triangles are generated by default.
  // Example usage:
  //
  //     var mesh1 = GL.Mesh.plane();
  //     var mesh2 = GL.Mesh.plane({ detail: 5 });
  //     var mesh3 = GL.Mesh.plane({ detailX: 20, detailY: 40 });
  //
  Mesh.plane = function (options) {
    var mesh, detailX, detailY, x, y, t, s, i;
    options = options || {};
    mesh = new Mesh(options);
    detailX = options.detailX || options.detail || 1;
    detailY = options.detailY || options.detail || 1;

    for (y = 0; y <= detailY; y += 1) {
      t = y / detailY;
      for (x = 0; x <= detailX; x += 1) {
        s = x / detailX;
        mesh.vertices.push([2 * s - 1, 2 * t - 1, 0]);
        if (mesh.coords) {
          mesh.coords.push([s, t]);
        }
        if (mesh.normals) {
          mesh.normals.push([0, 0, 1]);
        }
        if (x < detailX && y < detailY) {
          i = x + y * (detailX + 1);
          mesh.triangles.push([i, i + 1, i + detailX + 1]);
          mesh.triangles.push([i + detailX + 1, i + 1, i + detailX + 2]);
        }
      }
    }

    mesh.compile();
    return mesh;
  };

  // Export constructor function.
  return Mesh;
});

/*jshint indent: 2, browser: true, newcap: true, multistr: true, es5: true */
/*global define: false, Float32Array: false, Uint8Array: false*/

// GPGPU Utils (singleton, one instance in the environment).
define('energy2d/gpu/gpgpu',['require','energy2d/gpu/context','energy2d/gpu/texture','energy2d/gpu/shader','energy2d/gpu/mesh'],function (require) {
  'use strict';
  var
    // Dependencies.
    context = require('energy2d/gpu/context'),
    Texture = require('energy2d/gpu/texture'),
    Shader  = require('energy2d/gpu/shader'),
    Mesh    = require('energy2d/gpu/mesh'),

    // The internal `gl` variable holds the current WebGL context.
    gl,

    // GPGPU utils must know dimensions of data (grid).
    // This assumption that all the textures will have the same dimensions is
    // caused by performance reasons (helps avoiding recreating data structures).
    // To set grid dimensions and initialize WebGL context, call init(grid_width, grid_height).
    grid_width,
    grid_height,

    // Texture used as a temporary storage (Float, RGBA).
    temp_texture,
    // Texture used for Float to RGBA conversion (Unsigned Byte, RGBA).
    output_texture,
    // Array (Float32Array) used as temporal storage during writing RGBA textures.
    temp_storage,
    // Mesh used for rendering.
    plane,

    // Flag which determines if synchronization is allowed or not.
    sync_allowed = false,

    // Flag which determines if WebGL context and necessary objects are initialized.
    WebGL_initialized = false,

    // Special shader for encoding floats based on:
    // https://github.com/cscheid/facet/blob/master/src/shade/bits/encode_float.js
    encode_program,
    copy_program,

    // GLSL sources.
    basic_vertex_shader =
    '\
    varying vec2 coord;\
    void main() {\
      coord = gl_Vertex.xy * 0.5 + 0.5;\
      gl_Position = vec4(gl_Vertex.xyz, 1.0);\
    }',

    encode_fragment_shader =
    '\
    uniform sampler2D texture;\
    uniform float channel;\
    varying vec2 coord;\
    float shift_right(float v, float amt) {\
      v = floor(v) + 0.5;\
      return floor(v / exp2(amt));\
    }\
    float shift_left(float v, float amt) {\
      return floor(v * exp2(amt) + 0.5);\
    }\
    \
    float mask_last(float v, float bits) {\
      return mod(v, shift_left(1.0, bits));\
    }\
    float extract_bits(float num, float from, float to) {\
      from = floor(from + 0.5);\
      to = floor(to + 0.5);\
      return mask_last(shift_right(num, from), to - from);\
    }\
    vec4 encode_float(float val) {\
      if (val == 0.0)\
        return vec4(0, 0, 0, 0);\
      float sign = val > 0.0 ? 0.0 : 1.0;\
      val = abs(val);\
      float exponent = floor(log2(val));\
      float biased_exponent = exponent + 127.0;\
      float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0;\
      \
      float t = biased_exponent / 2.0;\
      float last_bit_of_biased_exponent = fract(t) * 2.0;\
      float remaining_bits_of_biased_exponent = floor(t);\
      \
      float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0;\
      float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0;\
      float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0;\
      float byte1 = (sign * 128.0 + remaining_bits_of_biased_exponent) / 255.0;\
      return vec4(byte4, byte3, byte2, byte1);\
    }\
    void main() {\
      vec4 data = texture2D(texture, coord);\
      if (channel == 0.0)\
        gl_FragColor = encode_float(data.r);\
      else if (channel == 1.0)\
        gl_FragColor = encode_float(data.g);\
      else if (channel == 2.0)\
        gl_FragColor = encode_float(data.b);\
      else\
        gl_FragColor = encode_float(data.a);\
    }',

    copy_fragment_shader =
    '\
    uniform sampler2D texture;\
    varying vec2 coord;\
    void main() {\
      gl_FragColor = texture2D(texture, coord);\
    }',

    // Common error messages.
    INIT_ERR = 'GPGPU: call init(grid_width, grid_height) with proper dimensions first!',

    // Features and extensions. Their availability will be updated during initialization.
    feature = {
      'WebGLContext': {
        required: true,
        available: false
      },
      'OES_texture_float': {
        required: true,
        available: false
      },
      'FLOAT texture as render target': {
        required: true,
        available: false
      },
      'OES_texture_float_linear': {
        required: false,
        available: false
      }
    },

    //
    // Private methods.
    //
    initWebGL = function () {
      // Setup WebGL context.
      gl = context.getWebGLContext();
      if (gl) {
        feature['WebGLContext'].available = true;
      } else {
        feature['WebGLContext'].available = false;
        throw new Error("GPGPU: WebGL is not supported!");
      }

      // Check if OES_texture_float is available.
      if (gl.getExtension('OES_texture_float')) {
        feature['OES_texture_float'].available = true;
      } else {
        feature['OES_texture_float'].available = false;
        throw new Error("GPGPU: OES_texture_float is not supported!");
      }

      // Optional extension check.
      if (gl.getExtension('OES_texture_float_linear')) {
        feature['OES_texture_float_linear'].available = true;
      } else {
        feature['OES_texture_float_linear'].available = false;
        console.warn("GPGPU: OES_texture_float_linear is not supported. Renering quality will be affected.");
      }

      // Check if rendering to FLOAT textures is supported.
      temp_texture = new Texture(1, 1, {
        type: gl.FLOAT,
        format: gl.RGBA,
        filter: feature['OES_texture_float_linear'].available ? gl.LINEAR : gl.NEAREST
      });
      temp_texture.setAsRenderTarget();
      if (gl.checkFramebufferStatus(gl.FRAMEBUFFER) === gl.FRAMEBUFFER_COMPLETE) {
        feature['FLOAT texture as render target'].available = true;
      } else {
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        feature['FLOAT texture as render target'].available = false;
        throw new Error("GPGPU: FLOAT texture as render target is not supported!");
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);

      // Configure WebGL context and create necessary objects and structures.
      gl.disable(gl.DEPTH_TEST);
      plane = Mesh.plane();
      encode_program = new Shader(basic_vertex_shader, encode_fragment_shader);
      copy_program = new Shader(basic_vertex_shader, copy_fragment_shader);
      // Initialization successful.
      WebGL_initialized = true;
    },

    packRGBAData = function (R, G, B, A, storage) {
      var i, i4, len;

      if (R.length !== G.length || R.length !== B.length || R.length !== A.length ||
          storage.length !== R.length * 4) {
        throw new Error("GPGPU: Invalid input data length.");
      }
      for (i = 0, len = R.length; i < len; i += 1) {
        i4 = i * 4;
        storage[i4]     = R[i];
        storage[i4 + 1] = G[i];
        storage[i4 + 2] = B[i];
        storage[i4 + 3] = A[i];
      }
    };

  //
  // Public API.
  //
  return {
    // Setups rendering context (only during first call) and necessary storage (texture, array).
    init: function (width, height) {
      var filter;

      if (!WebGL_initialized) {
        initWebGL();
      }
      // Set dimensions.
      grid_width = width;
      grid_height = height;

      filter = feature['OES_texture_float_linear'].available ? gl.LINEAR : gl.NEAREST;

      // Setup storage for given dimensions.
      temp_texture   = new Texture(grid_width, grid_height, { type: gl.FLOAT, format: gl.RGBA, filter: filter });
      output_texture = new Texture(grid_width, grid_height, { type: gl.UNSIGNED_BYTE, format: gl.RGBA, filter: filter });
      temp_storage   = new Float32Array(grid_width * grid_height * 4);
    },

    get featuresInfo() {
      if (!WebGL_initialized) {
        try {
          // While testing features / extensions, we don't want to throw
          // exceptions.
          initWebGL();
        } catch (e) {}
      }
      return feature;
    },

    getWebGLContext: function () {
      if (gl === undefined) {
        initWebGL();
      }
      return gl;
    },

    // Creates a floating point texture with proper parameters.
    createTexture: function () {
      if (!grid_width || !grid_height) {
        return new Error(INIT_ERR);
      }
      // Use RGBA format as this is the safest option. Single channel textures aren't well supported
      // as render targets attached to FBO.
      return new Texture(grid_width, grid_height, {
        type: gl.FLOAT,
        format: gl.RGBA,
        filter: feature['OES_texture_float_linear'].available ? gl.LINEAR : gl.NEAREST
      });
    },

    // Convert given array to the RGBA FLoat32Array (which can be used
    // in the writeTexture function) and fill one of its channel.
    // Channel should be between 0 and 3, where 0 = R, 1 = G, 2 = B and 3 = A.
    convertToRGBA: function (data, channel, output) {
      var rgba, i, len, i4;

      if (data.length !== grid_width * grid_height) {
        throw new Error("GPGPU: Invalid input data length.");
      }

      if (output === undefined) {
        rgba = new Float32Array(data.length * 4);
      } else {
        rgba = output;
      }

      if (channel === undefined) {
        channel = 0;
      }

      // Fill RGBA array.
      for (i = 0, len = data.length; i < len; i += 1) {
        i4 = i * 4;
        rgba[i4] = rgba[i4 + 1] = rgba[i4 + 2] = rgba[i4 + 3] = 0;
        rgba[i4 + channel] = data[i];
      }

      return rgba;
    },

    // Write a texture.
    writeTexture: function (tex, input) {
      var rgba = this.convertToRGBA(input, 0, temp_storage);
      // Make sure that texture is bound.
      gl.bindTexture(gl.TEXTURE_2D, tex.id);
      gl.texImage2D(gl.TEXTURE_2D, 0, tex.format, tex.width, tex.height, 0, tex.format, tex.type, rgba);
    },

    writeRGBATexture: function (tex, R, G, B, A) {
      packRGBAData(R, G, B, A, temp_storage);
      // Make sure that texture is bound.
      gl.bindTexture(gl.TEXTURE_2D, tex.id);
      gl.texImage2D(gl.TEXTURE_2D, 0, tex.format, tex.width, tex.height, 0, tex.format, tex.type, temp_storage);
    },

    // Read a floating point texture.
    // Returns Float32Array.
    readTexture: function (tex, output, channel) {
      var output_storage;
      if (!gl || tex.width !== grid_width || tex.height !== grid_height) {
        return new Error(INIT_ERR);
      }
      if (channel === undefined) {
        channel = 0;
      }
      // Use buffer of provided ouput array. So, when result is written there,
      // output is automaticaly updated in a right way.
      output_storage = new Uint8Array(output.buffer);

      tex.bind();
      output_texture.setAsRenderTarget();
      encode_program.uniforms({ channel: channel });
      encode_program.draw(plane);
      // format: gl.RGBA, type: gl.UNSIGNED_BYTE - only this set is accepted by WebGL readPixels.
      gl.readPixels(0, 0, output_texture.width, output_texture.height, output_texture.format, output_texture.type, output_storage);
    },

    copyTexture: function (src_tex, dst_tex) {
      src_tex.bind();
      dst_tex.setAsRenderTarget();
      copy_program.draw(plane);
    },

    // Execute a GLSL program.
    // Arguments:
    // - program - GL.Shader
    // - textures - array of GL.Texture
    // - output - output texture
    executeProgram: function (program, textures, output) {
      var i, len;
      // Bind textures for reading.
      for (i = 0, len = textures.length; i < len; i += 1) {
        textures[i].bind(i);
      }
      // Use temp texture as writing and reading from the same texture is impossible.
      temp_texture.setAsRenderTarget();
      // Draw simple plane (coordinates x/y from -1 to 1 to cover whole viewport).
      program.draw(plane);
      // Unbind textures.
      for (i = 0, len = textures.length; i < len; i += 1) {
        textures[i].unbind(i);
      }
      output.swapWith(temp_texture);
    },

    // Synchronization can be useful for debugging.
    setSynchronizationAllowed: function (b) {
      sync_allowed = b;
    },

    // Block until all GL execution is complete if synchronization is allowed.
    tryFinish: function () {
      if (sync_allowed) {
        gl.finish();
      }
    }
  };
});

define('text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/basic.vs.glsl',[],function () { return 'varying vec2 coord;\n\nvoid main() {\n  coord = gl_Vertex.xy * 0.5 + 0.5;\n  gl_Position = vec4(gl_Vertex.xy, 0.0, 1.0);\n}\n';});

define('text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/solver.fs.glsl',[],function () { return '// texture 0:\n// - R: t\n// - G: t0\n// - B: tb\n// - A: conductivity\nuniform sampler2D data0_tex;\n// texture 1:\n// - R: q\n// - G: capacity\n// - B: density\n// - A: fluidity\nuniform sampler2D data1_tex;\n\nuniform vec2 grid;\nuniform float hx;\nuniform float hy;\nuniform float inv_timeStep;\n\n// Boundary conditions uniforms\nuniform float enforce_temp;\nuniform float vN;\nuniform float vS;\nuniform float vW;\nuniform float vE;\n\nvarying vec2 coord;\n\nvoid main() {\n  vec4 data0 = texture2D(data0_tex, coord);\n  if (coord.x > grid.x && coord.x < 1.0 - grid.x &&\n      coord.y > grid.y && coord.y < 1.0 - grid.y) {\n    vec2 dx = vec2(grid.x, 0.0);\n    vec2 dy = vec2(0.0, grid.y);\n    float tb = data0.b;\n    // Check if tb is NaN. isnan() function is not available\n    // in OpenGL ES GLSL, so use some tricks. IEEE 754 spec defines\n    // that NaN != NaN, however this seems to not work on Windows.\n    // So, also check if the value is outside [-3.4e38, 3.4e38] (3.4e38\n    // is close to 32Float max value), as such values are not expected.\n    if (tb != tb || tb < -3.4e38 || tb > 3.4e38) {\n      vec4 data1 = texture2D(data1_tex, coord);\n      vec4 data0_m_dy = texture2D(data0_tex, coord - dy);\n      vec4 data0_p_dy = texture2D(data0_tex, coord + dy);\n      vec4 data0_m_dx = texture2D(data0_tex, coord - dx);\n      vec4 data0_p_dx = texture2D(data0_tex, coord + dx);\n      float sij = data1.g * data1.b * inv_timeStep;\n      float rij = data0.a;\n      float axij = hx * (rij + data0_m_dy.a);\n      float bxij = hx * (rij + data0_p_dy.a);\n      float ayij = hy * (rij + data0_m_dx.a);\n      float byij = hy * (rij + data0_p_dx.a);\n      data0.r = (data0.g * sij + data1.r\n                 + axij * data0_m_dy.r\n                 + bxij * data0_p_dy.r\n                 + ayij * data0_m_dx.r\n                 + byij * data0_p_dx.r)\n                 / (sij + axij + bxij + ayij + byij);\n    } else {\n      data0.r = tb;\n    }\n  } else if (enforce_temp == 1.0) {\n    // "temperature at border" boundary conditions are\n    // integrated into this shader.\n    if (coord.x < grid.x) {\n      data0.r = vN;\n    } else if (coord.x > 1.0 - grid.x) {\n      data0.r = vS;\n    } else if (coord.y < grid.y) {\n      data0.r = vW;\n    } else if (coord.y > 1.0 - grid.y) {\n      data0.r = vE;\n    }\n  }\n  gl_FragColor = data0;\n}\n';});

define('text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/force-flux-t.fs.glsl',[],function () { return '// texture 0: \n// - R: t\n// - G: t0\n// - B: tb\n// - A: conductivity\nuniform sampler2D data0_tex;\n\nuniform vec2 grid;\nuniform float vN;\nuniform float vS;\nuniform float vW;\nuniform float vE;\nuniform float delta_x;\nuniform float delta_y;\n\nvarying vec2 coord;\n\nvoid main() {\n  vec4 data0 = texture2D(data0_tex, coord);\n  vec2 dx = vec2(grid.x, 0.0);\n  vec2 dy = vec2(0.0, grid.y);\n  if (coord.x < grid.x) {\n    data0.r = texture2D(data0_tex, coord + dx).r\n            + vN * delta_y / data0.a;\n  } else if (coord.x > 1.0 - grid.x) {\n    data0.r = texture2D(data0_tex, coord - dx).r\n            - vS * delta_y / data0.a;\n  } else if (coord.y < grid.y) {\n    data0.r = texture2D(data0_tex, coord + dy).r\n            - vW * delta_x / data0.a;\n  } else if (coord.y > 1.0 - grid.y) {\n    data0.r = texture2D(data0_tex, coord - dy).r\n            + vE * delta_x / data0.a;\n  }\n  gl_FragColor = data0;\n}\n';});

define('text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/t-to-t0.fs.glsl',[],function () { return '// texture 0: \n// - R: t\n// - G: t0\n// - B: tb\n// - A: conductivity\nuniform sampler2D data0_tex;\n\nvarying vec2 coord;\n\nvoid main() {\n\tvec4 data0 = texture2D(data0_tex, coord);\n\tdata0.g = data0.r;\n\tgl_FragColor = data0;\n}\n';});

define('text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/maccormack-step1.fs.glsl',[],function () { return '// texture 0: \n// - R: t\n// - G: t0\n// - B: tb\n// - A: conductivity\nuniform sampler2D data0_tex;\n// texture 1: \n// - R: q\n// - G: capacity\n// - B: density\n// - A: fluidity\nuniform sampler2D data1_tex;\n// texture 2: \n// - R: u\n// - G: v\n// - B: u0\n// - A: v0\nuniform sampler2D data2_tex;\n\nuniform vec2 grid;\nuniform float tx;\nuniform float ty;\n\n// Boundary conditions uniforms.\nuniform float enforce_temp;\nuniform float vN;\nuniform float vS;\nuniform float vW;\nuniform float vE;\n\nvarying vec2 coord;\n\nvoid main() {\n  vec4 data0 = texture2D(data0_tex, coord);\n  \n  if (coord.x > grid.x && coord.x < 1.0 - grid.x &&\n      coord.y > grid.y && coord.y < 1.0 - grid.y) {\n    \n    float fluidity = texture2D(data1_tex, coord).a;\n    if (fluidity == 1.0) {\n      vec2 dx = vec2(grid.x, 0.0);\n      vec2 dy = vec2(0.0, grid.y);\n\n      // Temperature.\n      float t_m_dy = texture2D(data0_tex, coord - dy).r;\n      float t_p_dy = texture2D(data0_tex, coord + dy).r;\n      float t_m_dx = texture2D(data0_tex, coord - dx).r;\n      float t_p_dx = texture2D(data0_tex, coord + dx).r;\n      // Velocity.\n      float u_m_dy = texture2D(data2_tex, coord - dy).r;\n      float u_p_dy = texture2D(data2_tex, coord + dy).r;\n      float v_m_dx = texture2D(data2_tex, coord - dx).g;\n      float v_p_dx = texture2D(data2_tex, coord + dx).g;\n      // Update T0.\n      data0.g = data0.r - tx * (u_p_dy * t_p_dy - u_m_dy * t_m_dy)\n                        - ty * (v_p_dx * t_p_dx - v_m_dx * t_m_dx);\n    }\n  } else if (enforce_temp == 1.0) {\n    // "temperature at border" boundary conditions are\n    // integrated into this shader.\n    if (coord.x < grid.x) {\n      data0.g = vN;\n    } else if (coord.x > 1.0 - grid.x) {\n      data0.g = vS;\n    } else if (coord.y < grid.y) {\n      data0.g = vW;\n    } else if (coord.y > 1.0 - grid.y) {\n      data0.g = vE;\n    }\n  }\n  gl_FragColor = data0;\n}\n';});

define('text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/maccormack-step2.fs.glsl',[],function () { return '// texture 0: \n// - R: t\n// - G: t0\n// - B: tb\n// - A: conductivity\nuniform sampler2D data0_tex;\n// texture 1: \n// - R: q\n// - G: capacity\n// - B: density\n// - A: fluidity\nuniform sampler2D data1_tex;\n// texture 2: \n// - R: u\n// - G: v\n// - B: u0\n// - A: v0\nuniform sampler2D data2_tex;\n\nuniform vec2 grid;\nuniform float tx;\nuniform float ty;\n\n// Boundary conditions uniforms.\nuniform float enforce_temp;\nuniform float vN;\nuniform float vS;\nuniform float vW;\nuniform float vE;\n\nvarying vec2 coord;\n\nvoid main() {\n  vec4 data0 = texture2D(data0_tex, coord);\n  \n  if (coord.x > grid.x && coord.x < 1.0 - grid.x &&\n      coord.y > grid.y && coord.y < 1.0 - grid.y) {\n    \n    float fluidity = texture2D(data1_tex, coord).a;\n    if (fluidity == 1.0) {\n      vec2 dx = vec2(grid.x, 0.0);\n      vec2 dy = vec2(0.0, grid.y);\n\n      // Temperature t0.\n      float t0_m_dy = texture2D(data0_tex, coord - dy).g;\n      float t0_p_dy = texture2D(data0_tex, coord + dy).g;\n      float t0_m_dx = texture2D(data0_tex, coord - dx).g;\n      float t0_p_dx = texture2D(data0_tex, coord + dx).g;\n      // Velocity.\n      float u = texture2D(data2_tex, coord).r;\n      float v = texture2D(data2_tex, coord).g;\n      // Update T.\n      data0.r = 0.5 * (data0.r + data0.g)\n              - 0.5 * tx * u * (t0_p_dy - t0_m_dy)\n              - 0.5 * ty * v * (t0_p_dx - t0_m_dx);\n    }\n  } else if (enforce_temp == 1.0) {\n    // "temperature at border" boundary conditions are\n    // integrated into this shader.\n    if (coord.x < grid.x) {\n      data0.r = vN;\n    } else if (coord.x > 1.0 - grid.x) {\n      data0.r = vS;\n    } else if (coord.y < grid.y) {\n      data0.r = vW;\n    } else if (coord.y > 1.0 - grid.y) {\n      data0.r = vE;\n    }\n  }\n  gl_FragColor = data0;\n}\n';});

/*global define: false*/

define('energy2d/models/physics-solvers-gpu/heat-solver-gpu',['require','exports','module','energy2d/gpu/shader','energy2d/gpu/gpgpu','text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/basic.vs.glsl','text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/solver.fs.glsl','text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/force-flux-t.fs.glsl','text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/force-flux-t.fs.glsl','text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/t-to-t0.fs.glsl','text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/maccormack-step1.fs.glsl','text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/maccormack-step2.fs.glsl'],function (require, exports) {
  'use strict';
  var
    // Dependencies.
    Shader = require('energy2d/gpu/shader'),
    // GPGPU utilities. It's a singleton instance.
    // It should have been previously initialized by core-model.
    gpgpu  = require('energy2d/gpu/gpgpu'),
    // Shader sources.
    basic_vs            = require('text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/basic.vs.glsl'),
    solver_fs           = require('text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/solver.fs.glsl'),
    force_flux_t_fs     = require('text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/force-flux-t.fs.glsl'),
    force_flux_t0_fs    = require('text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/force-flux-t.fs.glsl'),
    t_to_t0             = require('text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/t-to-t0.fs.glsl'),
    maccormack_step1_fs = require('text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/maccormack-step1.fs.glsl'),
    maccormack_step2_fs = require('text!energy2d/models/physics-solvers-gpu/heat-solver-glsl/maccormack-step2.fs.glsl'),

    RELAXATION_STEPS = 10;

  exports.makeHeatSolverGPU = function (model) {
    var
      // ========================================================================
      // GLSL Shaders:
      // - Main solver.
      solver_program           = new Shader(basic_vs, solver_fs),
      // - Force flux boundary (for T).
      force_flux_t_program     = new Shader(basic_vs, force_flux_t_fs),
      // - Force flux boundary (for T0).
      force_flux_t0_program    = new Shader(basic_vs, force_flux_t0_fs),
      // - Copy single channel of texture (t to t0).
      t_to_t0_program          = new Shader(basic_vs, t_to_t0),
      // - MacCormack advection step 1.
      maccormack_step1_program = new Shader(basic_vs, maccormack_step1_fs),
      // - MacCormack advection step 2.
      maccormack_step2_program = new Shader(basic_vs, maccormack_step2_fs),
      // ========================================================================

      // Basic simulation parameters.
      props = model.getModelOptions(),
      nx = props.grid_width,
      ny = props.grid_height,

      timeStep = props.timeStep,
      boundary = props.boundary,

      delta_x = props.model_width / props.grid_width,
      delta_y = props.model_height / props.grid_height,

      relaxation_steps = RELAXATION_STEPS,

      // Simulation textures provided by model.
      // texture 0:
      // - R: t
      // - G: t0
      // - B: tb
      // - A: conductivity
      data0_tex = model.getSimulationTexture(0),
      // texture 1:
      // - R: q
      // - G: capacity
      // - B: density
      // - A: fluidity
      data1_tex = model.getSimulationTexture(1),
      // texture 2:
      // - R: u
      // - G: v
      // - B: u0
      // - A: v0
      data2_tex = model.getSimulationTexture(2),

      // Convenience variables.
      data_0_1_2_array = [data0_tex, data1_tex, data2_tex],
      data_0_1_array = [data0_tex, data1_tex],
      data_0_array = [data0_tex],
      grid_vec = [1 / ny, 1 / nx],

      init = function () {
        var uniforms;

        // Solver program uniforms.
        uniforms = {
          // Texture units.
          data0_tex: 0,
          data1_tex: 1,
          // Uniforms.
          grid: grid_vec,
          enforce_temp: 0.0,
          hx: 0.5 / (delta_x * delta_x),
          hy: 0.5 / (delta_y * delta_y),
          inv_timeStep: 1.0 / timeStep
        };
        solver_program.uniforms(uniforms);

        // MacCormack step 1 program uniforms.
        uniforms = {
          // Texture units.
          data0_tex: 0,
          data1_tex: 1,
          data2_tex: 2,
          // Uniforms.
          grid: grid_vec,
          enforce_temp: 0.0,
          tx: 0.5 * timeStep / delta_x,
          ty: 0.5 * timeStep / delta_y
        };
        maccormack_step1_program.uniforms(uniforms);
        maccormack_step2_program.uniforms(uniforms);

        if (boundary.type === "temperature") {
          uniforms = {
            // Additional uniforms.
            enforce_temp: 1.0,
            vN:  boundary.upper,
            vS:  boundary.lower,
            vW:  boundary.left,
            vE:  boundary.right
          };
          // Integrate boundary conditions with other programs.
          // This is optimization that allows to limit render-to-texture calls.
          solver_program.uniforms(uniforms);
          maccormack_step1_program.uniforms(uniforms);
          maccormack_step2_program.uniforms(uniforms);
        } else if (boundary.type === "flux") {
          uniforms = {
            // Texture units.
            data0_tex: 0,
            // Uniforms.
            grid: grid_vec,
            vN: boundary.upper,
            vS: boundary.lower,
            vW: boundary.left,
            vE: boundary.right,
            delta_x: delta_x,
            delta_y: delta_y
          };
          // Flux boundary conditions can't be integrated into solver program,
          // so use separate GLSL programs.
          force_flux_t_program.uniforms(uniforms);
          force_flux_t0_program.uniforms(uniforms);
        }
      },

      macCormack = function () {
        // MacCormack step 1.
        gpgpu.executeProgram(
          maccormack_step1_program,
          data_0_1_2_array,
          data0_tex
        );
        if (boundary.type === "flux") {
          // Additional program for boundary conditions
          // is required only for "flux at border" option.
          // If "temperature at border" is used, boundary
          // conditions are enforced by the MacCormack program.
          gpgpu.executeProgram(
            force_flux_t0_program,
            data_0_array,
            data0_tex
          );
        }
        // MacCormack step 2.
        gpgpu.executeProgram(
          maccormack_step2_program,
          data_0_1_2_array,
          data0_tex
        );
        if (boundary.type === "flux") {
          // Additional program for boundary conditions
          // is required only for "flux at border" option.
          // If "temperature at border" is used, boundary
          // conditions are enforced by the MacCormack program.
          gpgpu.executeProgram(
            force_flux_t_program,
            data_0_array,
            data0_tex
          );
        }
      },

      heat_solver_gpu = {
        solve: function (convective) {
          var k;
          // Store previous values of t in t0.
          gpgpu.executeProgram(
            t_to_t0_program,
            data_0_array,
            data0_tex
          );
          for (k = 0; k < relaxation_steps; k += 1) {
            gpgpu.executeProgram(
              solver_program,
              data_0_1_array,
              data0_tex
            );
            if (boundary.type === "flux") {
              // Additional program for boundary conditions
              // is required only for "flux at border" option.
              // If "temperature at border" is used, boundary
              // conditions are enforced by the solver program.
              gpgpu.executeProgram(
                force_flux_t_program,
                data_0_array,
                data0_tex
              );
            }
          }
          if (convective) {
            macCormack();
          }
        }
      };
    // One-off initialization.
    init();
    return heat_solver_gpu;
  };
});

/*global define: false*/

define('energy2d/models/physics-solvers/fluid-solver',['require','exports','module','arrays'],function (require, exports) {
  'use strict';
  var
    arrays = require('arrays'),

    RELAXATION_STEPS = 5,
    GRAVITY = 0,

    BUOYANCY_AVERAGE_ALL = 0,
    BUOYANCY_AVERAGE_COLUMN = 1;

  exports.makeFluidSolver = function (model) {
    var
      // Basic simulation parameters.
      props = model.getModelOptions(),
      nx = props.grid_width,
      ny = props.grid_height,

      relaxationSteps = RELAXATION_STEPS,
      gravity = GRAVITY,

      // Simulation arrays provided by model.
      t        = model.getTemperatureArray(),
      fluidity = model.getFluidityArray(),
      uWind    = model.getUWindArray(),
      vWind    = model.getVWindArray(),

      // Internal simulation arrays.
      array_type = model.getArrayType(),
      u0         = arrays.create(nx * ny, 0, array_type),
      v0         = arrays.create(nx * ny, 0, array_type),

      // Convenience variables.
      nx1 = nx - 1,
      ny1 = ny - 1,
      nx2 = nx - 2,
      ny2 = ny - 2,

      deltaX = props.model_width / props.grid_width,
      deltaY = props.model_height / props.grid_height,

      i2dx  = 0.5 / deltaX,
      i2dy  = 0.5 / deltaY,
      idxsq = 1.0 / (deltaX * deltaX),
      idysq = 1.0 / (deltaY * deltaY),

      //
      // Private methods
      //

      // b = 1 horizontal; b = 2 vertical
      applyBoundary = function (b, f) {
        var
          horizontal = b === 1,
          vertical   = b === 2,
          nx1nx = nx1 * nx,
          nx2nx = nx2 * nx,
          i, j, inx, inx_plus1, inx_plus_ny1, inx_plus_ny2, nx_plusj;

        for (i = 1; i < nx1; i += 1) {
          inx = i * nx;
          inx_plus1 = inx + 1;
          inx_plus_ny1 = inx + ny1;
          inx_plus_ny2 = inx + ny2;
          // upper side
          f[inx] = vertical ? -f[inx_plus1] : f[inx_plus1];
          // lower side
          f[inx_plus_ny1] = vertical ? -f[inx_plus_ny2] : f[inx_plus_ny2];
        }
        for (j = 1; j < ny1; j += 1) {
          // left side
          nx_plusj = nx + j;
          f[j] = horizontal ? -f[nx_plusj] : f[nx_plusj];
          // right side
          f[nx1nx + j] = horizontal ? -f[nx2nx + j] : f[nx2nx + j];
        }

        // upper-left corner
        f[0] = 0.5 * (f[nx] + f[1]);
        // upper-right corner
        f[nx1nx] = 0.5 * (f[nx2nx] + f[nx1nx + 1]);
        // lower-left corner
        f[ny1] = 0.5 * (f[nx + ny1] + f[ny2]);
        // lower-right corner
        f[nx1nx + ny1] = 0.5 * (f[nx2nx + ny1] + f[nx1nx + ny2]);
      },

      setObstacleVelocity = function (u, v) {
        var
          count = 0,
          uw, vw,
          i, j, inx, jinx, jinx_plus_nx, jinx_minus_nx, jinx_plus_1, jinx_minus_1;

        for (i = 1; i < nx1; i += 1) {
          inx = i * nx;
          for (j = 1; j < ny1; j += 1) {
            jinx = inx + j;
            jinx_minus_nx = jinx - nx;
            jinx_plus_nx = jinx + nx;
            jinx_minus_1 = jinx - 1;
            jinx_plus_1 = jinx + 1;

            if (!fluidity[jinx]) {
              uw = uWind[jinx];
              vw = vWind[jinx];
              count = 0;
              if (fluidity[jinx_minus_nx]) {
                count += 1;
                u[jinx] = uw - u[jinx_minus_nx];
                v[jinx] = vw + v[jinx_minus_nx];
              } else if (fluidity[jinx_plus_nx]) {
                count += 1;
                u[jinx] = uw - u[jinx_plus_nx];
                v[jinx] = vw + v[jinx_plus_nx];
              }
              if (fluidity[jinx_minus_1]) {
                count += 1;
                u[jinx] = uw + u[jinx_minus_1];
                v[jinx] = vw - v[jinx_minus_1];
              } else if (fluidity[jinx_plus_1]) {
                count += 1;
                u[jinx] = uw + u[jinx_plus_1];
                v[jinx] = vw - v[jinx_plus_1];
              }
              if (count === 0) {
                u[jinx] = uw;
                v[jinx] = vw;
              }
            }
          }
        }
      },

      // ensure dx/dn = 0 at the boundary (the Neumann boundary condition)
      // float[][] x
      setObstacleBoundary = function (x) {
        var i, j, inx, jinx, jinx_plus_nx, jinx_minus_nx, jinx_plus_1, jinx_minus_1;

        for (i = 1; i < nx1; i += 1) {
          inx = i * nx;
          for (j = 1; j < ny1; j += 1) {
            jinx = inx + j;
            if (!fluidity[jinx]) {
              jinx_minus_nx = jinx - nx;
              jinx_plus_nx = jinx + nx;
              jinx_minus_1 = jinx - 1;
              jinx_plus_1 = jinx + 1;

              if (fluidity[jinx_minus_nx]) {
                x[jinx] = x[jinx_minus_nx];
              } else if (fluidity[jinx_plus_nx]) {
                x[jinx] = x[jinx_plus_nx];
              }
              if (fluidity[jinx_minus_1]) {
                x[jinx] = x[jinx_minus_1];
              } else if (fluidity[jinx_plus_1]) {
                x[jinx] = x[jinx_plus_1];
              }
            }
          }
        }
      },

      getMeanTemperature = function (i, j) {
        var
          lowerBound = 0,
          upperBound = ny,
          t0 = 0,
          k, inx_plus_k;

          // search for the upper bound
        for (k = j - 1; k > 0; k -= 1) {
          inx_plus_k = i * nx + k;
          if (!fluidity[inx_plus_k]) {
            lowerBound = k;
            break;
          }
        }

        for (k = j + 1; k < ny; k += 1) {
          inx_plus_k = i * nx + k;
          if (!fluidity[inx_plus_k]) {
            upperBound = k;
            break;
          }
        }

        for (k = lowerBound; k < upperBound; k += 1) {
          inx_plus_k = i * nx + k;
          t0 += t[inx_plus_k];
        }
        return t0 / (upperBound - lowerBound);
      },

      applyBuoyancy = function (f) {
        var
          g = gravity * props.timeStep,
          b = props.thermal_buoyancy * props.timeStep,
          t0,
          i, j, inx, jinx;

        switch (props.buoyancy_approximation) {
        case BUOYANCY_AVERAGE_ALL:
          t0 = (function (array) {
            // Returns average value of an array.
            var
              acc = 0,
              length = array.length,
              i;
            for (i = 0; i < length; i += 1) {
              acc += array[i];
            }
            return acc / length;
          }(t)); // Call with the temperature array.
          for (i = 1; i < nx1; i += 1) {
            inx = i * nx;
            for (j = 1; j < ny1; j += 1) {
              jinx = inx + j;
              if (fluidity[jinx]) {
                f[jinx] += (g - b) * t[jinx] + b * t0;
              }
            }
          }
          break;
        case BUOYANCY_AVERAGE_COLUMN:
          for (i = 1; i < nx1; i += 1) {
            inx = i * nx;
            for (j = 1; j < ny1; j += 1) {
              jinx = inx + j;
              if (fluidity[jinx]) {
                t0 = getMeanTemperature(i, j);
                f[jinx] += (g - b) * t[jinx] + b * t0;
              }
            }
          }
          break;
        }
      },

      conserve = function (u, v, phi, div) {
        var
          s = 0.5 / (idxsq + idysq),
          k, i, j, inx, jinx, jinx_plus_nx, jinx_minus_nx, jinx_plus_1, jinx_minus_1;

        for (i = 1; i < nx1; i += 1) {
          inx = i * nx;
          for (j = 1; j < ny1; j += 1) {
            jinx = inx + j;
            if (fluidity[jinx]) {
              jinx_minus_nx = jinx - nx;
              jinx_plus_nx = jinx + nx;
              jinx_minus_1 = jinx - 1;
              jinx_plus_1 = jinx + 1;

              div[jinx] = (u[jinx_plus_nx] - u[jinx_minus_nx]) * i2dx + (v[jinx_plus_1] - v[jinx_minus_1]) * i2dy;
              phi[jinx] = 0;
            }
          }
        }
        applyBoundary(0, div);
        applyBoundary(0, phi);
        setObstacleBoundary(div);
        setObstacleBoundary(phi);

        for (k = 0; k < relaxationSteps; k += 1) {
          for (i = 1; i < nx1; i += 1) {
            inx = i * nx;
            for (j = 1; j < ny1; j += 1) {
              jinx = inx + j;
              if (fluidity[jinx]) {
                jinx_minus_nx = jinx - nx;
                jinx_plus_nx = jinx + nx;
                jinx_minus_1 = jinx - 1;
                jinx_plus_1 = jinx + 1;

                phi[jinx] = s
                    * ((phi[jinx_minus_nx] + phi[jinx_plus_nx]) * idxsq
                    + (phi[jinx_minus_1] + phi[jinx_plus_1]) * idysq - div[jinx]);
              }
            }
          }
        }

        for (i = 1; i < nx1; i += 1) {
          inx = i * nx;
          for (j = 1; j < ny1; j += 1) {
            jinx = inx + j;
            if (fluidity[jinx]) {
              jinx_minus_nx = jinx - nx;
              jinx_plus_nx = jinx + nx;
              jinx_minus_1 = jinx - 1;
              jinx_plus_1 = jinx + 1;

              u[jinx] -= (phi[jinx_plus_nx] - phi[jinx_minus_nx]) * i2dx;
              v[jinx] -= (phi[jinx_plus_1] - phi[jinx_minus_1]) * i2dy;
            }
          }
        }
        applyBoundary(1, u);
        applyBoundary(2, v);
      },

      diffuse = function (b, f0, f) {
        var
          timeStep = props.timeStep,
          viscosity = props.background_viscosity,
          hx = timeStep * viscosity * idxsq,
          hy = timeStep * viscosity * idysq,
          dn = 1.0 / (1 + 2 * (hx + hy)),
          k, i, j, inx, jinx, jinx_plus_nx, jinx_minus_nx, jinx_plus_1, jinx_minus_1;

        arrays.copy(f, f0);
        for (k = 0; k < relaxationSteps; k += 1) {
          for (i = 1; i < nx1; i += 1) {
            inx = i * nx;
            for (j = 1; j < ny1; j += 1) {
              jinx = inx + j;
              if (fluidity[jinx]) {
                jinx_minus_nx = jinx - nx;
                jinx_plus_nx = jinx + nx;
                jinx_minus_1 = jinx - 1;
                jinx_plus_1 = jinx + 1;

                f[jinx] = (f0[jinx] + hx * (f[jinx_minus_nx] + f[jinx_plus_nx]) + hy
                        * (f[jinx_minus_1] + f[jinx_plus_1]))
                        * dn;
              }
            }
          }
          applyBoundary(b, f);
        }
      },

      // MacCormack
      macCormack = function (b, f0, f) {
        var
          timeStep = props.timeStep,
          tx = 0.5 * timeStep / deltaX,
          ty = 0.5 * timeStep / deltaY,
          i, j, inx, jinx, jinx_plus_nx, jinx_minus_nx, jinx_plus_1, jinx_minus_1;

        for (i = 1; i < nx1; i += 1) {
          inx = i * nx;
          for (j = 1; j < ny1; j += 1) {
            jinx = inx + j;
            if (fluidity[jinx]) {
              jinx_minus_nx = jinx - nx;
              jinx_plus_nx = jinx + nx;
              jinx_minus_1 = jinx - 1;
              jinx_plus_1 = jinx + 1;

              f[jinx] = f0[jinx]
                      - tx
                      * (u0[jinx_plus_nx] * f0[jinx_plus_nx] - u0[jinx_minus_nx]
                              * f0[jinx_minus_nx])
                      - ty
                      * (v0[jinx_plus_1] * f0[jinx_plus_1] - v0[jinx_minus_1]
                              * f0[jinx_minus_1]);
            }
          }
        }

        applyBoundary(b, f);

        for (i = 1; i < nx1; i += 1) {
          inx = i * nx;
          for (j = 1; j < ny1; j += 1) {
            jinx = inx + j;
            if (fluidity[jinx]) {
              jinx_minus_nx = jinx - nx;
              jinx_plus_nx = jinx + nx;
              jinx_minus_1 = jinx - 1;
              jinx_plus_1 = jinx + 1;

              f0[jinx] = 0.5 * (f0[jinx] + f[jinx]) - 0.5 * tx
                      * u0[jinx] * (f[jinx_plus_nx] - f[jinx_minus_nx]) - 0.5
                      * ty * v0[jinx] * (f[jinx_plus_1] - f[jinx_minus_1]);
            }
          }
        }

        arrays.copy(f0, f);

        applyBoundary(b, f);
      },

      advect = function (b, f0, f) {
        macCormack(b, f0, f);
      };

    return {
      // TODO: swap the two arrays instead of copying them every time?
      solve: function (u, v) {
        if (props.thermal_buoyancy !== 0) {
          applyBuoyancy(v);
        }
        setObstacleVelocity(u, v);
        if (props.background_viscosity > 0) {
          // inviscid case
          diffuse(1, u0, u);
          diffuse(2, v0, v);
          conserve(u, v, u0, v0);
          setObstacleVelocity(u, v);
        }
        arrays.copy(u, u0);
        arrays.copy(v, v0);
        advect(1, u0, u);
        advect(2, v0, v);
        conserve(u, v, u0, v0);
        setObstacleVelocity(u, v);
      }
    };
  };
});

define('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/basic.vs.glsl',[],function () { return 'varying vec2 coord;\n\nvoid main() {\n  coord = gl_Vertex.xy * 0.5 + 0.5;\n  gl_Position = vec4(gl_Vertex.xy, 0.0, 1.0);\n}\n';});

define('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/maccormack-step1.fs.glsl',[],function () { return '// texture 1: \n// - R: q\n// - G: capacity\n// - B: density\n// - A: fluidity\nuniform sampler2D data1_tex;\n// texture 2: \n// - R: u\n// - G: v\n// - B: u0\n// - A: v0\nuniform sampler2D data2_tex;\n\nuniform vec2 grid;\nuniform float tx;\nuniform float ty;\n\nvarying vec2 coord;\n\nvoid main() {\n  vec4 data2 = texture2D(data2_tex, coord);\n  float fluidity = texture2D(data1_tex, coord).a;\n  \n  if (coord.x > grid.x && coord.x < 1.0 - grid.x &&\n      coord.y > grid.y && coord.y < 1.0 - grid.y &&\n      fluidity == 1.0) {\n    \n    vec2 dx = vec2(grid.x, 0.0);\n    vec2 dy = vec2(0.0, grid.y);\n    \n    vec4 data2_m_dy = texture2D(data2_tex, coord - dy);\n    vec4 data2_p_dy = texture2D(data2_tex, coord + dy);\n    vec4 data2_m_dx = texture2D(data2_tex, coord - dx);\n    vec4 data2_p_dx = texture2D(data2_tex, coord + dx);\n    // Update velocity UV components.\n    data2.rg = data2.ba - tx * (data2_p_dy.bb * data2_p_dy.ba - data2_m_dy.bb * data2_m_dy.ba)\n              - ty * (data2_p_dx.aa * data2_p_dx.ba - data2_m_dx.aa * data2_m_dx.ba);\n  }\n\n  gl_FragColor = data2;\n}\n';});

define('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/maccormack-step2.fs.glsl',[],function () { return '// texture 1: \n// - R: q\n// - G: capacity\n// - B: density\n// - A: fluidity\nuniform sampler2D data1_tex;\n// texture 2: \n// - R: u\n// - G: v\n// - B: u0\n// - A: v0\nuniform sampler2D data2_tex;\n\nuniform vec2 grid;\nuniform float tx;\nuniform float ty;\n\nvarying vec2 coord;\n\nvoid main() {\n  vec4 data2 = texture2D(data2_tex, coord);\n  float fluidity = texture2D(data1_tex, coord).a;\n  \n  if (coord.x > grid.x && coord.x < 1.0 - grid.x &&\n      coord.y > grid.y && coord.y < 1.0 - grid.y &&\n      fluidity == 1.0) {\n    \n    vec2 dx = vec2(grid.x, 0.0);\n    vec2 dy = vec2(0.0, grid.y);\n    \n    vec4 data2_m_dy = texture2D(data2_tex, coord - dy);\n    vec4 data2_p_dy = texture2D(data2_tex, coord + dy);\n    vec4 data2_m_dx = texture2D(data2_tex, coord - dx);\n    vec4 data2_p_dx = texture2D(data2_tex, coord + dx);\n    // Update velocity UV components.\n    data2.rg = 0.5 * (data2.ba + data2.rg) \n            - 0.5 * tx * data2.bb * (data2_p_dy.rg - data2_m_dy.rg)\n            - 0.5 * ty * data2.aa * (data2_p_dx.rg - data2_m_dx.rg);\n  }\n\n  gl_FragColor = data2;\n}\n';});

define('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/apply-uv-boundary.fs.glsl',[],function () { return '// texture 2: \n// - R: u\n// - G: v\n// - B: u0\n// - A: v0\nuniform sampler2D data2_tex;\n\nuniform vec2 grid;\n\nvarying vec2 coord;\n\nvoid main() {\n  vec4 data2 = texture2D(data2_tex, coord);\n  vec2 dx = vec2(grid.x, 0.0);\n  vec2 dy = vec2(0.0, grid.y);\n  // Process corners.\n  // TODO: values from previous step are used for corners.\n  if (coord.x < grid.x && coord.y < grid.y) {  \n    vec4 data2_p_dy = texture2D(data2_tex, coord + dy);\n    vec4 data2_p_dx = texture2D(data2_tex, coord + dx);\n    data2.rg = 0.5 * (data2_p_dy.rg + data2_p_dx.rg);\n  }\n  else if (coord.x > 1.0 - grid.x && coord.y < grid.y) {  \n    vec4 data2_p_dy = texture2D(data2_tex, coord + dy);\n    vec4 data2_m_dx = texture2D(data2_tex, coord - dx);\n    data2.rg = 0.5 * (data2_p_dy.rg + data2_m_dx.rg);\n  }\n  else if (coord.x > 1.0 - grid.x && coord.y > 1.0 - grid.y) {  \n    vec4 data2_m_dy = texture2D(data2_tex, coord - dy);\n    vec4 data2_m_dx = texture2D(data2_tex, coord - dx);\n    data2.rg = 0.5 * (data2_m_dy.rg + data2_m_dx.rg);\n  }\n  else if (coord.x < grid.x && coord.y > 1.0 - grid.y) {  \n    vec4 data2_m_dy = texture2D(data2_tex, coord - dy);\n    vec4 data2_p_dx = texture2D(data2_tex, coord + dx);\n    data2.rg = 0.5 * (data2_m_dy.rg + data2_p_dx.rg);\n  }\n  // Process boundaries.\n  // Left.\n  else if (coord.x < grid.x) {\n    vec4 data2_p_dx = texture2D(data2_tex, coord + dx);\n    data2.rg = vec2(data2_p_dx.r, -data2_p_dx.g);\n  }\n  // Right.\n  else if (coord.x > 1.0 - grid.x) {\n    vec4 data2_m_dx = texture2D(data2_tex, coord - dx);\n    data2.rg = vec2(data2_m_dx.r, -data2_m_dx.g);\n  }\n  // Down.\n  else if (coord.y < grid.y) {\n    vec4 data2_p_dy = texture2D(data2_tex, coord + dy);\n    data2.rg = vec2(-data2_p_dy.r, data2_p_dy.g);\n  }\n  // Up.\n  else if (coord.y > 1.0 - grid.y) {\n    vec4 data2_m_dy = texture2D(data2_tex, coord - dy);\n    data2.rg = vec2(-data2_m_dy.r, data2_m_dy.g);\n  }\n  \n  gl_FragColor = data2;\n}\n';});

define('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/apply-u0v0-boundary.fs.glsl',[],function () { return '// texture 2: \n// - R: u\n// - G: v\n// - B: u0\n// - A: v0\nuniform sampler2D data2_tex;\n\nuniform vec2 grid;\n\nvarying vec2 coord;\n\nvoid main() {\n  vec4 data2 = texture2D(data2_tex, coord);\n  vec2 dx = vec2(grid.x, 0.0);\n  vec2 dy = vec2(0.0, grid.y);\n  // Process corners.\n  // TODO: values from previous step are used for corners.\n  if (coord.x < grid.x && coord.y < grid.y) {  \n    vec4 data2_p_dy = texture2D(data2_tex, coord + dy);\n    vec4 data2_p_dx = texture2D(data2_tex, coord + dx);\n    data2.ba = 0.5 * (data2_p_dy.ba + data2_p_dx.ba);\n  }\n  else if (coord.x > 1.0 - grid.x && coord.y < grid.y) {  \n    vec4 data2_p_dy = texture2D(data2_tex, coord + dy);\n    vec4 data2_m_dx = texture2D(data2_tex, coord - dx);\n    data2.ba = 0.5 * (data2_p_dy.ba + data2_m_dx.ba);\n  }\n  else if (coord.x > 1.0 - grid.x && coord.y > 1.0 - grid.y) {  \n    vec4 data2_m_dy = texture2D(data2_tex, coord - dy);\n    vec4 data2_m_dx = texture2D(data2_tex, coord - dx);\n    data2.ba = 0.5 * (data2_m_dy.ba + data2_m_dx.ba);\n  }\n  else if (coord.x < grid.x && coord.y > 1.0 - grid.y) {  \n    vec4 data2_m_dy = texture2D(data2_tex, coord - dy);\n    vec4 data2_p_dx = texture2D(data2_tex, coord + dx);\n    data2.ba = 0.5 * (data2_m_dy.ba + data2_p_dx.ba);\n  }\n  // Process boundaries.\n  // Left.\n  else if (coord.x < grid.x) {\n    data2.ba = texture2D(data2_tex, coord + dx).ba;\n  }\n  // Right.\n  else if (coord.x > 1.0 - grid.x) {\n    data2.ba = texture2D(data2_tex, coord - dx).ba;\n  }\n  // Down.\n  else if (coord.y < grid.y) {\n    data2.ba = texture2D(data2_tex, coord + dy).ba;\n  }\n  // Up.\n  else if (coord.y > 1.0 - grid.y) {\n    data2.ba = texture2D(data2_tex, coord - dy).ba;\n  }\n  \n  gl_FragColor = data2;\n}\n';});

define('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/set-obstacle-boundary.fs.glsl',[],function () { return '// texture 1: \n// - R: q\n// - G: capacity\n// - B: density\n// - A: fluidity\nuniform sampler2D data1_tex;\n// texture 2: \n// - R: u\n// - G: v\n// - B: u0\n// - A: v0\nuniform sampler2D data2_tex;\n\nuniform vec2 grid;\n\nvarying vec2 coord;\n\nvoid main() {\n  vec4 data2 = texture2D(data2_tex, coord);\n  float fluidity = texture2D(data1_tex, coord).a;\n  \n  if (coord.x > grid.x && coord.x < 1.0 - grid.x &&\n      coord.y > grid.y && coord.y < 1.0 - grid.y &&\n      fluidity == 0.0) {\n    \n    vec2 dx = vec2(grid.x, 0.0);\n    vec2 dy = vec2(0.0, grid.y);\n\n    if (texture2D(data1_tex, coord - dy).a == 1.0) {\n      data2.ba = texture2D(data2_tex, coord - dy).ba;\n    } \n    else if (texture2D(data1_tex, coord + dy).a == 1.0) {\n      data2.ba = texture2D(data2_tex, coord + dy).ba;\n    } \n\n    if (texture2D(data1_tex, coord - dx).a == 1.0) {\n      data2.ba = texture2D(data2_tex, coord - dx).ba;\n    } \n    else if (texture2D(data1_tex, coord + dx).a == 1.0) {\n      data2.ba = texture2D(data2_tex, coord + dx).ba;\n    } \n  }\n\n  gl_FragColor = data2;\n}\n';});

define('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/set-obstacle-velocity.fs.glsl',[],function () { return '// texture 1: \n// - R: q\n// - G: capacity\n// - B: density\n// - A: fluidity\nuniform sampler2D data1_tex;\n// texture 2: \n// - R: u\n// - G: v\n// - B: u0\n// - A: v0\nuniform sampler2D data2_tex;\n// texture 3: \n// - R: uWind\n// - G: vWind\n// - B: undefined\n// - A: undefined\nuniform sampler2D data3_tex;\n\nuniform vec2 grid;\n\nvarying vec2 coord;\n\nvoid main() {\n  vec4 data2 = texture2D(data2_tex, coord);\n  float fluidity = texture2D(data1_tex, coord).a;\n\n  if (coord.x > grid.x && coord.x < 1.0 - grid.x &&\n      coord.y > grid.y && coord.y < 1.0 - grid.y &&\n      fluidity == 0.0) {\n    \n    vec2 dx = vec2(grid.x, 0.0);\n    vec2 dy = vec2(0.0, grid.y);\n\n    int count = 0;\n\n    if (texture2D(data1_tex, coord - dy).a == 1.0) {\n      count += 1;\n      vec2 data2_m_dy = texture2D(data2_tex, coord - dy).rg;\n      data2.rg = texture2D(data3_tex, coord).rg + vec2(-data2_m_dy.r, data2_m_dy.g);\n    } \n    else if (texture2D(data1_tex, coord + dy).a == 1.0) {\n      count += 1;\n      vec2 data2_p_dy = texture2D(data2_tex, coord + dy).rg;\n      data2.rg = texture2D(data3_tex, coord).rg + vec2(-data2_p_dy.r, data2_p_dy.g);\n    } \n\n    if (texture2D(data1_tex, coord - dx).a == 1.0) {\n      count += 1;\n      vec2 data2_m_dx = texture2D(data2_tex, coord - dx).rg;\n      data2.rg = texture2D(data3_tex, coord).rg + vec2(data2_m_dx.r, -data2_m_dx.g);\n    } \n    else if (texture2D(data1_tex, coord + dx).a == 1.0) {\n      count += 1;\n      vec2 data2_p_dx = texture2D(data2_tex, coord + dx).rg;\n      data2.rg = texture2D(data3_tex, coord).rg + vec2(data2_p_dx.r, -data2_p_dx.g);\n    } \n\n    if (count == 0) {\n      data2.rg = texture2D(data3_tex, coord).rg;\n    }\n  }\n  \n  gl_FragColor = data2;\n}\n';});

define('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/uv-to-u0v0.fs.glsl',[],function () { return '// texture 2: \n// - R: u\n// - G: v\n// - B: u0\n// - A: v0\nuniform sampler2D data2_tex;\n\nvarying vec2 coord;\n\nvoid main() {\n\tvec4 data2 = texture2D(data2_tex, coord);\n\tdata2.ba = data2.rg;\n\tgl_FragColor = data2;\n}\n';});

define('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/conserve-step1.fs.glsl',[],function () { return '// texture 1: \n// - R: q\n// - G: capacity\n// - B: density\n// - A: fluidity\nuniform sampler2D data1_tex;\n// texture 2: \n// - R: u\n// - G: v\n// - B: u0\n// - A: v0\nuniform sampler2D data2_tex;\n\nuniform vec2 grid;\nuniform float i2dx;\nuniform float i2dy;\n\nvarying vec2 coord;\n\nvoid main() {\n  vec4 data2 = texture2D(data2_tex, coord);\n  float fluidity = texture2D(data1_tex, coord).a;\n  \n  if (coord.x > grid.x && coord.x < 1.0 - grid.x &&\n      coord.y > grid.y && coord.y < 1.0 - grid.y &&\n      fluidity == 1.0) {\n    \n    vec2 dx = vec2(grid.x, 0.0);\n    vec2 dy = vec2(0.0, grid.y);\n    \n    vec4 data2_m_dy = texture2D(data2_tex, coord - dy);\n    vec4 data2_p_dy = texture2D(data2_tex, coord + dy);\n    vec4 data2_m_dx = texture2D(data2_tex, coord - dx);\n    vec4 data2_p_dx = texture2D(data2_tex, coord + dx);\n    \n    // Phi.\n    data2.b = 0.0;\n    // Div.\n    data2.a = (data2_p_dy.r - data2_m_dy.r) * i2dx + (data2_p_dx.g - data2_m_dx.g) * i2dy;\n  }\n\n  gl_FragColor = data2;\n}\n';});

define('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/conserve-step2.fs.glsl',[],function () { return '// texture 1: \n// - R: q\n// - G: capacity\n// - B: density\n// - A: fluidity\nuniform sampler2D data1_tex;\n// texture 2: \n// - R: u\n// - G: v\n// - B: u0\n// - A: v0\nuniform sampler2D data2_tex;\n\nuniform vec2 grid;\nuniform float s;\nuniform float idxsq;\nuniform float idysq;\n\nvarying vec2 coord;\n\nvoid main() {\n  vec4 data2 = texture2D(data2_tex, coord);\n  float fluidity = texture2D(data1_tex, coord).a;\n  \n  if (coord.x > grid.x && coord.x < 1.0 - grid.x &&\n      coord.y > grid.y && coord.y < 1.0 - grid.y &&\n      fluidity == 1.0) {\n    \n    vec2 dx = vec2(grid.x, 0.0);\n    vec2 dy = vec2(0.0, grid.y);\n    \n    vec4 data2_m_dy = texture2D(data2_tex, coord - dy);\n    vec4 data2_p_dy = texture2D(data2_tex, coord + dy);\n    vec4 data2_m_dx = texture2D(data2_tex, coord - dx);\n    vec4 data2_p_dx = texture2D(data2_tex, coord + dx);\n    \n    // Phi.\n    data2.b = s * ((data2_m_dy.b + data2_p_dy.b) * idxsq + (data2_m_dx.b + data2_p_dx.b) * idysq - data2.a);\n  }\n\n  gl_FragColor = data2;\n}\n';});

define('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/conserve-step3.fs.glsl',[],function () { return '// texture 1: \n// - R: q\n// - G: capacity\n// - B: density\n// - A: fluidity\nuniform sampler2D data1_tex;\n// texture 2: \n// - R: u\n// - G: v\n// - B: u0\n// - A: v0\nuniform sampler2D data2_tex;\n\nuniform vec2 grid;\nuniform float i2dx;\nuniform float i2dy;\n\nvarying vec2 coord;\n\nvoid main() {\n  vec4 data2 = texture2D(data2_tex, coord);\n  float fluidity = texture2D(data1_tex, coord).a;\n  \n  if (coord.x > grid.x && coord.x < 1.0 - grid.x &&\n      coord.y > grid.y && coord.y < 1.0 - grid.y &&\n      fluidity == 1.0) {\n    \n    vec2 dx = vec2(grid.x, 0.0);\n    vec2 dy = vec2(0.0, grid.y);\n    \n    vec4 data2_m_dy = texture2D(data2_tex, coord - dy);\n    vec4 data2_p_dy = texture2D(data2_tex, coord + dy);\n    vec4 data2_m_dx = texture2D(data2_tex, coord - dx);\n    vec4 data2_p_dx = texture2D(data2_tex, coord + dx);\n    \n    // U.\n    data2.r -= (data2_p_dy.b - data2_m_dy.b) * i2dx;\n    // V.\n    data2.g -= (data2_p_dx.b - data2_m_dx.b) * i2dy;\n  }\n\n  gl_FragColor = data2;\n}\n';});

define('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/diffuse.fs.glsl',[],function () { return '// texture 1: \n// - R: q\n// - G: capacity\n// - B: density\n// - A: fluidity\nuniform sampler2D data1_tex;\n// texture 2: \n// - R: u\n// - G: v\n// - B: u0\n// - A: v0\nuniform sampler2D data2_tex;\n\nuniform vec2 grid;\nuniform float hx;\nuniform float hy;\nuniform float dn;\n\nvarying vec2 coord;\n\nvoid main() {\n  vec4 data2 = texture2D(data2_tex, coord);\n  float fluidity = texture2D(data1_tex, coord).a;\n  \n  if (coord.x > grid.x && coord.x < 1.0 - grid.x &&\n      coord.y > grid.y && coord.y < 1.0 - grid.y &&\n      fluidity == 1.0) {\n    \n    vec2 dx = vec2(grid.x, 0.0);\n    vec2 dy = vec2(0.0, grid.y);\n    \n    vec4 data2_m_dy = texture2D(data2_tex, coord - dy);\n    vec4 data2_p_dy = texture2D(data2_tex, coord + dy);\n    vec4 data2_m_dx = texture2D(data2_tex, coord - dx);\n    vec4 data2_p_dx = texture2D(data2_tex, coord + dx);\n    // Update velocity UV components.\n    data2.rg = (data2.ba + hx * (data2_m_dy.rg + data2_p_dy.rg)\n                         + hy * (data2_m_dx.rg + data2_p_dx.rg)) * dn;\n  }\n\n  gl_FragColor = data2;\n}\n';});

define('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/apply-buoyancy.fs.glsl',[],function () { return '// texture 0: \n// - R: t\n// - G: t0\n// - B: tb\n// - A: conductivity\nuniform sampler2D data0_tex;\n// texture 1: \n// - R: q\n// - G: capacity\n// - B: density\n// - A: fluidity\nuniform sampler2D data1_tex;\n// texture 2: \n// - R: u\n// - G: v\n// - B: u0\n// - A: v0\nuniform sampler2D data2_tex;\n\nuniform vec2 grid;\nuniform float g;\nuniform float b;\n\nvarying vec2 coord;\n\nvoid main() {\n  vec4 data2 = texture2D(data2_tex, coord);\n  float fluidity = texture2D(data1_tex, coord).a;\n  \n  if (coord.x > grid.x && coord.x < 1.0 - grid.x &&\n      coord.y > grid.y && coord.y < 1.0 - grid.y &&\n      fluidity == 1.0) {\n    \n    vec2 dx = vec2(grid.x, 0.0);\n    vec2 dy = vec2(0.0, grid.y);\n    \n    float t = texture2D(data0_tex, coord).r;\n    // Get average column temperature.\n\n    float avg_t = t;\n    float count = 1.0;\n    vec2 n_coord = coord - dx;\n    // Silly while(true) loop (almost).\n    // While loops are not allowed.\n    // For loops with non-constant expressions also.\n    for (int i = 1; i != 0; i++) {\n      if (n_coord.x > 0.0 && texture2D(data1_tex, n_coord).a == 1.0) {\n        avg_t += texture2D(data0_tex, n_coord).r;\n        count += 1.0;\n        n_coord -= dx;\n      } else {\n        break;\n      }\n    }\n    n_coord = coord + dx;\n    // Silly while(true) loop (almost).\n    // While loops are not allowed.\n    // For loops with non-constant expressions also.\n    for (int i = 1; i != 0; i++) {\n      if (n_coord.x < 1.0 && texture2D(data1_tex, n_coord).a == 1.0) {\n        avg_t += texture2D(data0_tex, n_coord).r;\n        count += 1.0;\n        n_coord += dx;\n      } else {\n        break;\n      }\n    }\n    avg_t /= count;\n\n    // Update velocity V component.\n    data2.g += (g - b) * t + b * avg_t;\n  }\n\n  gl_FragColor = data2;\n}\n';});

/*global define: false*/

define('energy2d/models/physics-solvers-gpu/fluid-solver-gpu',['require','exports','module','energy2d/gpu/shader','energy2d/gpu/gpgpu','text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/basic.vs.glsl','text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/maccormack-step1.fs.glsl','text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/maccormack-step2.fs.glsl','text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/apply-uv-boundary.fs.glsl','text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/apply-u0v0-boundary.fs.glsl','text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/set-obstacle-boundary.fs.glsl','text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/set-obstacle-velocity.fs.glsl','text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/uv-to-u0v0.fs.glsl','text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/conserve-step1.fs.glsl','text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/conserve-step2.fs.glsl','text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/conserve-step3.fs.glsl','text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/diffuse.fs.glsl','text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/apply-buoyancy.fs.glsl'],function (require, exports) {
  'use strict';
  var
    // Dependencies.
    Shader = require('energy2d/gpu/shader'),
    // GPGPU utilities. It's a singleton instance.
    // It should have been previously initialized by core-model.
    gpgpu  = require('energy2d/gpu/gpgpu'),
    // Shader sources. One of Lab build steps converts sources to JavaScript file.
    basic_vs                 = require('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/basic.vs.glsl'),
    maccormack_step1_fs      = require('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/maccormack-step1.fs.glsl'),
    maccormack_step2_fs      = require('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/maccormack-step2.fs.glsl'),
    apply_uv_boundary_fs     = require('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/apply-uv-boundary.fs.glsl'),
    apply_u0v0_boundary_fs   = require('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/apply-u0v0-boundary.fs.glsl'),
    set_obstacle_boundary_fs = require('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/set-obstacle-boundary.fs.glsl'),
    set_obstacle_velocity_fs = require('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/set-obstacle-velocity.fs.glsl'),
    uv_to_u0v0_fs            = require('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/uv-to-u0v0.fs.glsl'),
    conserve_step1_fs        = require('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/conserve-step1.fs.glsl'),
    conserve_step2_fs        = require('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/conserve-step2.fs.glsl'),
    conserve_step3_fs        = require('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/conserve-step3.fs.glsl'),
    diffuse_fs               = require('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/diffuse.fs.glsl'),
    apply_buoyancy_fs        = require('text!energy2d/models/physics-solvers-gpu/fluid-solver-glsl/apply-buoyancy.fs.glsl'),

    RELAXATION_STEPS = 10,
    GRAVITY = 0;

  exports.makeFluidSolverGPU = function (model) {
    var
      // ========================================================================
      // GLSL Shaders:
      // - MacCormack advection, first step.
      maccormack_step1_program      = new Shader(basic_vs, maccormack_step1_fs),
      maccormack_step2_program      = new Shader(basic_vs, maccormack_step2_fs),
      apply_uv_boundary_program     = new Shader(basic_vs, apply_uv_boundary_fs),
      apply_u0v0_boundary_program   = new Shader(basic_vs, apply_u0v0_boundary_fs),
      set_obstacle_boundary_program = new Shader(basic_vs, set_obstacle_boundary_fs),
      set_obstacle_velocity_program = new Shader(basic_vs, set_obstacle_velocity_fs),
      uv_to_u0v0_program            = new Shader(basic_vs, uv_to_u0v0_fs),
      conserve_step1_program        = new Shader(basic_vs, conserve_step1_fs),
      conserve_step2_program        = new Shader(basic_vs, conserve_step2_fs),
      conserve_step3_program        = new Shader(basic_vs, conserve_step3_fs),
      diffuse_program               = new Shader(basic_vs, diffuse_fs),
      apply_buoyancy_program        = new Shader(basic_vs, apply_buoyancy_fs),
      // ========================================================================

      // Simulation arrays provided by model.
      // texture 0:
      // - R: t
      // - G: t0
      // - B: tb
      // - A: conductivity
      data0_tex = model.getSimulationTexture(0),
      // texture 1:
      // - R: q
      // - G: capacity
      // - B: density
      // - A: fluidity
      data1_tex = model.getSimulationTexture(1),
      // texture 2:
      // - R: u
      // - G: v
      // - B: u0
      // - A: v0
      data2_tex = model.getSimulationTexture(2),
      // texture 3:
      // - R: uWind
      // - G: vWind
      // - B: undefined
      // - A: undefined
      data3_tex = model.getSimulationTexture(3),

      // Basic simulation parameters.
      props = model.getModelOptions(),
      nx = props.grid_width,
      ny = props.grid_height,

      timeStep         = props.timeStep,
      thermal_buoyancy = props.thermal_buoyancy,
      viscosity        = props.background_viscosity,

      delta_x = props.model_width / props.grid_width,
      delta_y = props.model_height / props.grid_height,

      relaxation_steps = RELAXATION_STEPS,
      gravity = GRAVITY,

      // Convenience variables.
      i2dx  = 0.5 / delta_x,
      i2dy  = 0.5 / delta_y,
      idxsq = 1.0 / (delta_x * delta_x),
      idysq = 1.0 / (delta_y * delta_y),
      s     = 0.5 / (idxsq + idysq),

      hx = timeStep * viscosity * idxsq,
      hy = timeStep * viscosity * idysq,
      dn = 1.0 / (1 + 2 * (hx + hy)),

      g = gravity * timeStep,
      b = thermal_buoyancy * timeStep,

      grid_vec = [1 / ny, 1 / nx],

      // Textures sets.
      data_2_array = [data2_tex],
      data_1_2_array = [data1_tex, data2_tex],
      data_0_1_2_array = [data0_tex, data1_tex, data2_tex],
      data_1_2_3_array = [data1_tex, data2_tex, data3_tex],

      init = function () {
        var uniforms;

        // MacCormack step 1 and 2 uniforms.
        uniforms = {
          // Texture units.
          data1_tex: 0,
          data2_tex: 1,
          // Uniforms.
          grid: grid_vec,
          tx: 0.5 * timeStep / delta_x,
          ty: 0.5 * timeStep / delta_y
        };
        maccormack_step1_program.uniforms(uniforms);
        maccormack_step2_program.uniforms(uniforms);

        // Apply UV / U0V0 boundary uniforms.
        uniforms = {
          // Texture units.
          data2_tex: 0,
          // Uniforms.
          grid: grid_vec
        };
        apply_uv_boundary_program.uniforms(uniforms);
        apply_u0v0_boundary_program.uniforms(uniforms);

        // Set obstacle boundary uniforms.
        uniforms = {
          // Texture units.
          data1_tex: 0,
          data2_tex: 1,
          // Uniforms.
          grid: grid_vec
        };
        set_obstacle_boundary_program.uniforms(uniforms);

        // Set obstacle velocity uniforms.
        uniforms = {
          // Texture units.
          data1_tex: 0,
          data2_tex: 1,
          data3_tex: 2,
          // Uniforms.
          grid: grid_vec
        };
        set_obstacle_velocity_program.uniforms(uniforms);

        // Conserve step 1 and 3 uniforms.
        uniforms = {
          // Texture units.
          data1_tex: 0,
          data2_tex: 1,
          // Uniforms.
          grid: grid_vec,
          i2dx: i2dx,
          i2dy: i2dy
        };
        conserve_step1_program.uniforms(uniforms);
        conserve_step3_program.uniforms(uniforms);

        // Conserve step 2 uniforms.
        uniforms = {
          // Texture units.
          data1_tex: 0,
          data2_tex: 1,
          // Uniforms.
          grid: grid_vec,
          s: s,
          idxsq: idxsq,
          idysq: idysq
        };
        conserve_step2_program.uniforms(uniforms);

        // Diffuse uniforms.
        uniforms = {
          // Texture units.
          data1_tex: 0,
          data2_tex: 1,
          // Uniforms.
          grid: grid_vec,
          hx: hx,
          hy: hy,
          dn: dn
        };
        diffuse_program.uniforms(uniforms);

        // Apply buoyancy uniforms.
        uniforms = {
          // Texture units.
          data0_tex: 0,
          data1_tex: 1,
          data2_tex: 2,
          // Uniforms.
          grid: grid_vec,
          g: g,
          b: b
        };
        apply_buoyancy_program.uniforms(uniforms);
      },

      applyBuoyancy = function () {
        gpgpu.executeProgram(
          apply_buoyancy_program,
          data_0_1_2_array,
          data2_tex
        );
      },

      macCormack = function () {
        // Step 1.
        gpgpu.executeProgram(
          maccormack_step1_program,
          data_1_2_array,
          data2_tex
        );
        // Apply boundary.
        gpgpu.executeProgram(
          apply_uv_boundary_program,
          data_2_array,
          data2_tex
        );
        // Step 2.
        gpgpu.executeProgram(
          maccormack_step2_program,
          data_1_2_array,
          data2_tex
        );
        // Apply boundary again.
        gpgpu.executeProgram(
          apply_uv_boundary_program,
          data_2_array,
          data2_tex
        );
      },

      conserve = function () {
        var k;
        // Step 1.
        gpgpu.executeProgram(
          conserve_step1_program,
          data_1_2_array,
          data2_tex
        );
        // Apply boundary.
        gpgpu.executeProgram(
          apply_u0v0_boundary_program,
          data_2_array,
          data2_tex
        );
        // Set obstacle boundary.
        gpgpu.executeProgram(
          set_obstacle_boundary_program,
          data_1_2_array,
          data2_tex
        );
        // Relaxation.
        for (k = 0; k < relaxation_steps; k += 1) {
          // Step 2.
          gpgpu.executeProgram(
            conserve_step2_program,
            data_1_2_array,
            data2_tex
          );
        }
        // Step 3.
        gpgpu.executeProgram(
          conserve_step3_program,
          data_1_2_array,
          data2_tex
        );
        // Apply boundary.
        gpgpu.executeProgram(
          apply_uv_boundary_program,
          data_2_array,
          data2_tex
        );
      },

      diffuse = function () {
        var k;
        // Copy UV to U0V0.
        gpgpu.executeProgram(
          uv_to_u0v0_program,
          data_2_array,
          data2_tex
        );
        // Relaxation.
        for (k = 0; k < relaxation_steps; k += 1) {
          // Step 2.
          gpgpu.executeProgram(
            diffuse_program,
            data_1_2_array,
            data2_tex
          );

          // Apply boundary.
          gpgpu.executeProgram(
            apply_uv_boundary_program,
            data_2_array,
            data2_tex
          );
        }
      },

      setObstacleVelocity = function () {
        gpgpu.executeProgram(
          set_obstacle_velocity_program,
          data_1_2_3_array,
          data2_tex
        );
      },

      copyUVtoU0V0 = function () {
        gpgpu.executeProgram(
          uv_to_u0v0_program,
          data_2_array,
          data2_tex
        );
      },

      fluid_solver_gpu = {
        solve: function () {
          if (thermal_buoyancy !== 0) {
            applyBuoyancy();
          }
          setObstacleVelocity();
          if (viscosity > 0) {
            diffuse();
            conserve();
            setObstacleVelocity();
          }
          copyUVtoU0V0();
          macCormack();
          conserve();
          setObstacleVelocity();
        }
      };

    // One-off initialization.
    init();

    return fluid_solver_gpu;
  };
});

/*jslint indent: 2, browser: true, newcap: true */
/*globals define: false*/

define('energy2d/models/helpers',['require','exports','module'],function (require, exports, module) {
  'use strict';

  exports.hypot = function (x, y) {
    var t;
    x = Math.abs(x);
    y = Math.abs(y);
    t = Math.min(x, y);
    x = Math.max(x, y);
    if (x === 0) return 0;
    t = t / x;
    return x * Math.sqrt(1 + t * t);
  };
});
/*jslint indent: 2, browser: true, newcap: true */
/*globals define: false*/

define('energy2d/models/shape',['require','exports','module'],function (require, exports, module) {
  'use strict';

  // Based on: http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
  // It is optional to repeat the first vertex at the end of list of polygon vertices.
  exports.pointInsidePolygon = function (nvert, vertx, verty, testx, testy) {
    var c = 0, i, j;
    for (i = 0, j = nvert - 1; i < nvert; j = i, i += 1) {
      if (((verty[i] > testy) !== (verty[j] > testy)) &&
          (testx < (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) + vertx[i])) {
        c = !c;
      }
    }
    return !!c;
  };

  //
  // Line in 2D.
  //
  // It is defined by two points - (x1, y1) and (x2, y2).
  var Line = exports.Line = function (x1, y1, x2, y2) {
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    this.y2 = y2;
  };

  Line.prototype.intersectsLine = function (line) {
    var
      result,
      a1 = {x: this.x1, y: this.y1},
      a2 = {x: this.x2, y: this.y2},
      b1 = {x: line.x1, y: line.y1},
      b2 = {x: line.x2, y: line.y2},
      ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x),
      ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x),
      u_b  = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y),
      ua, ub;

    if (u_b !== 0) {
      ua = ua_t / u_b;
      ub = ub_t / u_b;

      if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
        result = true;
      } else {
        result = false;
      }
    } else {
      if (ua_t === 0 || ub_t === 0) {
        result = true;  // Coincident.
      } else {
        result = false; // Parallel.
      }
    }
    return result;
  };

  //
  // Polygon.
  //
  // Implements Shape2D interface:
  // - polygonize()
  // - contains(x, y)
  var Polygon = exports.Polygon = function (count, x_coords, y_coords, x, y) {
    this.count = count;
    this.raw_x_coords = x_coords;
    this.raw_y_coords = y_coords;
    this.x_coords = new Array(count);
    this.y_coords = new Array(count);
    // x_coords and y_coors will be updated now:
    this.x = x || 0;
    this.y = y || 0;
  };

  Object.defineProperty(Polygon.prototype, 'x', {
    get: function() {
      return this._x;
    },
    set: function(v) {
      var i, len;
      for (i = 0, len = this.count; i < len; i++) {
        this.x_coords[i] = this.raw_x_coords[i] + v;
      }
      this._x = v;
    }
  });

  Object.defineProperty(Polygon.prototype, 'y', {
    get: function() {
      return this._y;
    },
    set: function(v) {
      var i, len;
      for (i = 0, len = this.count; i < len; i++) {
        this.y_coords[i] = this.raw_y_coords[i] + v;
      }
      this._y = v;
    }
  });

  Polygon.prototype.polygonize = function () {
    return this;
  };

  // Based on: http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
  // It is optional to repeat the first vertex at the end of list of polygon vertices.
  Polygon.prototype.contains = function (x, y) {
    var
      x_coords = this.x_coords,
      y_coords = this.y_coords,
      count = this.count,
      c = 0, i, j;

    for (i = 0, j = count - 1; i < count; j = i, i += 1) {
      if (((y_coords[i] > y) !== (y_coords[j] > y)) &&
          (x < (x_coords[j] - x_coords[i]) * (y - y_coords[i]) / (y_coords[j] - y_coords[i]) + x_coords[i])) {
        c = !c;
      }
    }
    // Convert to Boolean.
    return !!c;
  };

  //
  // Rectangle.
  // x, y - left-top corner
  //
  // Implements Shape2D interface:
  // - polygonize()
  // - contains(x, y)
  var Rectangle = exports.Rectangle = function (x, y, width, height) {
    this.x = x;
    this.y = y;
    this.width = width;
    this.height = height;
    this.polygon_cache = undefined;
  };

  Rectangle.prototype.polygonize = function () {
    var
      x, y, w, h;

    if (!this.polygon_cache) {
      x = this.x;
      y = this.y;
      w = this.width;
      h = this.height;
      this.polygon_cache = new Polygon(4, [x, x + w, x + w, x], [y, y, y + h, y + h]);
    }
    return this.polygon_cache;
  };

  Rectangle.prototype.contains = function (x, y) {
    return x >= this.x && x <= this.x + this.width &&
           y >= this.y && y <= this.y + this.height;
  };

  // Helper function, used by Ellipse and Ring.
  var polygonizeEllipse = function (x, y, ra, rb, segments) {
    var
      vx = new Array(segments),
      vy = new Array(segments),
      delta = 2 * Math.PI / segments,
      theta, i;

    for (i = 0; i < segments; i += 1) {
      theta = delta * i;
      vx[i] = x + ra * Math.cos(theta);
      vy[i] = y + rb * Math.sin(theta);
    }
    return new Polygon(segments, vx, vy);
  };

  //
  // Ellipse.
  // x, y - center
  // a, b - diameter (not radius)
  //
  // Implements Shape2D interface:
  // - polygonize()
  // - contains(x, y)
  var Ellipse = exports.Ellipse = function (x, y, a, b) {
    this.x = x;
    this.y = y;
    this.a = a;
    this.b = b;
    this.polygon_cache = undefined;
  };

  Ellipse.prototype.POLYGON_SEGMENTS = 50;

  Ellipse.prototype.polygonize = function () {
    if (!this.polygon_cache) {
      this.polygon_cache = polygonizeEllipse(this.x, this.y, this.a * 0.5, this.b * 0.5, this.POLYGON_SEGMENTS);
    }
    return this.polygon_cache;
  };

  Ellipse.prototype.contains = function (x, y) {
    var
      px = x - this.x,
      py = y - this.y,
      ra = this.a * 0.5,
      rb = this.b * 0.5;

    return px * px / (ra * ra) + py * py / (rb * rb) <= 1;
  };

  //
  // Ring.
  // x, y - center
  // inner, outer - diameter (not radius)
  //
  // Implements Shape2D interface:
  // - polygonize()
  // - contains(x, y)
  var Ring = exports.Ring = function (x, y, inner, outer) {
    this.x = x;
    this.y = y;
    this.inner = inner;
    this.outer = outer;
    this.polygon_cache = undefined;
  };

  Ring.prototype.POLYGON_SEGMENTS = 50;

  // Returns OUTER circle polygonization.
  Ring.prototype.polygonize = function () {
    if (!this.polygon_cache) {
      this.polygon_cache = polygonizeEllipse(this.x, this.y, this.outer * 0.5, this.outer * 0.5, this.POLYGON_SEGMENTS);
    }
    return this.polygon_cache;
  };

  Ring.prototype.contains = function (x, y) {
    var
      px = x - this.x,
      py = y - this.y,
      ra_outer = this.outer * 0.5,
      rb_outer = this.outer * 0.5,
      ra_inner = this.inner * 0.5,
      rb_inner = this.inner * 0.5;

    return (px * px / (ra_outer * ra_outer) + py * py / (rb_outer * rb_outer) <= 1) &&
           (px * px / (ra_inner * ra_inner) + py * py / (rb_inner * rb_inner) >= 1);
  };
});

/*jslint indent: 2, browser: true, newcap: true */
/*globals define: false*/

define('energy2d/models/photon',['require','exports','module','energy2d/models/helpers','energy2d/models/shape','energy2d/models/shape'],function (require, exports, module) {
  'use strict';
  var
    hypot     = require('energy2d/models/helpers').hypot,
    Line      = require('energy2d/models/shape').Line,
    Rectangle = require('energy2d/models/shape').Rectangle,

    //
    // Photon class.
    //
    Photon = exports.Photon = function (x, y, energy, c, angle) {
      this.x = x;
      this.y = y;
      this.energy = energy;
      this.c = c;

      if (angle !== undefined) {
        this.vx = Math.cos(angle) * c;
        this.vy = Math.sin(angle) * c;
      }
    };

  Photon.prototype.isContained = function (xmin, xmax, ymin, ymax) {
    return this.x >= xmin && this.x <= xmax && this.y >= ymin && this.y <= ymax;
  };

  Photon.prototype.move = function (dt) {
    this.x += this.vx * dt;
    this.y += this.vy * dt;
  };

  Photon.prototype.reflectFromLine = function (line, time_step) {
    var
      x1 = this.x,
      y1 = this.y,
      x2 = this.x - this.vx * time_step,
      y2 = this.y - this.vy * time_step,
      photon_line = new Line(x1, y1, x2, y2),
      vx = this.vx,
      vy = this.vy,
      r12, sin, cos, u, w;

    if (photon_line.intersectsLine(line)) {
      x1 = line.x1;
      y1 = line.y1;
      x2 = line.x2;
      y2 = line.y2;
      r12 = 1.0 / hypot(x1 - x2, y1 - y2);
      sin = (y2 - y1) * r12;
      cos = (x2 - x1) * r12;
      // Velocity component parallel to the line.
      u = vx * cos + vy * sin;
      // Velocity component perpendicular to the line.
      w = vy * cos - vx * sin;
      // Update velocities.
      this.vx = u * cos + w * sin;
      this.vy = u * sin - w * cos;
      return true;
    }
    return false;
  };

  Photon.prototype.reflectFromRectangle = function (rectangle, time_step) {
    var
      x0 = rectangle.x,
      y0 = rectangle.y,
      x1 = rectangle.x + rectangle.width,
      y1 = rectangle.y + rectangle.height,
      dx, dy;

    dx = this.vx * time_step;
    if (this.x - dx < x0) {
      this.vx = -Math.abs(this.vx);
    } else if (this.x - dx > x1) {
      this.vx = Math.abs(this.vx);
    }
    dy = this.vy * time_step;
    if (this.y - dy < y0) {
      this.vy = -Math.abs(this.vy);
    } else if (this.y - dy > y1) {
      this.vy = Math.abs(this.vy);
    }
  };

  Photon.prototype.reflectFromPolygon = function (polygon, time_step) {
    var
      line = new Line(), // no params, as this object will be reused many times
      i, len;

    for (i = 0, len = polygon.count - 1; i < len; i += 1) {
      line.x1 = polygon.x_coords[i];
      line.y1 = polygon.y_coords[i];
      line.x2 = polygon.x_coords[i + 1];
      line.y2 = polygon.y_coords[i + 1];
      if (this.reflectFromLine(line, time_step)) {
        return;
      }
    }
    line.x1 = polygon.x_coords[polygon.count - 1];
    line.y1 = polygon.y_coords[polygon.count - 1];
    line.x2 = polygon.x_coords[0];
    line.y2 = polygon.y_coords[0];
    this.reflectFromLine(line, time_step);
  };

  Photon.prototype.reflect = function (shape, time_step) {
    // Check if part contains a photon BEFORE possible polygonization.
    if (!shape.contains(this.x, this.y)) {
      return false;
    }

    if (shape instanceof Rectangle) {
      // Rectangle also can be polygonized, but for performance reasons
      // use separate method.
      this.reflectFromRectangle(shape, time_step);
    } else {
      // Other shapes (ellipses, rings, polygons) - polygonize() first
      // (polygonize() for polygon returns itself).
      this.reflectFromPolygon(shape.polygonize(), time_step);
    }
    return true;
  };
});

/*global define: false*/

define('energy2d/models/physics-solvers/ray-solver',['require','exports','module','energy2d/models/photon'],function (require, exports) {
  'use strict';
  var
    Photon = require('energy2d/models/photon').Photon;

  exports.makeRaySolver = function (model) {
    var
      // Basic simulation parameters.
      props = model.getModelOptions(),

      // Simulation arrays provided by model.
      q       = model.getPowerArray(),
      parts   = model.getPartsArray(),
      photons = model.getPhotonsArray(),

      // Convenience variables.
      lx = props.model_width,
      ly = props.model_height,

      nx = props.grid_width,
      ny = props.grid_height,
      nx1 = nx - 1,
      ny1 = ny - 1,

      delta_x = props.model_width / props.grid_width,
      delta_y = props.model_height / props.grid_height,

      //
      // Private methods
      //

      sunAngle = function () {
        return Math.PI - props.sun_angle;
      },

      // TODO: implement something efficient. Linked list?
      cleanupPhotonsArray = function () {
        var i = 0;
        while (i < photons.length) {
          if (photons[i] === undefined) {
            photons.splice(i, 1);
          } else {
            i += 1;
          }
        }
      },

      applyBoundary = function () {
        var i, len;
        for (i = 0, len = photons.length; i < len; i += 1) {
          if (!photons[i].isContained(0, lx, 0, ly)) {
            photons[i] = undefined;
          }
        }
        cleanupPhotonsArray();
      },

      isContained = function (x, y) {
        var i, len;
        for (i = 0, len = parts.length; i < len; i += 1) {
          if (parts[i].contains(x, y)) {
            return true;
          }
        }
        return false;
      },

      shootAtAngle = function (dx, dy) {
        var
          sun_angle = sunAngle(),
          ray_power = props.solar_power_density,
          ray_speed = props.solar_ray_speed,
          m = Math.floor(lx / dx),
          n = Math.floor(ly / dy),
          x, y, i;
        if (sun_angle >= 0 && sun_angle < 0.5 * Math.PI) {
          y = 0;
          for (i = 1; i <= m; i += 1) {
            x = dx * i;
            if (!isContained(x, y)) {
              photons.push(new Photon(x, y, ray_power, ray_speed, sun_angle));
            }
          }
          x = 0;
          for (i = 0; i <= n; i += 1) {
            y = dy * i;
            if (!isContained(x, y)) {
              photons.push(new Photon(x, y, ray_power, ray_speed, sun_angle));
            }
          }
        } else if (sun_angle < 0 && sun_angle >= -0.5 * Math.PI) {
          y = ly;
          for (i = 1; i <= m; i += 1) {
            x = dx * i;
            if (!isContained(x, y)) {
              photons.push(new Photon(x, y, ray_power, ray_speed, sun_angle));
            }
          }
          x = 0;
          for (i = 0; i <= n; i += 1) {
            y = ly - dy * i;
            if (!isContained(x, y)) {
              photons.push(new Photon(x, y, ray_power, ray_speed, sun_angle));
            }
          }
        } else if (sun_angle < Math.PI + 0.001 && sun_angle >= 0.5 * Math.PI) {
          y = 0;
          for (i = 0; i <= m; i += 1) {
            x = lx - dx * i;
            if (!isContained(x, y)) {
              photons.push(new Photon(x, y, ray_power, ray_speed, sun_angle));
            }
          }
          x = lx;
          for (i = 1; i <= n; i += 1) {
            y = dy * i;
            if (!isContained(x, y)) {
              photons.push(new Photon(x, y, ray_power, ray_speed, sun_angle));
            }
          }
        } else if (sun_angle >= -Math.PI && sun_angle < -0.5 * Math.PI) {
          y = ly;
          for (i = 0; i <= m; i += 1) {
            x = lx - dx * i;
            if (!isContained(x, y)) {
              photons.push(new Photon(x, y, ray_power, ray_speed, sun_angle));
            }
          }
          x = lx;
          for (i = 1; i <= n; i += 1) {
            y = ly - dy * i;
            if (!isContained(x, y)) {
              photons.push(new Photon(x, y, ray_power, ray_speed, sun_angle));
            }
          }
        }
      };

    return {
      solve: function () {
        var
          timeStep = props.timeStep,
          photon_emission_interval = props.photon_emission_interval,

          factor = 1.0 / (timeStep * photon_emission_interval),
          idx = 1.0 / delta_x,
          idy = 1.0 / delta_y,
          photon, part, x, y,
          i, j, photons_len, parts_len;

        for (i = 0, photons_len = photons.length; i < photons_len; i += 1) {
          photon = photons[i];
          photon.move(timeStep);

          for (j = 0, parts_len = parts.length; j < parts_len; j += 1) {
            part = parts[j];
            if (part.reflect(photon, timeStep)) {
              break;
            } else if (part.absorb(photon)) {
              x = Math.max(Math.min(Math.round(photon.x * idx), nx1), 0);
              y = Math.max(Math.min(Math.round(photon.y * idy), ny1), 0);
              q[x * ny + y] = photon.energy * factor;
              // Remove photon.
              photons[i] = undefined;
              break;
            }
          }
        }
        // Clean up absorbed photons.
        cleanupPhotonsArray();
        // Remove photons that are out of bounds.
        applyBoundary();
      },

      radiate: function () {
        var part, i, len;
        for (i = 0, len = parts.length; i < len; i += 1) {
          part = parts[i];
          if (part.emissivity > 0) {
            part.radiate(model);
          }
        }
      },

      sunShine: function () {
        var
          sun_angle = sunAngle(),
          s, c, spacing;

        if (sun_angle < 0) {
          return;
        }
        s = Math.abs(Math.sin(sun_angle));
        c = Math.abs(Math.cos(sun_angle));
        spacing = s * ly < c * lx ? ly / c : lx / s;
        spacing /= props.solar_ray_count;
        shootAtAngle(spacing / s, spacing / c);
      }
    };
  };
});

/*jslint indent: 2, browser: true, newcap: true */
/*globals define: false*/

define('energy2d/models/part',['require','exports','module','energy2d/models/constants','energy2d/models/helpers','energy2d/models/photon','energy2d/models/shape','energy2d/models/shape','energy2d/models/shape','energy2d/models/shape','energy2d/models/shape','energy2d/models/shape'],function (require, exports, module) {
  'use strict';
  var
    constants      = require('energy2d/models/constants'),
    hypot          = require('energy2d/models/helpers').hypot,
    Photon         = require('energy2d/models/photon').Photon,
    shape_utils    = require('energy2d/models/shape'),
    Line           = require('energy2d/models/shape').Line,
    Polygon        = require('energy2d/models/shape').Polygon,
    Rectangle      = require('energy2d/models/shape').Rectangle,
    Ellipse        = require('energy2d/models/shape').Ellipse,
    Ring           = require('energy2d/models/shape').Ring,

    // Part's constants.
    RADIATOR_SPACING = 0.5,
    MINIMUM_RADIATING_TEMPERATUE = 20,
    UNIT_SURFACE_AREA = 100,
    SIN30 = Math.sin(Math.PI / 6),
    COS30 = Math.cos(Math.PI / 6),
    SIN60 = Math.sin(Math.PI / 3),
    COS60 = Math.cos(Math.PI / 3),

    // Constructor function.
    Part = exports.Part = function (options) {
      var vertices, count, i;
      this._options = options;

      // Validate and process options.
      if (options.shapeType === "rectangle") {
        this.shape = new Rectangle(options.x, options.y, options.width, options.height);
      } else if (options.shapeType === "ellipse") {
        this.shape = new Ellipse(options.x, options.y, options.a, options.b);
      } else if (options.shapeType === "ring") {
        this.shape = new Ring(options.x, options.y, options.inner, options.outer);
      } else if (options.shapeType === "polygon") {
        vertices = options.vertices.split(', ');
        this.x_coords = [];
        this.y_coords = [];
        for (i = 0, count = vertices.length * 0.5; i < count; i += 1) {
          this.x_coords[i] = Number(vertices[2 * i]);
          this.y_coords[i] = Number(vertices[2 * i + 1]);
        }
        this.shape = new Polygon(count, this.x_coords, this.y_coords, options.x, options.y);
      } else {
        throw new Error("Part: shape not defined or not supported.");
      }
    };

  Object.defineProperty(Part.prototype, "shapeType", {
    get: function () {
      return this._options.shapeType;
    }
  });

  ["x", "y", "width", "height", "inner", "outer", "a", "b", "raw_x_coords", "raw_y_coords"].forEach(function (key) {
    Object.defineProperty(Part.prototype, key, {
      get: function () {
        return this.shape[key];
      },
      set: function (v) {
        this.shape[key] = v;
        this.polygon_cache = undefined;
      }
    });
  });

  Object.defineProperty(Part.prototype, "vertices", {
    get: function () {
      if (this.shapeType !== "polygon") return undefined;
      var x = this.shape.raw_x_coords,
          y = this.shape.raw_y_coords,
          r = [], i, len;
      for (i = 0, len = x.length; i < len; i++) {
        r.push(x[i]);
        r.push(y[i]);
      }
      return r.join(", ");
    }
  });

  ["thermal_conductivity", "specific_heat", "density", "temperature", "constant_temperature", "power", "wind_speed", "wind_angle",
   "transmission", "reflection", "absorption", "emissivity",
   "visible", "filled", "color", "texture", "label", "draggable"].forEach(function (key) {
    Object.defineProperty(Part.prototype, key, {
      get: function () {
        return this._options[key];
      },
      set: function (v) {
        this._options[key] = v;
      }
    });
  });

  Part.prototype.getLabel = function () {
    var label = this.label, s;

    function formatLabel(value, suffix) {
      var valueStr;
      if (value >= 100) {
        valueStr = value.toFixed();
      } else if (value >= 10) {
        valueStr = value.toFixed(1);
      } else {
        valueStr = value.toFixed(2);
      }
      return valueStr + suffix;
    }

    if (label === "%temperature") {
      s = formatLabel(this.temperature, " \u00b0C");
    } else if (label === "%density") {
      s = formatLabel(this.density, " kg/m\u00b3");
    } else if (label === "%specific_heat") {
      s = formatLabel(this.specific_heat, " J/(kg\u00d7\u00b0C)");
    } else if (label === "%thermal_conductivity") {
      s = formatLabel(this.thermal_conductivity, " W/(m\u00d7\u00b0C)");
    } else if (label === "%power_density") {
      s = formatLabel(this.power, " W/m\u00b3");
    } else if (label === "%area") {
      if (this.shapeType === "rectangle") {
        s = formatLabel(this.width * this.height, " m\u00b2");
      } else if (this.shapeType === "ellipse") {
        s = formatLabel(this.a * this.b * 0.25 * Math.PI, " m\u00b2");
      }
    } else if (label === "%width") {
      if (this.shapeType === "rectangle") {
        s = formatLabel(this.width, " m");
      } else if (this.shapeType === "ellipse") {
        s = formatLabel(this.a, " m");
      }
    } else if (label === "%height") {
      if (this.shapeType === "rectangle") {
        s = formatLabel(this.height, " m");
      } else if (this.shapeType === "ellipse") {
        s = formatLabel(this.b, " m");
      }
    } else {
      s = label;
    }
    return s;
  };

  // Returns cells occupied by part on the given grid
  // Grid is described by:
  //   nx - grid columns count
  //   ny - grid rows count
  //   lx - grid width
  //   ly - grid height
  // TODO: refactor it, probably using contains method.
  Part.prototype.getGridCells = function (nx, ny, lx, ly) {
    var
      nx1 = nx - 1,
      ny1 = ny - 1,
      dx = nx1 / lx,
      dy = ny1 / ly,

      rectangleIndices = function (rect) {
        var i, j, i0, j0, i_max, j_max, idx, indices = [];

        i0 = Math.min(Math.max(Math.ceil(rect.x * dx), 0), nx1);
        j0 = Math.min(Math.max(Math.ceil(rect.y * dy), 0), ny1);
        i_max = Math.min(Math.max(Math.floor((rect.x + rect.width) * dx), 0), nx1);
        j_max = Math.min(Math.max(Math.floor((rect.y + rect.height) * dy), 0), ny1);
        indices = new Array((i_max - i0 + 1) * (j_max - j0 + 1));
        idx = 0;
        for (i = i0; i <= i_max; i += 1) {
          for (j = j0; j <= j_max; j += 1) {
            indices[idx += 1] = i * ny + j;
          }
        }
        return indices;
      },

      ellipseIndices = function (ellipse) {
        var
          px = ellipse.x * dx,
          py = ellipse.y * dy,
          ra = ellipse.a * 0.5 * dx,
          rb = ellipse.b * 0.5 * dy,
          eq, i, i0, i_max, j, j0, j_max,
          idx, indices = [];

        i0 = Math.min(Math.max(Math.ceil(px - ra), 0), nx1);
        i_max = Math.min(Math.max(Math.floor(px + ra), 0), nx1);
        indices = [];
        idx = 0;
        for (i = i0; i <= i_max; i += 1) {
          // solve equation x^2/a^2 + y^2/b^2 < 1 for given x (=> i)
          // to get range of y (=> j)
          eq = Math.sqrt(1 - (i - px) * (i - px) / (ra * ra));
          j0 = Math.min(Math.max(Math.ceil(py - rb * eq), 0), ny1);
          j_max = Math.min(Math.max(Math.floor(py + rb * eq), 0), ny1);
          for (j = j0; j <= j_max; j += 1) {
            indices[idx += 1] = i * ny + j;
          }
        }
        return indices;
      },

      ringIndices = function (ring) {
        var
          px = ring.x * dx,
          py = ring.y * dy,
          ra = ring.outer * 0.5 * dx,
          rb = ring.outer * 0.5 * dy,
          ra_inner = ring.inner * 0.5 * dx,
          rb_inner = ring.inner * 0.5 * dy,
          i, i0, i_max, j, j0, j1, j2, j_max, eq,
          idx, indices = [];

        i0 = Math.min(Math.max(Math.ceil(px - ra), 0), nx1);
        i_max = Math.min(Math.max(Math.floor(px + ra), 0), nx1);

        for (i = i0; i <= i_max; i += 1) {
          // solve equation x^2/a^2 + y^2/b^2 < 1 for given x (=> i)
          // to get range of y (=> j)
          eq = Math.sqrt(1 - (i - px) * (i - px) / (ra * ra));
          j0 = Math.min(Math.max(Math.ceil(py - rb * eq), 0), ny1);
          j_max = Math.min(Math.max(Math.floor(py + rb * eq), 0), ny1);

          if (Math.abs(i - px) < ra_inner) {
            // also calculate inner ellipse
            eq = Math.sqrt(1 - (i - px) * (i - px) / (ra_inner * ra_inner));
            j1 = Math.min(Math.max(Math.ceil(py - rb_inner * eq), 0), ny1);
            j2 = Math.min(Math.max(Math.floor(py + rb_inner * eq), 0), ny1);
            for (j = j0; j <= j1; j += 1) {
              indices[idx += 1] = i * ny + j;
            }
            for (j = j2; j <= j_max; j += 1) {
              indices[idx += 1] = i * ny + j;
            }
          } else {
            // consider only outer ellipse
            for (j = j0; j <= j_max; j += 1) {
              indices[idx += 1] = i * ny + j;
            }
          }
        }
        return indices;
      },

      polygonIndices = function (polygon) {
        var
          count = polygon.x_coords.length,
          x_coords = new Array(count),
          y_coords = new Array(count),
          x_min = Number.MAX_VALUE, x_max = Number.MIN_VALUE,
          y_min = Number.MAX_VALUE, y_max = Number.MIN_VALUE,
          i, i0, i_max, j, j0, j_max,
          idx, indices = [];

        for (i = 0; i < count; i += 1) {
          x_coords[i] = polygon.x_coords[i] * dx;
          y_coords[i] = polygon.y_coords[i] * dy;
          if (x_coords[i] < x_min) {
            x_min = x_coords[i];
          }
          if (x_coords[i] > x_max) {
            x_max = x_coords[i];
          }
          if (y_coords[i] < y_min) {
            y_min = y_coords[i];
          }
          if (y_coords[i] > y_max) {
            y_max = y_coords[i];
          }
        }

        i0 = Math.min(Math.max(Math.round(x_min), 0), nx1);
        j0 = Math.min(Math.max(Math.round(y_min), 0), ny1);
        i_max = Math.min(Math.max(Math.round(x_max), 0), nx1);
        j_max = Math.min(Math.max(Math.round(y_max), 0), ny1);
        indices = [];
        idx = 0;
        for (i = i0; i <= i_max; i += 1) {
          for (j = j0; j <= j_max; j += 1) {
            if (shape_utils.pointInsidePolygon(count, x_coords, y_coords, i, j)) {
              indices[idx += 1] = i * ny + j;
            }
          }
        }
        return indices;
      };

    if (this.shapeType === "rectangle") {
      return rectangleIndices(this.shape);
    }
    if (this.shapeType === "ellipse") {
      return ellipseIndices(this.shape);
    }
    if (this.shapeType === "ring") {
      return ringIndices(this.shape);
    }
    if (this.shapeType === "polygon") {
      return polygonIndices(this.shape);
    }
    throw new Error("Part: unknown shape.");
  };

  // Tests if the specified coordinates are inside the boundary of the Part.
  Part.prototype.contains = function (x, y) {
    return this.shape.contains(x, y);
  };

  // Test whether part reflects given Photon p.
  Part.prototype.reflect = function (p, time_step) {
    // Try to reflect when part's reflection equals ~1.
    if (Math.abs(this.reflection - 1) < 0.001) {
      return p.reflect(this.shape, time_step);
    }
    // Other case.
    return false;
  };

  // Test whether part absorbs given Photon p.
  Part.prototype.absorb = function (p) {
    // Absorb when absorption equals ~1 and photon is inside part's shape.
    if (Math.abs(this.absorption - 1) < 0.001) {
      return this.shape.contains(p.x, p.y);
    }
    // Other case.
    return false;
  };

  Part.prototype.getIrradiance = function (temperature) {
    var t2;
    if (this.emissivity === 0) {
      return 0;
    }
    t2 = 273 + temperature;
    t2 *= t2;
    return this.emissivity * constants.STEFAN_CONSTANT * UNIT_SURFACE_AREA * t2 * t2;
  };

  // Emit photons if part meets radiation conditions.
  Part.prototype.radiate = function (model) {
    var
      // The shape is polygonized and radiateFromLine() is called for each line.
      poly = this.shape.polygonize(),
      line = new Line(),
      i, len;

    if (this.emissivity === 0) {
      return;
    }
    // Must follow the clockwise direction in setting lines.
    for (i = 0, len = poly.count - 1; i < len; i += 1) {
      line.x1 = poly.x_coords[i];
      line.y1 = poly.y_coords[i];
      line.x2 = poly.x_coords[i + 1];
      line.y2 = poly.y_coords[i + 1];
      this.radiateFromLine(model, line);
    }
    line.x1 = poly.x_coords[poly.count - 1];
    line.y1 = poly.y_coords[poly.count - 1];
    line.x2 = poly.x_coords[0];
    line.y2 = poly.y_coords[0];
    this.radiateFromLine(model, line);
  };

  // Helper function for radiate() method.
  Part.prototype.radiateFromLine = function (model, line) {
    var options, length, cos, sin, n, x, y, p, d, vx, vy, vxi, vyi, nray, ir,
      i, k;

    if (this.emissivity === 0) {
      return;
    }
    options = model.getModelOptions();
    length = hypot(line.x1 - line.x2, line.y1 - line.y2);
    cos = (line.x2 - line.x1) / length;
    sin = (line.y2 - line.y1) / length;
    n = Math.max(1, Math.round(length / RADIATOR_SPACING));
    vx = options.solar_ray_speed * sin;
    vy = -options.solar_ray_speed * cos;
    if (n === 1) {
      d = 0.5 * length;
      x = line.x1 + d * cos;
      y = line.y1 + d * sin;
      d = model.getAverageTemperatureAt(x, y);
      if (d > MINIMUM_RADIATING_TEMPERATUE) {
        d = model.getTemperatureAt(x, y);
        p = new Photon(x, y, this.getIrradiance(d), options.solar_ray_speed);
        p.vx = vx;
        p.vy = vy;
        model.addPhoton(p);
        if (!this.constant_temperature) {
          model.setTemperatureAt(x, y, d - p.energy / this.specific_heat);
        }
      }
    } else {
      vxi = new Array(4);
      vyi = new Array(4);
      vxi[0] = vx * COS30 - vy * SIN30;
      vyi[0] = vx * SIN30 + vy * COS30;
      vxi[1] = vy * SIN30 + vx * COS30;
      vyi[1] = vy * COS30 - vx * SIN30;
      vxi[2] = vx * COS60 - vy * SIN60;
      vyi[2] = vx * SIN60 + vy * COS60;
      vxi[3] = vy * SIN60 + vx * COS60;
      vyi[3] = vy * COS60 - vx * SIN60;
      nray = 1 + vxi.length;
      for (i = 0; i < n; i += 1) {
        d = (i + 0.5) * RADIATOR_SPACING;
        x = line.x1 + d * cos;
        y = line.y1 + d * sin;
        d = model.getAverageTemperatureAt(x, y);
        ir = this.getIrradiance(d) / nray;
        if (d > MINIMUM_RADIATING_TEMPERATUE) {
          p = new Photon(x, y, ir, options.solar_ray_speed);
          p.vx = vx;
          p.vy = vy;
          model.addPhoton(p);
          for (k = 0; k < nray - 1; k += 1) {
            p = new Photon(x, y, ir, options.solar_ray_speed);
            p.vx = vxi[k];
            p.vy = vyi[k];
            model.addPhoton(p);
          }
          if (!this.constant_temperature) {
            model.changeAverageTemperatureAt(x, y, -ir * nray / this.specific_heat);
          }
        }
      }
    }
  };
});

/*global define: false */

define('energy2d/models/core-model',['require','exports','module','arrays','energy2d/models/physics-solvers/heat-solver','energy2d/models/physics-solvers-gpu/heat-solver-gpu','energy2d/models/physics-solvers/fluid-solver','energy2d/models/physics-solvers-gpu/fluid-solver-gpu','energy2d/models/physics-solvers/ray-solver','energy2d/models/part','energy2d/gpu/gpgpu','energy2d/models/helpers'],function (require, exports) {
  'use strict';

  var
    arrays          = require('arrays'),
    heatsolver      = require('energy2d/models/physics-solvers/heat-solver'),
    heatsolver_GPU  = require('energy2d/models/physics-solvers-gpu/heat-solver-gpu'),
    fluidsolver     = require('energy2d/models/physics-solvers/fluid-solver'),
    fluidsolver_GPU = require('energy2d/models/physics-solvers-gpu/fluid-solver-gpu'),
    raysolver       = require('energy2d/models/physics-solvers/ray-solver'),
    Part            = require('energy2d/models/part').Part,
    gpgpu           = require('energy2d/gpu/gpgpu'),
    hypot           = require('energy2d/models/helpers').hypot,

    array_type = (function () {
      try {
        new Float32Array();
      } catch (e) {
        return 'regular';
      }
      return 'Float32Array';
    }());

  // Core Energy2D model.
  //
  // It creates and manages all the data and parameters used for calculations.
  exports.makeCoreModel = function (opt, partsOpt) {
    var
      // Simulation grid dimensions.
      nx = opt.grid_width,
      ny = opt.grid_height,
      array_size = nx * ny,

      // Spacing.
      delta_x = opt.model_width / nx,
      delta_y = opt.model_height / ny,

      // Simulation steps counter.
      indexOfStep = 0,

      // Physics solvers
      // (initialized later, when core model object is built).
      heatSolver,
      fluidSolver,
      ray_solver,

      // GPU versions of solvers.
      heat_solver_gpu,
      fluid_solver_gpu,

      // Optimization flags.
      radiative,
      has_part_power,

      // WebGL GPGPU optimization.
      WebGL_active = false,
      // This variable holds possible error message connected with WebGL.
      WebGL_error,

      // Performance model.
      // By default, mock this object.
      // To measure performance, set valid object
      // using core_model.setPerformanceTools(tools);
      perf = {
        start: function () {},
        stop: function () {},
        startFPS: function () {},
        updateFPS: function () {},
        stopFPS: function () {}
      },

      //
      // Simulation arrays:
      //
      // - temperature array
      t = arrays.create(array_size, opt.background_temperature, array_type),
      // - internal temperature boundary array
      tb = arrays.create(array_size, NaN, array_type),
      // - velocity x-component array (m/s)
      u = arrays.create(array_size, 0, array_type),
      // - velocity y-component array (m/s)
      v = arrays.create(array_size, 0, array_type),
      // - internal heat generation array
      q = arrays.create(array_size, 0, array_type),
      // - wind speed
      uWind = arrays.create(array_size, 0, array_type),
      vWind = arrays.create(array_size, 0, array_type),
      // - conductivity array
      conductivity = arrays.create(array_size, opt.background_conductivity, array_type),
      // - specific heat capacity array
      capacity = arrays.create(array_size, opt.background_specific_heat, array_type),
      // - density array
      density = arrays.create(array_size, opt.background_density, array_type),
      // - fluid cell array
      fluidity = arrays.create(array_size, true, array_type),
      // - photons array
      photons = [],

      //
      // [GPGPU] Simulation textures:
      //
      // texture 0:
      // - R: t
      // - G: t0
      // - B: tb
      // - A: conductivity
      // texture 1:
      // - R: q
      // - G: capacity
      // - B: density
      // - A: fluidity
      // texture 2:
      // - R: u
      // - G: v
      // - B: u0
      // - A: v0
      // texture 3:
      // - R: uWind
      // - G: vWind
      // - B: undefined
      // - A: undefined
      texture = [],

      // Generate parts array.
      parts = (function () {
        var result = [],
            i, len;

        if (partsOpt) {
          if (!arrays.isArray(partsOpt)) {
            partsOpt = [partsOpt];
          }
          result = new Array(partsOpt.length);
          for (i = 0, len = partsOpt.length; i < len; i += 1) {
            result[i] = new Part(partsOpt[i]);
          }
        }
        return result;
      }()),

      //
      // Private methods
      //
      initGPGPU = function () {
        WebGL_active = false;

        // Make sure that environment is a browser.
        if (typeof window === 'undefined') {
          throw new Error("Core model: WebGL GPGPU unavailable in the node.js environment.");
        }
        // Init module.
        // Width is ny, height is nx (due to data organization).
        gpgpu.init(ny, nx);

        // Create simulation textures.
        texture[0] = gpgpu.createTexture();
        texture[1] = gpgpu.createTexture();
        texture[2] = gpgpu.createTexture();
        texture[3] = gpgpu.createTexture();

        // Update textures as material properties should be already set.
        fillGPGPUTextures();

        // Create GPU solvers.
        // GPU version of heat solver.
        heat_solver_gpu = heatsolver_GPU.makeHeatSolverGPU(core_model);
        // GPU version of fluid solver.
        fluid_solver_gpu = fluidsolver_GPU.makeFluidSolverGPU(core_model);

        WebGL_active = true;
      },

      fillGPGPUTextures = function () {
        // texture 0:
        // - R: t
        // - G: t0
        // - B: tb
        // - A: conductivity
        gpgpu.writeRGBATexture(texture[0], t, t, tb, conductivity);
        // texture 1:
        // - R: q
        // - G: capacity
        // - B: density
        // - A: fluidity
        gpgpu.writeRGBATexture(texture[1], q, capacity, density, fluidity);
        // texture 2:
        // - R: u
        // - G: v
        // - B: u0
        // - A: v0
        gpgpu.writeRGBATexture(texture[2], u, v, u, v);
        // texture 3:
        // - R: uWind
        // - G: vWind
        // - B: undefined
        // - A: undefined
        gpgpu.writeRGBATexture(texture[3], uWind, vWind, uWind, vWind);
      },

      setupOptimizationFlags = function () {
        radiative = (function () {
          var i, len;
          if (opt.sunny) {
            return true;
          }
          for (i = 0, len = parts.length; i < len; i += 1) {
            if (parts[i].emissivity > 0) {
              return true;
            }
          }
          return false;
        }());

        has_part_power = (function () {
          var i, len;
          for (i = 0, len = parts.length; i < len; i += 1) {
            if (parts[i].power > 0) {
              return true;
            }
          }
          return false;
        }());
      },

      setupPart = function (part, updateOnly) {
        var
          lx = opt.model_width,
          ly = opt.model_height,
          indices, idx,
          ii, len;

        indices = part.getGridCells(nx, ny, lx, ly);
        for (ii = 0, len = indices.length; ii < len; ii += 1) {
          idx = indices[ii];

          if (!updateOnly) {
            t[idx] = part.temperature;
          }
          fluidity[idx] = false;
          conductivity[idx] = part.thermal_conductivity;
          capacity[idx] = part.specific_heat;
          density[idx] = part.density;

          if (part.wind_speed !== 0) {
            uWind[idx] = part.wind_speed * Math.cos(part.wind_angle);
            vWind[idx] = part.wind_speed * Math.sin(part.wind_angle);
          }

          if (part.constant_temperature) {
            tb[idx] = part.temperature;
          }
        }
      },

      resetArrays = function (skipTempAndVelocity) {
        if (!skipTempAndVelocity) {
          arrays.fill(t, opt.background_temperature);
          arrays.fill(u, 0);
          arrays.fill(v, 0);
        }
        arrays.fill(tb, NaN);
        arrays.fill(q, 0);
        arrays.fill(uWind, 0);
        arrays.fill(vWind, 0);
        arrays.fill(conductivity, opt.background_conductivity);
        arrays.fill(capacity, opt.background_specific_heat);
        arrays.fill(density, opt.background_density);
        arrays.fill(fluidity, true);
      },

      setupMaterialProperties = function (updateOnly) {
        if (!parts || parts.length === 0) return;
        var i;
        // Treat overlapping parts as original Energy2D.
        for (i = parts.length - 1; i >= 0; i -= 1) {
          setupPart(parts[i], updateOnly);
        }
      },

      refreshPowerArray = function () {
        var part, x, y, i, iny, j, k, len, count;
        for (i = 0; i < nx; i += 1) {
          x = i * delta_x;
          iny = i * ny;
          for (j = 0; j < ny; j += 1) {
            y = j * delta_y;
            q[iny + j] = 0;
            count = 0;
            if (has_part_power) {
              for (k = 0, len = parts.length; k < len; k += 1) {
                part = parts[k];
                if (part.shape.contains(x, y)) {
                  q[iny + j] += part.power;
                  count++;
                }
              }
              if (count > 0) q[iny + j] /= count;
            }
          }
        }
      },

      getVorticityAt = function (i, j) {
        var du_dy = (u[i * ny + j + 1] - u[i * ny + j - 1]) / delta_x,
            dv_dx = (v[(i + 1) * ny + j] - v[(i - 1) * ny + j]) / delta_y;
        return 0.5 * (du_dy - dv_dx);
      },

      //
      // Public API
      //
      core_model = {
        // !!!
        // Performs next step of a simulation.
        // !!!
        nextStep: function () {
          perf.start('Core model step');
          if (WebGL_active) {
            // GPU solvers.
            if (opt.convective) {
              perf.start('Fluid solver GPU');
              fluid_solver_gpu.solve();
              perf.stop('Fluid solver GPU');
            }
            perf.start('Heat solver GPU');
            heat_solver_gpu.solve(opt.convective);
            perf.stop('Heat solver GPU');
          } else {
            // CPU solvers.
            if (radiative) {
              perf.start('Ray solver CPU');
              if (indexOfStep % opt.photon_emission_interval === 0) {
                refreshPowerArray();
                if (opt.sunny) {
                  ray_solver.sunShine();
                }
                ray_solver.radiate();
              }
              ray_solver.solve();
              perf.stop('Ray solver CPU');
            }
            if (opt.convective) {
              perf.start('Fluid solver CPU');
              fluidSolver.solve(u, v);
              perf.stop('Fluid solver CPU');
            }
            perf.start('Heat solver CPU');
            heatSolver.solve(opt.convective, t, q);
            perf.stop('Heat solver CPU');
          }
          indexOfStep += 1;
          perf.stop('Core model step');
        },

        // Sets performance tools.
        // It's expected to be an object created by
        // energy2d.utils.performance.makePerformanceTools
        setPerformanceTools: function (perf_tools) {
          perf = perf_tools;
        },

        reset: function () {
          indexOfStep = 0;
          resetArrays();
          setupOptimizationFlags();
          setupMaterialProperties();
          refreshPowerArray();
          if (WebGL_active) {
            fillGPGPUTextures();
          }
        },

        partsChanged: function (part, propChanged) {
          // TODO: in theory we don't have to process all parts. If needed
          // implement something tricker.
          // Note that temperature and velocity aren't reset to provide better
          // interactivity.
          resetArrays(true);
          setupOptimizationFlags();
          setupMaterialProperties(true);
          refreshPowerArray();

          if (propChanged === "temperature") {
            setupPart(part);
          }
        },

        addPart: function (props) {
          var part = new Part(props);
          parts.push(part);
          setupPart(part);
        },

        removePart: function (i) {
          parts.splice(i, 1);
          core_model.partsChanged();
        },

        useWebGL: function (v) {
          if (WebGL_active === v) return;
          if (!core_model.isWebGLCompatible()) {
            // Some models are incompatible with WebGL.
            WebGL_active = false;
            return;
          }

          if (v) {
            // Initialize GPGPU, this will also copy current temperature
            // and velocity arrays into textures.
            initGPGPU();
          } else {
            // Copy data back from GPU to main memory.
            core_model.syncTemperature();
            core_model.syncVelocity();
            WebGL_active = false;
          }
        },

        isWebGLActive: function () {
          return WebGL_active;
        },

        isWebGLCompatible: function () {
          return !radiative;
        },

        getWebGLError: function () {
          return WebGL_error;
        },

        syncTemperature: function () {
          if (WebGL_active) {
            gpgpu.readTexture(texture[0], t);
          }
        },

        syncVelocity: function () {
          if (WebGL_active) {
            gpgpu.readTexture(texture[2], u, 0);
            gpgpu.readTexture(texture[2], v, 1);
          }
        },

        getIndexOfStep: function () {
          return indexOfStep;
        },
        // Returns loaded options after validation.
        getModelOptions: function () {
          return opt;
        },

        // Temperature manipulation.
        getTemperatureAt: function (x, y) {
          var
            i = Math.max(Math.min(nx - 1, Math.round(x / delta_x)), 0),
            j = Math.max(Math.min(ny - 1, Math.round(y / delta_y)), 0);

          return t[i * ny + j];
        },

        setTemperatureAt: function (x, y, temperature) {
          var
            i = Math.max(Math.min(nx - 1, Math.round(x / delta_x)), 0),
            j = Math.max(Math.min(ny - 1, Math.round(y / delta_y)), 0);

          t[i * ny + j] = temperature;
        },

        getAverageTemperatureAt: function (x, y) {
          var
            temp = 0,
            nx1 = nx - 1,
            ny1 = ny - 1,
            i0 = Math.round(x / delta_x),
            j0 = Math.round(y / delta_y),
            i, j;

          i = Math.max(Math.min(nx1, i0), 0);
          j = Math.max(Math.min(ny1, j0), 0);
          temp += t[i * ny + j];
          i = Math.max(Math.min(nx1, i0 + 1), 0);
          j = Math.max(Math.min(ny1, j0), 0);
          temp += t[i * ny + j];
          i = Math.max(Math.min(nx1, i0 - 1), 0);
          j = Math.max(Math.min(ny1, j0), 0);
          temp += t[i * ny + j];
          i = Math.max(Math.min(nx1, i0), 0);
          j = Math.max(Math.min(ny1, j0 + 1), 0);
          temp += t[i * ny + j];
          i = Math.max(Math.min(nx1, i0), 0);
          j = Math.max(Math.min(ny1, j0 - 1), 0);
          temp += t[i * ny + j];
          return temp * 0.2;
        },

        // TODO: based on Java version, check it as the logic seems to be weird.
        changeAverageTemperatureAt: function (x, y, increment) {
          var
            nx1 = nx - 1,
            ny1 = ny - 1,
            i0 = Math.round(x / delta_x),
            j0 = Math.round(y / delta_y),
            i, j;

          increment *= 0.2;
          i = Math.min(nx1, i0);
          j = Math.min(ny1, j0);
          if (i >= 0 && j >= 0) {
            t[i * ny + j] += increment;
          }
          i = Math.min(nx1, i0 + 1);
          j = Math.min(ny1, j0);
          if (i >= 0 && j >= 0) {
            t[i * ny + j] += increment;
          }
          i = Math.min(nx1, i0 - 1);
          j = Math.min(ny1, j0);
          if (i >= 0 && j >= 0) {
            t[i * ny + j] += increment;
          }
          i = Math.min(nx1, i0);
          j = Math.min(ny1, j0 + 1);
          if (i >= 0 && j >= 0) {
            t[i * ny + j] += increment;
          }
          i = Math.min(nx1, i0);
          j = Math.min(ny1, j0 - 1);
          if (i >= 0 && j >= 0) {
            t[i * ny + j] += increment;
          }
        },

        getVorticityAt: function (x, y) {
          var i = Math.max(Math.min(nx - 1, Math.round(x / delta_x)), 0),
              j = Math.max(Math.min(ny - 1, Math.round(y / delta_y)), 0);
          return getVorticityAt(i, j);
        },

        getAverageVorticityAt: function (x, y) {
          var i = Math.max(Math.min(nx - 1, Math.round(x / delta_x)), 0),
              j = Math.max(Math.min(ny - 1, Math.round(y / delta_y)), 0),
              vor = getVorticityAt(i, j);
          vor += getVorticityAt(i - 1, j);
          vor += getVorticityAt(i + 1, j);
          vor += getVorticityAt(i, j - 1);
          vor += getVorticityAt(i, j + 1);
          vor += getVorticityAt(i - 1, j - 1);
          vor += getVorticityAt(i - 1, j + 1);
          vor += getVorticityAt(i + 1, j - 1);
          vor += getVorticityAt(i + 1, j + 1);
          return vor / 9;
        },

        getSpeedAt: function (x, y) {
          var
            i = Math.max(Math.min(nx - 1, Math.round(x / delta_x)), 0),
            j = Math.max(Math.min(ny - 1, Math.round(y / delta_y)), 0);

          return hypot(u[i * ny + j], v[i * ny + j]);
        },

        getHeatFluxAt: function (x, y) {
          var
            i = Math.max(Math.min(nx - 1, Math.round(x / delta_x)), 0),
            j = Math.max(Math.min(ny - 1, Math.round(y / delta_y)), 0),
            fx = conductivity[i * ny + j] * (t[(i - 1) * ny + j] - t[(i + 1) * ny + j]) / (2 * delta_x),
            fy = conductivity[i * ny + j] * (t[i * ny + j - 1] - t[i * ny + j + 1]) / (2 * delta_y);
          return [fx, fy];
        },

        addPhoton: function (photon) {
          photons.push(photon);
        },

        removePhoton: function (photon) {
          var idx = photons.indexOf(photon);
          if (idx !== -1) {
            photons.splice(idx, 1);
          }
        },

        // Simple getters.
        getArrayType: function () {
          // return module variable
          return array_type;
        },
        getPerformanceModel: function () {
          return perf;
        },
        // Arrays.
        getTemperatureArray: function () {
          return t;
        },
        getUVelocityArray: function () {
          return u;
        },
        getVVelocityArray: function () {
          return v;
        },
        getUWindArray: function () {
          return uWind;
        },
        getVWindArray: function () {
          return vWind;
        },
        getBoundaryTemperatureArray: function () {
          return tb;
        },
        getPowerArray: function () {
          return q;
        },
        getConductivityArray: function () {
          return conductivity;
        },
        getCapacityArray: function () {
          return capacity;
        },
        getDensityArray: function () {
          return density;
        },
        getFluidityArray: function () {
          return fluidity;
        },
        getPhotonsArray: function () {
          return photons;
        },
        getPartsArray: function () {
          return parts;
        },
         // Textures.
        getTemperatureTexture: function () {
          return texture[0];
        },
        getVelocityTexture: function () {
          return texture[2];
        },
        getSimulationTexture: function (id) {
          return texture[id];
        }
      };

    //
    // One-off initialization.
    //
    setupOptimizationFlags();
    setupMaterialProperties();
    refreshPowerArray();

    // CPU version of solvers.
    heatSolver = heatsolver.makeHeatSolver(core_model);
    fluidSolver = fluidsolver.makeFluidSolver(core_model);
    ray_solver = raysolver.makeRaySolver(core_model);

    // Finally, return public API object.
    return core_model;
  };
});
/*global define: false, d3: false */

define('energy2d/modeler',['require','common/alert','common/console','common/validator','common/serialize','common/lab-modeler-mixin','energy2d/metadata','energy2d/models/core-model'],function (require) {
  'use strict';
  var alert           = require('common/alert'),
      console         = require('common/console'),
      validator       = require('common/validator'),
      serialize       = require('common/serialize'),
      LabModelerMixin = require('common/lab-modeler-mixin'),
      metadata        = require('energy2d/metadata'),
      coremodel       = require('energy2d/models/core-model'),

      unitsDefinition = {
        units: {
          time: {
            name: "second",
            pluralName: "seconds",
            symbol: "s"
          },
          temperature: {
            name: "degree Celsius",
            pluralName: "degrees Celsius",
            symbol: "C"
          },
          length: {
            name: "meter",
            pluralName: "meters",
            symbol: "m"
          },
          velocity: {
            name: "meter per second",
            pluralName: "meters per second",
            symbol: "m/s"
          }
        }
      };

  return function Modeler(initialProperties) {
    var model,
        coreModel,

        labModelerMixin = new LabModelerMixin({
          metadata: metadata,
          unitsDefinition: unitsDefinition,
          initialProperties: initialProperties,
          setters: {
            use_WebGL: function (v) {
              if (coreModel) {
                setWebGLEnabled(v);
              }
              ticksToGPUSync = model.properties.ticksPerGPUSync;
            },
            ticksPerGPUSync: function (v) {
              if (coreModel) syncGPU();
              ticksToGPUSync = Number(v); // support "Infinity" value
            }
          }
        }),
        propertySupport = labModelerMixin.propertySupport,
        dispatch = labModelerMixin.dispatchSupport,

        ticksToGPUSync = 0,

        // Sensors are modeler-level objects, they only define outputs
        // and have nothing to do with physics calculations.
        sensors = [],
        anemometers = [],

        viewModel = {
          parts: [],
          sensors: []
        },

        updatePartsViewModel = (function () {
          function PartWrapper(rawPart) {
            Object.defineProperty(this, '_rawPart', {
              enumerable: false,
              get: function () {
                return rawPart;
              }
            });
          }
          Object.keys(metadata.part).forEach(function (key) {
            Object.defineProperty(PartWrapper.prototype, key, {
              enumerable: true,
              get: function () {
                return this._rawPart[key];
              },
              set: function (v) {
                var WebGLOrg = model.properties.use_WebGL;
                // This will update CPU array.
                model.properties.use_WebGL = false;

                propertySupport.invalidatingChangePreHook();

                // Update raw part object.
                this._rawPart[key] = validator.validateSingleProperty(metadata.part[key], key, v);

                if (model.isStopped()) {
                  // Recalculate all arrays, "authoring" mode.
                  coreModel.reset();
                } else {
                  // Update core model arrays based on part's properties.
                  coreModel.partsChanged(this._rawPart, key);
                }

                propertySupport.invalidatingChangePostHook();

                // Restore original WebGL option value. It will
                // copy CPU arrays to GPU in case of need.
                model.properties.use_WebGL = WebGLOrg;
                dispatch.partsChanged();
              }
            });
          });
          PartWrapper.prototype.computeLabel = function() {
            return this._rawPart.getLabel();
          };

          return function () {
            var rawParts = coreModel.getPartsArray(),
                viewParts = viewModel.parts,
                i, len;
            viewParts.length = 0;
            for (i = 0, len = rawParts.length; i < len; i++) {
              viewParts.push(new PartWrapper(rawParts[i]));
            }
          };
        }()),

        updateSensorViewModel = (function () {
          function SensorWrapper(rawObj) {
            Object.defineProperty(this, '_rawObj', {
              enumerable: false,
              get: function () {
                return rawObj;
              }
            });
          }
          var constraint = {
            x: function (v) { return Math.max(0, Math.min(model.properties.model_width, v)); },
            y: function (v) { return Math.max(0, Math.min(model.properties.model_height, v)); }
          };
          Object.keys(metadata.sensor).forEach(function (key) {
            Object.defineProperty(SensorWrapper.prototype, key, {
              enumerable: true,
              get: function () {
                return this._rawObj[key];
              },
              set: function (v) {
                propertySupport.invalidatingChangePreHook();
                v = constraint[key] ? constraint[key](v) : v;
                this._rawObj[key] = validator.validateSingleProperty(metadata.sensor[key], key, v);
                propertySupport.invalidatingChangePostHook();
                dispatch.sensorsChanged();
              }
            });
          });

          return function () {
            var viewSensors = viewModel.sensors,
                i, len;
            viewSensors.length = 0;
            for (i = 0, len = sensors.length; i < len; i++) {
              viewSensors.push(new SensorWrapper(sensors[i]));
            }
          };
        }());

    function setWebGLEnabled(v) {
      try {
        coreModel.useWebGL(v);
      } catch (e) {
        console.warn("WebGL initialization failed. CPU solvers and rendering will be used.");
        console.warn(e.message);
      }
    }

    function syncGPU() {
      coreModel.syncTemperature();
      coreModel.syncVelocity();
    }

    function hasDiverged() {
      var t = model.getTemperatureArray(),
          i, len;

      for (i = 0, len = t.length; i < len; i++) {
        if (isNaN(t[i]) || Math.abs(t[i]) > 1e10) {
          model.stop();
          coreModel.reset();
          return true;
        }
      }
      return false;
    }

    function validateParts(partsArray) {
      var result = [];
      partsArray.forEach(function (v) {
        result.push(validator.validateCompleteness(metadata.part, v));
      });
      return result;
    }

    function createSensors(sensorsSpec) {
      var sensorValue = {
            thermometer: function () {
              return model.getTemperatureAt(this.x, this.y);
            },
            anemometer: function () {
              return this._rot;
            },
            heatFlux: function () {
              var flux = model.getHeatFluxAt(this.x, this.y);
              return flux[0] * this._sin + flux[1] * this._cos;
            }
          },
          sensorOutputDesc = {
            thermometer: {
              label: "Temperature",
              unitType: 'temperature',
              format: '.1f'
            },
            anemometer: {
            },
            heatFlux: {
              label: "Heat Flux",
              unitName: "Watt Per Square Meter",
              unitPluralName: "Watts Per Square Meter",
              unitAbbreviation: "W/m",
              format: '.1f'
            }
          };

      sensors = [];
      sensorsSpec.forEach(function (s, idx) {
        s = validator.validateCompleteness(metadata.sensor, s);
        if (s.type === "anemometer") {
          s._rot = 0;
          anemometers.push(s);
        }
        if (s.type === "heatFlux") {
          s.angle = s.angle || 0;
          s._sin = Math.sin(-s.angle * Math.PI / 180);
          s._cos = Math.cos(s.angle * Math.PI / 180);
        }
        Object.defineProperty(s, "value", {
          enumerable: true,
          get: sensorValue[s.type]
        });
        sensors.push(s);

        model.defineOutput("sensor-" + idx, sensorOutputDesc[s.type], function() {
          return s.value;
        });
      });
    }

    function updateAnemometers() {
      var a, i, len;
      for (i = 0, len = anemometers.length; i < len; i++) {
        a = anemometers[i];
        a._rot += model.getSpeedAt(a.x, a.y) * (model.getVorticityAt(a.x, a.y) < 0 ? -1 : 1) *
                  model.properties.timeStep * 700;
        a._rot = a._rot % 360;
      }
    }

    model = {
      tick: function () {
        var i, len, diverged;
        for (i = 0, len = model.properties.timeStepsPerTick; i < len; i++) {
          coreModel.nextStep();
        }
        if (coreModel.isWebGLActive()) {
          if (ticksToGPUSync > 0) {
            ticksToGPUSync--;
          } else {
            syncGPU();
            ticksToGPUSync = Number(model.properties.ticksPerGPUSync); // support "Infinity" value
            diverged = hasDiverged();
          }
        } else {
          diverged = hasDiverged();
        }
        updateAnemometers();
        model.updateAllOutputProperties();
        dispatch.tick();

        if (diverged) {
          alert("The model has diverged and has been reset!\n\nTry changing its parameters " +
                "(e.g. 'timeStep', positions of parts etc.) or reload it to restore the initial configuration.");
        }
      },

      syncTemperature: function () {
        propertySupport.invalidatingChangePreHook();
        coreModel.syncTemperature();
        propertySupport.invalidatingChangePostHook();
      },
      syncVelocity: function () {
        propertySupport.invalidatingChangePreHook();
        coreModel.syncVelocity();
        propertySupport.invalidatingChangePostHook();
      },

      addPart: function (props) {
        var WebGLOrg = model.properties.use_WebGL;

        // This will update CPU array.
        model.properties.use_WebGL = false;

        props = validator.validateCompleteness(metadata.part, props);

        propertySupport.invalidatingChangePreHook();

        coreModel.addPart(props);
        updatePartsViewModel();

        propertySupport.invalidatingChangePostHook();

        // Restore original WebGL option value. It will
        // copy CPU arrays to GPU in case of need.
        model.properties.use_WebGL = WebGLOrg;
        dispatch.partsChanged();
      },

      removePart: function (i) {
        var WebGLOrg = model.properties.use_WebGL;

        // This will update CPU array.
        model.properties.use_WebGL = false;

        propertySupport.invalidatingChangePreHook();

        coreModel.removePart(i);
        updatePartsViewModel();

        propertySupport.invalidatingChangePostHook();

        // Restore original WebGL option value. It will
        // copy CPU arrays to GPU in case of need.
        model.properties.use_WebGL = WebGLOrg;
        dispatch.partsChanged();
      },

      stepCounter: function () {
        return coreModel.getIndexOfStep();
      },
      isNewStep: function () {
        return true;
      },
      stepBack: function (num) {
        return coreModel.getIndexOfStep();
      },
      stepForward: function (num) {
        if (!arguments.length) { num = 1; }
        if (!this.isStopped()) {
          this.stop();
        }
        var i=-1; while(++i < num) {
          model.tick();
        }
        return coreModel.getIndexOfStep();
      },
      getTime: function () {
        return model.properties.timeStep * coreModel.getIndexOfStep();
      },
      isWebGLActive: function () {
        return coreModel.isWebGLActive();
      },
      isWebGLCompatible: function() {
        return coreModel.isWebGLCompatible();
      },
      getWebGLError: function () {
        return coreModel.getWebGLError();
      },
      getIndexOfStep: function () {
        return coreModel.getIndexOfStep();
      },
      getTemperatureAt: function (x, y) {
        return coreModel.getTemperatureAt(x, y);
      },
      getAverageTemperatureAt: function (x, y) {
        return coreModel.getAverageTemperatureAt(x, y);
      },
      getVorticityAt: function (x, y) {
        return coreModel.getVorticityAt(x, y);
      },
      getHeatFluxAt: function (x, y) {
        return coreModel.getHeatFluxAt(x, y);
      },
      getAverageVorticityAt: function (x, y) {
        return coreModel.getAverageVorticityAt(x, y);
      },
      getSpeedAt: function (x, y) {
        return coreModel.getSpeedAt(x, y);
      },
      getTemperatureArray: function () {
        return coreModel.getTemperatureArray();
      },
      getTemperatureTexture: function () {
        return coreModel.getTemperatureTexture();
      },
      getUVelocityArray: function () {
        return coreModel.getUVelocityArray();
      },
      getVVelocityArray: function () {
        return coreModel.getVVelocityArray();
      },
      getVelocityTexture: function () {
        return coreModel.getVelocityTexture();
      },
      getPhotonsArray: function () {
        return coreModel.getPhotonsArray();
      },

      getPartsArray: function () {
        return viewModel.parts;
      },

      getSensorsArray: function () {
        return viewModel.sensors;
      },

      setPerformanceTools: function () {
        return coreModel.setPerformanceTools();
      },

      serialize: function () {
        var propCopy = {},
            rawProperties = propertySupport.rawValues;

        propCopy = serialize(metadata.mainProperties, rawProperties);
        propCopy.viewOptions = serialize(metadata.viewOptions, rawProperties);

        propCopy.structure = {
          part: []
        };
        viewModel.parts.forEach(function (p) {
          propCopy.structure.part.push(serialize(metadata.part, p));
        });

        propCopy.sensors = [];
        viewModel.sensors.forEach(function (s) {
          propCopy.sensors.push(serialize(metadata.sensor, s));
        });

        return propCopy;
      }
    };

    (function () {
      var parts;

      labModelerMixin.mixInto(model);
      dispatch.addEventTypes("tick", "partsChanged", "sensorsChanged");

      // Validate parts before passing options to coreModel.
      if (initialProperties.structure && initialProperties.structure.part) {
        parts = validateParts(initialProperties.structure.part);
      }

      coreModel = coremodel.makeCoreModel(model.properties, parts);
      setWebGLEnabled(model.properties.use_WebGL);

      if (initialProperties.sensors) {
        createSensors(initialProperties.sensors);
      }

      updatePartsViewModel();
      updateSensorViewModel();

      // Temporal workaround. In fact width and height should
      // be outputs based on min / max.
      model.defineOutput('minX', {}, function() {
        return 0;
      });
      model.defineOutput('minY', {}, function() {
        return 0;
      });
      model.defineOutput('maxX', {}, function() {
        return model.properties.model_width;
      });
      model.defineOutput('maxY', {}, function() {
        return model.properties.model_height;
      });

      model.defineOutput('time', {
        label: "Time",
        unitType: 'time',
        format: '.2f'
      }, function() {
        return model.getTime();
      });

      model.defineOutput('displayTime', {
        label: "Time"
      }, (function() {
        var f = d3.format("02d");
        return function() {
          var time = model.getTime(),
              seconds, minutes, hours, days;
          time = Math.floor(time);
          seconds = time % 60;
          time = Math.floor(time / 60);
          minutes = time % 60;
          time = Math.floor(time / 60);
          hours = time % 24;
          time = Math.floor(time / 24);
          days = time;
          return days + ':' + f(hours) + ':' + f(minutes)  + ':' + f(seconds);
        };
      }()));
    }());

    return model;
  };
});

/*jslint indent: 2, browser: true, newcap: true */
/*globals define: false*/


define('energy2d/views/helpers',[],function () {
  'use strict';

  // Return module with functions.
  return {
    // HSV to RGB color conversion.
    //
    // H runs from 0 to 360 degrees,
    // S and V run from 0 to 100.
    // 
    // Ported from the excellent java algorithm by Eugene Vishnevsky at:
    // http://www.cs.rit.edu/~ncs/color/t_convert.html
    // http://snipplr.com/view.php?codeview&id=14590
    HSVToRGB: function (h, s, v) {
      var
        r, g, b,
        i,
        f, p, q, t;

      // Make sure our arguments stay in-range
      h = Math.max(0, Math.min(360, h));
      s = Math.max(0, Math.min(100, s));
      v = Math.max(0, Math.min(100, v));

      // We accept saturation and value arguments from 0 to 100 because that's
      // how Photoshop represents those values. Internally, however, the
      // saturation and value are calculated from a range of 0 to 1. We make
      // That conversion here.
      s /= 100;
      v /= 100;

      if (s === 0) {
        // Achromatic (grey)
        r = g = b = v;
        return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
      }

      h /= 60; // sector 0 to 5
      i = Math.floor(h);
      f = h - i; // factorial part of h
      p = v * (1 - s);
      q = v * (1 - s * f);
      t = v * (1 - s * (1 - f));

      switch (i) {
      case 0:
        r = v;
        g = t;
        b = p;
        break;

      case 1:
        r = q;
        g = v;
        b = p;
        break;

      case 2:
        r = p;
        g = v;
        b = t;
        break;

      case 3:
        r = p;
        g = q;
        b = v;
        break;

      case 4:
        r = t;
        g = p;
        b = v;
        break;

      default: // case 5:
        r = v;
        g = p;
        b = q;
      }

      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
    }
  };
});

/*jslint indent: 2, browser: true, newcap: true, sub: true */
/*globals define: false, $: false*/

define('energy2d/views/color-palette',['require','energy2d/views/helpers'],function (require) {
  'use strict';
  var
    // Dependencies.
    view_helpers = require('energy2d/views/helpers'),

    // Object with available color palettes.
    color_palette,
    // Constructor function.
    ColorPalette;

  // Setup basic color palettes.
  color_palette = {};
  color_palette['0'] = color_palette['RAINBOW']  = [[ 0, 0, 128 ], [ 20, 50, 120 ], [ 20, 100, 200 ], [ 10, 150, 150 ], [ 120, 180, 50 ], [ 220, 200, 10 ], [ 240, 160, 36 ], [ 225, 50, 50 ], [ 230, 85, 110 ], [ 250, 250, 250 ], [ 255, 255, 255 ] ];
  color_palette['1'] = color_palette['IRON']     = [ [ 40, 20, 100 ], [ 80, 20, 150 ], [ 150, 20, 150 ], [ 200, 50, 120 ], [ 220, 80, 80 ], [ 230, 120, 30 ], [ 240, 200, 20 ], [ 240, 220, 80 ], [ 255, 255, 125 ], [ 250, 250, 250 ], [ 255, 255, 255 ] ];
  color_palette['2'] = color_palette['GRAY']     = [ [ 50, 50, 50 ], [ 75, 75, 75 ], [ 100, 100, 100 ], [ 125, 125, 125 ], [ 150, 150, 150 ], [ 175, 175, 175 ], [ 200, 200, 200 ], [ 225, 225, 225 ], [ 250, 250, 250 ], [ 255, 255, 255 ] ];
  color_palette['3'] = color_palette['RAINBOW2'] = (function () {
    var
      HSVToRGB = view_helpers.HSVToRGB,
      length = 256,
      rgb = new Array(length),
      i;

    for (i = 0; i < length; i += 1) {
      rgb[i] = view_helpers.HSVToRGB(length - 1 - i, 100, 90);
    }
    return rgb;
  }());

  ColorPalette = function (color_palette_id) {
    if (color_palette_id === undefined || color_palette_id === 'DEFAULT') {
      color_palette_id = 'RAINBOW';
    }
    this.color_palette_id = color_palette_id;
  };

  ColorPalette.prototype.getRGBArray = function () {
    if (color_palette[this.color_palette_id] !== undefined) {
      return color_palette[this.color_palette_id];
    }
  };

  // Export constructor function.
  return ColorPalette;
});

/*global define: false, $: false*/

// Heatmap view.
//
// It uses HTML5 Canvas for rendering.
// getHTMLElement() returns jQuery object with the canvas used for rendering.
// Before use, this view should be bound with a heatmap using bindHeapmap(heatmap, grid_width, grid_height).
// To render the heatmap use renderHeatmap() method.
// Set size of the heatmap using CSS rules. The view fits canvas dimensions to the real
// size of the HTML element to avoid low quality CSS scaling *ONLY* when HQ rendering is enabled.
// Otherwise, the canvas has the same dimensions as heatmap grid and fast CSS scaling is used.

define('energy2d/views/heatmap',['require','energy2d/views/color-palette'],function (require) {
  'use strict';
  var
    // Dependencies.
    ColorPalette = require('energy2d/views/color-palette');

  return function HeatmapView(html_id) {
    var
      DEFAULT_ID = 'energy2d-heatmap-view',

      $heatmap_canvas,
      canvas_ctx,

      rgb_array,
      max_rgb_idx,

      heatmap,
      grid_width,
      grid_height,
      min_temp = 0,
      max_temp = 50,

      //
      // Private methods.
      //
      initHTMLelement = function () {
        $heatmap_canvas = $('<canvas />');
        $heatmap_canvas.attr('id', html_id || DEFAULT_ID);
        canvas_ctx = $heatmap_canvas[0].getContext('2d');
      },

      //
      // Public API.
      //
      heatmap_view = {
        // Render heat map on the canvas.
        renderHeatmap: function () {
          var
            scale, rgb_idx, val, color1, color2,
            image_data, data,
            i, j, iny, pix_index, pix_stride;

          if (!heatmap) {
            throw new Error("Heatmap: bind heatmap before rendering.");
          }

          canvas_ctx.clearRect(0, 0, grid_width, grid_height);
          // TODO: is it really necessary?
          canvas_ctx.fillStyle = "rgb(0,0,0)";

          scale = max_rgb_idx / Math.max(1, max_temp - min_temp);
          image_data = canvas_ctx.getImageData(0, 0, grid_width, grid_height);
          data = image_data.data;

          pix_index = 0;
          pix_stride = 4 * grid_width;
          for (i = 0; i < grid_width; i += 1) {
            iny = i * grid_height;
            pix_index = 4 * i;
            for (j = 0; j < grid_height; j += 1) {
              val = scale * (heatmap[iny + j] - min_temp);
              rgb_idx = Math.floor(val);
              // Get fractional part of val.
              val -= rgb_idx;
              if (rgb_idx < 0) {
                rgb_idx = 0;
                val = 0;
              } else if (rgb_idx > max_rgb_idx - 1) {
                rgb_idx = max_rgb_idx - 1;
                val = 1;
              }
              color1 = rgb_array[rgb_idx];
              color2 = rgb_array[rgb_idx + 1];
              data[pix_index]     = color1[0] * (1 - val) + color2[0] * val;
              data[pix_index + 1] = color1[1] * (1 - val) + color2[1] * val;
              data[pix_index + 2] = color1[2] * (1 - val) + color2[2] * val;
              data[pix_index + 3] = 255;
              pix_index += pix_stride;
            }
          }
          canvas_ctx.putImageData(image_data, 0, 0);
        },

        // Bind heatmap to the view.
        bindHeatmap: function (new_heatmap, new_grid_width, new_grid_height) {
          if (new_grid_width * new_grid_height !== new_heatmap.length) {
            throw new Error("Heatmap: provided heatmap has wrong dimensions.");
          }
          heatmap = new_heatmap;
          grid_width = new_grid_width;
          grid_height = new_grid_height;
          this.setCanvasSize(grid_width, grid_height);
        },

        getHTMLElement: function () {
          return $heatmap_canvas;
        },

        resize: function () {
          // Don't do anything, canvas width and height depend on  grid
          // dimensions, not CSS dimensions of canvas itself.
          // If grid is 100x100, but CSS dimensions are 500x500, CSS scaling
          // will be used.
        },

        setCanvasSize: function (w, h) {
          $heatmap_canvas.attr('width',  w);
          $heatmap_canvas.attr('height', h);
        },

        setMinTemperature: function (v) {
          min_temp = v;
        },
        setMaxTemperature: function (v) {
          max_temp = v;
        },
        setColorPalette: function (id) {
          rgb_array = new ColorPalette(id).getRGBArray();
          max_rgb_idx = rgb_array.length - 1;
        }
      };
    // One-off initialization.
    // Set the default color palette.
    heatmap_view.setColorPalette('DEFAULT');

    initHTMLelement();

    return heatmap_view;
  };
});

define('text!energy2d/views/heatmap-webgl-glsl/basic.vs.glsl',[],function () { return 'varying vec2 coord;\n\nvoid main() {\n  coord = gl_TexCoord.xy;\n  gl_Position = vec4(gl_Vertex.xyz, 1.0);\n}\n';});

define('text!energy2d/views/heatmap-webgl-glsl/temp-renderer.fs.glsl',[],function () { return '// Provided textur contains temperature data in R channel.\nuniform sampler2D heatmap_tex;\nuniform sampler2D palette_tex;\n\nuniform float max_temp;\nuniform float min_temp;\n\nvarying vec2 coord;\n\nvoid main() {\n  float temp = texture2D(heatmap_tex, coord).r;\n  float scaled_temp = (temp - min_temp) / max(1.0, max_temp - min_temp);\n  gl_FragColor = texture2D(palette_tex, vec2(scaled_temp, 0.5));\n}\n';});

/*jslint indent: 2, browser: true, newcap: true */
/*globals define: false, Uint8Array: false, $: false */

// Heatmap WebGL view.
//
// It uses HTML5 Canvas and WebGL for rendering.
// getHTMLElement() returns jQuery object with the canvas used for rendering.
// Before use, this view should be bound with a heatmap texture using bindHeapmapTexture(heatmap_tex).
// To render the heatmap use renderHeatmapTexture() method.
// Set size of the heatmap using CSS rules.
define('energy2d/views/heatmap-webgl',['require','energy2d/gpu/context','energy2d/gpu/texture','energy2d/gpu/shader','energy2d/gpu/mesh','energy2d/views/color-palette','text!energy2d/views/heatmap-webgl-glsl/basic.vs.glsl','text!energy2d/views/heatmap-webgl-glsl/temp-renderer.fs.glsl'],function (require) {
  'use strict';
  var
    // Dependencies.
    context      = require('energy2d/gpu/context'),
    Texture      = require('energy2d/gpu/texture'),
    Shader       = require('energy2d/gpu/shader'),
    Mesh         = require('energy2d/gpu/mesh'),
    ColorPalette = require('energy2d/views/color-palette'),
    // Shader sources.
    basic_vs         = require('text!energy2d/views/heatmap-webgl-glsl/basic.vs.glsl'),
    temp_renderer_fs = require('text!energy2d/views/heatmap-webgl-glsl/temp-renderer.fs.glsl');

  return function HeatmapWebGLView(html_id) {
    var
      // Get WebGL context.
      gl = context.getWebGLContext(),
      // GLSL Render program.
      render_program = new Shader(basic_vs, temp_renderer_fs),
      // Plane used for rendering.
      plane = Mesh.plane({ coords: true }),
      // Color palette texture (init later).
      palette_tex,

      DEFAULT_ID = 'energy2d-heatmap-webgl-view',

      $heatmap_canvas,
      canvas_width,
      canvas_height,

      heatmap_tex,
      min_temp = 0,
      max_temp = 50,

      //
      // Private methods.
      //
      initHTMLelement = function () {
        $heatmap_canvas = $(gl.canvas);
        $heatmap_canvas.attr('id', html_id || DEFAULT_ID);
      },

      // Make sure that no FBO is bound and viewport has proper dimensions
      // (it's not obvious as this context is also used for GPGPU calculations).
      setupRenderTarget = function () {
        // Ensure that FBO is null, as GPGPU operations which use FBOs also take place.
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        // This is necessary, as GPGPU operations can modify viewport size.
        gl.viewport(0, 0, canvas_width, canvas_height);
      },

      //
      // Public API.
      //
      heatmap_view = {
        // Render heat map on the canvas.
        renderHeatmap: function () {

          if (!heatmap_tex) {
            throw new Error("Heatmap: bind heatmap texture before rendering.");
          }

          setupRenderTarget();

          gl.clear(gl.COLOR_BUFFER_BIT);
          heatmap_tex.bind(0);
          palette_tex.bind(1);
          render_program.draw(plane);
          palette_tex.unbind(1);
          heatmap_tex.unbind(0);
        },

        resize: function () {
          canvas_width = $heatmap_canvas.width();
          canvas_height = $heatmap_canvas.height();
          $heatmap_canvas.attr('width', canvas_width);
          $heatmap_canvas.attr('height', canvas_height);
        },

        // Bind heatmap to the view.
        bindHeatmapTexture: function (new_heatmap_tex) {
          heatmap_tex = new_heatmap_tex;
        },

        getHTMLElement: function () {
          return $heatmap_canvas;
        },

        setMinTemperature: function (v) {
          min_temp = v;
          render_program.uniforms({
            min_temp: min_temp
          });
        },
        setMaxTemperature: function (v) {
          max_temp = v;
          render_program.uniforms({
            max_temp: max_temp
          });
        },
        setColorPalette: function (id) {
          var rgb_array, len, tex_data, i, i4;
          rgb_array = new ColorPalette(id).getRGBArray();
          len = rgb_array.length;
          tex_data = new Uint8Array(len * 4);
          for (i = 0; i < len; i += 1) {
            i4 = i * 4;
            tex_data[i4]     = rgb_array[i][0];
            tex_data[i4 + 1] = rgb_array[i][1];
            tex_data[i4 + 2] = rgb_array[i][2];
            tex_data[i4 + 3] = 255;
          }
          palette_tex = new Texture(len, 1, { type: gl.UNSIGNED_BYTE, format: gl.RGBA, filter: gl.LINEAR });
          gl.bindTexture(gl.TEXTURE_2D, palette_tex.id);
          gl.texImage2D(gl.TEXTURE_2D, 0, palette_tex.format, len, 1, 0, palette_tex.format, palette_tex.type, tex_data);
        }
      };

    // One-off initialization.
    // Set the default color palette.
    heatmap_view.setColorPalette('DEFAULT');
    // Set render program uniforms.
    render_program.uniforms({
      // Texture units.
      heatmap_tex: 0,
      palette_tex: 1,
      // Uniforms.
      min_temp: min_temp,
      max_temp: max_temp
    });
    // Setup texture coordinates.
    plane.coords = [[1, 0], [1, 1], [0, 0], [0, 1]];
    // Update buffers.
    plane.compile();

    initHTMLelement();

    return heatmap_view;
  };
});

/*global define: false, $: false*/

// WebGL Status.
// Presents available WebGL features.
//
// getHTMLElement() method returns JQuery object with DIV that contains status.

define('energy2d/views/webgl-status',['require','common/controllers/checkbox-controller','energy2d/gpu/gpgpu'],function (require) {
  'use strict';
  var
    // Dependencies.
    CheckboxController = require('common/controllers/checkbox-controller'),
    gpgpu              = require('energy2d/gpu/gpgpu'),

    GET_WEBGL = '<p><a href="http://get.webgl.org" target="_blank">Click to learn more about WebGL.</a></p>';

  return function WebGLStatusView(html_id) {
    var
      DEFAULT_ID = 'e2d-webgl-status',

      $div,
      $webgl_icon,
      $status_wrapper,
      $status,

      webgl_checkbox = new CheckboxController({
        "type": "checkbox",
        "id": "webgl-status-checkbox",
        "text": "WebGL-accelerated physics engine",
        "property": "use_WebGL"
      }),
      $checkbox = webgl_checkbox.getViewContainer(),

      // Energy2D modeler.
      energy2d_modeler,

      //
      // Private methods.
      //
      initHTMLelement = function () {
        var $closeBtn;

        $div = $('<div />');
        $div.attr('id', html_id || DEFAULT_ID);
        $status_wrapper = $('<div id="status-wrapper"/>');
        $status_wrapper.appendTo($div);
        $status = $('<div />');
        $status.appendTo($status_wrapper);

        $closeBtn = $('<a id="hide-webgl-status" class="button"><i class="icon-remove"></i></a>');
        $closeBtn.on('click', hide);
        $closeBtn.appendTo($status_wrapper);

        $checkbox.appendTo($status_wrapper);

        $webgl_icon = $('<a id="show-webgl-status" class="button"><i class="icon-bolt"></i></a>');
        $webgl_icon.on('click', show);
        $webgl_icon.appendTo($div);

        $status_wrapper.hide();
      },

      show = function () {
        $webgl_icon.hide();
        $status_wrapper.fadeIn();
      },

      hide = function () {
        $webgl_icon.fadeIn();
        $status_wrapper.fadeOut();
      },

      //
      // Public API.
      //
      WebGL_status_view = {
        bindModel: function (model) {
          energy2d_modeler = model;
          // Actually this function should be named 'bindModel(model)'.
          webgl_checkbox.modelLoadedCallback();
        },

        render: function () {
          var modelCompatible = energy2d_modeler.isWebGLCompatible(),
              feature = gpgpu.featuresInfo,
              requiredFeatures = true,
              optionalFeatures = true,
              initError = energy2d_modeler.properties.use_WebGL && !energy2d_modeler.isWebGLActive(),
              content;

          $status.empty();

          Object.keys(feature).forEach(function (name) {
            var f = feature[name];
            if (f.required && !f.available) {
              requiredFeatures = false;
            }
            if (!f.required && !f.available) {
              optionalFeatures = false;
            }
          });

          // WebGL + required extensions availability message.
          if (requiredFeatures && optionalFeatures) {
            $status.append('<p>Your browser <span class="happy">supports</span> WebGL as well as all required and optional extensions!</p>');
          } else if (requiredFeatures) {
            $status.append('<p>Your browser <span class="happy">supports</span> WebGL and all required extensions! However some ' +
                           'optional extensions are unavailable:</p>');
            Object.keys(feature).forEach(function (name) {
              var f = feature[name],
                  supported;
              if (!f.required) {
                supported = f.available ? '<span class="happy"><i class="icon-ok"></i></span>' : '<span class="sad"><i class="icon-remove"></i></span>';
                $status.append('<p class="extension">' + supported + ' ' + name + '</p>');
              }
            });
            $status.append('<p>WebGL rendering quality can be affected.</p>');
          } else if (feature['WebGL']) {
            $status.append('<p>Your browser <span class="happy">supports</span> WebGL, however not all required extensions are available:</p>');
            Object.keys(feature).forEach(function (name) {
              var f = feature[name],
                  supported;
              if (f.required) {
                supported = f.available ? '<span class="happy"><i class="icon-ok"></i></span>' : '<span class="sad"><i class="icon-remove"></i></span>';
                $status.append('<p class="extension">' + supported + ' ' + name + '</p>');
              }
            });
            $status.append(GET_WEBGL);
          } else {
            $status.append('<p>Sorry, your browser <span class="sad">does not support</span> WebGL.');
            $status.append(GET_WEBGL);
          }

          // Model compatibility message.
          if (modelCompatible) {
            content = 'This model is <span class="happy">compatible</span> with WebGL-accelerated physics engine';
            if (energy2d_modeler.isWebGLActive()) {
              content += ' and it is <span class="happy">active</span>.';
            } else {
              content += ', but it is <span class="sad">inactive</span>.';
              if (initError) {
                content += ' Unfortunately, its initialization <span class="sad">failed</span>. Check the browser console for details.';
              } else if (requiredFeatures) {
                content += ' Enable it to speed up simulation:';
              }
            }
            $status.append('<p>' + content + '</p>');
          } else {
            $status.append('<p>Unfortunately, some features used in this model are <span class="sad">incompatible</span> ' +
                           'with WebGL-accelerated physics engine.</p>');
          }

          // WebGL solvers checkbox.
          if (!requiredFeatures || !modelCompatible || initError) {
            // If any test failed hide the checkbox.
            $checkbox.hide();
          } else {
            $checkbox.show();
          }

          // WebGL icon tooltip message and color.
          if (initError) {
            content = 'WebGL initialization failed.';
            $webgl_icon.removeClass("happy");
            $webgl_icon.addClass("sad");
          } else if (!requiredFeatures || !modelCompatible) {
            content = 'WebGL unavailable.';
            $webgl_icon.removeClass("happy");
            $webgl_icon.addClass("sad");
          } else if (!energy2d_modeler.isWebGLActive()) {
            content = 'WebGL available, but inactive.';
            $webgl_icon.removeClass("happy");
            $webgl_icon.removeClass("sad");
          } else {
            content = 'WebGL available and active.';
            $webgl_icon.removeClass("sad");
            $webgl_icon.addClass("happy");
          }
          content += ' Click for detailed information.';
          $webgl_icon.attr('title', content);

          if (initError) {
            // Display panel when user requested WebGL, but it wasn't
            // initialized correctly.
            show();
          }
        },

        getHTMLElement: function () {
          return $div;
        }
      };

    // One-off initialization.
    initHTMLelement();

    return WebGL_status_view;
  };
});

/*jslint indent: 2, browser: true, newcap: true */
/*globals define: false, $: false*/

// Vector map view.
//
// It uses HTML5 Canvas for rendering.
// getHTMLElement() returns jQuery object with canvas used for rendering.
// Before use, this view should be bound with the vector map using bindVectormap(vectormap_u, vectormap_v, width, height, spacing).
// To render vector map use renderVectormap() method.
// Set size of the vectormap using CSS rules. The view fits canvas dimensions to the real
// size of the HTML element to avoid low quality CSS scaling.

define('energy2d/views/vectormap',[],function () {
  'use strict';

  return function VectormapView(html_id) {
    var
      DEFAULT_ID = 'energy2d-vectormap-view',
      VECTOR_SCALE = 100,
      VECTOR_BASE_LEN = 8,
      WING_COS = Math.cos(0.523598776),
      WING_SIN = Math.sin(0.523598776),
      WING_LEN = 4,
      ARROW_COLOR = "rgb(175,175,175)",

      $vectormap_canvas,
      canvas_ctx,
      canvas_width,
      canvas_height,

      vectormap_u,
      vectormap_v,
      grid_width,
      grid_height,
      spacing,

      enabled = true,

      //
      // Private methods.
      //
      initHTMLelement = function () {
        $vectormap_canvas = $('<canvas />');
        $vectormap_canvas.attr('id', html_id || DEFAULT_ID);
        canvas_ctx = $vectormap_canvas[0].getContext('2d');
      },

      // Helper method for drawing a single vector.
      drawVector = function (x, y, vx, vy) {
        var
          r = 1.0 / Math.sqrt(vx * vx + vy * vy),
          arrowx = vx * r,
          arrowy = vy * r,
          x1 = x + arrowx * VECTOR_BASE_LEN + vx * VECTOR_SCALE,
          y1 = y + arrowy * VECTOR_BASE_LEN + vy * VECTOR_SCALE,
          wingx = WING_LEN * (arrowx * WING_COS + arrowy * WING_SIN),
          wingy = WING_LEN * (arrowy * WING_COS - arrowx * WING_SIN);

        canvas_ctx.beginPath();
        canvas_ctx.moveTo(x, y);
        canvas_ctx.lineTo(x1, y1);

        canvas_ctx.lineTo(x1 - wingx, y1 - wingy);
        canvas_ctx.moveTo(x1, y1);

        wingx = WING_LEN * (arrowx * WING_COS - arrowy * WING_SIN);
        wingy = WING_LEN * (arrowy * WING_COS + arrowx * WING_SIN);
        canvas_ctx.lineTo(x1 - wingx, y1 - wingy);

        canvas_ctx.stroke();
      },

      //
      // Public API.
      //
      vectormap_view = {
        // Render vectormap on the canvas.
        renderVectormap: function () {
          if (!enabled) return;

          var
            dx, dy, x0, y0, uij, vij,
            i, j, iny, ijny;

          if (!vectormap_u || !vectormap_v) {
            throw new Error("Vectormap: bind vectormap before rendering.");
          }

          dx = canvas_width / grid_width;
          dy = canvas_height / grid_height;

          canvas_ctx.clearRect(0, 0, canvas_width, canvas_height);
          canvas_ctx.strokeStyle = ARROW_COLOR;
          canvas_ctx.lineWidth = 1;

          for (i = 1; i < grid_width - 1; i += spacing) {
            iny = i * grid_height;
            x0 = (i + 0.5) * dx; // + 0.5 to move arrow into field center
            for (j = 1; j < grid_height - 1; j += spacing) {
              ijny = iny + j;
              y0 = (j + 0.5) * dy; // + 0.5 to move arrow into field center
              uij = vectormap_u[ijny];
              vij = vectormap_v[ijny];
              if (uij * uij + vij * vij > 1e-15) {
                drawVector(x0, y0, uij, vij);
              }
            }
          }
        },

        clear: function () {
          canvas_ctx.clearRect(0, 0, canvas_width, canvas_height);
        },

        get enabled() {
          return enabled;
        },
        set enabled(v) {
          enabled = v;
          // Clear vectormap, as .renderVectormap() call won't do it.
          if (!enabled) vectormap_view.clear();
        },

        // Bind vector map to the view.
        bindVectormap: function (new_vectormap_u, new_vectormap_v, new_grid_width, new_grid_height, arrows_per_row) {
          if (new_grid_width * new_grid_height !== new_vectormap_u.length) {
            throw new Error("Heatmap: provided U component of vectormap has wrong dimensions.");
          }
          if (new_grid_width * new_grid_height !== new_vectormap_v.length) {
            throw new Error("Heatmap: provided V component of vectormap has wrong dimensions.");
          }
          vectormap_u = new_vectormap_u;
          vectormap_v = new_vectormap_v;
          grid_width = new_grid_width;
          grid_height = new_grid_height;
          spacing = Math.round(new_grid_width / arrows_per_row);
        },

        getHTMLElement: function () {
          return $vectormap_canvas;
        },

        resize: function () {
          canvas_width = $vectormap_canvas.width();
          canvas_height = $vectormap_canvas.height();
          $vectormap_canvas.attr('width', canvas_width);
          $vectormap_canvas.attr('height', canvas_height);
        }
      };

    // One-off initialization.
    initHTMLelement();

    return vectormap_view;
  };
});

define('text!energy2d/views/vectormap-webgl-glsl/vectormap.vs.glsl',[],function () { return '// Provided texture contains vector data in RG channels.\nattribute vec2 origin;\n\nuniform sampler2D vectormap_tex;\nuniform float base_length;\nuniform float vector_scale;\nuniform vec2 scale;\n\nvoid main() {\n  // Read vector which should be visualized.\n  vec2 vec = texture2D(vectormap_tex, gl_TexCoord.xy).xy;\n  vec.y = -vec.y;\n\n  if (length(vec) < 1e-15) {\n    // Do not draw to small vectors.\n    // Set position outside [-1, 1] region, which is rendered.\n    gl_Position = vec4(2.0);\n    return;\n  }\n\n  // Test which part of the vector arrow is being processed. \n  if (gl_Vertex.x == 0.0 && gl_Vertex.y == 0.0) {\n    // Origin of the arrow is being processed.\n    // Just transform its coordinates.\n    gl_Position = vec4(origin, 0.0, 1.0);\n  } else {\n    // Other parts of arrow are being processed.\n    // Set proper length of the arrow, rotate it, scale\n    // and finally transform.\n\n    // Calculate arrow length.\n    vec2 new_pos = gl_Vertex.xy;\n    new_pos.x += base_length + vector_scale * length(vec);\n\n    // Calculate angle between reference arrow (horizontal).\n    vec = normalize(vec);\n    float angle = acos(dot(vec, vec2(1.0, 0.0)));\n    if (vec.y < 0.0) {\n      angle = -angle;\n    }\n    // Prepare rotation matrix.\n    // See: http://en.wikipedia.org/wiki/Rotation_matrix\n    mat2 rot_m = mat2(\n      cos(angle), sin(angle),\n     -sin(angle), cos(angle)\n    );\n    // Rotate.\n    new_pos = rot_m * new_pos;\n    // Scale.\n    new_pos = new_pos * scale;\n    // Transform.\n    gl_Position = vec4(new_pos + origin, 0.0, 1.0);\n  }\n}\n';});

define('text!energy2d/views/vectormap-webgl-glsl/vectormap.fs.glsl',[],function () { return 'uniform vec4 color;\n\nvoid main() {\n  gl_FragColor = color;\n}\n';});

/*global define: false, $: false*/

// Vectormap WebGL view.
//
// It uses HTML5 Canvas and WebGL for rendering.
// getHTMLElement() returns jQuery object with the canvas used for rendering.
// Before use, this view should be bound with a heatmap texture using bindHeapmapTexture(vectormap_tex).
// To render the heatmap use renderVectormapTexture() method.
// Set size of the heatmap using CSS rules.

define('energy2d/views/vectormap-webgl',['require','energy2d/gpu/context','energy2d/gpu/shader','energy2d/gpu/mesh','text!energy2d/views/vectormap-webgl-glsl/vectormap.vs.glsl','text!energy2d/views/vectormap-webgl-glsl/vectormap.fs.glsl'],function (require) {
  'use strict';
  var
    // Dependencies.
    context = require('energy2d/gpu/context'),
    Shader  = require('energy2d/gpu/shader'),
    Mesh    = require('energy2d/gpu/mesh'),
    // Shader sources. One of Lab build steps converts sources to the JavaScript file.
    vectormap_vs = require('text!energy2d/views/vectormap-webgl-glsl/vectormap.vs.glsl'),
    vectormap_fs = require('text!energy2d/views/vectormap-webgl-glsl/vectormap.fs.glsl');

  return function VectormapWebGLView(html_id) {
    var
      // Get WebGL context.
      gl = context.getWebGLContext(),
      // GLSL Render program.
      render_program = new Shader(vectormap_vs, vectormap_fs),
      // Plane used for rendering.
      arrows = new Mesh({ coords: true, lines: true }),

      DEFAULT_ID = 'energy2d-vectormap-webgl-view',
      VECTOR_SCALE = 100,
      VECTOR_BASE_LEN = 8,
      ARROW_COLOR = [0.7, 0.7, 0.7, 1.0],

      $vectormap_canvas,
      canvas_width,
      canvas_height,

      vectormap_tex,
      grid_width,
      grid_height,
      spacing,

      enabled = true,

      //
      // Private methods.
      //
      initGeometry = function () {
        var i, j, idx, origin, coord,
          gdx = 2.0 / grid_width,
          gdy = 2.0 / grid_height,
          tdx = 1.0 / grid_width,
          tdy = 1.0 / grid_height;

        arrows.addVertexBuffer('origins', 'origin');
        arrows.vertices = [];
        arrows.origins = [];
        arrows.coords = [];
        arrows.lines = [];

        idx = 0;
        for (i = 1; i < grid_width - 1; i += spacing) {
          for (j = 1; j < grid_height - 1; j += spacing) {
            // Base arrows vertices. Origin, front and two wings. The unit is pixel.
            // Base length is 0.01 px - just for convenience (it distinguish front of the arrows from the origin).
            arrows.vertices.push([0, 0, 0], [0.01, 0, 0], [-3, 2, 0], [-3, -2, 0]);
            // All of these vertices have to know which vector they are representing.
            origin = [-1.0 + (i + 0.5) * gdx, 1.0 - (j + 0.5) * gdy, 0];
            arrows.origins.push(origin, origin, origin, origin);
            // Texture coordinates.
            coord = [(j + 0.5) * tdy, (i + 0.5) * tdx];
            arrows.coords.push(coord, coord, coord, coord);
            // Draw three lines. From origin to the fron of the arrows + two wings.
            arrows.lines.push([idx, idx + 1], [idx + 1, idx + 2], [idx + 1, idx + 3]);
            idx += 4;
          }
        }
        // Update buffers.
        arrows.compile();
      },

      initHTMLelement = function () {
        $vectormap_canvas = $(gl.canvas);
        $vectormap_canvas.attr('id', html_id || DEFAULT_ID);
      },

      // Make sure that no FBO is bound and viewport has proper dimensions
      // (it's not obvious as this context is also used for GPGPU calculations).
      setupRenderTarget = function () {
        // Ensure that FBO is null, as GPGPU operations which use FBOs also take place.
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        // This is necessary, as GPGPU operations can modify viewport size.
        gl.viewport(0, 0, canvas_width, canvas_height);
      },

      //
      // Public API.
      //
      vectormap_view = {
        // Render heat map on the canvas.
        renderVectormap: function () {
          if (!enabled) return;

          if (!vectormap_tex) {
            throw new Error("Vectormap: bind heatmap texture before rendering.");
          }

          setupRenderTarget();

          vectormap_tex.bind(0);
          render_program.draw(arrows, gl.LINES);
          vectormap_tex.unbind(0);
        },

        get enabled() {
          return enabled;
        },
        set enabled(v) {
          enabled = v;
        },

        resize: function () {
          canvas_width = $vectormap_canvas.width();
          canvas_height = $vectormap_canvas.height();
          $vectormap_canvas.attr('width', canvas_width);
          $vectormap_canvas.attr('height', canvas_height);
          // Render ara has dimensions from -1.0 to 1.0, so its width/height is 2.0.
          render_program.uniforms({
            scale: [2.0 / canvas_width, 2.0 / canvas_height]
          });
        },

        // Bind vectormap to the view.
        bindVectormapTexture: function (new_vectormap_tex, new_grid_width, new_grid_height, arrows_per_row) {
          vectormap_tex = new_vectormap_tex;
          grid_width = new_grid_width;
          grid_height = new_grid_height;
          spacing = Math.round(grid_width / arrows_per_row);

          initGeometry();
        },

        getHTMLElement: function () {
          return $vectormap_canvas;
        }
      };

    // One-off initialization.
    // Set render program uniforms.
    render_program.uniforms({
      // Texture units.
      vectormap_tex: 0,
      // Uniforms.
      base_length: VECTOR_BASE_LEN,
      vector_scale: VECTOR_SCALE,
      color: ARROW_COLOR
    });

    initHTMLelement();

    return vectormap_view;
  };
});

/*global define: false, $: false*/

// Energy2D photons view.
//
// It uses HTML5 Canvas for rendering.
// getHTMLElement() returns jQuery object with canvas used for rendering.
// Before use, this view should be bound with the parts array using bindPhotonsArray(photons).
// To render parts use renderPhotons() method.
// Set size of the parts view using CSS rules. The view fits canvas dimensions to the real
// size of the HTML element to avoid low quality scaling.

define('energy2d/views/photons',[],function () {
  'use strict';

  return function PhotonsView(html_id) {
    var
      DEFAULT_ID = 'energy2d-photons-view',
      DEFAULT_CLASS = 'energy2d-photons-view',

      PHOTON_LENGTH = 10,

      $photons_canvas,
      canvas_ctx,
      canvas_width,
      canvas_height,

      photons,
      scale_x,
      scale_y,
      scene_width,
      scene_height,

      //
      // Private methods.
      //
      initHTMLelement = function () {
        $photons_canvas = $('<canvas />');
        $photons_canvas.attr('id', html_id || DEFAULT_ID);
        $photons_canvas.addClass(DEFAULT_CLASS);

        canvas_ctx = $photons_canvas[0].getContext('2d');
      },

      setCanvasStyle = function () {
        canvas_ctx.strokeStyle = "rgba(255,255,255,128)";
        canvas_ctx.lineWidth = 0.5;
      },

      //
      // Public API.
      //
      photons_view = {
        // Render vectormap on the canvas.
        renderPhotons: function () {
          var
            photon, sx, sy, r,
            i, len;

          if (!photons) {
            throw new Error("Photons view: bind parts array before rendering.");
          }

          canvas_ctx.clearRect(0, 0, canvas_width, canvas_height);
          for (i = 0, len = photons.length; i < len; i += 1) {
            photon = photons[i];

            sx = photon.x * scale_x;
            sy = photon.y * scale_y;
            r = 1 / Math.sqrt(photon.vx * photon.vx + photon.vy * photon.vy);

            canvas_ctx.beginPath();
            canvas_ctx.moveTo(sx, sy);
            canvas_ctx.lineTo(sx + PHOTON_LENGTH * photon.vx * r, sy + PHOTON_LENGTH * photon.vy * r);
            canvas_ctx.stroke();
          }
        },

        // Bind vector map to the view.
        bindPhotonsArray: function (new_photons, new_scene_width, new_scene_height) {
          photons = new_photons;
          scene_width = new_scene_width;
          scene_height = new_scene_height;
          scale_x = canvas_width / scene_width;
          scale_y = canvas_height / scene_height;
        },

        getHTMLElement: function () {
          return $photons_canvas;
        },

        resize: function () {
          canvas_width = $photons_canvas.width();
          canvas_height = $photons_canvas.height();
          scale_x = canvas_width / scene_width;
          scale_y = canvas_height / scene_height;
          $photons_canvas.attr('width', canvas_width);
          $photons_canvas.attr('height', canvas_height);
          setCanvasStyle();
        }
      };

    // One-off initialization.
    initHTMLelement();
    setCanvasStyle();

    return photons_view;
  };
});
/*global define: false, d3: false */

define('energy2d/views/parts',[],function () {

  // Classic version of Energy2D was rendering rectangles with small shift.
  // If we do the same then converted models look better.
  var E2D_XY_SHIFT = -1,
      E2D_DIM_SHIFT = 2;

  return function PartsView(SVGContainer, g) {
    var api,
        parts,

        m2px = SVGContainer.model2px,
        m2pxInv = SVGContainer.model2pxInv,

        shapeTest = {
          "rect":    function (d) { return d.shapeType === "rectangle" ? this : null; },
          "ellipse": function (d) { return d.shapeType === "ellipse" ? this : null; },
          "path": function (d) { return d.shapeType === "polygon" || d.shapeType === "ring" ? this : null; }
        },

        ringPathSpec = d3.svg.arc()
            .innerRadius(function (d) { return m2px(d.inner * 0.5); })
            .outerRadius(function (d) { return m2px(d.outer * 0.5); })
            .startAngle(0)
            .endAngle(Math.PI * 2),

        dragBehavior = (function () {
          var x, y, minX, maxX, minY, maxY, bbox;
          return d3.behavior.drag()
              .origin(function (d) {
                return {
                  x: m2px(d.x),
                  y: m2pxInv(d.y)
                };
              })
              .on("dragstart", function (d) {
                var rx, ry;
                if (d.draggable) {
                  x = y = null;
                  rx = m2px.range();
                  ry = m2pxInv.range();
                  minX = Math.min(rx[0], rx[1]);
                  maxX = Math.max(rx[0], rx[1]);
                  minY = Math.min(ry[0], ry[1]);
                  maxY = Math.max(ry[0], ry[1]);
                  bbox = this.getBBox();
                  bbox.x0 = bbox.x + 10;
                  bbox.y0 = bbox.y + 10;
                  bbox.x1 = bbox.x + bbox.width - 10;
                  bbox.y1 = bbox.y + bbox.height - 10;
                  d3.select(this).style("opacity", 0.7);
                }
              })
              .on("drag", function (d) {
                if (d.draggable) {
                  x = d3.event.x;
                  y = d3.event.y;
                  x -= Math.max(0, bbox.x0 + x - maxX) + Math.min(0, bbox.x1 + x - minX);
                  y -= Math.max(0, bbox.y0 + y - maxY) + Math.min(0, bbox.y1 + y - minY);
                  d3.select(this).attr("transform", "translate(" + x + "," + y + ")");
                }
              })
              .on("dragend", function (d) {
                if (d.draggable) {
                  d3.select(this).style("opacity", 1);
                  if (x !== null) { // no need to check 'y' too
                    d.x = m2px.invert(x);
                    d.y = m2pxInv.invert(y);
                  }
                }
              });
        }());

    function transform(d) { return "translate(" + m2px(d.x || 0) + "," + m2pxInv(d.y || 0) + ")"; }
    function width(d) { return m2px(d.width) + E2D_DIM_SHIFT; }
    function height(d) { return m2px(d.height) + E2D_DIM_SHIFT; }
    function rx(d) { return m2px(d.a * 0.5); }
    function ry(d) { return m2px(d.b * 0.5); }
    function visibility(d) { return d.visible ? "visible" : "hidden"; }
    function textureFill(d) { return d.texture ? "url(#texture-1)" : "none"; }
    function label(d) { return d.computeLabel(); }
    function dx() { return -this.getBBox().width / 2; }
    function fill(d) {
      if (!d.filled) return 'rgba(0, 0, 0, 0)';
      var color;
      if (d.color === "auto") {
        if (d.power > 0) {
          color = '#FFFF00';
        } else if (d.power < 0) {
          color = '#B0C4DE';
        } else if (d.constant_temperature) {
          // Heatmap will be visible.
          color = 'rgba(0, 0, 0, 0)';
        } else {
          color = "#999";
        }
      } else {
        // Typical color definition.
        color = d.color;
        // TODO: this should be done during XML->JSON conversion.
        if (!isNaN(parseInt(color, 16))) {
          while (color.length < 6) {
            color = '0' + color;
          }
          color = '#' + color;
        }
      }
      return color;
    }
    function polygonPathSpec(d) {
      var res = [],
          x = d.raw_x_coords,
          y = d.raw_y_coords,
          i, len;
      for (i = 0, len = x.length; i < len; i++) {
        res.push(m2px(x[i]));
        res.push(m2pxInv(y[i]));
      }
      return "M" + res.join(",") + "Z";
    }
    function pathSpec(d) {
      switch (d.shapeType ) {
      case "polygon":
        return polygonPathSpec(d);
      case "ring":
        return ringPathSpec(d);
      }
    }
    function xLabel (d) {
      var s = d.shapeType;
      return s === "rectangle" || s === "polygon" ? this.parentNode.firstElementChild.getBBox().width / 2 : 0;
    }
    function yLabel (d) {
      var s = d.shapeType;
      return s === "rectangle" || s === "polygon" ? this.parentNode.firstElementChild.getBBox().height / 2 : 0;
    }

    function generateTextures() {
      var p = g.append("defs").append("pattern")
          .attr("id", "texture-1")
          .attr("patternUnits", "userSpaceOnUse")
          .attr("x", 0)
          .attr("y", 0)
          .attr("width", "0.7em")
          .attr("height", "0.7em")
          .attr("viewBox", "0 0 16 16");
      p.append("path")
          .attr("class", "e2d-texture-path-shadow")
          .attr("d", "M0,0 L16,16 M-1,15 L1,17 M15,-1 L17,1");
      p.append("path")
          .attr("class", "e2d-texture-path")
          .attr("d", "M0,0 L16,16 M-1,15 L1,17 M15,-1 L17,1");
    }

    function renderShape(shape, enter, update) {
      enter = enter.select(shapeTest[shape]);
      enter.append(shape)
          .attr("class", "e2d-part-shape");
      enter.append(shape)
          .attr("class", "e2d-part-shape-outline")
          .attr("fill", textureFill);

      // Propagate data.
      update.select(".e2d-part-shape");
      update.select(".e2d-part-shape-outline");

      switch(shape) {
      case "rect":
        update.selectAll("rect")
            .attr("x", E2D_XY_SHIFT)
            .attr("y", E2D_XY_SHIFT)
            .attr("width", width)
            .attr("height", height);
        break;
      case "ellipse":
        update.selectAll("ellipse")
            .attr("rx", rx)
            .attr("ry", ry);
        break;
      case "path":
        update.selectAll("path")
            .attr("d", pathSpec);
        break;
      }
    }

    function renderLabels(enter, update) {
      enter.append("text")
          .attr("class", "e2d-part-label-shadow")
          .attr("dy", ".35em");
      enter.append("text")
          .attr("class", "e2d-part-label")
          .attr("dy", ".35em");

      // Propagate data.
      update.select(".e2d-part-label");
      update.select(".e2d-part-label-shadow");
      update.selectAll(".e2d-part-label, .e2d-part-label-shadow")
          .text(label)
          .attr("dx", dx)
          .attr("x", xLabel)
          .attr("y", yLabel);
    }

    // Public API.
    api = {
      renderParts: function () {
        if (!parts) return;

        var part, partEnter;

        part = g.selectAll(".e2d-part").data(parts);
        partEnter = part.enter().append("g")
            // "part" class is useful for onClick handles, so author
            // can call: onClick("part", function () { ... }).
            .attr("class", "e2d-part part");

        renderShape("rect", partEnter, part);
        renderShape("ellipse", partEnter, part);
        renderShape("path", partEnter, part);
        renderLabels(partEnter, part);

        partEnter.call(dragBehavior);

        part
            .attr("transform", transform);
        part.select(".e2d-part-shape")
            .attr("fill", fill)
            .style("visibility", visibility);

        part.exit().remove();
      },

      bindPartsArray: function (newParts) {
        parts = newParts;
      }
    };

    (function () {
      generateTextures();
    }());

    return api;
  };
});

/*global define: false, d3: false */

define('energy2d/views/sensors',[],function () {
  var TH_W = 2,
      TH_H = 4;

  return function SensorsView(SVGContainer, g) {
    var api,

        m2px = SVGContainer.model2px,
        m2pxInv = SVGContainer.model2pxInv,

        sensors,

        thermBg, // d3.selection
        thermReading, // d3.selection
        thermValScale = d3.scale.linear().clamp(true).domain([0, 50]).range([TH_H, 0]),

        anemoRot, // d3.selection

        heatFluxReading, // d3.selection

        dragBehavior = d3.behavior.drag()
            .origin(function (d) {
                return {
                  x: m2px(d.x),
                  y: m2pxInv(d.y)
                };
              })
            .on("drag", function (d) {
              d.x = m2px.invert(d3.event.x);
              d.y = m2pxInv.invert(d3.event.y);
            });

    function em(val) { return val + "%"; }
    function transform(d) { return "translate(" + m2px(d.x) + "," + m2pxInv(d.y) + ")"; }
    function labelDx() { return -this.getBBox().width / 2; }
    function labelText(d) { return d.label; }
    function readingText(d) { return d.value.toFixed(1) + " C"; }
    function bgHeight(d) { return em(thermValScale(d.value)); }

    function anemometerRotation(d) { return "rotate(" + d.value + ")"; }

    function heatFluxReadingText(d) { return d.value.toFixed(1) + " W/m"; }
    function heatFluxRot(d) { return "rotate(" + d.angle + ")"; }

    function measuringPoint(g) {
      g = g.append("g").attr("class", "e2d-measuring-point");
      g.append("line")
          .attr("x1", 0)
          .attr("y1", "-0.8%")
          .attr("x2", 0)
          .attr("y2", "0.8%");
      g.append("line")
          .attr("x1", "-0.8%")
          .attr("y1", 0)
          .attr("x2", "0.8%")
          .attr("y2", 0);
      g.append("circle")
          .attr("r", "0.8%");
    }

    function supportLabels(enter, update) {
      enter.append("text").attr("class", "e2d-sensor-reading-shadow");
      enter.append("text").attr("class", "e2d-sensor-reading");
      enter.append("text").attr("class", "e2d-sensor-label-shadow");
      enter.append("text").attr("class", "e2d-sensor-label");

      // Looks strange, but it propagates data from parent to labels.
      // .selectAll() doesn't do it. We can do it here, before rendering.
      // If labels don't exist yet, enter will propagate data. If they
      // exist, data binding will be updated.
      update.select(".e2d-sensor-label");
      update.select(".e2d-sensor-label-shadow");
      update.select(".e2d-sensor-reading");
      update.select(".e2d-sensor-reading-shadow");
    }

    function renderThermometers(data) {
      var update = g.selectAll(".e2d-sensor.thermometer").data(data.filter(function (d) {
            return d.type === "thermometer";
          })),
          enter = update.enter().append("g")
              .attr("class", "e2d-sensor sensor thermometer")
              .call(dragBehavior);
      supportLabels(enter, update);

      // Note that background and fill are inverted (background covers
      // fill). It's easier to change only height of background instead of
      // manipulating both Y coordinate and height of fill.
      enter.append("rect").attr("class", "e2d-thermometer-fill");
      enter.append("rect").attr("class", "e2d-thermometer-background");
      enter.call(measuringPoint);

      update.attr("transform", transform);
      update.select(".e2d-thermometer-fill")
        .attr("x", em(-0.5 * TH_W))
        .attr("y", em(-0.5 * TH_H))
        .attr("width", em(TH_W))
        .attr("height", em(TH_H));
      thermBg = update.select(".e2d-thermometer-background")
        .attr("x", em(-0.5 * TH_W))
        .attr("y", em(-0.5 * TH_H))
        .attr("width", em(TH_W))
        .attr("height", bgHeight);
      thermReading = update.selectAll(".e2d-sensor-reading, .e2d-sensor-reading-shadow")
        .text(readingText)
        .attr("y", em(-0.5 * TH_H))
        .attr("dy", "-.2em")
        .attr("dx", "-.7em");
      update.selectAll(".e2d-sensor-label, .e2d-sensor-label-shadow")
        .text(labelText)
        .attr("dx", labelDx)
        .attr("dy", "1em")
        .attr("y", em(0.5 * TH_H));

      update.exit().remove();
    }

    function renderAnemometer(data) {
      var update = g.selectAll(".e2d-sensor.anemometer").data(data.filter(function (d) {
            return d.type === "anemometer";
          })),
          enter = update.enter().append("g")
              .attr("class", "e2d-sensor sensor anemometer")
              .call(dragBehavior);
      supportLabels(enter, update);

      enter = enter
        .append("svg")
          .attr("class", "e2d-anemometer-shape")
          .attr("viewBox", "-50 -50 100 100")
          .attr("x", "-3%")
          .attr("y", "-3%")
          .attr("width", "6%")
          .attr("height", "6%")
        .append("g")
          .attr("class", "e2d-anemometer-rot");

      enter.append("path")
          .attr("d", "M-10,10 L0,50 L10,10 Z")
          .attr("transform", "rotate(0)");
      enter.append("path")
          .attr("d", "M-10,10 L0,50 L10,10 Z")
          .attr("transform", "rotate(120)");
      enter.append("path")
          .attr("d", "M-10,10 L0,50 L10,10 Z")
          .attr("transform", "rotate(240)");
      enter.append("circle")
          .attr("r", 12);

      update.attr("transform", transform);
      anemoRot = update.select(".e2d-anemometer-rot")
          .attr("transform", anemometerRotation);
      update.selectAll(".e2d-sensor-label, .e2d-sensor-label-shadow")
        .text(labelText)
        .attr("dx", labelDx)
        .attr("dy", "0.7em")
        .attr("y", "3%");

      update.exit().remove();
    }

    function renderHeatFluxSensors(data) {
      var update = g.selectAll(".e2d-sensor.heatFlux").data(data.filter(function (d) {
            return d.type === "heatFlux";
          })),
          enter = update.enter().append("g")
              .attr("class", "e2d-sensor sensor heatFlux")
              .call(dragBehavior);

      enter = enter.append("g")
          .attr("transform", heatFluxRot);
      enter.append("rect")
          .attr("class", "e2d-heatflux-shape")
          .attr("x", "-3%")
          .attr("y", "-1%")
          .attr("width", "6%")
          .attr("height", "2%");
      enter.append("svg")
          .attr("viewBox", "0 0 6 1")
          .attr("x", "-3%")
          .attr("y", "-1%")
          .attr("width", "6%")
          .attr("height", "2%")
        .append("path")
          .attr("class", "e2d-heatflux-pattern")
          .attr("d", "M0,0L1,1L2,0L3,1L4,0L5,1L6,0");
      enter.call(measuringPoint);

      supportLabels(enter, update);

      update.attr("transform", transform);
      heatFluxReading = update.selectAll(".e2d-sensor-reading, .e2d-sensor-reading-shadow")
        .text(heatFluxReadingText)
        .attr("y", "-1%")
        .attr("dy", "-.2em")
        .attr("dx", "-1.8em");
      update.selectAll(".e2d-sensor-label, .e2d-sensor-label-shadow")
        .text(labelText)
        .attr("dx", labelDx)
        .attr("dy", "0.9em")
        .attr("y", "1%");

      update.exit().remove();
    }

    // Public API.
    api = {
      update: function () {
        thermBg.attr("height", bgHeight);
        thermReading.text(readingText);
        anemoRot.attr("transform", anemometerRotation);
        heatFluxReading.text(heatFluxReadingText);
      },

      renderSensors: function () {
        if (!sensors) return;

        renderThermometers(sensors);
        renderAnemometer(sensors);
        renderHeatFluxSensors(sensors);
      },

      bindSensorsArray: function (newSensors) {
        sensors = newSensors;
      },

      setMinMaxTemp: function (min, max) {
        thermValScale.domain([min, max]);
      }
    };

    return api;
  };
});

/*global define: false, $: false */

define('energy2d/views/renderer',['require','energy2d/views/heatmap','energy2d/views/heatmap-webgl','energy2d/views/webgl-status','energy2d/views/vectormap','energy2d/views/vectormap-webgl','energy2d/views/photons','energy2d/views/parts','energy2d/views/sensors'],function(require) {
  var HeatmapView        = require('energy2d/views/heatmap'),
      HeatmapWebGLView   = require('energy2d/views/heatmap-webgl'),
      WebGLStatus        = require('energy2d/views/webgl-status'),
      VectormapView      = require('energy2d/views/vectormap'),
      VectormapWebGLView = require('energy2d/views/vectormap-webgl'),
      PhotonsView        = require('energy2d/views/photons'),
      PartsView          = require('energy2d/views/parts'),
      SensorsView        = require('energy2d/views/sensors');


  return function Renderer(SVGContainer) {
    var api,
        model,

        heatmap_view,
        velocity_view,
        photons_view,
        parts_view,
        sensors_view,
        webgl_status = new WebGLStatus(),
        $status = webgl_status.getHTMLElement(),
        $canvasCont = $("<div id='e2d-canvas-views'>"),
        cavasCount = 0,

        beforeSetup = true;

    function setAsNextLayer(view) {
      var $layer = view.getHTMLElement();

      $layer.css('width', '100%');
      $layer.css('height', '100%');
      $layer.css('position', 'absolute');
      $layer.css('top', 0);
      $layer.css('left', 0);
      $layer.css('z-index', cavasCount);
      cavasCount += 1;

      $canvasCont.append($layer);

      // Note that we SHOULD implement it in the following way:
      //
      // var $layer = view.getHTMLElement(),
      //     fo = g.append("foreignObject").attr({
      //       width: "100%",
      //       height: "100%"
      //     }).style({
      //       width: "100%",
      //       height: "100%"
      //     });
      // $layer.css('width', '100%');
      // if (!customHeight) $layer.css('height', '100%');
      // $layer.appendTo(fo);
      //
      // but foreignObject support is completely broken in Chrome (works fine in Firefox).
      // TODO: check if new version (30+?) fixes that.
    }

    function setupCavnasViews() {
      var props = model.properties;

      $canvasCont.empty();
      cavasCount = 0;
      // Use isWebGLActive() method, not use_WebGL property. The fact that
      // use_WebGL option is set to true doesn't mean that WebGL can be
      // initialized. It's only a preference.
      if (model.isWebGLActive()) {
        heatmap_view = new HeatmapWebGLView();
        velocity_view = new VectormapWebGLView();
        // Both VectormapWebGL and HeatmapWebGL use common canvas,
        // so it's enough to set it only once as the next layer.
        setAsNextLayer(velocity_view);
      } else {
        heatmap_view = new HeatmapView();
        setAsNextLayer(heatmap_view);
        velocity_view = new VectormapView();
        setAsNextLayer(velocity_view);
      }
      photons_view = new PhotonsView();
      setAsNextLayer(photons_view);

      // It must be called after attaching to parent node.
      heatmap_view.resize();
      velocity_view.resize();
      photons_view.resize();

      // Bind models to freshly created views.
      if (model.isWebGLActive()) {
        heatmap_view.bindHeatmapTexture(model.getTemperatureTexture());
        velocity_view.bindVectormapTexture(model.getVelocityTexture(), props.grid_width, props.grid_height, 25);
      } else {
        heatmap_view.bindHeatmap(model.getTemperatureArray(), props.grid_width, props.grid_height);
        velocity_view.bindVectormap(model.getUVelocityArray(), model.getVVelocityArray(), props.grid_width, props.grid_height, 25);
      }
      photons_view.bindPhotonsArray(model.getPhotonsArray(), props.model_width, props.model_height);
    }

    function setVisOptions () {
      var props = model.properties;
      velocity_view.enabled = props.velocity;
      heatmap_view.setMinTemperature(props.minimum_temperature);
      heatmap_view.setMaxTemperature(props.maximum_temperature);
      heatmap_view.setColorPalette(props.color_palette_type);
      sensors_view.setMinMaxTemp(props.minimum_temperature, props.maximum_temperature);
    }

    api = {
      getHeightForWidth: function(width) {
        return width * model.properties.grid_height / model.properties.grid_width;
      },

      setup: function () {
        beforeSetup = false;
        setupCavnasViews();

        parts_view.bindPartsArray(model.getPartsArray());
        sensors_view.bindSensorsArray(model.getSensorsArray());
        webgl_status.bindModel(model);
        setVisOptions();

        parts_view.renderParts();
        sensors_view.renderSensors();
        webgl_status.render();
        api.update();

        model.addPropertiesListener("use_WebGL", function() {
          setupCavnasViews();
          setVisOptions();
          webgl_status.render();
          api.update();
        });
        model.addPropertiesListener(["color_palette_type", "velocity",
                                     "minimum_temperature", "maximum_temperature"], function () {
          setVisOptions();
          api.update();
        });
        model.on('tick.view-update', api.update);
        model.on('partsChanged.view-update', function () {
          parts_view.renderParts();
        });
        model.on('sensorsChanged.view-update', function () {
          sensors_view.renderSensors();
        });
      },

      update: function () {
        if (beforeSetup) return;
        heatmap_view.renderHeatmap();
        velocity_view.renderVectormap();
        photons_view.renderPhotons();
        sensors_view.update();
      },

      resize: function () {
        // Ignore all resize() callbacks if view isn't already set up.
        if (beforeSetup) return;
        heatmap_view.resize();
        velocity_view.resize();
        photons_view.resize();
        parts_view.renderParts();
        sensors_view.renderSensors();
        api.update();
      },

      reset: function () {},

      setFocus: function () {
        if (model.get("enableKeyboardHandlers")) {
          this.$el.focus();
        }
      },

      bindModel: function(newModel) {
        model = newModel;
      }
    };

    (function() {
      // Instantiate SVG views.
      parts_view = new PartsView(SVGContainer, SVGContainer.viewport.append("g"));
      sensors_view = new SensorsView(SVGContainer, SVGContainer.viewport.append("g"));
      SVGContainer.$el.append($canvasCont);
      SVGContainer.$el.append($status);
    }());

    return api;
  };
});
/*global define: false, Lab: false, model: false, d3: false */

define('energy2d/benchmarks/benchmarks',[],function () {

  return function Benchmarks(controller) {

    var benchmarks = [
      {
        name: "commit",
        numeric: false,
        run: function(done) {
          var link = "<a href='"+Lab.version.repo.commit.url+"' class='opens-in-new-window' target='_blank'>"+Lab.version.repo.commit.short_sha+"</a>";
          if (Lab.version.repo.dirty) {
            link += " <i>dirty</i>";
          }
          done(link);
        }
      },
      {
        name: "just graphics (steps/s)",
        numeric: true,
        formatter: d3.format("5.1f"),
        run: function(done) {
          var elapsed, start, i;
          model.stop();
          model.properties.use_WebGL = false;
          start = +Date.now();
          i = 0;
          while (i++ < 100) {
            controller.modelContainer.update();
          }
          elapsed = Date.now() - start;
          done(100/elapsed*1000);
        }
      },
      {
        name: "model (steps/s)",
        numeric: true,
        formatter: d3.format("5.1f"),
        run: function(done) {
          var start, elapsed;
          model.stop();
          start = +Date.now();
          model.suppressEvents(function () {
            var i = 0;
            while (i++ < 50) {
              model.tick();
            }
          });
          elapsed = Date.now() - start;
          done(50/elapsed*1000);
        }
      },
      {
        name: "model+graphics (steps/s)",
        numeric: true,
        formatter: d3.format("5.1f"),
        run: function(done) {
          var start, elapsed, i;
          model.stop();
          model.properties.use_WebGL = false;
          start = +Date.now();
          i = 0;
          while (i++ < 50) {
            model.tick();
          }
          elapsed = Date.now() - start;
          done(50/elapsed*1000);
        }
      },
      {
        name: "model+graphics-webgl(steps/s)",
        numeric: true,
        formatter: d3.format("5.1f"),
        run: function(done) {
          var start, elapsed, i;
          model.stop();
          model.properties.use_WebGL = true;
          start = +Date.now();
          i = 0;
          while (i++ < 50) {
            model.tick();
          }
          elapsed = Date.now() - start;
          done(50/elapsed*1000);
        }
      },
      {
        name: "fps",
        numeric: true,
        formatter: d3.format("5.1f"),
        run: function(done) {
          // warmup
          model.properties.use_WebGL = false;
          model.start();
          setTimeout(function() {
            model.stop();
            var start = model.get('time');
            setTimeout(function() {
              // actual fps calculation
              model.start();
              setTimeout(function() {
                model.stop();
                var elapsedModelTime = model.get('time') - start;
                done( elapsedModelTime / (model.get('timeStepsPerTick') * model.get('timeStep')) / 2 );
              }, 2000);
            }, 100);
          }, 1000);
        }
      },
      {
        name: "fps-webgl",
        numeric: true,
        formatter: d3.format("5.1f"),
        run: function(done) {
          // warmup
          model.properties.use_WebGL = true;
          model.start();
          setTimeout(function() {
            model.stop();
            var start = model.get('time');
            setTimeout(function() {
              // actual fps calculation
              model.start();
              setTimeout(function() {
                model.stop();
                var elapsedModelTime = model.get('time') - start;
                done( elapsedModelTime / (model.get('timeStepsPerTick') * model.get('timeStep')) / 2 );
              }, 2000);
            }, 100);
          }, 1000);
        }
      },
      {
        name: "interactive",
        numeric: false,
        run: function(done) {
          done(window.location.pathname + window.location.hash);
        }
      }
    ];

    return benchmarks;

  };
});

/*global define: false, model: false */

define('energy2d/controllers/scripting-api',[],function () {

  return function MD2DScriptingAPI (api) {

    return {
      getTemperatureAt: function getTemperatureAt(x, y) {
        return model.getTemperatureAt(x, y);
      },

      getAverageTemperatureAt: function getAverageTemperatureAt(x, y) {
        return model.getAverageTemperatureAt(x, y);
      },

      getSensor: function getSensor(i) {
        return model.getSensorsArray()[i];
      },

      getPart: function getPart(i) {
        return model.getPartsArray()[i];
      },

      addPart: function addPart(props) {
        model.addPart(props);
      },

      removePart: function removePart(i) {
        model.removePart(i);
      },

      getNumberOfParts: function getNumberOfParts() {
        return model.getPartsArray().length;
      },

      syncTemperature: function syncTemperature() {
        model.syncTemperature();
      }
    };
  };
});

/*global define: false, d3: false, model: true */

define('energy2d/controllers/controller',['require','energy2d/modeler','common/views/svg-container','energy2d/views/renderer','energy2d/benchmarks/benchmarks','energy2d/controllers/scripting-api'],function (require) {
  // Dependencies.
  var Model          = require('energy2d/modeler'),
      SVGContainer   = require('common/views/svg-container'),
      Renderer       = require('energy2d/views/renderer'),
      Benchmarks     = require('energy2d/benchmarks/benchmarks'),
      ScriptingAPI   = require('energy2d/controllers/scripting-api');

  return function (modelUrl, modelOptions) {
    // Export model to global namespace;
    model = new Model(modelOptions);

    var api,
        dispatch = d3.dispatch('modelLoaded'),
        modelContainer = new SVGContainer(model, modelUrl, Renderer, {origin: 'top-left'}),
        benchmarks;

    api = {
      get type() {
        return "energy2d";
      },
      get benchmarks() {
        return benchmarks;
      },
      get modelUrl() {
        return modelUrl;
      },
      get modelContainer() {
        return modelContainer;
      },

      on: function(type, listener) {
        dispatch.on(type, listener);
      },

      getViewContainer: function () {
        return api.modelContainer.$el;
      },

      getHeightForWidth: function (width) {
        return api.modelContainer.getHeightForWidth(width);
      },

      resize: function () {
        api.modelContainer.resize();
      },

      repaint: function () {
        api.modelContainer.repaint();
      },

      enableKeyboardHandlers: function () {
        return true;
      },

      reload: function (newModelUrl, newModelOptions, suppressEvents) {
        api.modelUrl = newModelUrl || api.modelUrl;
        modelOptions = newModelOptions || modelOptions;

        model = new Model(modelOptions);
        api.modelContainer.bindModel(model);

        if (!suppressEvents) dispatch.modelLoaded();
      },

      modelInDOM: function () {
        api.modelContainer.setup();
      },

      state: function () {
        return model.serialize();
      },

      ScriptingAPI: ScriptingAPI
    };

    benchmarks = new Benchmarks(api);

    return api;
  };
});

/*global define, model, $, setTimeout, document, window */

define('common/controllers/interactives-controller',['require','lab.config','arrays','common/alert','common/controllers/interactive-metadata','common/validator','common/interactive-not-found','common/controllers/bar-graph-controller','common/controllers/graph-controller','common/controllers/export-controller','common/controllers/scripting-api','common/controllers/button-controller','common/controllers/checkbox-controller','common/controllers/text-controller','common/controllers/image-controller','common/controllers/radio-controller','common/controllers/slider-controller','common/controllers/pulldown-controller','common/controllers/numeric-output-controller','common/controllers/parent-message-api','common/controllers/thermometer-controller','common/controllers/playback-controller','common/controllers/div-controller','common/controllers/setup-banner','common/controllers/about-dialog','common/controllers/share-dialog','common/controllers/credits-dialog','common/layout/semantic-layout','common/layout/templates','md2d/controllers/controller','solar-system/controllers/controller','signal-generator/controller','sensor/controller','energy2d/controllers/controller'],function (require) {
  // Dependencies.
  var labConfig               = require('lab.config'),
      arrays                  = require('arrays'),
      alert                   = require('common/alert'),
      metadata                = require('common/controllers/interactive-metadata'),
      validator               = require('common/validator'),
      interactiveNotFound     = require('common/interactive-not-found'),
      BarGraphController      = require('common/controllers/bar-graph-controller'),
      GraphController         = require('common/controllers/graph-controller'),
      ExportController        = require('common/controllers/export-controller'),
      ScriptingAPI            = require('common/controllers/scripting-api'),
      ButtonController        = require('common/controllers/button-controller'),
      CheckboxController      = require('common/controllers/checkbox-controller'),
      TextController          = require('common/controllers/text-controller'),
      ImageController         = require('common/controllers/image-controller'),
      RadioController         = require('common/controllers/radio-controller'),
      SliderController        = require('common/controllers/slider-controller'),
      PulldownController      = require('common/controllers/pulldown-controller'),
      NumericOutputController = require('common/controllers/numeric-output-controller'),
      ParentMessageAPI        = require('common/controllers/parent-message-api'),
      ThermometerController   = require('common/controllers/thermometer-controller'),
      PlaybackController      = require('common/controllers/playback-controller'),
      DivController           = require('common/controllers/div-controller'),

      // Helper function which just provides banner definition.
      setupBanner             = require('common/controllers/setup-banner'),
      AboutDialog             = require('common/controllers/about-dialog'),
      ShareDialog             = require('common/controllers/share-dialog'),
      CreditsDialog           = require('common/controllers/credits-dialog'),
      SemanticLayout          = require('common/layout/semantic-layout'),
      templates               = require('common/layout/templates'),

      ModelControllerFor = {
        'md2d':             require('md2d/controllers/controller'),
        'solar-system':     require('solar-system/controllers/controller'),
        'signal-generator': require('signal-generator/controller'),
        'sensor':           require('sensor/controller'),
        'energy2d':         require('energy2d/controllers/controller')
      },

      // Set of available components.
      // - Key defines 'type', which is used in the interactive JSON.
      // - Value is a constructor function of the given component.
      // Each constructor should assume that it will be called with
      // following arguments:
      // 1. component definition (unmodified object from the interactive JSON),
      // 2. scripting API object,
      // 3. public API of the InteractiveController.
      // Of course, some of them can be passed unnecessarily, but
      // the InteractiveController follows this convention.
      //
      // The instantiated component should provide following interface:
      // # serialize()           - function returning a JSON object, which represents current state
      //                           of the component. When component doesn't change its state,
      //                           it should just return a copy (!) of the initial component definition.
      // # getViewContainer()    - function returning a jQuery object containing
      //                           DOM elements of the component.
      // # modelLoadedCallback() - optional function taking no arguments, a callback
      //                           which is called when the model is loaded.
      // # resize()              - optional function taking no arguments, a callback
      //                           which is called by the layout algorithm when component's container
      //                           dimensions are changed. This lets component to adjust itself to the
      //                           new container dimensions.
      //
      // Note that each components view container (so, jQuery object returned by getViewContainer() has to
      // have class 'component'! It's required and checked in the runtime by the interactive controller.
      // It ensures good practices while implementing new components.
      // Please see: src/sass/lab/_interactive-component.sass to check what this CSS class defines.
      ComponentConstructor = {
        'text':          TextController,
        'image':         ImageController,
        'button':        ButtonController,
        'checkbox':      CheckboxController,
        'pulldown':      PulldownController,
        'radio':         RadioController,
        'thermometer':   ThermometerController,
        'barGraph':      BarGraphController,
        'graph':         GraphController,
        'slider':        SliderController,
        'numericOutput': NumericOutputController,
        'div':           DivController,
        'playback':      PlaybackController
      };

  return function InteractivesController(interactiveReference, viewSelector) {

    var interactive = {},
        controller = {},
        modelController,
        $interactiveContainer,
        models = [],
        modelsHash = {},
        propertiesListeners = [],
        componentCallbacks = [],
        onLoadScripts = [],
        resizeCallbacks = [],
        modelLoadedCallbacks = [],

        // Hash of instantiated components.
        // Key   - component ID.
        // Value - array of component instances.
        componentByID = {},

        // Simple list of instantiated components.
        componentList = [],

        // List of custom parameters which are used by the interactive.
        customParametersByName = [],

        // API for scripts defined in the interactive JSON file.
        scriptingAPI,

        // additional model-specific scripting api
        modelScriptingAPI,

        // Handles exporting data to DataGames, if 'exports' are specified.
        exportController,

        // Doesn't currently have any public methods, but probably will.
        parentMessageAPI,

        // Dialogs which can be shown using banner.
        aboutDialog,
        shareDialog,
        creditsDialog,

        semanticLayout,
        getNextTabIndex;


    // simple tabindex support, also exposed via api.getNextTabIndex()
    getNextTabIndex = (function () {
      var tabIndex = -1;
      return function() {
        return tabIndex++;
      };
    });

    function getModel(modelId) {
      if (modelsHash[modelId]) {
        return modelsHash[modelId];
      }
      throw new Error("No model found with id "+modelId);
    }

    /**
      Load the model from the model definitions hash.
      'modelLoaded' is called after the model loads.

      @param: modelId.
      @optionalParam modelObject
    */
    function loadModel(modelId, modelConfig) {
      var modelDefinition = getModel(modelId),
          interactiveViewOptions,
          interactiveModelOptions;

      controller.currentModel = modelDefinition;

      if (modelDefinition.viewOptions) {
        // Make a deep copy of modelDefinition.viewOptions, so we can freely mutate interactiveViewOptions
        // without the results being serialized or displayed in the interactives editor.
        interactiveViewOptions = $.extend(true, {}, modelDefinition.viewOptions);
      } else {
        interactiveViewOptions = { controlButtons: 'play' };
      }

      onLoadScripts = [];
      if (modelDefinition.onLoad) {
        onLoadScripts.push( scriptingAPI.makeFunctionInScriptContext( getStringFromArray(modelDefinition.onLoad) ) );
      }

      if (modelDefinition.modelOptions) {
        // Make a deep copy of modelDefinition.modelOptions.
        interactiveModelOptions = $.extend(true, {}, modelDefinition.modelOptions);
      }

      if (modelConfig) {
        finishWithLoadedModel(modelDefinition.url, modelConfig);
      } else {
        if (modelDefinition.url) {
          $.get(labConfig.actualRoot + modelDefinition.url).done(function(modelConfig) {
            // Deal with the servers that return the json as text/plain
            modelConfig = typeof modelConfig === 'string' ? JSON.parse(modelConfig) : modelConfig;
            finishWithLoadedModel(modelDefinition.url, modelConfig);
          }).fail(function() {
            modelConfig = {
              "type": "md2d",
              "width": 2.5,
              "height": 1.5,
              "viewOptions": {
                "backgroundColor": "rgba(245,200,200,255)",
                "showClock": false,
                "textBoxes": [
                  {
                    "text": "Model could not be loaded:",
                    "x": 0.0,
                    "y": 1.0,
                    "width": 2.5,
                    "height": 0.25,
                    "fontScale": 1.4,
                    "layer": 1,
                    "frame": "rectangle",
                    "textAlign": "center",
                    "strokeOpacity": 0,
                    "backgroundColor": "rgb(232,231,231)"
                  },
                  {
                    "text": modelDefinition.url,
                    "x": 0.0,
                    "y": 0.8,
                    "width": 2.5,
                    "height": 0.25,
                    "fontScale": 0.9,
                    "layer": 1,
                    "frame": "rectangle",
                    "textAlign": "center",
                    "strokeOpacity": 0,
                    "backgroundColor": "rgb(232,231,231)"
                  }
                ]
              }
            };
            finishWithLoadedModel(modelDefinition.url, modelConfig);
          });
        } else {
          modelConfig = modelDefinition.model;
          finishWithLoadedModel("", modelConfig);
        }
      }

      function processOptions(modelConfig, interactiveModelConfig, interactiveViewConfig) {
        var modelOptions,
            viewOptions;

        function meldOptions (base, overlay) {
          var p;
          for(p in base) {
            if (overlay[p] === undefined) {
              if (arrays.isArray(base[p])) {
                // Array.
                overlay[p] = $.extend(true, [], base[p]);
              } else if (typeof base[p] === "object") {
                // Object.
                overlay[p] = $.extend(true, {}, base[p]);
              } else {
                // Basic type.
                overlay[p] = base[p];
              }
            } else if (typeof overlay[p] === "object" && !(overlay[p] instanceof Array)) {
              overlay[p] = meldOptions(base[p], overlay[p]);
            }
          }
          return overlay;
        }

        // 1. Process view options.
        // Do not modify initial configuration.
        viewOptions = $.extend(true, {}, interactiveViewConfig);
        // Merge view options defined in interactive (interactiveViewConfig)
        // with view options defined in the basic model description.
        viewOptions = meldOptions(modelConfig.viewOptions || {}, viewOptions);

        // 2. Process model options.
        // Do not modify initial configuration.
        modelOptions = $.extend(true, {}, interactiveModelConfig);
        // Merge model options defined in interactive (interactiveModelConfig)
        // with the basic model description.
        modelOptions = meldOptions(modelConfig || {}, modelOptions);

        // Update view options in the basic model description after merge.
        // Note that many unnecessary options can be passed to Model constructor
        // because of that (e.g. view-only options defined in the interactive).
        // However, all options which are unknown for Model will be discarded
        // during options validation, so this is not a problem
        // (but significantly simplifies configuration).
        modelOptions.viewOptions = viewOptions;

        return modelOptions;
      }

      function finishWithLoadedModel(modelUrl, modelConfig) {
        var modelOptions = processOptions(modelConfig, interactiveModelOptions, interactiveViewOptions);

        if (modelController) {
          modelController.reload(modelUrl, modelOptions, true);
        } else {
          createModelController(modelConfig.type, modelUrl, modelOptions);
          // also be sure to get notified when the underlying model changes
          modelController.on('modelLoaded', modelLoaded);
          controller.modelController = modelController;
        }
        // This will attach model container to DOM.
        semanticLayout.setupModel(modelController);

        setupModelPlayerKeyboardHandler();
        // Setup model and notify observers that model was loaded.
        modelLoaded();

        // Layout interactive after modelLoaded() callback!
        semanticLayout.layoutInteractive();
      }

      function createModelController(type, modelUrl, modelOptions) {
        // set default model type to "md2d"
        var modelType = type || "md2d";

        if (ModelControllerFor[modelType] === null) {
          throw new Error("Couldn't understand modelType '" + modelType + "'!");
        }

        modelController = new ModelControllerFor[modelType](modelUrl, modelOptions, controller);

        // Extending universal Interactive scriptingAPI with model-specific scripting API
        if (modelController.ScriptingAPI) {
          scriptingAPI.extend(modelController.ScriptingAPI);
          scriptingAPI.exposeScriptingAPI();
        }
      }
    }

    // ------------------------------------------------------------
    //
    // Handle keyboard shortcuts for model operation.
    //
    // ------------------------------------------------------------

    function setupModelPlayerKeyboardHandler() {
      // Deregister previous keydown handlers. Use namespaces so the code
      // will not inadvertently remove event handlers attached by other code.
      $interactiveContainer.off('keydown.interactiveController');
      if (modelController && modelController.enableKeyboardHandlers()) {
        $interactiveContainer.on('keydown.interactiveController', function(event) {
          var keycode = event.keycode || event.which;
          switch(keycode) {
            case 13:                 // return
            event.preventDefault();
            scriptingAPI.api.start();
            break;

            case 32:                 // space
            event.preventDefault();
            if (!scriptingAPI.api.isStopped()) {
              scriptingAPI.api.stop();
            } else {
              scriptingAPI.api.start();
            }
            break;

            case 37:                 // left-arrow
            event.preventDefault();
            if (!scriptingAPI.api.isStopped()) {
              scriptingAPI.api.stop();
            } else {
              scriptingAPI.api.stepBack();
            }
            break;

            case 39:                 // right-arrow
            event.preventDefault();
            if (!scriptingAPI.api.isStopped()) {
              scriptingAPI.api.stop();
            } else {
              scriptingAPI.api.stepForward();
            }
            break;
          }
        });
        // $interactiveContainer.focus();
      }
    }

    function setupLayout() {
      var template, layout, comp, components, fontScale, banner, resizeAfterFullscreen;

      if (typeof interactive.template === "string") {
        template = templates[interactive.template];
      } else {
        template = interactive.template;
      }

      // The authored definition of which components go in which container.
      layout = interactive.layout;
      // Font scale which affect whole interactive container.
      fontScale = interactive.fontScale;

      // Banner hash containing components, layout containers and layout deinition
      // (components location). Keep it in a separate structure, because we do not
      // expect these objects to be serialized!
      banner = setupBanner(scriptingAPI, interactive, creditsDialog, aboutDialog, shareDialog);
      // Register callbacks of banner components.
      components = banner.components;
      for (comp in components) {
        if (components.hasOwnProperty(comp)) {
          comp = components[comp];
          if (comp.modelLoadedCallback) {
            // $.proxy ensures that callback will be always executed
            // in the context of correct object ('this' binding).
            componentCallbacks.push($.proxy(comp.modelLoadedCallback, comp));
          }
        }
      }
      // Note that all of these operations create a new object.
      // So interactive definition specified by the author won't be affected.
      // This is important for serialization correctness.
      template = banner.template.concat(template);
      layout = $.extend({}, layout, banner.layout);
      components = $.extend({}, componentByID, banner.components);

      // Setup layout using both author components and components
      // created automatically in this controller.
      semanticLayout.initialize(template, layout, components, fontScale);

      // We are rendering in embeddable mode if only element on page
      // so resize when window resizes.
      if (onlyElementOnPage()) {
        $(window).unbind('resize');
        $(window).on('resize', function() {
          controller.resize();
        });
      }

      // in all cases, call resize when entering and existing fullscreen
      resizeAfterFullscreen = function() {
        // need to call twice, as safari requires two attempts before it has
        // the correct dimensions.
        controller.resize();
        setTimeout(controller.resize, 50);
      };
      document.addEventListener("fullscreenchange", resizeAfterFullscreen, false);

      document.addEventListener("mozfullscreenchange", resizeAfterFullscreen, false);

      document.addEventListener("webkitfullscreenchange", resizeAfterFullscreen, false);
    }

    function createComponent(component) {
          // Get type and ID of the requested component from JSON definition.
      var type = component.type,
          id = component.id,
          comp;

      // Use an appropriate constructor function and create a new instance of the given type.
      // Note that we use constant set of parameters for every type:
      // 1. component definition (exact object from interactive JSON),
      // 2. scripting API object,
      // 3. public API of the InteractiveController.
      comp = new ComponentConstructor[type](component, scriptingAPI, controller);

      if (!comp.getViewContainer().hasClass("component")) {
        throw new Error("Invalid Interactive Component implementation. Each component has to have 'component' class.");
      }

      // Save the new instance.
      componentByID[id] = comp;
      componentList.push(comp);

      // Register component callback if it is available.
      if (comp.modelLoadedCallback) {
        // $.proxy ensures that callback will be always executed
        // in the context of correct object ('this' binding).
        componentCallbacks.push($.proxy(comp.modelLoadedCallback, comp));
      }
    }

    /**
      Generic function that accepts either a string or an array of strings,
      and returns the complete string
    */
    function getStringFromArray(str) {
      if (typeof str === 'string') {
        return str;
      }
      return str.join('\n');
    }

    /**
      Call this after the model loads, to process any queued resize and update events
      that depend on the model's properties, then draw the screen.
    */
    function modelLoaded() {
      var i, listener;

      setupCustomOutputs("basic", controller.currentModel.outputs, interactive.outputs);
      setupCustomParameters(controller.currentModel.parameters, interactive.parameters);
      // Setup filtered outputs after basic outputs and parameters, as filtered output require its input
      // to exist during its definition.
      setupCustomOutputs("filtered", controller.currentModel.filteredOutputs, interactive.filteredOutputs);

      modelController.modelInDOM();
      // Call component callbacks *when* the layout is created.
      // Some callbacks require that their views are already attached to the DOM, e.g. (bar graph uses
      //getBBox() which in Firefox works only when element is visible and rendered).
      for(i = 0; i < componentCallbacks.length; i++) {
        componentCallbacks[i]();
      }

      // setup messaging with embedding parent window
      parentMessageAPI = new ParentMessageAPI(model, modelController.modelContainer, controller);

      for(i = 0; i < propertiesListeners.length; i++) {
        listener = propertiesListeners[i];
        model.addPropertiesListener(listener[0], listener[1]);
      }

      for(i = 0; i < onLoadScripts.length; i++) {
        onLoadScripts[i]();
      }

      for(i = 0; i < modelLoadedCallbacks.length; i++) {
        modelLoadedCallbacks[i]();
      }
    }

    /**
      Validates interactive definition.

      Displays meaningful info in case of any errors. Also an exception is being thrown.

      @param interactive
        hash representing the interactive specification
    */
    function validateInteractive(interactive) {
      var i, len, models, model, components, errMsg;

      function validateArray(modelName, array) {
        var i, len, errMsg;
        // Support undefined / null values - just return.
        if (!array) return;

        try {
          for (i = 0, len = array.length; i < len; i++) {
            array[i] = validator.validateCompleteness(metadata[modelName], array[i]);
          }
        } catch (e) {
          errMsg = "Incorrect " + modelName +  " definition:\n" + e.message;
          alert(errMsg);
          throw new Error(errMsg);
        }
      }

      // Validate top level interactive properties.
      try {
        interactive = validator.validateCompleteness(metadata.interactive, interactive);
      } catch (e) {
        errMsg = "Incorrect interactive definition:\n" + e.message;
        alert(errMsg);
        throw new Error(errMsg);
      }

      validateArray("model", interactive.models);
      validateArray("parameter", interactive.parameters);
      validateArray("output", interactive.outputs);
      validateArray("filteredOutput", interactive.filteredOutputs);

      // Validate also nested strucutres.
      models = interactive.models;
      for (i = 0, len = models.length; i < len; i++) {
        model = models[i];
        validateArray("parameter", model.parameters);
        validateArray("output", model.outputs);
        validateArray("filteredOutput", model.filteredOutputs);
      }

      components = interactive.components;
      try {
        for (i = 0, len = components.length; i < len; i++) {
          components[i] = validator.validateCompleteness(metadata[components[i].type], components[i]);
        }
      } catch (e) {
        errMsg = "Incorrect " + components[i].type + " component definition:\n" + e.message;
        alert(errMsg);
        throw new Error(errMsg);
      }

      // Validate exporter, if any...
      if (interactive.exports) {
        try {
          interactive.exports = validator.validateCompleteness(metadata.exports, interactive.exports);
        } catch (e) {
          errMsg = "Incorrect exports definition:\n" + e.message;
          alert(errMsg);
          throw new Error(errMsg);
        }
      }

      return interactive;
    }

    /**
      Is the Interactive the only element on the page?

      An Interactive can either be displayed as the only content on a page
      (often in an iframe) or in a dom element on a page with other elements.

      TODO: make more robust
      This function makes a simplifying assumption that the Interactive is the
      only content on the page if the parent of the parent is the <body> element
    */
    function onlyElementOnPage() {
      return $interactiveContainer.parent().parent().prop("nodeName") === "BODY";
    }

    /**
      The main method called when this controller is created.

      Populates the element pointed to by viewSelector with divs to contain the
      molecule container (view) and the various components specified in the interactive
      definition, and

      @param newInteractive
        hash representing the interactive specification or string representing path or full url
    */
    function loadInteractive(newInteractive) {
      if (typeof newInteractive === "string") {
        $.get(newInteractive).done(function(results) {
          if (typeof results === 'string') results = JSON.parse(results);
          controller.interactive = results;
          finishLoadingInteractive();
        })
        .fail(function() {
          document.title = "Interactive not found";
          controller.interactive = interactiveNotFound(newInteractive);
          finishLoadingInteractive();
        });
      } else {
        // we were passed an interactive object
        controller.interactive = newInteractive
        finishLoadingInteractive();
      }
    }

    function finishLoadingInteractive() {
      var componentJsons,
          i, len;

      componentCallbacks = [];

      // Validate interactive.
      controller.interactive = validateInteractive(controller.interactive);
      interactive = controller.interactive;

      // Set up the list of possible models.
      models = interactive.models;
      for (i = 0, len = models.length; i < len; i++) {
        modelsHash[models[i].id] = models[i];
      }

      // Prepare interactive components.
      componentJsons = interactive.components || [];

      // Clear component instances.
      componentList = [];
      componentByID = {};

      for (i = 0, len = componentJsons.length; i < len; i++) {
        createComponent(componentJsons[i]);
      }

      // Setup exporter, if any...
      if (interactive.exports) {
        // Regardless of whether or not we are able to export data to an enclosing container,
        // setup export controller so you can debug exports by typing script.exportData() in the
        // console.
        exportController = new ExportController(interactive.exports);
        componentCallbacks.push(exportController.modelLoadedCallback);

        // If there is an enclosing container we can export data to (e.g., we're iframed into
        // DataGames) then add an "Analyze Data" button the bottom position of the interactive
        if (ExportController.isExportAvailable()) {
          createComponent({
            "type": "button",
            "text": "Analyze Data",
            "id": "-lab-analyze-data",
            "action": "exportData();"
          });
        }
      }

      // When all components are created, we can initialize semantic layout.
      setupLayout();

      // FIXME: I moved this after setupLayout() on the previous line
      // when I added the possiblity of including the model definition in the model
      // section of the Interactive. We were counting on the ajax get operation taking
      // long enough to not occur until after setupLayout() finished.
      //
      // But ... there is a performance issue, it makes sense to start the ajax request
      // for the model definition as soon as the Interactive Controller can.
      //
      // Load first model
      loadModel(models[0].id);
    }

    /**
      After a model loads, this method sets up the custom output properties specified in the "model"
      section of the interactive and in the interactive.

      Any output property definitions in the model section of the interactive specification override
      properties with the same that are specified in the main body if the interactive specification.

      @outputType - accept two values "basic" and "filtered", as this function can be used for processing
        both types of outputs.
    */
    function setupCustomOutputs(outputType, modelOutputs, interactiveOutputs) {
      if (!modelOutputs && !interactiveOutputs) return;

      var outputs = {},
          prop,
          output;

      function processOutputsArray(outputsArray) {
        if (!outputsArray) return;
        for (var i = 0; i < outputsArray.length; i++) {
          outputs[outputsArray[i].name] = outputsArray[i];
        }
      }

      // per-model output definitions override output definitions from interactives
      processOutputsArray(interactiveOutputs);
      processOutputsArray(modelOutputs);

      for (prop in outputs) {
        if (outputs.hasOwnProperty(prop)) {
          output = outputs[prop];
          // DOM elements (and, by analogy, Next Gen MW interactive components like slides)
          // have "ids". But, in English, properties have "names", but not "ids".
          switch (outputType) {
            case "basic":
              model.defineOutput(output.name, {
                label: output.label,
                unitType: output.unitType,
                unitName: output.unitName,
                unitPluralName: output.unitPluralName,
                unitAbbreviation: output.unitAbbreviation
              }, scriptingAPI.makeFunctionInScriptContext(getStringFromArray(output.value)));
              break;
            case "filtered":
              model.defineFilteredOutput(output.name, {
                label: output.label,
                unitType: output.unitType,
                unitName: output.unitName,
                unitPluralName: output.unitPluralName,
                unitAbbreviation: output.unitAbbreviation
              }, output.property, output.type, output.period);
              break;
          }
        }
      }
    }

    /**
      After a model loads, this method is used to set up the custom parameters specified in the
      model section of the interactive, or in the toplevel of the interactive
    */
    function setupCustomParameters(modelParameters, interactiveParameters) {
      if (!modelParameters && !interactiveParameters) return;

      var initialValues = {},
          customParameters,
          i, parameter, onChangeFunc;

      // append modelParameters second so they're processed later (and override entries of the
      // same name in interactiveParameters)
      customParameters = (interactiveParameters || []).concat(modelParameters || []);

      for (i = 0; i < customParameters.length; i++) {
        parameter = customParameters[i];
        // onChange callback is optional.
        onChangeFunc = undefined;
        if (parameter.onChange) {
          onChangeFunc = scriptingAPI.makeFunctionInScriptContext('value', getStringFromArray(parameter.onChange));
        }
        // Define parameter using modeler.
        model.defineParameter(parameter.name, {
          label: parameter.label,
          unitType: parameter.unitType,
          unitName: parameter.unitName,
          unitPluralName: parameter.unitPluralName,
          unitAbbreviation: parameter.unitAbbreviation
        }, onChangeFunc);

        if (parameter.initialValue !== undefined) {
          initialValues[parameter.name] = parameter.initialValue;
        }
        // Save reference to the definition which is finally used.
        // Note that if parameter is defined both in interactive top-level scope
        // and models section, one from model sections will be defined in this hash.
        // It's necessary to update correctly values of parameters during serialization.
        customParametersByName[parameter.name] = parameter;
      }

      model.set(initialValues);
    }

    //
    // Public API.
    //
    controller = {
      getDGExportController: function () {
        return exportController;
      },
      getModelController: function () {
        return modelController;
      },
      pushOnLoadScript: function (callback) {
        onLoadScripts.push(callback);
      },

      getNextTabIndex: getNextTabIndex,

      /**
        Notifies interactive controller that the dimensions of its container have changed.
        It triggers the layout algorithm again.
      */
      resize: function () {
        var i;

        semanticLayout.layoutInteractive();
        // TODO: use events!
        for(i = 0; i < resizeCallbacks.length; i++) {
          resizeCallbacks[i]();
        }
      },
      /**
       * Adds an event listener for the specified type.
       * Supported events are: "resize" and "modelLoaded".
       *
       * @param {string} type Event type ("resize" or "modelLoaded").
       * @param  {function|array} callback Callback function or an array of functions.
       */
      on: function (type, callback) {
        if (typeof callback === "function") {
          callback = [callback];
        } else if ($.isArray(callback)) {
          if (callback.some(function (cb) { return typeof cb !== 'function'; })) {
            throw new Error("Invalid callback, must be an array of functions.");
          }
        } else {
          throw new Error("Invalid callback, must be a function or array of functions.");
        }

        switch(type) {
          case "resize":
            resizeCallbacks = resizeCallbacks.concat(callback);
            break;
          case "modelLoaded":
            modelLoadedCallbacks = modelLoadedCallbacks.concat(callback);
            break;
        }
      },

      /**
       * Gets interactive property from interactive JSON definition.
       * @param  {string} name Property name.
       * @return {*}      Property value.
       */
      get: function (name) {
        return interactive[name];
      },

      /**
        Serializes interactive, returns object ready to be stringified.
        e.g. JSON.stringify(interactiveController.serialize());
      */
      serialize: function () {
        var result, i, len, param, val;

        // This is the tricky part.
        // Basically, parameters can be defined in two places - in model definition object or just as a top-level
        // property of the interactive definition. 'customParameters' list contains references to all parameters
        // currently used by the interactive, no matter where they were specified. So, it's enough to process
        // and update only these parameters. Because of that, later we can easily serialize interactive definition
        // with updated values and avoid deciding whether this parameter is defined in 'models' section
        // or top-level 'parameters' section. It will be updated anyway.
        if (model !== undefined && model.get !== undefined) {
          for (param in customParametersByName) {
            if (customParametersByName.hasOwnProperty(param)) {
              param = customParametersByName[param];
              val = model.get(param.name);
              if (val !== undefined) {
                param.initialValue = val;
              }
            }
          }
        }

        // Copy basic properties from the initial definition, as they are immutable.
        // FIXME: this should be based on enumerating properties in the metadata. The issue is properties
        // added to the metadata like "importedFrom" have to be then manually added here.
        result = {
          title: interactive.title,
          publicationStatus: interactive.publicationStatus,
          subtitle: interactive.subtitle,
          fontScale: interactive.fontScale,
          about: arrays.isArray(interactive.about) ? $.extend(true, [], interactive.about) : interactive.about,
          // Node that models section can also contain custom parameters definition. However, their initial values
          // should be already updated (take a look at the beginning of this function), so we can just serialize whole array.
          models: $.extend(true, [], interactive.models),
          // All used parameters are already updated, they contain currently used values.
          parameters: $.extend(true, [], interactive.parameters),
          // Outputs are directly bound to the model, we can copy their initial definitions.
          outputs: $.extend(true, [], interactive.outputs),
          filteredOutputs: $.extend(true, [], interactive.filteredOutputs)
        };

        // add optional attributes to result if defined
        if (typeof interactive.fontScale !== 'undefined') {
          result.fontScale = interactive.fontScale
        }
        if (typeof interactive.importedFrom !== 'undefined') {
          result.importedFrom = interactive.importedFrom
        }

        // Serialize components.
        result.components = [];
        for (i = 0, len = componentList.length; i < len; i++) {
          if (componentList[i].serialize) {
            result.components.push(componentList[i].serialize());
          }
        }

        // Copy layout from the initial definition, as it is immutable.
        result.layout = $.extend(true, {}, interactive.layout);
        if (typeof interactive.template === "string") {
          result.template = interactive.template;
        } else {
          result.template = $.extend(true, [], interactive.template);
        }

        return result;
      },
      // Make these private variables and functions available
      loadInteractive: loadInteractive,
      validateInteractive: validateInteractive,
      loadModel: loadModel,
      interactiveNotFound: interactiveNotFound
    };

    //
    // Initialization.
    //

    // Create scripting API.
    scriptingAPI = new ScriptingAPI(controller, modelScriptingAPI);
    // Expose API to global namespace (prototyping / testing using the browser console).
    scriptingAPI.exposeScriptingAPI();
    // Select interactive container.
    // TODO: controller rather should create it itself to follow pattern of other components.
    $interactiveContainer = $(viewSelector);
    // add container to API
    controller.interactiveContainer = $interactiveContainer;
    // Initialize semantic layout.
    semanticLayout = new SemanticLayout($interactiveContainer);
    creditsDialog = new CreditsDialog();
    aboutDialog = new AboutDialog();
    shareDialog = new ShareDialog();
    controller.on("resize", $.proxy(shareDialog.updateIframeSize, shareDialog));
    // Run this when controller is created.
    loadInteractive(interactiveReference, viewSelector);

    return controller;
  };
});

/*global define: false console: true */

define('common/structured-clone',['require'],function (require) {
  var featureSupported = false,
      publicAPI = {};

  function isStructuredCloneSupported() {
    var result = 0;

    if (!!window.postMessage) {
      try {
        // Safari 5.1 will sometimes throw an exception and sometimes won't, lolwut?
        // When it doesn't we capture the message event and check the
        // internal [[Class]] property of the message being passed through.
        // Safari will pass through DOM nodes as Null iOS safari on the other hand
        // passes it through as DOMWindow, gotcha.
        window.onmessage = function(e){
          var type = Object.prototype.toString.call(e.data);
          result = (type.indexOf("Null") != -1 || type.indexOf("DOMWindow") != -1) ? 1 : 0;
          featureSupported = {
            'structuredClones': result
          };
        };
        // Spec states you can't transmit DOM nodes and it will throw an error
        // postMessage implimentations that support cloned data will throw.
        window.postMessage(document.createElement("a"),"*");
      } catch(e) {
        // BBOS6 throws but doesn't pass through the correct exception
        // so check error message
        result = (e.DATA_CLONE_ERR || e.message == "Cannot post cyclic structures.") ? 1 : 0;
        featureSupported = {
          'structuredClones': result
        };
      }
    }
  }

  isStructuredCloneSupported();

  function supported() {
    return featureSupported && featureSupported.structuredClones > 0;
  }

  publicAPI.supported = supported;

  return publicAPI;

});

/*global define: false, window: false */

define('grapher/public-api',['require','../lab.version','../lab.config','grapher/core/graph','grapher/bar-graph/bar-graph-model','grapher/bar-graph/bar-graph-view'],function (require) {
  'use strict';
  var
    version = require('../lab.version'),
    config  = require('../lab.config'),
    Graph         = require('grapher/core/graph'),
    BarGraphModel = require('grapher/bar-graph/bar-graph-model'),
    BarGraphView  = require('grapher/bar-graph/bar-graph-view'),
    // Object to be returned.
    publicAPI;

  publicAPI = {
    version: "0.0.1",
    // ==========================================================================
    // Add functions and modules which should belong to this API:
    // - graph constructor,
    Graph: Graph,
    // - bar graph model,
    BarGraphModel: BarGraphModel,
    // - bar graph view.
    BarGraphView: BarGraphView
    // ==========================================================================
  };

  // Finally, export API to global namespace.
  // Create or get 'Lab' global object (namespace).
  window.Lab = window.Lab || {};
  // Export config modules.
  window.Lab.config = config;

  // Export this API under 'grapher' name.
  window.Lab.grapher = publicAPI;

  // Also return publicAPI as module.
  return publicAPI;
});

/*global define */

define('import-export/netlogo-importer',['require','underscore'],function(require) {

  var _ = require('underscore'),
     fields = ["computationalInputs", "computationalOutputs", "studentInputs"];

  function columnLabelWithUnits(col) {
    return col.units ? col.label + " (" + col.units + ")" : col.label;
  }

  return {
    importRun: function(data, run) {
      if (typeof data === 'string') data = JSON.parse(data);

      return {
        perRunLabels: _.flatten(fields.map(function (field) {
          return data.description[field];
        })).map(columnLabelWithUnits),

        perRunValues: _.flatten(fields.map(function (field) {
          return data.runs[run][field];
        })),

        perTickLabels: data.description.timeSeriesData.map(columnLabelWithUnits),

        // Just a fancy way of copying the nested arrays
        perTickValues: data.runs[run].timeSeriesData.map(function (list) {
          return list.map(_.identity);
        })
      };
    },

    numberOfRuns: function(data) {
      if (typeof data === 'string') data = JSON.parse(data);
      return data.runs.length;
    },

    timeStamps: function(data) {
      if (typeof data === 'string') data = JSON.parse(data);
      return _.pluck(data.runs, 'timeStamp');
    },

    runHavingTimeStamp: function(data, timeStamp) {
      if (typeof data === 'string') data = JSON.parse(data);

      // Would be nice to have a generator expression/lazy-list equivalent, so we could use 'pluck'
      // and 'indexOf' without having to iterate over all runs before filtering the first one.

      for (var i = 0; i < data.runs.length; i++) {
        if (data.runs[i].timeStamp === timeStamp) {
          return i;
        }
      }
      return null;

    }

  };
});

/*global define: false, window: false */

define('import-export/public-api',['require','import-export/dg-exporter','import-export/netlogo-importer'],function (require) {
  'use strict';

  window.Lab = window.Lab || {};

  return window.Lab.importExport = {
    version: "0.0.1",
    // ==========================================================================
    // Functions and modules which should belong to this API:

    // Data Games exporter
    dgExporter:      require('import-export/dg-exporter'),
    netlogoImporter: require('import-export/netlogo-importer')
    // ==========================================================================
  };
});

/*global define: false */

define('public-api',['require','lab.version','lab.config','common/controllers/interactives-controller','common/benchmark/benchmark','common/structured-clone','grapher/public-api','import-export/public-api'],function (require) {
  var version = require('lab.version'),
      config  = require('lab.config'),
      InteractivesController  = require('common/controllers/interactives-controller'),
      benchmark               = require('common/benchmark/benchmark'),
      structuredClone         = require('common/structured-clone');

  // Require public-api modules.
  require('grapher/public-api');
  require('import-export/public-api');

  // Create or get 'Lab' global object (namespace).
  window.Lab = window.Lab || {};
  window.Lab.version = version;
  window.Lab.config = config;
  window.Lab.structuredClone = structuredClone;
  window.Lab.InteractivesController = InteractivesController;
  window.Lab.benchmark = benchmark;
});
require(['public-api'], undefined, undefined, true); }());